<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>H | MC TIL</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Some structure and enum information for minecraft bedrock edition.">
    
    <link rel="preload" href="/mcstructure/assets/css/0.styles.5de0a167.css" as="style"><link rel="preload" href="/mcstructure/assets/js/app.56b0ab36.js" as="script"><link rel="preload" href="/mcstructure/assets/js/2.56e23786.js" as="script"><link rel="preload" href="/mcstructure/assets/js/113.a961fd7d.js" as="script"><link rel="prefetch" href="/mcstructure/assets/js/10.dda8da32.js"><link rel="prefetch" href="/mcstructure/assets/js/100.d193fca3.js"><link rel="prefetch" href="/mcstructure/assets/js/101.324df8d1.js"><link rel="prefetch" href="/mcstructure/assets/js/102.81d32953.js"><link rel="prefetch" href="/mcstructure/assets/js/103.bafffe55.js"><link rel="prefetch" href="/mcstructure/assets/js/104.4a4116d4.js"><link rel="prefetch" href="/mcstructure/assets/js/105.ee5ab7c3.js"><link rel="prefetch" href="/mcstructure/assets/js/106.16520c01.js"><link rel="prefetch" href="/mcstructure/assets/js/107.e4e2fef9.js"><link rel="prefetch" href="/mcstructure/assets/js/108.9771cecd.js"><link rel="prefetch" href="/mcstructure/assets/js/109.07a059f8.js"><link rel="prefetch" href="/mcstructure/assets/js/11.84aff5f4.js"><link rel="prefetch" href="/mcstructure/assets/js/110.79e73184.js"><link rel="prefetch" href="/mcstructure/assets/js/111.735fe11b.js"><link rel="prefetch" href="/mcstructure/assets/js/112.5b8c9633.js"><link rel="prefetch" href="/mcstructure/assets/js/114.f46e6ac6.js"><link rel="prefetch" href="/mcstructure/assets/js/115.29d129b9.js"><link rel="prefetch" href="/mcstructure/assets/js/116.0761604d.js"><link rel="prefetch" href="/mcstructure/assets/js/117.8fa51bbe.js"><link rel="prefetch" href="/mcstructure/assets/js/118.65b68c09.js"><link rel="prefetch" href="/mcstructure/assets/js/119.0b88b1c0.js"><link rel="prefetch" href="/mcstructure/assets/js/12.fb0b2343.js"><link rel="prefetch" href="/mcstructure/assets/js/120.6514cc60.js"><link rel="prefetch" href="/mcstructure/assets/js/121.30792057.js"><link rel="prefetch" href="/mcstructure/assets/js/122.ac6c9052.js"><link rel="prefetch" href="/mcstructure/assets/js/123.9dde14ff.js"><link rel="prefetch" href="/mcstructure/assets/js/124.1b8cd48f.js"><link rel="prefetch" href="/mcstructure/assets/js/125.ba14f223.js"><link rel="prefetch" href="/mcstructure/assets/js/126.5dd69ba6.js"><link rel="prefetch" href="/mcstructure/assets/js/127.32df8d72.js"><link rel="prefetch" href="/mcstructure/assets/js/128.aa9a14cc.js"><link rel="prefetch" href="/mcstructure/assets/js/129.d7a703a5.js"><link rel="prefetch" href="/mcstructure/assets/js/13.b8437649.js"><link rel="prefetch" href="/mcstructure/assets/js/130.d8f7ecf5.js"><link rel="prefetch" href="/mcstructure/assets/js/131.0c1d33fe.js"><link rel="prefetch" href="/mcstructure/assets/js/132.8b6e6ff3.js"><link rel="prefetch" href="/mcstructure/assets/js/133.f999118d.js"><link rel="prefetch" href="/mcstructure/assets/js/134.bc4a2893.js"><link rel="prefetch" href="/mcstructure/assets/js/135.e6e793b3.js"><link rel="prefetch" href="/mcstructure/assets/js/136.c50dcaff.js"><link rel="prefetch" href="/mcstructure/assets/js/137.209d5c8a.js"><link rel="prefetch" href="/mcstructure/assets/js/138.3eed47db.js"><link rel="prefetch" href="/mcstructure/assets/js/139.5e9afeaa.js"><link rel="prefetch" href="/mcstructure/assets/js/14.c94aa248.js"><link rel="prefetch" href="/mcstructure/assets/js/140.ac85c96f.js"><link rel="prefetch" href="/mcstructure/assets/js/141.82f0f06f.js"><link rel="prefetch" href="/mcstructure/assets/js/142.08052153.js"><link rel="prefetch" href="/mcstructure/assets/js/143.97d16176.js"><link rel="prefetch" href="/mcstructure/assets/js/144.66c74f2b.js"><link rel="prefetch" href="/mcstructure/assets/js/145.58e96ed1.js"><link rel="prefetch" href="/mcstructure/assets/js/146.4c73b3b4.js"><link rel="prefetch" href="/mcstructure/assets/js/147.0e0e09a7.js"><link rel="prefetch" href="/mcstructure/assets/js/148.a8c2c253.js"><link rel="prefetch" href="/mcstructure/assets/js/149.99f1b4f1.js"><link rel="prefetch" href="/mcstructure/assets/js/15.fd6df6e3.js"><link rel="prefetch" href="/mcstructure/assets/js/16.855c8adf.js"><link rel="prefetch" href="/mcstructure/assets/js/17.860009b0.js"><link rel="prefetch" href="/mcstructure/assets/js/18.63105a6b.js"><link rel="prefetch" href="/mcstructure/assets/js/19.fbddb16b.js"><link rel="prefetch" href="/mcstructure/assets/js/20.605578ab.js"><link rel="prefetch" href="/mcstructure/assets/js/21.1e5adf90.js"><link rel="prefetch" href="/mcstructure/assets/js/22.29bfa69a.js"><link rel="prefetch" href="/mcstructure/assets/js/23.566201a2.js"><link rel="prefetch" href="/mcstructure/assets/js/24.d912e845.js"><link rel="prefetch" href="/mcstructure/assets/js/25.8885d257.js"><link rel="prefetch" href="/mcstructure/assets/js/26.8409713f.js"><link rel="prefetch" href="/mcstructure/assets/js/27.49cb5267.js"><link rel="prefetch" href="/mcstructure/assets/js/28.2a890355.js"><link rel="prefetch" href="/mcstructure/assets/js/29.6ea7598b.js"><link rel="prefetch" href="/mcstructure/assets/js/3.50967458.js"><link rel="prefetch" href="/mcstructure/assets/js/30.1a3c3902.js"><link rel="prefetch" href="/mcstructure/assets/js/31.24ec9e8b.js"><link rel="prefetch" href="/mcstructure/assets/js/32.40831503.js"><link rel="prefetch" href="/mcstructure/assets/js/33.6602f7d9.js"><link rel="prefetch" href="/mcstructure/assets/js/34.75d333d9.js"><link rel="prefetch" href="/mcstructure/assets/js/35.84bf3e5a.js"><link rel="prefetch" href="/mcstructure/assets/js/36.fe4e7307.js"><link rel="prefetch" href="/mcstructure/assets/js/37.b2ee95ad.js"><link rel="prefetch" href="/mcstructure/assets/js/38.c03d5dee.js"><link rel="prefetch" href="/mcstructure/assets/js/39.a60df6e0.js"><link rel="prefetch" href="/mcstructure/assets/js/4.f5835878.js"><link rel="prefetch" href="/mcstructure/assets/js/40.6322a006.js"><link rel="prefetch" href="/mcstructure/assets/js/41.420acfde.js"><link rel="prefetch" href="/mcstructure/assets/js/42.a4ef9cfe.js"><link rel="prefetch" href="/mcstructure/assets/js/43.660cc3cf.js"><link rel="prefetch" href="/mcstructure/assets/js/44.683fc1e0.js"><link rel="prefetch" href="/mcstructure/assets/js/45.f27a9ad0.js"><link rel="prefetch" href="/mcstructure/assets/js/46.9f9edd2c.js"><link rel="prefetch" href="/mcstructure/assets/js/47.fd3ae547.js"><link rel="prefetch" href="/mcstructure/assets/js/48.375f8f97.js"><link rel="prefetch" href="/mcstructure/assets/js/49.e0d0f024.js"><link rel="prefetch" href="/mcstructure/assets/js/5.e0bd9261.js"><link rel="prefetch" href="/mcstructure/assets/js/50.aa126f14.js"><link rel="prefetch" href="/mcstructure/assets/js/51.e939b03e.js"><link rel="prefetch" href="/mcstructure/assets/js/52.a2d46eef.js"><link rel="prefetch" href="/mcstructure/assets/js/53.72de48c3.js"><link rel="prefetch" href="/mcstructure/assets/js/54.54675155.js"><link rel="prefetch" href="/mcstructure/assets/js/55.8b419ad8.js"><link rel="prefetch" href="/mcstructure/assets/js/56.07af8dcf.js"><link rel="prefetch" href="/mcstructure/assets/js/57.0bedaec9.js"><link rel="prefetch" href="/mcstructure/assets/js/58.37c94f2a.js"><link rel="prefetch" href="/mcstructure/assets/js/59.b0866a6a.js"><link rel="prefetch" href="/mcstructure/assets/js/6.04e2a2d2.js"><link rel="prefetch" href="/mcstructure/assets/js/60.5c5afc8c.js"><link rel="prefetch" href="/mcstructure/assets/js/61.ea56e4d6.js"><link rel="prefetch" href="/mcstructure/assets/js/62.3cb13464.js"><link rel="prefetch" href="/mcstructure/assets/js/63.83c0082d.js"><link rel="prefetch" href="/mcstructure/assets/js/64.2cd02c8b.js"><link rel="prefetch" href="/mcstructure/assets/js/65.c16cc8f2.js"><link rel="prefetch" href="/mcstructure/assets/js/66.ad2d4521.js"><link rel="prefetch" href="/mcstructure/assets/js/67.83e59ab1.js"><link rel="prefetch" href="/mcstructure/assets/js/68.beec9ddd.js"><link rel="prefetch" href="/mcstructure/assets/js/69.b4bc257c.js"><link rel="prefetch" href="/mcstructure/assets/js/7.fd995bdf.js"><link rel="prefetch" href="/mcstructure/assets/js/70.1ea3abef.js"><link rel="prefetch" href="/mcstructure/assets/js/71.3cf65839.js"><link rel="prefetch" href="/mcstructure/assets/js/72.6f64c4ab.js"><link rel="prefetch" href="/mcstructure/assets/js/73.452d7013.js"><link rel="prefetch" href="/mcstructure/assets/js/74.0660e6d9.js"><link rel="prefetch" href="/mcstructure/assets/js/75.b7b5e783.js"><link rel="prefetch" href="/mcstructure/assets/js/76.5fddaea1.js"><link rel="prefetch" href="/mcstructure/assets/js/77.be26bbc6.js"><link rel="prefetch" href="/mcstructure/assets/js/78.0e00fef4.js"><link rel="prefetch" href="/mcstructure/assets/js/79.731c37fb.js"><link rel="prefetch" href="/mcstructure/assets/js/8.1cbf1ff3.js"><link rel="prefetch" href="/mcstructure/assets/js/80.2282d655.js"><link rel="prefetch" href="/mcstructure/assets/js/81.33a53399.js"><link rel="prefetch" href="/mcstructure/assets/js/82.196f3fc3.js"><link rel="prefetch" href="/mcstructure/assets/js/83.e9cb3f05.js"><link rel="prefetch" href="/mcstructure/assets/js/84.35c05041.js"><link rel="prefetch" href="/mcstructure/assets/js/85.16e996b6.js"><link rel="prefetch" href="/mcstructure/assets/js/86.97412bd5.js"><link rel="prefetch" href="/mcstructure/assets/js/87.2244cc28.js"><link rel="prefetch" href="/mcstructure/assets/js/88.f00d5fcc.js"><link rel="prefetch" href="/mcstructure/assets/js/89.13359307.js"><link rel="prefetch" href="/mcstructure/assets/js/9.86a5a003.js"><link rel="prefetch" href="/mcstructure/assets/js/90.3b4668a2.js"><link rel="prefetch" href="/mcstructure/assets/js/91.85f8c578.js"><link rel="prefetch" href="/mcstructure/assets/js/92.c7bfeb53.js"><link rel="prefetch" href="/mcstructure/assets/js/93.87278538.js"><link rel="prefetch" href="/mcstructure/assets/js/94.9636adb8.js"><link rel="prefetch" href="/mcstructure/assets/js/95.49a2df5b.js"><link rel="prefetch" href="/mcstructure/assets/js/96.f84087c6.js"><link rel="prefetch" href="/mcstructure/assets/js/97.777e52ef.js"><link rel="prefetch" href="/mcstructure/assets/js/98.95f637bf.js"><link rel="prefetch" href="/mcstructure/assets/js/99.535a1eab.js">
    <link rel="stylesheet" href="/mcstructure/assets/css/0.styles.5de0a167.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/mcstructure/" class="home-link router-link-active"><!----> <span class="site-name">MC TIL</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/mcstructure/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/Redbeanw44602/mcstructure" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/mcstructure/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/Redbeanw44602/mcstructure" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Struct</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/mcstructure/1.16.201/structure/A.html" class="sidebar-link">A</a></li><li><a href="/mcstructure/1.16.201/structure/A~1.html" class="sidebar-link">A~1</a></li><li><a href="/mcstructure/1.16.201/structure/B.html" class="sidebar-link">B</a></li><li><a href="/mcstructure/1.16.201/structure/B~1.html" class="sidebar-link">B~1</a></li><li><a href="/mcstructure/1.16.201/structure/B~2.html" class="sidebar-link">B~2</a></li><li><a href="/mcstructure/1.16.201/structure/C.html" class="sidebar-link">C</a></li><li><a href="/mcstructure/1.16.201/structure/C~1.html" class="sidebar-link">C~1</a></li><li><a href="/mcstructure/1.16.201/structure/C~2.html" class="sidebar-link">C~2</a></li><li><a href="/mcstructure/1.16.201/structure/C~3.html" class="sidebar-link">C~3</a></li><li><a href="/mcstructure/1.16.201/structure/D.html" class="sidebar-link">D</a></li><li><a href="/mcstructure/1.16.201/structure/D~1.html" class="sidebar-link">D~1</a></li><li><a href="/mcstructure/1.16.201/structure/D~2.html" class="sidebar-link">D~2</a></li><li><a href="/mcstructure/1.16.201/structure/D~3.html" class="sidebar-link">D~3</a></li><li><a href="/mcstructure/1.16.201/structure/D~4.html" class="sidebar-link">D~4</a></li><li><a href="/mcstructure/1.16.201/structure/D~5.html" class="sidebar-link">D~5</a></li><li><a href="/mcstructure/1.16.201/structure/D~6.html" class="sidebar-link">D~6</a></li><li><a href="/mcstructure/1.16.201/structure/D~7.html" class="sidebar-link">D~7</a></li><li><a href="/mcstructure/1.16.201/structure/D~8.html" class="sidebar-link">D~8</a></li><li><a href="/mcstructure/1.16.201/structure/D~9.html" class="sidebar-link">D~9</a></li><li><a href="/mcstructure/1.16.201/structure/D~10.html" class="sidebar-link">D~10</a></li><li><a href="/mcstructure/1.16.201/structure/E.html" class="sidebar-link">E</a></li><li><a href="/mcstructure/1.16.201/structure/E~1.html" class="sidebar-link">E~1</a></li><li><a href="/mcstructure/1.16.201/structure/F.html" class="sidebar-link">F</a></li><li><a href="/mcstructure/1.16.201/structure/F~1.html" class="sidebar-link">F~1</a></li><li><a href="/mcstructure/1.16.201/structure/G.html" class="sidebar-link">G</a></li><li><a href="/mcstructure/1.16.201/structure/H.html" aria-current="page" class="active sidebar-link">H</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/mcstructure/1.16.201/structure/I.html" class="sidebar-link">I</a></li><li><a href="/mcstructure/1.16.201/structure/I~1.html" class="sidebar-link">I~1</a></li><li><a href="/mcstructure/1.16.201/structure/I~2.html" class="sidebar-link">I~2</a></li><li><a href="/mcstructure/1.16.201/structure/J.html" class="sidebar-link">J</a></li><li><a href="/mcstructure/1.16.201/structure/K.html" class="sidebar-link">K</a></li><li><a href="/mcstructure/1.16.201/structure/L.html" class="sidebar-link">L</a></li><li><a href="/mcstructure/1.16.201/structure/L~1.html" class="sidebar-link">L~1</a></li><li><a href="/mcstructure/1.16.201/structure/M.html" class="sidebar-link">M</a></li><li><a href="/mcstructure/1.16.201/structure/M~1.html" class="sidebar-link">M~1</a></li><li><a href="/mcstructure/1.16.201/structure/M~2.html" class="sidebar-link">M~2</a></li><li><a href="/mcstructure/1.16.201/structure/M~3.html" class="sidebar-link">M~3</a></li><li><a href="/mcstructure/1.16.201/structure/N.html" class="sidebar-link">N</a></li><li><a href="/mcstructure/1.16.201/structure/O.html" class="sidebar-link">O</a></li><li><a href="/mcstructure/1.16.201/structure/P.html" class="sidebar-link">P</a></li><li><a href="/mcstructure/1.16.201/structure/P~1.html" class="sidebar-link">P~1</a></li><li><a href="/mcstructure/1.16.201/structure/P~2.html" class="sidebar-link">P~2</a></li><li><a href="/mcstructure/1.16.201/structure/P~3.html" class="sidebar-link">P~3</a></li><li><a href="/mcstructure/1.16.201/structure/Q.html" class="sidebar-link">Q</a></li><li><a href="/mcstructure/1.16.201/structure/R.html" class="sidebar-link">R</a></li><li><a href="/mcstructure/1.16.201/structure/R~1.html" class="sidebar-link">R~1</a></li><li><a href="/mcstructure/1.16.201/structure/R~2.html" class="sidebar-link">R~2</a></li><li><a href="/mcstructure/1.16.201/structure/R~3.html" class="sidebar-link">R~3</a></li><li><a href="/mcstructure/1.16.201/structure/S.html" class="sidebar-link">S</a></li><li><a href="/mcstructure/1.16.201/structure/S~1.html" class="sidebar-link">S~1</a></li><li><a href="/mcstructure/1.16.201/structure/S~2.html" class="sidebar-link">S~2</a></li><li><a href="/mcstructure/1.16.201/structure/S~3.html" class="sidebar-link">S~3</a></li><li><a href="/mcstructure/1.16.201/structure/S~4.html" class="sidebar-link">S~4</a></li><li><a href="/mcstructure/1.16.201/structure/T.html" class="sidebar-link">T</a></li><li><a href="/mcstructure/1.16.201/structure/T~1.html" class="sidebar-link">T~1</a></li><li><a href="/mcstructure/1.16.201/structure/U.html" class="sidebar-link">U</a></li><li><a href="/mcstructure/1.16.201/structure/V.html" class="sidebar-link">V</a></li><li><a href="/mcstructure/1.16.201/structure/W.html" class="sidebar-link">W</a></li><li><a href="/mcstructure/1.16.201/structure/W~1.html" class="sidebar-link">W~1</a></li><li><a href="/mcstructure/1.16.201/structure/X.html" class="sidebar-link">X</a></li><li><a href="/mcstructure/1.16.201/structure/Z.html" class="sidebar-link">Z</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Enums</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="h"><a href="#h" class="header-anchor">#</a> H</h1> <h3 id="hashedstring"><a href="#hashedstring" class="header-anchor">#</a> <code>HashedString</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int64</code></td> <td>mStrHash</td></tr> <tr><td>8</td> <td>(32) <code>std::string</code></td> <td>mStr</td></tr> <tr><td>40</td> <td>(8) <code>const HashedString *</code></td> <td>mLastMatch</td></tr></tbody></table> <h3 id="handlertype"><a href="#handlertype" class="header-anchor">#</a> <code>HandlerType</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) ``</td> <td>adjectives</td></tr> <tr><td>4</td> <td>(4) ``</td> <td>pType</td></tr> <tr><td>8</td> <td>(4) ``</td> <td>dispCatchObj</td></tr> <tr><td>12</td> <td>(4) ``</td> <td>addressOfHandler</td></tr> <tr><td>16</td> <td>(4) ``</td> <td>dispFrame</td></tr></tbody></table> <h3 id="historicalframetimes"><a href="#historicalframetimes" class="header-anchor">#</a> <code>HistoricalFrameTimes</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int64</code></td> <td>mFrameIndex</td></tr> <tr><td>8</td> <td>(120) <code>float[30]</code></td> <td>mHistoricalMinimumFrameTimes</td></tr> <tr><td>128</td> <td>(120) <code>float[30]</code></td> <td>mHistoricalMaximumFrameTimes</td></tr> <tr><td>248</td> <td>(120) <code>float[30]</code></td> <td>mHistoricalAverageFrameTimes</td></tr> <tr><td>368</td> <td>(120) <code>float[30]</code></td> <td>mLastFrameTime</td></tr></tbody></table> <h3 id="hitresult"><a href="#hitresult" class="header-anchor">#</a> <code>HitResult</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>Vec3</code></td> <td>mStartPos</td></tr> <tr><td>12</td> <td>(12) <code>Vec3</code></td> <td>mRayDir</td></tr> <tr><td>24</td> <td>(4) <code>HitResultType</code></td> <td>mType</td></tr> <tr><td>28</td> <td>(1) <code>unsigned __int8</code></td> <td>mFacing</td></tr> <tr><td>32</td> <td>(12) <code>BlockPos</code></td> <td>mBlock</td></tr> <tr><td>44</td> <td>(12) <code>Vec3</code></td> <td>mPos</td></tr> <tr><td>56</td> <td>(24) <code>WeakRefT&lt;EntityRefTraits&gt;</code></td> <td>mEntity</td></tr> <tr><td>80</td> <td>(1) <code>bool</code></td> <td>mIsHitLiquid</td></tr> <tr><td>81</td> <td>(1) <code>unsigned __int8</code></td> <td>mLiquidFacing</td></tr> <tr><td>84</td> <td>(12) <code>BlockPos</code></td> <td>mLiquid</td></tr> <tr><td>96</td> <td>(12) <code>Vec3</code></td> <td>mLiquidPos</td></tr> <tr><td>108</td> <td>(1) <code>bool</code></td> <td>mIndirectHit</td></tr></tbody></table> <h3 id="holographicplatform-holoframeofreferencesetupdata"><a href="#holographicplatform-holoframeofreferencesetupdata" class="header-anchor">#</a> <code>HolographicPlatform::HoloFrameOfReferenceSetupData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>Vec3</code></td> <td>mMinecraftPlayerPos</td></tr> <tr><td>12</td> <td>(4) <code>float</code></td> <td>mUIWidth</td></tr> <tr><td>16</td> <td>(4) <code>float</code></td> <td>mUIHeight</td></tr> <tr><td>20</td> <td>(4) <code>float</code></td> <td>mUIGuiScale</td></tr> <tr><td>24</td> <td>(4) <code>float</code></td> <td>mVerticalFovRadians</td></tr> <tr><td>28</td> <td>(4) <code>float</code></td> <td>mAspectRatio</td></tr> <tr><td>32</td> <td>(4) <code>float</code></td> <td>mHoloUIWidth</td></tr> <tr><td>36</td> <td>(4) <code>float</code></td> <td>mHoloUIHeight</td></tr> <tr><td>40</td> <td>(4) <code>float</code></td> <td>mHoloHUDWidth</td></tr> <tr><td>44</td> <td>(4) <code>float</code></td> <td>mHoloHUDHeight</td></tr> <tr><td>48</td> <td>(64) <code>Matrix</code></td> <td>mMinecraftSteveRelativeSpaceToRealitySpaceTransform</td></tr> <tr><td>112</td> <td>(4) <code>float</code></td> <td>mRealityFrameModeWorldScale</td></tr> <tr><td>116</td> <td>(64) <code>Matrix</code></td> <td>mScreenAnchorAugmentationMatrix</td></tr> <tr><td>180</td> <td>(64) <code>Matrix</code></td> <td>mMinecraftView</td></tr> <tr><td>244</td> <td>(64) <code>Matrix</code></td> <td>mMinecraftProj</td></tr> <tr><td>308</td> <td>(1) <code>bool</code></td> <td>mDrawUIHeadLocked</td></tr> <tr><td>309</td> <td>(1) <code>bool</code></td> <td>mTrueMonoscopicModeEnabled</td></tr> <tr><td>310</td> <td>(1) <code>bool</code></td> <td>mDrawFloatingHud</td></tr> <tr><td>311</td> <td>(1) <code>bool</code></td> <td>mFixHud</td></tr> <tr><td>312</td> <td>(64) <code>Matrix</code></td> <td>mHUDMatrixPatch</td></tr> <tr><td>376</td> <td>(64) <code>Matrix</code></td> <td>mHUDToLeftHandPatch</td></tr> <tr><td>440</td> <td>(4) <code>HoloUIToPoseSource</code></td> <td>mUIPoseSource</td></tr> <tr><td>444</td> <td>(64) <code>Matrix</code></td> <td>mVRTransitionMatrixPatch</td></tr></tbody></table> <h3 id="hbui-routerlocation"><a href="#hbui-routerlocation" class="header-anchor">#</a> <code>hbui::RouterLocation</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::weak_ptr&lt;AbstractScene&gt;</code></td> <td>mScene</td></tr> <tr><td>16</td> <td>(32) <code>std::string</code></td> <td>mUrl</td></tr> <tr><td>48</td> <td>(32) <code>std::string</code></td> <td>mPath</td></tr> <tr><td>80</td> <td>(40) <code>std::optional&lt;std::string &gt;</code></td> <td>mQuery</td></tr> <tr><td>120</td> <td>(40) <code>std::optional&lt;std::string &gt;</code></td> <td>mFragment</td></tr> <tr><td>160</td> <td>(4) <code>_BYTE[4]</code></td> <td>mMode</td></tr> <tr><td>164</td> <td>(4) <code>hbui::RouteType</code></td> <td>mRouteType</td></tr> <tr><td>168</td> <td>(32) <code>std::string</code></td> <td>mState</td></tr></tbody></table> <h3 id="hoverscreeneventdata"><a href="#hoverscreeneventdata" class="header-anchor">#</a> <code>HoverScreenEventData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>UIPropertyBag *</code></td> <td>properties</td></tr> <tr><td>8</td> <td>(1) <code>bool</code></td> <td>hover</td></tr></tbody></table> <h3 id="holoinputmodechangescreeneventdata"><a href="#holoinputmodechangescreeneventdata" class="header-anchor">#</a> <code>HoloInputModeChangeScreenEventData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>_BYTE[4]</code></td> <td>mode</td></tr></tbody></table> <h3 id="hbui-facetregistry-facetentry"><a href="#hbui-facetregistry-facetentry" class="header-anchor">#</a> <code>hbui::FacetRegistry::FacetEntry</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>name</td></tr> <tr><td>32</td> <td>(64) <code>std::function&lt;std::unique_ptr&lt;hbui::IFacet&gt; __cdecl(void)&gt;</code></td> <td>constructor</td></tr> <tr><td>96</td> <td>(8) <code>std::unique_ptr&lt;hbui::IFacet&gt;</code></td> <td>facet</td></tr></tbody></table> <h3 id="hbui-feature-registerisenabledchangedcallback-l5-lambda-1ab57bcd99c576631ba41c810ebdfff7"><a href="#hbui-feature-registerisenabledchangedcallback-l5-lambda-1ab57bcd99c576631ba41c810ebdfff7" class="header-anchor">#</a> <code>hbui::Feature::registerIsEnabledChangedCallback::__l5::&lt;lambda_1ab57bcd99c576631ba41c810ebdfff7&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;void __cdecl(bool)&gt;</code></td> <td>callback</td></tr></tbody></table> <h3 id="hbui-routerhistory-fullhistory"><a href="#hbui-routerhistory-fullhistory" class="header-anchor">#</a> <code>hbui::RouterHistory::FullHistory</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;std::string&gt;</code></td> <td>entries</td></tr> <tr><td>24</td> <td>(4) <code>int</code></td> <td>current</td></tr></tbody></table> <h3 id="hbui-sceneprovider-createscene-l2-lambda-9198b0a63744d6caef4e6bf93514f963"><a href="#hbui-sceneprovider-createscene-l2-lambda-9198b0a63744d6caef4e6bf93514f963" class="header-anchor">#</a> <code>hbui::SceneProvider::createScene::__l2::&lt;lambda_9198b0a63744d6caef4e6bf93514f963&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>hbui::SceneProvider *const</code></td> <td>__this</td></tr></tbody></table> <h3 id="hbui-sceneprovider-createscene-l2-lambda-03742a56a76ff97dd1e21e945eb64304"><a href="#hbui-sceneprovider-createscene-l2-lambda-03742a56a76ff97dd1e21e945eb64304" class="header-anchor">#</a> <code>hbui::SceneProvider::createScene::__l2::&lt;lambda_03742a56a76ff97dd1e21e945eb64304&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>hbui::SceneProvider *const</code></td> <td>__this</td></tr></tbody></table> <h3 id="hbui-sceneprovider-createscene-l2-lambda-3ee6f9688302b02ab45782d3ee16d8ce"><a href="#hbui-sceneprovider-createscene-l2-lambda-3ee6f9688302b02ab45782d3ee16d8ce" class="header-anchor">#</a> <code>hbui::SceneProvider::createScene::__l2::&lt;lambda_3ee6f9688302b02ab45782d3ee16d8ce&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>hbui::SceneProvider *const</code></td> <td>__this</td></tr></tbody></table> <h3 id="hbui-sceneprovider-createscene-l2-lambda-b4883a86f58b08e1adf25075f2619414"><a href="#hbui-sceneprovider-createscene-l2-lambda-b4883a86f58b08e1adf25075f2619414" class="header-anchor">#</a> <code>hbui::SceneProvider::createScene::__l2::&lt;lambda_b4883a86f58b08e1adf25075f2619414&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>hbui::SceneProvider *const</code></td> <td>__this</td></tr></tbody></table> <h3 id="hbui-sceneprovider-createscene-l2-lambda-198843c04982cc508dc4bb1d040ed8de"><a href="#hbui-sceneprovider-createscene-l2-lambda-198843c04982cc508dc4bb1d040ed8de" class="header-anchor">#</a> <code>hbui::SceneProvider::createScene::__l2::&lt;lambda_198843c04982cc508dc4bb1d040ed8de&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;std::string&gt;</code></td> <td>featureFlags</td></tr></tbody></table> <h3 id="hbui-sceneprovider-createscene-l2-lambda-304967065c66569af40ba27c5a2bf6f5"><a href="#hbui-sceneprovider-createscene-l2-lambda-304967065c66569af40ba27c5a2bf6f5" class="header-anchor">#</a> <code>hbui::SceneProvider::createScene::__l2::&lt;lambda_304967065c66569af40ba27c5a2bf6f5&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>hbui::SceneProvider *const</code></td> <td>__this</td></tr></tbody></table> <h3 id="hbui-sceneprovider-createscene-l2-lambda-29ee3a92f3d498426295e1b7ffbcb6ea"><a href="#hbui-sceneprovider-createscene-l2-lambda-29ee3a92f3d498426295e1b7ffbcb6ea" class="header-anchor">#</a> <code>hbui::SceneProvider::createScene::__l2::&lt;lambda_29ee3a92f3d498426295e1b7ffbcb6ea&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>hbui::SceneProvider *const</code></td> <td>__this</td></tr></tbody></table> <h3 id="hbui-sceneprovider-createscene-l2-lambda-df7288e7b03dfb70aec84d96b0a91b02"><a href="#hbui-sceneprovider-createscene-l2-lambda-df7288e7b03dfb70aec84d96b0a91b02" class="header-anchor">#</a> <code>hbui::SceneProvider::createScene::__l2::&lt;lambda_df7288e7b03dfb70aec84d96b0a91b02&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>hbui::SceneProvider *const</code></td> <td>__this</td></tr></tbody></table> <h3 id="hbui-sceneprovider-createscene-l2-lambda-420fe536fd38216466f4e15beb7f8f35"><a href="#hbui-sceneprovider-createscene-l2-lambda-420fe536fd38216466f4e15beb7f8f35" class="header-anchor">#</a> <code>hbui::SceneProvider::createScene::__l2::&lt;lambda_420fe536fd38216466f4e15beb7f8f35&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>hbui::SceneProvider *const</code></td> <td>__this</td></tr></tbody></table> <h3 id="hbui-sceneprovider-createscene-l2-lambda-4e8329eee189f5c87c78bda6854976e8"><a href="#hbui-sceneprovider-createscene-l2-lambda-4e8329eee189f5c87c78bda6854976e8" class="header-anchor">#</a> <code>hbui::SceneProvider::createScene::__l2::&lt;lambda_4e8329eee189f5c87c78bda6854976e8&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>hbui::SceneProvider *const</code></td> <td>__this</td></tr></tbody></table> <h3 id="hbui-sceneprovider-createscene-l2-lambda-b8cda2d613720fd8ef484f58bcce6777"><a href="#hbui-sceneprovider-createscene-l2-lambda-b8cda2d613720fd8ef484f58bcce6777" class="header-anchor">#</a> <code>hbui::SceneProvider::createScene::__l2::&lt;lambda_b8cda2d613720fd8ef484f58bcce6777&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>hbui::SceneProvider *const</code></td> <td>__this</td></tr></tbody></table> <h3 id="hbui-sceneprovider-createscene-l8-lambda-41cdb76c9bee798add5b424eb551b203"><a href="#hbui-sceneprovider-createscene-l8-lambda-41cdb76c9bee798add5b424eb551b203" class="header-anchor">#</a> <code>hbui::SceneProvider::createScene::__l8::&lt;lambda_41cdb76c9bee798add5b424eb551b203&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>hbui::SceneProvider *const</code></td> <td>__this</td></tr></tbody></table> <h3 id="hummingbirdui-callbackentry"><a href="#hummingbirdui-callbackentry" class="header-anchor">#</a> <code>HummingbirdUI::CallbackEntry</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>void *</code></td> <td>token</td></tr> <tr><td>8</td> <td>(64) <code>std::function&lt;void __cdecl(void)&gt;</code></td> <td>callback</td></tr></tbody></table> <h3 id="hbui-hybridresourcelocation"><a href="#hbui-hybridresourcelocation" class="header-anchor">#</a> <code>hbui::HybridResourceLocation</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>hbui::HybridResourceFileSystem</code></td> <td>mFileSystem</td></tr> <tr><td>8</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>mPath</td></tr> <tr><td>40</td> <td>(8) <code>const PackInstance *</code></td> <td>mPack</td></tr></tbody></table> <h3 id="hbui-routematcher-entry"><a href="#hbui-routematcher-entry" class="header-anchor">#</a> <code>hbui::RouteMatcher::Entry</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>const std::string</code></td> <td>baseScreenId</td></tr> <tr><td>32</td> <td>(40) <code>const std::basic_regex&lt;char,std::regex_traits&lt;char&gt; &gt;</code></td> <td>pattern</td></tr> <tr><td>72</td> <td>(4) <code>hbui::RouteType</code></td> <td>type</td></tr> <tr><td>76</td> <td>(4) <code>_BYTE[4]</code></td> <td>mode</td></tr> <tr><td>80</td> <td>(64) <code>std::function&lt;void __cdecl(std::string const &amp;)&gt;</code></td> <td>callback</td></tr></tbody></table> <h3 id="hbui-routerlocationeventing-screenchangedproperties"><a href="#hbui-routerlocationeventing-screenchangedproperties" class="header-anchor">#</a> <code>hbui::RouterLocationEventing::ScreenChangedProperties</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>mShouldFireEvent</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,std::string&gt;</code></td> <td>mEventProperties</td></tr></tbody></table> <h3 id="hostoptionsubcommand"><a href="#hostoptionsubcommand" class="header-anchor">#</a> <code>HostOptionSubCommand</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>mButtonText</td></tr> <tr><td>32</td> <td>(32) <code>std::string</code></td> <td>mTexture</td></tr> <tr><td>64</td> <td>(32) <code>std::string</code></td> <td>mSubCommand</td></tr></tbody></table> <h3 id="hudscreencontroller"><a href="#hudscreencontroller" class="header-anchor">#</a> <code>HudScreenController</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2672) <code>ClientInstanceScreenController</code></td> <td>baseclass_0</td></tr> <tr><td>2672</td> <td>(8) <code>BossEventListener</code></td> <td>baseclass_a70</td></tr> <tr><td>2680</td> <td>(1) <code>bool</code></td> <td>mEDUDiscoveryObserved</td></tr> <tr><td>2684</td> <td>(4) <code>int</code></td> <td>mInputDelayTimer</td></tr> <tr><td>2688</td> <td>(32) <code>std::string</code></td> <td>mPopupItemText</td></tr> <tr><td>2720</td> <td>(32) <code>std::string</code></td> <td>mPopupJukeboxText</td></tr> <tr><td>2752</td> <td>(32) <code>std::string</code></td> <td>mTipText</td></tr> <tr><td>2784</td> <td>(12) <code>BlockPos</code></td> <td>mPlayerPos</td></tr> <tr><td>2796</td> <td>(12) <code>BlockPos</code></td> <td>mAgentPos</td></tr> <tr><td>2808</td> <td>(4) <code>_BYTE[4]</code></td> <td>mRecordedDirtyState</td></tr> <tr><td>2816</td> <td>(16) <code>std::shared_ptr&lt;HudContainerManagerController&gt;</code></td> <td>mHudScreenManagerController</td></tr> <tr><td>2832</td> <td>(16) <code>std::shared_ptr&lt;ScoreboardScreenController&gt;</code></td> <td>mScoreboardScreenController</td></tr> <tr><td>2848</td> <td>(16) <code>std::shared_ptr&lt;GamePlayTipScreenController&gt;</code></td> <td>mGamePlayTipScreenController</td></tr> <tr><td>2864</td> <td>(1) <code>bool</code></td> <td>mIsPlayerRiding</td></tr> <tr><td>2865</td> <td>(1) <code>bool</code></td> <td>mVRRiding</td></tr> <tr><td>2866</td> <td>(1) <code>bool</code></td> <td>mIsCreative</td></tr> <tr><td>2867</td> <td>(1) <code>bool</code></td> <td>mVR</td></tr> <tr><td>2868</td> <td>(1) <code>bool</code></td> <td>mHasPresentedInitialChat</td></tr> <tr><td>2869</td> <td>(1) <code>bool</code></td> <td>mIsAutoSaving</td></tr> <tr><td>2870</td> <td>(1) <code>bool</code></td> <td>mIsAutoSaveTimerDone</td></tr> <tr><td>2872</td> <td>(48) <code>Stopwatch</code></td> <td>mAutoSaveTimer</td></tr> <tr><td>2920</td> <td>(48) <code>Stopwatch</code></td> <td>mHUDOpacityTimer</td></tr> <tr><td>2968</td> <td>(4) <code>float</code></td> <td>mHUDOpacityOverride</td></tr> <tr><td>2972</td> <td>(1) <code>bool</code></td> <td>mOverrideHUDOpacity</td></tr> <tr><td>2973</td> <td>(1) <code>bool</code></td> <td>mVoiceTipsVisible</td></tr> <tr><td>2976</td> <td>(32) <code>std::string</code></td> <td>mVoiceName</td></tr> <tr><td>3008</td> <td>(1) <code>bool</code></td> <td>mIsTitleOnDisplay</td></tr> <tr><td>3016</td> <td>(112) <code>TitleMessage</code></td> <td>mTitleQueuedData</td></tr> <tr><td>3128</td> <td>(112) <code>TitleMessage</code></td> <td>mTitleOnDisplayData</td></tr> <tr><td>3240</td> <td>(24) <code>std::vector&lt;HudScreenController::Tooltip&gt;</code></td> <td>mLeftTooltips</td></tr> <tr><td>3264</td> <td>(24) <code>std::vector&lt;HudScreenController::Tooltip&gt;</code></td> <td>mRightTooltips</td></tr></tbody></table> <h3 id="hudscreencontroller-tooltip"><a href="#hudscreencontroller-tooltip" class="header-anchor">#</a> <code>HudScreenController::Tooltip</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>Remapping::ActionEnum</code></td> <td>action</td></tr> <tr><td>4</td> <td>(1) <code>HudScreenController::Tooltip::Type</code></td> <td>type</td></tr> <tr><td>8</td> <td>(64) <code>std::function&lt;std::string __cdecl(void)&gt;</code></td> <td>getDescription</td></tr> <tr><td>72</td> <td>(32) <code>std::string</code></td> <td>keyPostfix</td></tr></tbody></table> <h3 id="hydrateparams"><a href="#hydrateparams" class="header-anchor">#</a> <code>HydrateParams</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>mProductId</td></tr> <tr><td>32</td> <td>(32) <code>std::string</code></td> <td>mLastModifiedDate</td></tr> <tr><td>64</td> <td>(1) <code>bool</code></td> <td>mDisableCachedResponseOnFailure</td></tr> <tr><td>65</td> <td>(1) <code>bool</code></td> <td>mUsePersonaBackend</td></tr></tbody></table> <h3 id="homesystem-tick-l2-lambda-13bc406ef66a336e9c00382282ba4146"><a href="#homesystem-tick-l2-lambda-13bc406ef66a336e9c00382282ba4146" class="header-anchor">#</a> <code>HomeSystem::tick::__l2::&lt;lambda_13bc406ef66a336e9c00382282ba4146&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>HomeSystem *const</code></td> <td>__this</td></tr></tbody></table> <h3 id="homecomponent"><a href="#homecomponent" class="header-anchor">#</a> <code>HomeComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>mRestrictionRadius</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>mRestrictionRadiusSqr</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>mCooldownTicksMax</td></tr> <tr><td>12</td> <td>(4) <code>int</code></td> <td>mCooldownTicks</td></tr> <tr><td>16</td> <td>(24) <code>std::vector&lt;WeakPtr&lt;BlockLegacy&gt;&gt;</code></td> <td>mHomeBlocks</td></tr> <tr><td>40</td> <td>(12) <code>BlockPos</code></td> <td>mHomePos</td></tr> <tr><td>52</td> <td>(4) <code>AutomaticID&lt;Dimension,int&gt;</code></td> <td>mDimensionId</td></tr></tbody></table> <h3 id="healabledefinition"><a href="#healabledefinition" class="header-anchor">#</a> <code>HealableDefinition</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;FeedItem&gt;</code></td> <td>mHealItems</td></tr> <tr><td>24</td> <td>(1) <code>bool</code></td> <td>mForceUse</td></tr> <tr><td>32</td> <td>(64) <code>ActorFilterGroup</code></td> <td>mFilter</td></tr></tbody></table> <h3 id="hitboxcomponent"><a href="#hitboxcomponent" class="header-anchor">#</a> <code>HitboxComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;Hitbox&gt;</code></td> <td>mHitboxes</td></tr></tbody></table> <h3 id="historicpredictiondata"><a href="#historicpredictiondata" class="header-anchor">#</a> <code>HistoricPredictionData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>slot</td></tr> <tr><td>8</td> <td>(248) <code>ItemStack</code></td> <td>item</td></tr></tbody></table> <h3 id="hugemushroomfeature"><a href="#hugemushroomfeature" class="header-anchor">#</a> <code>HugeMushroomFeature</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>Feature</code></td> <td>baseclass_0</td></tr> <tr><td>24</td> <td>(4) <code>int</code></td> <td>mForcedType</td></tr></tbody></table> <h3 id="hugefungusfeature"><a href="#hugefungusfeature" class="header-anchor">#</a> <code>HugeFungusFeature</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>Feature</code></td> <td>baseclass_0</td></tr> <tr><td>24</td> <td>(8) <code>const Block *</code></td> <td>mStemBlock</td></tr> <tr><td>32</td> <td>(8) <code>const Block *</code></td> <td>mHatBlock</td></tr> <tr><td>40</td> <td>(8) <code>const Block *</code></td> <td>mDecorBlock</td></tr> <tr><td>48</td> <td>(1) <code>const bool</code></td> <td>mAllowedToPlaceVines</td></tr></tbody></table> <h3 id="httprequest"><a href="#httprequest" class="header-anchor">#</a> <code>HTTPRequest</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>mURL</td></tr> <tr><td>32</td> <td>(32) <code>std::string</code></td> <td>mRequestBody</td></tr> <tr><td>64</td> <td>(32) <code>std::string</code></td> <td>mContentType</td></tr> <tr><td>96</td> <td>(4) <code>HTTPRequest::Method</code></td> <td>mRequestMethod</td></tr> <tr><td>104</td> <td>(104) <code>HTTPResponse</code></td> <td>mResponse</td></tr> <tr><td>208</td> <td>(16) <code>std::shared_ptr&lt;HTTPRequestInternal&gt;</code></td> <td>mRequest</td></tr> <tr><td>224</td> <td>(16) <code>std::map&lt;std::string,std::string&gt;</code></td> <td>mCookies</td></tr> <tr><td>240</td> <td>(16) <code>std::map&lt;std::string,std::string&gt;</code></td> <td>mHeaders</td></tr></tbody></table> <h3 id="httpresponse"><a href="#httpresponse" class="header-anchor">#</a> <code>HTTPResponse</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>body</td></tr> <tr><td>32</td> <td>(64) <code>std::unordered_map&lt;std::string,std::string&gt;</code></td> <td>headers</td></tr> <tr><td>96</td> <td>(4) <code>int</code></td> <td>responseCode</td></tr> <tr><td>100</td> <td>(4) <code>HTTPResponse::Status</code></td> <td>status</td></tr></tbody></table> <h3 id="hellspringfeature"><a href="#hellspringfeature" class="header-anchor">#</a> <code>HellSpringFeature</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>Feature</code></td> <td>baseclass_0</td></tr> <tr><td>24</td> <td>(8) <code>const Block *</code></td> <td>mBlock</td></tr> <tr><td>32</td> <td>(1) <code>bool</code></td> <td>mInsideRock</td></tr></tbody></table> <h3 id="hellfirefeature"><a href="#hellfirefeature" class="header-anchor">#</a> <code>HellFireFeature</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>Feature</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="hinstance"><a href="#hinstance" class="header-anchor">#</a> <code>HINSTANCE__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HINSTANCE__
{
  int unused;
};

</code></pre></div><h3 id="hungerattrpacket"><a href="#hungerattrpacket" class="header-anchor">#</a> <code>HungerAttrPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(8)) HungerAttrPacket : Packet
{
  float mMaxExhaustion;
};

</code></pre></div><h3 id="hungerattrpacket-vtbl"><a href="#hungerattrpacket-vtbl" class="header-anchor">#</a> <code>HungerAttrPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HungerAttrPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="hurtarmorpacket"><a href="#hurtarmorpacket" class="header-anchor">#</a> <code>HurtArmorPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj HurtArmorPacket : Packet
{
  _BYTE mCause[4];
  int mDmg;
};

</code></pre></div><h3 id="hurtarmorpacket-vtbl"><a href="#hurtarmorpacket-vtbl" class="header-anchor">#</a> <code>HurtArmorPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HurtArmorPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="hwnd"><a href="#hwnd" class="header-anchor">#</a> <code>HWND__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HWND__
{
  int unused;
};

</code></pre></div><h3 id="httpheaders"><a href="#httpheaders" class="header-anchor">#</a> <code>HttpHeaders</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HttpHeaders
{
  std::map&lt;std::string,std::string&gt; mHeaders;
  std::string mStatusLine;
  HttpHeaders::ParseState mParseState;
  std::string mParsedName;
  std::string mParsedValue;
  unsigned __int64 mCount;
};

</code></pre></div><h3 id="headertimercomponent"><a href="#headertimercomponent" class="header-anchor">#</a> <code>HeaderTimerComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HeaderTimerComponent : StoreUIComponent
{
  std::string mTimerExpiredText;
  std::string mTimerExpireOverride;
  __int64 mTimerExpireTime;
  bool mHideTimerOnExpiration;
  TimerType mTimerType;
  std::map&lt;int,std::string&gt; mTimerWarnings;
};

</code></pre></div><h3 id="headertimercomponent-vtbl"><a href="#headertimercomponent-vtbl" class="header-anchor">#</a> <code>HeaderTimerComponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HeaderTimerComponent_vtbl
{
  void (__fastcall *~StoreUIComponent)(StoreUIComponent *this);
  void (__fastcall *tick)(StoreUIComponent *this, ui::DirtyFlag *);
  bool (__fastcall *canRemove)(StoreUIComponent *this);
  int (__fastcall *getReadyCount)(StoreUIComponent *this);
  void (__fastcall *parseData)(StoreUIComponent *this, const struct web::json::value *);
};

</code></pre></div><h3 id="headerbannercomponent"><a href="#headerbannercomponent" class="header-anchor">#</a> <code>HeaderBannerComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HeaderBannerComponent : StoreUIComponent
{
  BannerType mBannerType;
};

</code></pre></div><h3 id="headerbannercomponent-vtbl"><a href="#headerbannercomponent-vtbl" class="header-anchor">#</a> <code>HeaderBannerComponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HeaderBannerComponent_vtbl
{
  void (__fastcall *~StoreUIComponent)(StoreUIComponent *this);
  void (__fastcall *tick)(StoreUIComponent *this, ui::DirtyFlag *);
  bool (__fastcall *canRemove)(StoreUIComponent *this);
  int (__fastcall *getReadyCount)(StoreUIComponent *this);
  void (__fastcall *parseData)(StoreUIComponent *this, const struct web::json::value *);
};

</code></pre></div><h3 id="headercomponent"><a href="#headercomponent" class="header-anchor">#</a> <code>HeaderComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HeaderComponent : StoreUIComponent
{
  std::string mHeader;
  std::string mNextSaleBeginsName;
  std::unique_ptr&lt;HeaderTimerComponent&gt; mTimerComponent;
  std::unique_ptr&lt;HeaderBannerComponent&gt; mBannerComponent;
};

</code></pre></div><h3 id="headercomponent-vtbl"><a href="#headercomponent-vtbl" class="header-anchor">#</a> <code>HeaderComponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HeaderComponent_vtbl
{
  void (__fastcall *~StoreUIComponent)(StoreUIComponent *this);
  void (__fastcall *tick)(StoreUIComponent *this, ui::DirtyFlag *);
  bool (__fastcall *canRemove)(StoreUIComponent *this);
  int (__fastcall *getReadyCount)(StoreUIComponent *this);
  void (__fastcall *parseData)(StoreUIComponent *this, const struct web::json::value *);
};

</code></pre></div><h3 id="hbui-ilibrary"><a href="#hbui-ilibrary" class="header-anchor">#</a> <code>hbui::ILibrary</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::ILibrary : Bedrock::EnableNonOwnerReferences
{
  hbui::ILibrary_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="hbui-iviewrenderer"><a href="#hbui-iviewrenderer" class="header-anchor">#</a> <code>hbui::IViewRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::IViewRenderer
{
  hbui::IViewRenderer_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="hbui-iviewrenderer-vtbl"><a href="#hbui-iviewrenderer-vtbl" class="header-anchor">#</a> <code>hbui::IViewRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::IViewRenderer_vtbl
{
  void (__fastcall *~IViewRenderer)(hbui::IViewRenderer *this);
  void (__fastcall *render)(hbui::IViewRenderer *this, ScreenContext *);
  void (__fastcall *pushFrame)(hbui::IViewRenderer *this, unsigned int);
  void (__fastcall *freeRenderingResources)(hbui::IViewRenderer *this);
  void (__fastcall *recreateRenderingResources)(hbui::IViewRenderer *this);
  void (__fastcall *resize)(hbui::IViewRenderer *this, unsigned int, unsigned int);
  void (__fastcall *resolve)(hbui::IViewRenderer *this, ScreenContext *, std::optional&lt;RectangleArea&gt;, std::optional&lt;RectangleArea&gt;);
};

</code></pre></div><h3 id="hbui-iview"><a href="#hbui-iview" class="header-anchor">#</a> <code>hbui::IView</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::IView
{
  hbui::IView_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="hbui-iviewlistener"><a href="#hbui-iviewlistener" class="header-anchor">#</a> <code>hbui::IViewListener</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::IViewListener
{
  hbui::IViewListener_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="hbui-iviewlistener-vtbl"><a href="#hbui-iviewlistener-vtbl" class="header-anchor">#</a> <code>hbui::IViewListener_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::IViewListener_vtbl
{
  void (__fastcall *~IViewListener)(hbui::IViewListener *this);
  void (__fastcall *onLoadSucceeded)(hbui::IViewListener *this, const char *);
  void (__fastcall *onLoadFailed)(hbui::IViewListener *this, const char *, const char *);
  bool (__fastcall *isActive)(hbui::IViewListener *this);
};

</code></pre></div><h3 id="hbui-cachesnapshot"><a href="#hbui-cachesnapshot" class="header-anchor">#</a> <code>hbui::CacheSnapshot</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct hbui::CacheSnapshot
{
  unsigned int filledBytes;
  unsigned int capacityBytes;
  unsigned int filledCount;
  unsigned int capacityCount;
};

</code></pre></div><h3 id="hbui-viewcachesnapshot"><a href="#hbui-viewcachesnapshot" class="header-anchor">#</a> <code>hbui::ViewCacheSnapshot</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct hbui::ViewCacheSnapshot
{
  unsigned int viewId;
  hbui::CacheSnapshot shadows;
  hbui::CacheSnapshot paths;
  hbui::CacheSnapshot textures;
  hbui::CacheSnapshot scratchLayerTextures;
};

</code></pre></div><h3 id="hbui-systemcachesnapshot"><a href="#hbui-systemcachesnapshot" class="header-anchor">#</a> <code>hbui::SystemCacheSnapshot</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct hbui::SystemCacheSnapshot
{
  unsigned int aliveImagesCount;
  unsigned int aliveTotalBytesUsed;
  unsigned int orphanedImagesCount;
  unsigned int orphanedBytesUsed;
};

</code></pre></div><h3 id="hbui-buffersnapshot"><a href="#hbui-buffersnapshot" class="header-anchor">#</a> <code>hbui::BufferSnapshot</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct hbui::BufferSnapshot
{
  unsigned int id;
  unsigned int usedSize;
  unsigned int size;
};

</code></pre></div><h3 id="hbui-debugdata"><a href="#hbui-debugdata" class="header-anchor">#</a> <code>hbui::DebugData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::DebugData
{
  const struct hbui::MemorySnapshot *mMemorySnapshot;
  std::vector&lt;hbui::ViewCacheSnapshot&gt; mViewCacheSnapshots;
  hbui::SystemCacheSnapshot mSystemCacheSnapshot;
  std::vector&lt;hbui::BufferSnapshot&gt; mVertexBufferSnapshots;
  std::vector&lt;hbui::BufferSnapshot&gt; mIndexBufferSnapshots;
};

</code></pre></div><h3 id="hbui-iview-vtbl"><a href="#hbui-iview-vtbl" class="header-anchor">#</a> <code>hbui::IView_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::IView_vtbl
{
  void (__fastcall *~IView)(hbui::IView *this);
  void (__fastcall *setViewListener)(hbui::IView *this, hbui::IViewListener *);
  void (__fastcall *resetViewListener)(hbui::IView *this);
  unsigned int (__fastcall *getId)(hbui::IView *this);
  void (__fastcall *update)(hbui::IView *this, long double);
  unsigned int (__fastcall *getWidth)(hbui::IView *this);
  unsigned int (__fastcall *getHeight)(hbui::IView *this);
  void (__fastcall *resize)(hbui::IView *this, unsigned int, unsigned int);
  void (__fastcall *reload)(hbui::IView *this);
  bool (__fastcall *isActive)(hbui::IView *this);
  void (__fastcall *deactivateTextInputAndFacets)(hbui::IView *this);
  void (__fastcall *updateInput)(hbui::IView *this);
  void (__fastcall *handleInput)(hbui::IView *this, const MouseAction *);
  void (__fastcall *setTextboxText)(hbui::IView *this, const std::string *);
  void (__fastcall *updateFacets)(hbui::IView *this);
  void (__fastcall *triggerEvent)(hbui::IView *this, const std::string *, const std::string *);
  void (__fastcall *setDebugFeature)(hbui::IView *this, UIDebugCommandFeature, bool);
  void (__fastcall *fillDebugData)(hbui::IView *this, hbui::DebugData *);
  void (__fastcall *handleMenuCancelButton)(hbui::IView *this);
  void (__fastcall *keyboardClosed)(hbui::IView *this);
  std::optional&lt;RectangleArea&gt; *(__fastcall *getTextInputControlArea)(hbui::IView *this, std::optional&lt;RectangleArea&gt; *result);
  std::optional&lt;RectangleArea&gt; *(__fastcall *getTextInputCaretOffsetArea)(hbui::IView *this, std::optional&lt;RectangleArea&gt; *result);
  void (__fastcall *routeChanged)(hbui::IView *this, const std::optional&lt;hbui::RouterLocation&gt; *, const hbui::RouterLocation *);
};

</code></pre></div><h3 id="hbui-ifacetregistry"><a href="#hbui-ifacetregistry" class="header-anchor">#</a> <code>hbui::IFacetRegistry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::IFacetRegistry
{
  hbui::IFacetRegistry_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="hbui-ifacet"><a href="#hbui-ifacet" class="header-anchor">#</a> <code>hbui::IFacet</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::IFacet
{
  hbui::IFacet_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="hbui-facetbinder"><a href="#hbui-facetbinder" class="header-anchor">#</a> <code>hbui::FacetBinder</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetBinder
{
};

</code></pre></div><h3 id="hbui-ifacet-vtbl"><a href="#hbui-ifacet-vtbl" class="header-anchor">#</a> <code>hbui::IFacet_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::IFacet_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-ifacetregistry-vtbl"><a href="#hbui-ifacetregistry-vtbl" class="header-anchor">#</a> <code>hbui::IFacetRegistry_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::IFacetRegistry_vtbl
{
  void (__fastcall *~IFacetRegistry)(hbui::IFacetRegistry *this);
  void (__fastcall *registerFacet)(hbui::IFacetRegistry *this, const std::string *, const std::function&lt;std::unique_ptr&lt;hbui::IFacet&gt; __cdecl(void)&gt; *);
  std::optional&lt;enum hbui::IFacetRegistry::Error&gt; *(__fastcall *activateFacet)(hbui::IFacetRegistry *this, std::optional&lt;enum hbui::IFacetRegistry::Error&gt; *result, hbui::FacetBinder *, const std::string *);
  std::optional&lt;enum hbui::IFacetRegistry::Error&gt; *(__fastcall *deactivateFacet)(hbui::IFacetRegistry *this, std::optional&lt;enum hbui::IFacetRegistry::Error&gt; *result, hbui::FacetBinder *, const std::string *);
  void (__fastcall *deactivateAllFacets)(hbui::IFacetRegistry *this, hbui::FacetBinder *);
  void (__fastcall *bind)(hbui::IFacetRegistry *this, hbui::FacetBinder *);
  void (__fastcall *update)(hbui::IFacetRegistry *this, hbui::FacetBinder *);
};

</code></pre></div><h3 id="hbui-ilibrary-vtbl"><a href="#hbui-ilibrary-vtbl" class="header-anchor">#</a> <code>hbui::ILibrary_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::ILibrary_vtbl
{
  void (__fastcall *~ILibrary)(hbui::ILibrary *this);
  void (__fastcall *update)(hbui::ILibrary *this, long double);
  void (__fastcall *onAppPreSuspended)(hbui::ILibrary *this, mce::RenderContext *);
  void (__fastcall *onAppResumed)(hbui::ILibrary *this, const Bedrock::NonOwnerPointer&lt;mce::ShaderGroup&gt;, const ResourcePackManager *);
  void (__fastcall *onActiveResourcePacksChanged)(hbui::ILibrary *this);
  std::tuple&lt;std::unique_ptr&lt;hbui::IView&gt;,std::unique_ptr&lt;hbui::IViewRenderer&gt; &gt; *(__fastcall *createViewAndRenderer)(hbui::ILibrary *this, std::tuple&lt;std::unique_ptr&lt;hbui::IView&gt;,std::unique_ptr&lt;hbui::IViewRenderer&gt; &gt; *result, const std::string *, unsigned int, unsigned int, std::unique_ptr&lt;hbui::IFacetRegistry&gt;, IClientInstance *, KeyboardManager *, bool);
  void (__fastcall *reloadAllViews)(hbui::ILibrary *this);
  void (__fastcall *setCompleteUninitialization)(hbui::ILibrary *this);
  void (__fastcall *fillDebugData)(hbui::ILibrary *this, hbui::DebugData *);
  void (__fastcall *initializeRendering)(hbui::ILibrary *this, const GuiData *, Bedrock::NonOwnerPointer&lt;mce::ShaderGroup&gt;, mce::RenderContext *);
  void (__fastcall *initializeBitmapFonts)(hbui::ILibrary *this, const ResourcePackManager *);
};

</code></pre></div><h3 id="hbui-sceneprovider"><a href="#hbui-sceneprovider" class="header-anchor">#</a> <code>hbui::SceneProvider</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::SceneProvider
{
  IClientInstance *mClientInstance;
  hbui::ILibrary *mUILibrary;
};

</code></pre></div><h3 id="holographicplatform"><a href="#holographicplatform" class="header-anchor">#</a> <code>HolographicPlatform</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(2)) HolographicPlatform
{
  HolographicPlatform_vtbl *__vftable /*VFT*/;
  HolographicPlatform::HoloFrameOfReferenceSetupData mFrameData;
  Vec3 mCurrentHMDPosSpring;
  Vec3 mHoloRealityModeGazeDirMCSpace;
  std::recursive_mutex mMutex;
  std::unordered_map&lt;unsigned int,Matrix&gt; mTransformMap;
  std::vector&lt;HolographicPlatform::HoloCursorWorldParams&gt; mWorldCursorParamsVec;
  bool mBasicTransformsSet;
  bool mStereoEnabled;
  bool mVRLayeringActive;
  bool mAllowMirrorPresent;
  Matrix mHeadlockedUITransform;
  float mDynamicMonoscopicEyeConvergenceDistance;
  float mStereoPerformanceBlockPercentage;
  float mUILayerAlpha;
  int mRecenterHoloUITimeout;
  HolographicPlatform::AimFromSpace mAimFromSpace;
  bool mLeftHandAvailable;
  bool mRightHandAvailable;
  std::string mLivingRoomHintText;
  unsigned int mHolographicFeatures;
  Vec3 mHoloviewerGazePointMCSpace;
  float mRealityFrameScale;
  bool mStuckCursorTriggered;
  float mHoloviewerRotY;
  float mHoloscreenSize;
  float mHoloviewerSize;
  float mLastGazeXCoordNorm;
  float mLastGazeYCoordNorm;
  float mLastGazeXMouseCoordNorm;
  float mLastGazeYMouseCoordNorm;
  bool mGazeOnScreen;
  bool mGestureStatePrimaryHandIsHeld;
  bool mRecenterGazeActivationOriginPoint;
};

</code></pre></div><h3 id="holographicplatform-luid"><a href="#holographicplatform-luid" class="header-anchor">#</a> <code>HolographicPlatform::LUID</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HolographicPlatform::LUID
{
  unsigned int LowPart;
  int HighPart;
};

</code></pre></div><h3 id="holographicplatform-vtbl"><a href="#holographicplatform-vtbl" class="header-anchor">#</a> <code>HolographicPlatform_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HolographicPlatform_vtbl
{
  void (__fastcall *~HolographicPlatform)(HolographicPlatform *this);
  void (__fastcall *init)(HolographicPlatform *this, std::shared_ptr&lt;Options&gt;);
  void (__fastcall *preInitUpdate)(HolographicPlatform *this);
  void (__fastcall *update)(HolographicPlatform *this, IClientInstance *);
  void (__fastcall *postRenderUpdate)(HolographicPlatform *this, IClientInstance *);
  void (__fastcall *getSoundSystemOutputDevice)(HolographicPlatform *this, SoundSystemGUID *);
  void (__fastcall *onAppFocusLost)(HolographicPlatform *this);
  void (__fastcall *onAppFocusGained)(HolographicPlatform *this);
  void (__fastcall *onAppSuspended)(HolographicPlatform *this);
  void (__fastcall *onAppResumed)(HolographicPlatform *this);
  void (__fastcall *onHMDFocusGained)(HolographicPlatform *this);
  void (__fastcall *onHMDFocusLost)(HolographicPlatform *this);
  void (__fastcall *onInitialResourcesLoaded)(HolographicPlatform *this);
  std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; *(__fastcall *waitForOutputMode)(HolographicPlatform *this, std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; *result, VROutputMode);
  bool (__fastcall *holographicMode)(HolographicPlatform *this);
  int (__fastcall *getWorkerFramerate)(HolographicPlatform *this);
  bool (__fastcall *allowVRFrameExperience)(HolographicPlatform *this);
  bool (__fastcall *allowSplitScreen)(HolographicPlatform *this);
  bool (__fastcall *supportsLoadingScreen)(HolographicPlatform *this);
  bool (__fastcall *pauseIsDesired)(HolographicPlatform *this);
  bool (__fastcall *allowThirdPersonView)(HolographicPlatform *this);
  bool (__fastcall *useSinglePassStereo)(HolographicPlatform *this);
  bool (__fastcall *drawCubemapInMono)(HolographicPlatform *this);
  bool (__fastcall *isVRMode)(HolographicPlatform *this);
  bool (__fastcall *isARMode)(HolographicPlatform *this);
  bool (__fastcall *isRenderingIn2D)(HolographicPlatform *this);
  bool (__fastcall *isSessionVisible)(HolographicPlatform *this);
  bool (__fastcall *needsPostRenderUpdate)(HolographicPlatform *this);
  bool (__fastcall *deviceHasPositionalTracking)(HolographicPlatform *this);
  bool (__fastcall *deviceNeedsToBeRemovedForXblSignin)(HolographicPlatform *this);
  bool (__fastcall *deviceNeedsToBeRemovedForSkinPicker)(HolographicPlatform *this);
  bool (__fastcall *deviceNeedsToBeRemovedForFilePicker)(HolographicPlatform *this);
  VRHUDPosition (__fastcall *getDefaultVRHUDPosition)(HolographicPlatform *this);
  void (__fastcall *setUndockHandler)(HolographicPlatform *this, std::function&lt;void __cdecl(void)&gt;);
  int (__fastcall *numRequiredControllers)(HolographicPlatform *this);
  std::string *(__fastcall *getPlatformRecalibrationMessage)(HolographicPlatform *this, std::string *result);
  std::string *(__fastcall *getPlatformRecalibrationMessageTTS)(HolographicPlatform *this, std::string *result, const GamePadRemappingLayout *);
  std::string *(__fastcall *getPlatformAlignmentPrompt)(HolographicPlatform *this, std::string *result);
  std::string *(__fastcall *getPlatformAlignmentPromptTTS)(HolographicPlatform *this, std::string *result, const GamePadRemappingLayout *);
  bool (__fastcall *forceControllerUsage)(HolographicPlatform *this);
  bool (__fastcall *separateEyePasses)(HolographicPlatform *this);
  void (__fastcall *createRenderGraph)(HolographicPlatform *this, mce::RenderGraph *, IClientInstance *);
  bool (__fastcall *isGazeDevicePresent)(HolographicPlatform *this);
  bool (__fastcall *isGestureDevicePresent)(HolographicPlatform *this);
  bool (__fastcall *useAlternateTouchInput)(HolographicPlatform *this);
  void (__fastcall *resetBaseFrameOfReference)(HolographicPlatform *this, float, bool);
  HolographicPlatform::LUID (__fastcall *getHoloDeviceAdapterLUID)(HolographicPlatform *this);
  void (__fastcall *captureRenderDevice)(HolographicPlatform *this);
  bool (__fastcall *isLocated)(HolographicPlatform *this);
  bool (__fastcall *isPrimaryHandHeld)(HolographicPlatform *this);
  bool (__fastcall *isSecondaryHandHeld)(HolographicPlatform *this);
  void (__fastcall *setScreenLocation)(HolographicPlatform *this, const Matrix *);
  void (__fastcall *setScreenLocation)(HolographicPlatform *this, const Vec3 *, const Vec3 *, float);
  void (__fastcall *setHeadlockedUITransform)(HolographicPlatform *this, const Matrix *, const float);
  void (__fastcall *setScreenLocationOffset)(HolographicPlatform *this, const Vec3 *);
  void (__fastcall *resetScreenLocationOffset)(HolographicPlatform *this);
  void (__fastcall *setHoloviewerLocation)(HolographicPlatform *this, const Matrix *);
  void (__fastcall *setHoloviewerLocation)(HolographicPlatform *this, const Vec3 *, const Vec3 *, float, bool);
  void (__fastcall *setRealityAnchorLocation)(HolographicPlatform *this, const Matrix *);
  float (__fastcall *getViewableScreenSize)(HolographicPlatform *this, float);
  void (__fastcall *defaultLSRPlane)(HolographicPlatform *this, HolographicPlatform::MCLocation);
  void (__fastcall *updateLSRPlane)(HolographicPlatform *this, HolographicPlatform::MCLocation, const Vec3 *);
  void (__fastcall *getLastLSRPlanePosAndNormPS)(HolographicPlatform *this, Vec3 *, Vec3 *);
  float (__fastcall *getSRCastDistance)(HolographicPlatform *this);
  bool (__fastcall *startEnvironmentScanning)(HolographicPlatform *this);
  void (__fastcall *stopEnvironmentScanning)(HolographicPlatform *this);
  void (__fastcall *resetEnvironmentScan)(HolographicPlatform *this);
  void (__fastcall *renderSRData)(HolographicPlatform *this, float, float);
  bool (__fastcall *hideCursorOnFocusLost)(HolographicPlatform *this, IClientInstance *);
  bool (__fastcall *getGazeCastResultPS)(HolographicPlatform *this, Vec3 *, Vec3 *, Vec3 *);
  bool (__fastcall *getStereoEnabled)(HolographicPlatform *this);
  void (__fastcall *setStereoEnabled)(HolographicPlatform *this, bool);
  void (__fastcall *delayForNextFingerPress)(HolographicPlatform *this, int);
  float (__fastcall *getPreferredUIAspectRatio)(HolographicPlatform *this);
  float (__fastcall *getPreferredLivingRoomLevelAspectRation)(HolographicPlatform *this);
  float (__fastcall *getVRFOV)(HolographicPlatform *this);
  float (__fastcall *getDefaultIngameUIDistance)(HolographicPlatform *this);
  bool (__fastcall *shouldCompressHUDWidth)(HolographicPlatform *this);
  void (__fastcall *getUIScreenWidthHeightScale)(HolographicPlatform *this, unsigned int *, unsigned int *, float *);
  void (__fastcall *getLivingRoomLevelTextureWidthHeight)(HolographicPlatform *this, unsigned int *, unsigned int *, float *);
  void (__fastcall *getItemInHandOffset)(HolographicPlatform *this, Vec3 *);
  const std::string *(__fastcall *getLivingRoomHintTextTTS)(HolographicPlatform *this, const std::string *result, const GamePadRemappingLayout *);
  UIRenderMode (__fastcall *getUIRenderMode)(HolographicPlatform *this);
  UIRenderMode (__fastcall *getVRHUDRenderMode)(HolographicPlatform *this);
  float (__fastcall *getHudAlphaBlendFactor)(HolographicPlatform *this);
  bool (__fastcall *getVRLowFrequencyHUD)(HolographicPlatform *this);
  const char *(__fastcall *getHandMaterial)(HolographicPlatform *this);
  bool (__fastcall *wantsToStealMouse)(HolographicPlatform *this);
  bool (__fastcall *drawHolographicBordersForUI)(HolographicPlatform *this);
  float (__fastcall *getDefaultHalfHoloScreenWidth)(HolographicPlatform *this);
  float (__fastcall *getDefaultHalfHoloHUDWidth)(HolographicPlatform *this);
  float (__fastcall *getAmbientBoost)(HolographicPlatform *this, float);
  bool (__fastcall *clampToMinimumLight)(HolographicPlatform *this);
  void (__fastcall *setUIClipRect)(HolographicPlatform *this, const RectangleArea *);
  float (__fastcall *getUIClipGrowPixels)(HolographicPlatform *this);
  bool (__fastcall *isFeatureEnabled)(HolographicPlatform *this, unsigned int);
  std::optional&lt;mce::framebuilder::gamecomponents::VrConfiguration&gt; *(__fastcall *getVrConfiguration)(HolographicPlatform *this, std::optional&lt;mce::framebuilder::gamecomponents::VrConfiguration&gt; *result);
  void (__fastcall *frameUpdate)(HolographicPlatform *this, FrameUpdateContext *);
  unsigned __int16 (__fastcall *getLivingRoomViewSetId)(HolographicPlatform *this);
  const mce::framebuilder::LivingRoomDescription *(__fastcall *getLivingRoomDescription)(HolographicPlatform *this);
  float (__fastcall *getMinimumLivingRoomFrameDistance)(HolographicPlatform *this);
  bool (__fastcall *neverStealMouse)(HolographicPlatform *this);
  bool (__fastcall *present)(HolographicPlatform *this, ScreenContext *);
  bool (__fastcall *isWaitingForPresent)(HolographicPlatform *this);
  bool (__fastcall *getAllowMirrorPresent)(HolographicPlatform *this);
  bool (__fastcall *permitRendering)(HolographicPlatform *this);
  bool (__fastcall *permitAudio)(HolographicPlatform *this);
  void (__fastcall *_prepPlatformSpecificTransforms)(HolographicPlatform *this);
  bool (__fastcall *_shouldRenderIn2D)(HolographicPlatform *this);
};

</code></pre></div><h3 id="holographicplatform-holocursorworldparams"><a href="#holographicplatform-holocursorworldparams" class="header-anchor">#</a> <code>HolographicPlatform::HoloCursorWorldParams</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(2)) HolographicPlatform::HoloCursorWorldParams
{
  HitResult hit;
  float pickRange;
  Vec3 pickDirectionMC;
  Vec3 lastGazePntMC;
  Vec3 lastGazeDirMC;
  Vec3 linearizedJumpAdj;
  float brightness;
  float overallScale;
  bool renderTextureMode;
  bool renderAsACube;
  bool forceFullyVisibleCrosshair;
};

</code></pre></div><h3 id="holoscenerenderer"><a href="#holoscenerenderer" class="header-anchor">#</a> <code>HolosceneRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HolosceneRenderer
{
  mce::Mesh mGazeIconMesh;
  mce::Mesh mHoloScreenFrame;
  mce::Mesh mHoloScreenLivingRoom;
  mce::Mesh mHoloScreenLivingRoomTable;
  mce::Mesh mUICursorMesh;
  mce::Mesh mHandFrameMesh;
  mce::Mesh mHandPointerMesh;
  mce::Mesh mCoordFrameMesh;
  mce::Mesh mGameCursorMesh;
  mce::Mesh mGameCursorShadowMesh;
  mce::Mesh mGameCursorCubeMesh;
  mce::Mesh mHandMeshLeft;
  mce::Mesh mHandMeshRight;
  mce::TexturePtr mWhiteIconTexture;
  mce::TexturePtr mHolographicWallTexture;
  mce::TexturePtr mCrosshairTexture;
  mce::TexturePtr mLivingRoomTexture;
  mce::TexturePtr mHandTexture;
  mce::MaterialPtr mHoloCursorPseudoShadowMaterial;
  mce::MaterialPtr mHoloCursorMainPartMaterial;
  mce::MaterialPtr mLivingRoomMaterial;
  mce::MaterialPtr mTextMaterial;
  mce::MaterialPtr mCoordFrameMaterial;
  mce::MaterialPtr mHandPointerMaterial;
  mce::MaterialPtr mHandMaterial;
  IClientInstance *mClient;
  mce::Color mVanishingColor;
  std::string mHintTextLocId;
  int mHintCycles;
  float mUIDist;
  float mHalfHoloScreenWidth;
  float mHalfHoloHUDWidth;
};

</code></pre></div><h3 id="hbui-resourceregistry-pathcount"><a href="#hbui-resourceregistry-pathcount" class="header-anchor">#</a> <code>hbui::ResourceRegistry::PathCount</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::ResourceRegistry::PathCount
{
  unsigned int mRefcount;
  Core::PathBuffer&lt;std::string &gt; mPath;
};

</code></pre></div><h3 id="hbui-resourceregistry"><a href="#hbui-resourceregistry" class="header-anchor">#</a> <code>hbui::ResourceRegistry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::ResourceRegistry
{
  std::unordered_map&lt;std::string,hbui::ResourceRegistry::PathCount&gt; mPaths;
  unsigned __int64 mNextAutomaticallyIncrementedId;
};

</code></pre></div><h3 id="hbui-routerhistory"><a href="#hbui-routerhistory" class="header-anchor">#</a> <code>hbui::RouterHistory</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::RouterHistory
{
  std::vector&lt;hbui::RouterLocation&gt; mEntries;
  int mCurrentIndex;
  hbui::RouterAction mLastAction;
  std::function&lt;void __cdecl(std::optional&lt;hbui::RouterLocation&gt; const &amp;,hbui::RouterLocation const &amp;)&gt; mOnChangeCallback;
  std::string mGetActionHelper;
};

</code></pre></div><h3 id="hbui-router"><a href="#hbui-router" class="header-anchor">#</a> <code>hbui::Router</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::Router
{
  hbui::RouterHistory mRouterHistory;
  hbui::RouterHistoryAdapter mRouterHistoryAdapter;
  std::unique_ptr&lt;hbui::IRouteMatcher&gt; mRouteMatcher;
  std::queue&lt;hbui::Router::QueuedRoute&gt; mQueuedRoutes;
  ISceneStack *mSceneStack;
  Core::Subject&lt;hbui::RouterObserver,Core::SingleThreadedLock&gt; mSubject;
  std::unique_ptr&lt;hbui::IRoutePrerequisiteHandler&gt; mPrerequisiteHandler;
  IScreenChangedEventing *mScreenChangedEventing;
  IClientInstance *mClientInstance;
  Social::IGameConnectionInfoProvider *mGameConnectionInfoProvider;
};

</code></pre></div><h3 id="hbui-routerhistoryadapter"><a href="#hbui-routerhistoryadapter" class="header-anchor">#</a> <code>hbui::RouterHistoryAdapter</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::RouterHistoryAdapter
{
  hbui::Router *mRouter;
  hbui::RouterHistory *mRouterHistory;
  hbui::RouterLocation mFallbackLocation;
};

</code></pre></div><h3 id="hbui-iroutematcher"><a href="#hbui-iroutematcher" class="header-anchor">#</a> <code>hbui::IRouteMatcher</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::IRouteMatcher
{
  hbui::IRouteMatcher_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="hbui-iroutematcher-vtbl"><a href="#hbui-iroutematcher-vtbl" class="header-anchor">#</a> <code>hbui::IRouteMatcher_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::IRouteMatcher_vtbl
{
  void (__fastcall *~IRouteMatcher)(hbui::IRouteMatcher *this);
  void (__fastcall *add)(hbui::IRouteMatcher *this, const std::string *, const std::basic_regex&lt;char,std::regex_traits&lt;char&gt; &gt; *, hbui::RouteType, hbui::RouteMode, std::function&lt;void __cdecl(std::string const &amp;)&gt;);
  void (__fastcall *addDefault)(hbui::IRouteMatcher *this, const std::string *, const std::string *);
  void (__fastcall *resolve)(hbui::IRouteMatcher *this, const std::string *);
  bool (__fastcall *isSupported)(hbui::IRouteMatcher *this, const std::string *);
  bool (__fastcall *areCompatible)(hbui::IRouteMatcher *this, const std::string *, const std::string *);
  bool (__fastcall *isRouteInDirectory)(hbui::IRouteMatcher *this, const std::string *, const std::string *);
  std::optional&lt;std::string &gt; *(__fastcall *getDefaultRouteForFile)(hbui::IRouteMatcher *this, std::optional&lt;std::string &gt; *result, const std::string *);
  std::optional&lt;std::string &gt; *(__fastcall *getDefaultRouteForDirectory)(hbui::IRouteMatcher *this, std::optional&lt;std::string &gt; *result, const std::string *);
  std::optional&lt;enum hbui::RouteType&gt; *(__fastcall *getRouteType)(hbui::IRouteMatcher *this, std::optional&lt;enum hbui::RouteType&gt; *result, const std::string *);
  std::optional&lt;enum hbui::RouteMode&gt; *(__fastcall *getRouteMode)(hbui::IRouteMatcher *this, std::optional&lt;enum hbui::RouteMode&gt; *result, const std::string *);
};

</code></pre></div><h3 id="hbui-router-queuedroute"><a href="#hbui-router-queuedroute" class="header-anchor">#</a> <code>hbui::Router::QueuedRoute</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) hbui::Router::QueuedRoute
{
  std::string route;
  std::string state;
  hbui::Router::QueuedRouteAction action;
};

</code></pre></div><h3 id="hbui-routerobserver"><a href="#hbui-routerobserver" class="header-anchor">#</a> <code>hbui::RouterObserver</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::RouterObserver : Core::Observer&lt;hbui::RouterObserver,Core::SingleThreadedLock&gt;
{
};

</code></pre></div><h3 id="hbui-routerobserver-vtbl"><a href="#hbui-routerobserver-vtbl" class="header-anchor">#</a> <code>hbui::RouterObserver_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::RouterObserver_vtbl
{
  void (__fastcall *~Observer&lt;hbui::RouterObserver,Core::SingleThreadedLock&gt;)(Core::Observer&lt;hbui::RouterObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *_onSubjectDestroyed)(Core::Observer&lt;hbui::RouterObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *onRouteChanged)(hbui::RouterObserver *this, const std::optional&lt;hbui::RouterLocation&gt; *, const hbui::RouterLocation *, hbui::RouterAction);
};

</code></pre></div><h3 id="hbui-irouteprerequisitehandler"><a href="#hbui-irouteprerequisitehandler" class="header-anchor">#</a> <code>hbui::IRoutePrerequisiteHandler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::IRoutePrerequisiteHandler
{
  hbui::IRoutePrerequisiteHandler_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="hbui-irouteprerequisitehandler-vtbl"><a href="#hbui-irouteprerequisitehandler-vtbl" class="header-anchor">#</a> <code>hbui::IRoutePrerequisiteHandler_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::IRoutePrerequisiteHandler_vtbl
{
  void (__fastcall *~IRoutePrerequisiteHandler)(hbui::IRoutePrerequisiteHandler *this);
  hbui::RoutePrerequisiteState (__fastcall *handleRoutePrerequisites)(hbui::IRoutePrerequisiteHandler *this, const std::string *, const std::string *);
};

</code></pre></div><h3 id="hbui-ifeature"><a href="#hbui-ifeature" class="header-anchor">#</a> <code>hbui::IFeature</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::IFeature
{
  hbui::IFeature_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="hbui-ifeature-vtbl"><a href="#hbui-ifeature-vtbl" class="header-anchor">#</a> <code>hbui::IFeature_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::IFeature_vtbl
{
  void (__fastcall *~IFeature)(hbui::IFeature *this);
  bool (__fastcall *isEnabled)(hbui::IFeature *this);
  void (__fastcall *registerIsEnabledChangedCallback)(hbui::IFeature *this, Bedrock::PubSub::ScopedSubscription *, std::function&lt;void __cdecl(bool)&gt;);
};

</code></pre></div><h3 id="hbui-feature"><a href="#hbui-feature" class="header-anchor">#</a> <code>hbui::Feature</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::Feature : hbui::IFeature
{
  Option *mMainToggle;
};

</code></pre></div><h3 id="hbui-feature-vtbl"><a href="#hbui-feature-vtbl" class="header-anchor">#</a> <code>hbui::Feature_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::Feature_vtbl
{
  void (__fastcall *~IFeature)(hbui::IFeature *this);
  bool (__fastcall *isEnabled)(hbui::IFeature *this);
  void (__fastcall *registerIsEnabledChangedCallback)(hbui::IFeature *this, Bedrock::PubSub::ScopedSubscription *, std::function&lt;void __cdecl(bool)&gt;);
};

</code></pre></div><h3 id="hbui-routerconfiguration"><a href="#hbui-routerconfiguration" class="header-anchor">#</a> <code>hbui::RouterConfiguration</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::RouterConfiguration
{
  hbui::RouterConfiguration_vtbl *__vftable /*VFT*/;
  const ResourcePackManager *mPackManager;
  IFileAccess *mFileAccess;
  Core::PathBuffer&lt;std::string &gt; mDataPath;
  std::vector&lt;hbui::Route&gt; mDefaultRoutes;
  std::vector&lt;hbui::Route&gt; mInGameRoutes;
  std::vector&lt;hbui::Route&gt; mOutOfGameRoutes;
};

</code></pre></div><h3 id="hbui-routerconfiguration-vtbl"><a href="#hbui-routerconfiguration-vtbl" class="header-anchor">#</a> <code>hbui::RouterConfiguration_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::RouterConfiguration_vtbl
{
  void (__fastcall *~RouterConfiguration)(hbui::RouterConfiguration *this);
};

</code></pre></div><h3 id="hbui-route"><a href="#hbui-route" class="header-anchor">#</a> <code>hbui::Route</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) hbui::Route
{
  std::string fileName;
  std::string route;
  _BYTE mode[4];
};

</code></pre></div><h3 id="hummingbirdui"><a href="#hummingbirdui" class="header-anchor">#</a> <code>HummingbirdUI</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HummingbirdUI : IHummingbirdUI
{
  hbui::DebugData mDebugData;
  hbui::Feature mFeatureToggle;
  hbui::Feature mUIRefreshToggle;
  hbui::Feature mUITextToSpeechToggle;
  ARVRPlatform mArVrPlatform;
  std::weak_ptr&lt;IFlightingToggles&gt; mFlightingToggles;
  std::function&lt;void __cdecl(void)&gt; mResetToMainMenu;
  Core::IFileSystem *mFileSystem;
  IFileAccess *mAppPackageFileAccess;
  const Core::PathBuffer&lt;std::string &gt; mPackagePath;
  IFileAccess *mRawFileAccess;
  const ResourcePackManager *mPackManager;
  hbui::RouterConfiguration mRouterConfigurationLoader;
  std::unique_ptr&lt;hbui::ILibrary&gt; mLibrary;
  hbui::ResourceRegistry mResourceRegistry;
  bool mAppWillRestart;
  std::vector&lt;HummingbirdUI::CallbackEntry&gt; mRouteConfigurationChangeCallbacks;
  Bedrock::PubSub::ScopedSubscription mUIRefreshSubscription;
  Bedrock::PubSub::ScopedSubscription mUITextToSpeechSubscription;
  Bedrock::PubSub::ScopedSubscription mFlightingTogglesSubscription;
};

</code></pre></div><h3 id="hummingbirdui-vtbl"><a href="#hummingbirdui-vtbl" class="header-anchor">#</a> <code>HummingbirdUI_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HummingbirdUI_vtbl
{
  void (__fastcall *~IHummingbirdUI)(IHummingbirdUI *this);
  bool (__fastcall *isUIRefreshEnabled)(IHummingbirdUI *this);
};

</code></pre></div><h3 id="hudscreencapabilities"><a href="#hudscreencapabilities" class="header-anchor">#</a> <code>HudScreenCapabilities</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HudScreenCapabilities : TypedScreenCapabilities&lt;HudScreenCapabilities&gt;
{
  bool mDisplayChatInputMsg;
};

</code></pre></div><h3 id="hudscreencapabilities-vtbl"><a href="#hudscreencapabilities-vtbl" class="header-anchor">#</a> <code>HudScreenCapabilities_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HudScreenCapabilities_vtbl
{
  void (__fastcall *~IScreenCapabilities)(IScreenCapabilities *this);
  bool (__fastcall *isOfType)(IScreenCapabilities *this, typeid_t&lt;IScreenCapabilities&gt;);
};

</code></pre></div><h3 id="hitdetectsystem"><a href="#hitdetectsystem" class="header-anchor">#</a> <code>HitDetectSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HitDetectSystem
{
  HitDetectSystem_vtbl *__vftable /*VFT*/;
  float mPickRange;
  float mInteractRange;
  bool mEvaluated;
  __declspec(align(8)) HitResult mViewHitResult;
  HitResult mViewLastHitResult;
  HitResult mViewLiquidHitResult;
  HitResult mViewLastLiquidHitResult;
  HitResult mPickHitResult;
  HitResult mPickLastHitResult;
  HitResult mPickLiquidHitResult;
  HitResult mPickLastLiquidHitResult;
  ClientHitDetectCoordinator *mEventCoordinator;
};

</code></pre></div><h3 id="hitdetectsystem-vtbl"><a href="#hitdetectsystem-vtbl" class="header-anchor">#</a> <code>HitDetectSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HitDetectSystem_vtbl
{
  void (__fastcall *~HitDetectSystem)(HitDetectSystem *this);
  void (__fastcall *reset)(HitDetectSystem *this);
  void (__fastcall *tick)(HitDetectSystem *this);
  void (__fastcall *evaluate)(HitDetectSystem *this, IClientInstance *, float);
  void (__fastcall *_evaluateType)(HitDetectSystem *this, IClientInstance *, float, Actor *, LocalPlayer *, bool, HitResult *, HitResult *);
};

</code></pre></div><h3 id="holohuddriftdynamics"><a href="#holohuddriftdynamics" class="header-anchor">#</a> <code>HoloHudDriftDynamics</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HoloHudDriftDynamics
{
  Matrix mMatrixPatch;
  Vec3 mHudDirPoseSpace;
  Vec3 mHudDirAVelPoseSpace;
  Vec3 mLastHudTargetDir;
  Vec3 mLastGazeToPoseDelta;
  long double mLastHudDirUpdateTime;
  bool mResetLastTargetDir;
  IClientInstance *mClient;
};

</code></pre></div><h3 id="hbui-itelemetry"><a href="#hbui-itelemetry" class="header-anchor">#</a> <code>hbui::ITelemetry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::ITelemetry
{
  hbui::ITelemetry_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="hbui-itelemetry-vtbl"><a href="#hbui-itelemetry-vtbl" class="header-anchor">#</a> <code>hbui::ITelemetry_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::ITelemetry_vtbl
{
  void (__fastcall *~ITelemetry)(hbui::ITelemetry *this);
  void (__fastcall *fireEventHummingbirdScreenLoadFailed)(hbui::ITelemetry *this);
  void (__fastcall *fireEventHummingbirdRouteUnsupported)(hbui::ITelemetry *this);
  void (__fastcall *fireEventHummingbirdJsException)(hbui::ITelemetry *this);
  void (__fastcall *fireEventScreenLoaded)(hbui::ITelemetry *this, const std::string *, long double, long double, long double);
};

</code></pre></div><h3 id="hbui-telemetry"><a href="#hbui-telemetry" class="header-anchor">#</a> <code>hbui::Telemetry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::Telemetry : hbui::ITelemetry
{
  IClientInstance *mClientInstance;
  IMinecraftEventing *mEventing;
};

</code></pre></div><h3 id="hbui-telemetry-vtbl"><a href="#hbui-telemetry-vtbl" class="header-anchor">#</a> <code>hbui::Telemetry_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::Telemetry_vtbl
{
  void (__fastcall *~ITelemetry)(hbui::ITelemetry *this);
  void (__fastcall *fireEventHummingbirdScreenLoadFailed)(hbui::ITelemetry *this);
  void (__fastcall *fireEventHummingbirdRouteUnsupported)(hbui::ITelemetry *this);
  void (__fastcall *fireEventHummingbirdJsException)(hbui::ITelemetry *this);
  void (__fastcall *fireEventScreenLoaded)(hbui::ITelemetry *this, const std::string *, long double, long double, long double);
};

</code></pre></div><h3 id="hardcodedspawnarearegistry"><a href="#hardcodedspawnarearegistry" class="header-anchor">#</a> <code>HardcodedSpawnAreaRegistry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HardcodedSpawnAreaRegistry
{
  std::unordered_map&lt;enum HardcodedSpawnAreaType,std::vector&lt;MobSpawnerData&gt;&gt; mMap;
};

</code></pre></div><h3 id="hooknetworkpeer"><a href="#hooknetworkpeer" class="header-anchor">#</a> <code>HookNetworkPeer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HookNetworkPeer : NetworkPeer
{
  unsigned int mUserId;
  NetworkHandler *mLobbyHandler;
  std::unique_ptr&lt;MPMCQueue&lt;std::string &gt;&gt; mIncomingData;
};

</code></pre></div><h3 id="hooknetworkpeer-vtbl"><a href="#hooknetworkpeer-vtbl" class="header-anchor">#</a> <code>HookNetworkPeer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HookNetworkPeer_vtbl
{
  void (__fastcall *~NetworkPeer)(NetworkPeer *this);
  void (__fastcall *sendPacket)(NetworkPeer *this, const std::string *, NetworkPeer::Reliability, int, unsigned __int16, Compressibility);
  NetworkPeer::DataStatus (__fastcall *receivePacket)(NetworkPeer *this, std::string *);
  NetworkPeer::NetworkStatus *(__fastcall *getNetworkStatus)(NetworkPeer *this, NetworkPeer::NetworkStatus *result);
  void (__fastcall *addIncomingData)(NetworkPeer *this, std::string);
  void (__fastcall *update)(NetworkPeer *this);
  void (__fastcall *flush)(NetworkPeer *this, std::function&lt;void __cdecl(void)&gt; *);
};

</code></pre></div><h3 id="hudcontainermanagermodel"><a href="#hudcontainermanagermodel" class="header-anchor">#</a> <code>HudContainerManagerModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudContainerManagerModel : ContainerManagerModel
{
  std::vector&lt;ItemStack&gt; mLastSlots;
};

</code></pre></div><h3 id="hudcontainermanagermodel-vtbl"><a href="#hudcontainermanagermodel-vtbl" class="header-anchor">#</a> <code>HudContainerManagerModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HudContainerManagerModel_vtbl
{
  void (__fastcall *~IContainerManager)(IContainerManager *this);
  ContainerID (__fastcall *getContainerId)(IContainerManager *this);
  void (__fastcall *setContainerId)(IContainerManager *this, ContainerID);
  ContainerType (__fastcall *getContainerType)(IContainerManager *this);
  void (__fastcall *setContainerType)(IContainerManager *this, ContainerType);
  void (__fastcall *serverInitItemStackIds)(IContainerManager *this);
  std::vector&lt;ItemStack&gt; *(__fastcall *getItemCopies)(IContainerManager *this, std::vector&lt;ItemStack&gt; *result);
  void (__fastcall *setSlot)(IContainerManager *this, int, const ItemStack *, bool);
  const ItemStack *(__fastcall *getSlot)(IContainerManager *this, int);
  void (__fastcall *setData)(IContainerManager *this, int, int);
  void (__fastcall *broadcastChanges)(IContainerManager *this);
  bool (__fastcall *validateContainer)(IContainerManager *this);
  bool (__fastcall *isValid)(ContainerManagerModel *this, float);
  ContainerScreenContext *(__fastcall *_postInit)(ContainerManagerModel *this, ContainerScreenContext *result);
};

</code></pre></div><h3 id="hidedescription"><a href="#hidedescription" class="header-anchor">#</a> <code>HideDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HideDescription : ComponentDescription
{
};

</code></pre></div><h3 id="hidedescription-vtbl"><a href="#hidedescription-vtbl" class="header-anchor">#</a> <code>HideDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HideDescription_vtbl
{
  const char *(__fastcall *getJsonName)(Description *this);
  void (__fastcall *~Description)(Description *this);
  void (__fastcall *deserializeData)(Description *this, DeserializeDataParams);
  void (__fastcall *serializeData)(Description *this, Json::Value *);
};

</code></pre></div><h3 id="hbui-facetbase-hbui-animationfacet"><a href="#hbui-facetbase-hbui-animationfacet" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::AnimationFacet&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetBase&lt;hbui::AnimationFacet&gt; : hbui::IFacet
{
};

</code></pre></div><h3 id="hbui-facetbase-hbui-animationfacet-vtbl"><a href="#hbui-facetbase-hbui-animationfacet-vtbl" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::AnimationFacet&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FacetBase&lt;hbui::AnimationFacet&gt;_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-optionwrapper-bool"><a href="#hbui-optionwrapper-bool" class="header-anchor">#</a> <code>hbui::OptionWrapper&lt;bool&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::OptionWrapper&lt;bool&gt;
{
  Option *mOption;
  Bedrock::PubSub::ScopedSubscription mOptionSubscription;
};

</code></pre></div><h3 id="hbui-animationfacet"><a href="#hbui-animationfacet" class="header-anchor">#</a> <code>hbui::AnimationFacet</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::AnimationFacet : hbui::FacetBase&lt;hbui::AnimationFacet&gt;
{
  bool mIsDirty;
  bool mScreenAnimations;
  hbui::OptionWrapper&lt;bool&gt; mScreenAnimationsOption;
};

</code></pre></div><h3 id="hbui-animationfacet-vtbl"><a href="#hbui-animationfacet-vtbl" class="header-anchor">#</a> <code>hbui::AnimationFacet_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::AnimationFacet_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-optionwrapper-bool-ctor-l5-lambda-0dd2ebf6df7ed0553bba2bc4c3b54465"><a href="#hbui-optionwrapper-bool-ctor-l5-lambda-0dd2ebf6df7ed0553bba2bc4c3b54465" class="header-anchor">#</a> <code>hbui::OptionWrapper&lt;bool&gt;::{ctor}::__l5::&lt;lambda_0dd2ebf6df7ed0553bba2bc4c3b54465&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::OptionWrapper&lt;bool&gt;::{ctor}::__l5::&lt;lambda_0dd2ebf6df7ed0553bba2bc4c3b54465&gt;
{
  hbui::OptionWrapper&lt;bool&gt; *const __this;
  bool *value;
  bool *isDirty;
};

</code></pre></div><h3 id="hbui-routeprerequisitehandlermc"><a href="#hbui-routeprerequisitehandlermc" class="header-anchor">#</a> <code>hbui::RoutePrerequisiteHandlerMC</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::RoutePrerequisiteHandlerMC : hbui::IRoutePrerequisiteHandler
{
  IMinecraftGame *mMinecraftGame;
  IClientInstance *mClient;
};

</code></pre></div><h3 id="hbui-routeprerequisitehandlermc-vtbl"><a href="#hbui-routeprerequisitehandlermc-vtbl" class="header-anchor">#</a> <code>hbui::RoutePrerequisiteHandlerMC_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::RoutePrerequisiteHandlerMC_vtbl
{
  void (__fastcall *~IRoutePrerequisiteHandler)(hbui::IRoutePrerequisiteHandler *this);
  hbui::RoutePrerequisiteState (__fastcall *handleRoutePrerequisites)(hbui::IRoutePrerequisiteHandler *this, const std::string *, const std::string *);
};

</code></pre></div><h3 id="homesection"><a href="#homesection" class="header-anchor">#</a> <code>HomeSection</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HomeSection : PDPSection
{
  const StoreCatalogItem *mItem;
};

</code></pre></div><h3 id="homesection-vtbl"><a href="#homesection-vtbl" class="header-anchor">#</a> <code>HomeSection_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HomeSection_vtbl
{
  void (__fastcall *~PDPSection)(PDPSection *this);
  std::unique_ptr&lt;ScreenController&gt; *(__fastcall *makeScreenController)(PDPSection *this, std::unique_ptr&lt;ScreenController&gt; *result, std::shared_ptr&lt;MainMenuScreenModel&gt;);
};

</code></pre></div><h3 id="hydrateresponsecallbackhandler"><a href="#hydrateresponsecallbackhandler" class="header-anchor">#</a> <code>HydrateResponseCallbackHandler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HydrateResponseCallbackHandler
{
  HydrateResponseCallbackHandler_vtbl *__vftable /*VFT*/;
  std::string mAcceptLanguage;
};

</code></pre></div><h3 id="hydrateresponsecallbackhandler-vtbl"><a href="#hydrateresponsecallbackhandler-vtbl" class="header-anchor">#</a> <code>HydrateResponseCallbackHandler_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HydrateResponseCallbackHandler_vtbl
{
  void (__fastcall *~HydrateResponseCallbackHandler)(HydrateResponseCallbackHandler *this);
  void (__fastcall *parseResponse)(HydrateResponseCallbackHandler *this, const struct web::json::value *, const CatalogBackend *);
  void (__fastcall *handleResponseCallback)(HydrateResponseCallbackHandler *this);
};

</code></pre></div><h3 id="hbui-facetbase-hbui-routerfacet"><a href="#hbui-facetbase-hbui-routerfacet" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::RouterFacet&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetBase&lt;hbui::RouterFacet&gt; : hbui::IFacet
{
};

</code></pre></div><h3 id="hbui-facetbase-hbui-routerfacet-vtbl"><a href="#hbui-facetbase-hbui-routerfacet-vtbl" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::RouterFacet&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FacetBase&lt;hbui::RouterFacet&gt;_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-routerfacet"><a href="#hbui-routerfacet" class="header-anchor">#</a> <code>hbui::RouterFacet</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::RouterFacet : hbui::FacetBase&lt;hbui::RouterFacet&gt;, hbui::RouterObserver
{
  bool mIsDirty;
  hbui::Router *mRouter;
};

</code></pre></div><h3 id="hbui-routerfacet-vtbl"><a href="#hbui-routerfacet-vtbl" class="header-anchor">#</a> <code>hbui::RouterFacet_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::RouterFacet_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-routeprerequisitehandlermc-handleachievementprerequisites-l15-lambda-0cc03f2b69703d47831966b90071f608"><a href="#hbui-routeprerequisitehandlermc-handleachievementprerequisites-l15-lambda-0cc03f2b69703d47831966b90071f608" class="header-anchor">#</a> <code>hbui::RoutePrerequisiteHandlerMC::_handleAchievementPrerequisites::__l15::&lt;lambda_0cc03f2b69703d47831966b90071f608&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::RoutePrerequisiteHandlerMC::_handleAchievementPrerequisites::__l15::&lt;lambda_0cc03f2b69703d47831966b90071f608&gt;
{
  hbui::RoutePrerequisiteHandlerMC *const __this;
  const std::string achievementDeepLinkId;
};

</code></pre></div><h3 id="hbui-routeprerequisitehandlermc-handleachievementprerequisites-l13-lambda-eeeb9f2af150426eb424d350f84fc216"><a href="#hbui-routeprerequisitehandlermc-handleachievementprerequisites-l13-lambda-eeeb9f2af150426eb424d350f84fc216" class="header-anchor">#</a> <code>hbui::RoutePrerequisiteHandlerMC::_handleAchievementPrerequisites::__l13::&lt;lambda_eeeb9f2af150426eb424d350f84fc216&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::RoutePrerequisiteHandlerMC::_handleAchievementPrerequisites::__l13::&lt;lambda_eeeb9f2af150426eb424d350f84fc216&gt;
{
};

</code></pre></div><h3 id="hudcontainermanagercontroller"><a href="#hudcontainermanagercontroller" class="header-anchor">#</a> <code>HudContainerManagerController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudContainerManagerController : ContainerManagerController
{
  std::weak_ptr&lt;HudContainerManagerModel&gt; mHudContainerManagerModel;
};

</code></pre></div><h3 id="hudcontainermanagercontroller-vtbl"><a href="#hudcontainermanagercontroller-vtbl" class="header-anchor">#</a> <code>HudContainerManagerController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HudContainerManagerController_vtbl
{
  void (__fastcall *~ContainerManagerController)(ContainerManagerController *this);
  void (__fastcall *registerContainerCallbacks)(ContainerManagerController *this);
  const ItemStackBase *(__fastcall *getTakeableItemStackBase)(ContainerManagerController *this, const SlotData *);
  void (__fastcall *handleTakeAmount)(ContainerManagerController *this, const SlotData *, int, const SlotData *);
  void (__fastcall *handleTakeAll)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handlePlaceAll)(ContainerManagerController *this, const SelectedSlotInfo *, const SlotData *);
  void (__fastcall *handleTakeHalf)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handlePlaceOne)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handlePlaceAmount)(ContainerManagerController *this, const SlotData *, int, const SlotData *);
  int (__fastcall *handleAutoPlace)(ContainerManagerController *this, const SlotData *, int, const std::vector&lt;AutoPlaceItem&gt; *, std::vector&lt;AutoPlaceResult&gt; *);
  int (__fastcall *handleAutoPlaceStack)(ContainerManagerController *this, const SlotData *, ItemTakeType, const std::vector&lt;AutoPlaceItem&gt; *, std::vector&lt;AutoPlaceResult&gt; *);
  void (__fastcall *handleSplitSingle)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handleSplitMultiple)(ContainerManagerController *this, const SelectedSlotInfo *, const ItemInstance *, const SlotData *);
  void (__fastcall *handleCoalesce)(ContainerManagerController *this, const SlotData *, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *handleSwap)(ContainerManagerController *this, const SlotData *, const SlotData *);
  bool (__fastcall *handleDrop)(ContainerManagerController *this, const SlotData *, const ItemTransferAmount);
  bool (__fastcall *handleDestroy)(ContainerManagerController *this, const SlotData *, const ItemTransferAmount);
  bool (__fastcall *handleDestroy)(ContainerManagerController *this, const SelectedSlotInfo *, const ItemTransferAmount);
  bool (__fastcall *handleConsume)(ContainerManagerController *this, const SlotData *, const ItemTransferAmount);
  void (__fastcall *handleAddToStack)(ContainerManagerController *this, const SlotData *, const SlotData *, ItemTakeType);
  void (__fastcall *closeContainers)(ContainerManagerController *this);
  const std::vector&lt;ContainerSplitControl&gt; *(__fastcall *getSplitItems)(ContainerManagerController *this);
  bool (__fastcall *isOutputSlot)(ContainerManagerController *this, const std::string *);
  void (__fastcall *_onItemTransferredFrom)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
  void (__fastcall *_onItemTransferredTo)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
  void (__fastcall *_onItemAcquired)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
  void (__fastcall *_onItemPlaced)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
};

</code></pre></div><h3 id="history-tickmobreplay"><a href="#history-tickmobreplay" class="header-anchor">#</a> <code>History::TickMobReplay</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj History::TickMobReplay : IReplayableActorInput
{
};

</code></pre></div><h3 id="history-tickmobreplay-vtbl"><a href="#history-tickmobreplay-vtbl" class="header-anchor">#</a> <code>History::TickMobReplay_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ History::TickMobReplay_vtbl
{
  void (__fastcall *~IReplayableActorInput)(IReplayableActorInput *this);
  void (__fastcall *advanceFrame)(IReplayableActorInput *this, IActorMovementProxy *);
  AdvanceFrameResult (__fastcall *advanceLiveFrame)(IReplayableActorInput *this, Actor *);
};

</code></pre></div><h3 id="history-synchedactordatareplay"><a href="#history-synchedactordatareplay" class="header-anchor">#</a> <code>History::SynchedActorDataReplay</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj History::SynchedActorDataReplay : IReplayableActorInput
{
  std::vector&lt;std::unique_ptr&lt;DataItem&gt;&gt; mData;
};

</code></pre></div><h3 id="history-synchedactordatareplay-vtbl"><a href="#history-synchedactordatareplay-vtbl" class="header-anchor">#</a> <code>History::SynchedActorDataReplay_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ History::SynchedActorDataReplay_vtbl
{
  void (__fastcall *~IReplayableActorInput)(IReplayableActorInput *this);
  void (__fastcall *advanceFrame)(IReplayableActorInput *this, IActorMovementProxy *);
  AdvanceFrameResult (__fastcall *advanceLiveFrame)(IReplayableActorInput *this, Actor *);
};

</code></pre></div><h3 id="history-attributereplay"><a href="#history-attributereplay" class="header-anchor">#</a> <code>History::AttributeReplay</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj History::AttributeReplay : IReplayableActorInput
{
  const UpdateAttributesPacket mPacket;
};

</code></pre></div><h3 id="history-attributereplay-vtbl"><a href="#history-attributereplay-vtbl" class="header-anchor">#</a> <code>History::AttributeReplay_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ History::AttributeReplay_vtbl
{
  void (__fastcall *~IReplayableActorInput)(IReplayableActorInput *this);
  void (__fastcall *advanceFrame)(IReplayableActorInput *this, IActorMovementProxy *);
  AdvanceFrameResult (__fastcall *advanceLiveFrame)(IReplayableActorInput *this, Actor *);
};

</code></pre></div><h3 id="history-createreplayableactorstatesource-l2-functionstatesource"><a href="#history-createreplayableactorstatesource-l2-functionstatesource" class="header-anchor">#</a> <code>History::createReplayableActorStateSource::__l2::FunctionStateSource</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj History::createReplayableActorStateSource::__l2::FunctionStateSource : IReplayableActorStateSource
{
  std::function&lt;std::unique_ptr&lt;IReplayableActorState&gt; __cdecl(IActorMovementProxy &amp;)&gt; mCreator;
};

</code></pre></div><h3 id="history-createreplayableactorstatesource-l2-functionstatesource-vtbl"><a href="#history-createreplayableactorstatesource-l2-functionstatesource-vtbl" class="header-anchor">#</a> <code>History::createReplayableActorStateSource::__l2::FunctionStateSource_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ History::createReplayableActorStateSource::__l2::FunctionStateSource_vtbl
{
  void (__fastcall *~IReplayableActorStateSource)(IReplayableActorStateSource *this);
  std::unique_ptr&lt;IReplayableActorState&gt; *(__fastcall *extract)(IReplayableActorStateSource *this, std::unique_ptr&lt;IReplayableActorState&gt; *result, IActorMovementProxy *);
};

</code></pre></div><h3 id="history-createplayersnapshotreplaysource-l2-playersnapshotreplay"><a href="#history-createplayersnapshotreplaysource-l2-playersnapshotreplay" class="header-anchor">#</a> <code>History::createPlayerSnapshotReplaySource::__l2::PlayerSnapshotReplay</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj History::createPlayerSnapshotReplaySource::__l2::PlayerSnapshotReplay : IReplayableActorState
{
  PlayerSnapshot mSnapshot;
};

</code></pre></div><h3 id="history-createplayersnapshotreplaysource-l2-playersnapshotreplay-vtbl"><a href="#history-createplayersnapshotreplaysource-l2-playersnapshotreplay-vtbl" class="header-anchor">#</a> <code>History::createPlayerSnapshotReplaySource::__l2::PlayerSnapshotReplay_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ History::createPlayerSnapshotReplaySource::__l2::PlayerSnapshotReplay_vtbl
{
  void (__fastcall *~IReplayableActorState)(IReplayableActorState *this);
  void (__fastcall *apply)(IReplayableActorState *this, IActorMovementProxy *);
};

</code></pre></div><h3 id="history-createplayersnapshotreplaysource-l2-lambda-1f894fb1c8414cded9e799b2cb78ac08"><a href="#history-createplayersnapshotreplaysource-l2-lambda-1f894fb1c8414cded9e799b2cb78ac08" class="header-anchor">#</a> <code>History::createPlayerSnapshotReplaySource::__l2::&lt;lambda_1f894fb1c8414cded9e799b2cb78ac08&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj History::createPlayerSnapshotReplaySource::__l2::&lt;lambda_1f894fb1c8414cded9e799b2cb78ac08&gt;
{
};

</code></pre></div><h3 id="history-synchedactordatareplay-advanceliveframe-l5-lambda-061e6f19e2a2840cfeb37a624df18704"><a href="#history-synchedactordatareplay-advanceliveframe-l5-lambda-061e6f19e2a2840cfeb37a624df18704" class="header-anchor">#</a> <code>History::SynchedActorDataReplay::advanceLiveFrame::__l5::&lt;lambda_061e6f19e2a2840cfeb37a624df18704&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj History::SynchedActorDataReplay::advanceLiveFrame::__l5::&lt;lambda_061e6f19e2a2840cfeb37a624df18704&gt;
{
  ActorUniqueID actorID;
};

</code></pre></div><h3 id="hmenu"><a href="#hmenu" class="header-anchor">#</a> <code>HMENU__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HMENU__
{
  int unused;
};

</code></pre></div><h3 id="hbitmap"><a href="#hbitmap" class="header-anchor">#</a> <code>HBITMAP__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HBITMAP__
{
  int unused;
};

</code></pre></div><h3 id="hkey"><a href="#hkey" class="header-anchor">#</a> <code>HKEY__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HKEY__
{
  int unused;
};

</code></pre></div><h3 id="hicon"><a href="#hicon" class="header-anchor">#</a> <code>HICON__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HICON__
{
  int unused;
};

</code></pre></div><h3 id="hbrush"><a href="#hbrush" class="header-anchor">#</a> <code>HBRUSH__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HBRUSH__
{
  int unused;
};

</code></pre></div><h3 id="hpalette"><a href="#hpalette" class="header-anchor">#</a> <code>HPALETTE__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HPALETTE__
{
  int unused;
};

</code></pre></div><h3 id="hdc"><a href="#hdc" class="header-anchor">#</a> <code>HDC__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HDC__
{
  int unused;
};

</code></pre></div><h3 id="henhmetafile"><a href="#henhmetafile" class="header-anchor">#</a> <code>HENHMETAFILE__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HENHMETAFILE__
{
  int unused;
};

</code></pre></div><h3 id="hstring"><a href="#hstring" class="header-anchor">#</a> <code>HSTRING__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HSTRING__
{
  int unused;
};

</code></pre></div><h3 id="hwinsta"><a href="#hwinsta" class="header-anchor">#</a> <code>HWINSTA__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HWINSTA__
{
  int unused;
};

</code></pre></div><h3 id="hostent"><a href="#hostent" class="header-anchor">#</a> <code>hostent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct hostent
{
  char *h_name;
  char **h_aliases;
  __int16 h_addrtype;
  __int16 h_length;
  char **h_addr_list;
};

</code></pre></div><h3 id="hstring-header"><a href="#hstring-header" class="header-anchor">#</a> <code>HSTRING_HEADER</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HSTRING_HEADER
{
  HSTRING_HEADER::&lt;unnamed_type_Reserved&gt; Reserved;
};

</code></pre></div><h3 id="hmetafile"><a href="#hmetafile" class="header-anchor">#</a> <code>HMETAFILE__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HMETAFILE__
{
  int unused;
};

</code></pre></div><h3 id="hrsrc"><a href="#hrsrc" class="header-anchor">#</a> <code>HRSRC__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HRSRC__
{
  int unused;
};

</code></pre></div><h3 id="hrawinput"><a href="#hrawinput" class="header-anchor">#</a> <code>HRAWINPUT__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HRAWINPUT__
{
  int unused;
};

</code></pre></div><h3 id="htouchinput"><a href="#htouchinput" class="header-anchor">#</a> <code>HTOUCHINPUT__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HTOUCHINPUT__
{
  int unused;
};

</code></pre></div><h3 id="hashedstring-stringhasher-char-const"><a href="#hashedstring-stringhasher-char-const" class="header-anchor">#</a> <code>HashedString::StringHasher&lt;char const *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HashedString::StringHasher&lt;char const *&gt;
{
};

</code></pre></div><h3 id="hashedstring-hash64-0"><a href="#hashedstring-hash64-0" class="header-anchor">#</a> <code>HashedString::Hash64&lt;0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HashedString::Hash64&lt;0&gt;
{
};

</code></pre></div><h3 id="hashedstring-hash64-nonullterminator-0"><a href="#hashedstring-hash64-nonullterminator-0" class="header-anchor">#</a> <code>HashedString::Hash64_noNullTerminator&lt;0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HashedString::Hash64_noNullTerminator&lt;0&gt;
{
};

</code></pre></div><h3 id="htask"><a href="#htask" class="header-anchor">#</a> <code>HTASK__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HTASK__
{
  int unused;
};

</code></pre></div><h3 id="hpen"><a href="#hpen" class="header-anchor">#</a> <code>HPEN__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HPEN__
{
  int unused;
};

</code></pre></div><h3 id="hrgn"><a href="#hrgn" class="header-anchor">#</a> <code>HRGN__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HRGN__
{
  int unused;
};

</code></pre></div><h3 id="haccel"><a href="#haccel" class="header-anchor">#</a> <code>HACCEL__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HACCEL__
{
  int unused;
};

</code></pre></div><h3 id="hdesk"><a href="#hdesk" class="header-anchor">#</a> <code>HDESK__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HDESK__
{
  int unused;
};

</code></pre></div><h3 id="humpd"><a href="#humpd" class="header-anchor">#</a> <code>HUMPD__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HUMPD__
{
  int unused;
};

</code></pre></div><h3 id="himc"><a href="#himc" class="header-anchor">#</a> <code>HIMC__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HIMC__
{
  int unused;
};

</code></pre></div><h3 id="hhook"><a href="#hhook" class="header-anchor">#</a> <code>HHOOK__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HHOOK__
{
  int unused;
};

</code></pre></div><h3 id="hwineventhook"><a href="#hwineventhook" class="header-anchor">#</a> <code>HWINEVENTHOOK__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HWINEVENTHOOK__
{
  int unused;
};

</code></pre></div><h3 id="hglrc"><a href="#hglrc" class="header-anchor">#</a> <code>HGLRC__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HGLRC__
{
  int unused;
};

</code></pre></div><h3 id="hashtype64-hash"><a href="#hashtype64-hash" class="header-anchor">#</a> <code>HashType64_hash</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HashType64_hash
{
};

</code></pre></div><h3 id="himcc"><a href="#himcc" class="header-anchor">#</a> <code>HIMCC__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HIMCC__
{
  int unused;
};

</code></pre></div><h3 id="hcolorspace"><a href="#hcolorspace" class="header-anchor">#</a> <code>HCOLORSPACE__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HCOLORSPACE__
{
  int unused;
};

</code></pre></div><h3 id="hmonitor"><a href="#hmonitor" class="header-anchor">#</a> <code>HMONITOR__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HMONITOR__
{
  int unused;
};

</code></pre></div><h3 id="hgestureinfo"><a href="#hgestureinfo" class="header-anchor">#</a> <code>HGESTUREINFO__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HGESTUREINFO__
{
  int unused;
};

</code></pre></div><h3 id="hlsurf"><a href="#hlsurf" class="header-anchor">#</a> <code>HLSURF__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HLSURF__
{
  int unused;
};

</code></pre></div><h3 id="hfont"><a href="#hfont" class="header-anchor">#</a> <code>HFONT__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HFONT__
{
  int unused;
};

</code></pre></div><h3 id="hstring-buffer"><a href="#hstring-buffer" class="header-anchor">#</a> <code>HSTRING_BUFFER__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HSTRING_BUFFER__
{
  int unused;
};

</code></pre></div><h3 id="hkl"><a href="#hkl" class="header-anchor">#</a> <code>HKL__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HKL__
{
  int unused;
};

</code></pre></div><h3 id="hstr"><a href="#hstr" class="header-anchor">#</a> <code>HSTR__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HSTR__
{
  int unused;
};

</code></pre></div><h3 id="hdrop"><a href="#hdrop" class="header-anchor">#</a> <code>HDROP__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HDROP__
{
  int unused;
};

</code></pre></div><h3 id="hsprite"><a href="#hsprite" class="header-anchor">#</a> <code>HSPRITE__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HSPRITE__
{
  int unused;
};

</code></pre></div><h3 id="helpcommand"><a href="#helpcommand" class="header-anchor">#</a> <code>HelpCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HelpCommand : Command
{
  std::string mCommand;
  int mPage;
};

</code></pre></div><h3 id="helpcommand-vtbl"><a href="#helpcommand-vtbl" class="header-anchor">#</a> <code>HelpCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HelpCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="hbui-scene"><a href="#hbui-scene" class="header-anchor">#</a> <code>hbui::Scene</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::Scene : AbstractScene, hbui::IViewListener, hbui::RouterObserver
{
  unsigned int mWidth;
  unsigned int mHeight;
  std::unique_ptr&lt;hbui::IView&gt; mView;
  std::unique_ptr&lt;hbui::IViewRenderer&gt; mViewRenderer;
  std::unique_ptr&lt;IScreenSettings&gt; mScreenSettings;
  const std::string mInitialURL;
  std::string mCurrentRoute;
  _BYTE mMode[4];
  _BYTE mState[4];
  RectangleArea mRenderingAABB;
  glm::tvec2&lt;float,0&gt; mGamepadCursorPosition;
  __int16 mCurrentPointerPositionX;
  __int16 mCurrentPointerPositionY;
  InputMode mCurrentInputMode;
  _BYTE mCurrentVRInputMode[4];
  std::unique_ptr&lt;AbstractScreenSetupCleanupStrategy&gt; mScreenSetupCleanup;
  std::shared_ptr&lt;AbstractSceneProxy&gt; mProxy;
  std::function&lt;void __cdecl(void)&gt; mOnLoadFailedCallback;
  hbui::ITelemetry *mTelemetry;
};

</code></pre></div><h3 id="hbui-scene-vtbl"><a href="#hbui-scene-vtbl" class="header-anchor">#</a> <code>hbui::Scene_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::Scene_vtbl
{
  void (__fastcall *~AbstractScene)(AbstractScene *this);
  void (__fastcall *OnMessage)(AbstractScene *this, UIMessage, std::string, std::vector&lt;std::shared_ptr&lt;MessageParam&gt;&gt;);
  std::shared_ptr&lt;UIControl&gt; *(__fastcall *getRootControl)(AbstractScene *this, std::shared_ptr&lt;UIControl&gt; *result);
  std::shared_ptr&lt;UIControlFactory&gt; *(__fastcall *getControlFactory)(AbstractScene *this, std::shared_ptr&lt;UIControlFactory&gt; *result);
  bool (__fastcall *isShowingModUI)(AbstractScene *this);
  void (__fastcall *setIsShowingModUI)(AbstractScene *this, bool);
  bool (__fastcall *isUIScene)(AbstractScene *this);
  void (__fastcall *init)(AbstractScene *this, const ScreenSizeData *);
  void (__fastcall *setSize)(AbstractScene *this, const ScreenSizeData *);
  void (__fastcall *onSetKeyboardHeight)(AbstractScene *this, float);
  void (__fastcall *onInternetUpdate)(AbstractScene *this);
  std::vector&lt;RectangleArea&gt; *(__fastcall *getInputAreas)(AbstractScene *this, std::vector&lt;RectangleArea&gt; *result);
  void (__fastcall *onFocusGained)(AbstractScene *this);
  void (__fastcall *onFocusLost)(AbstractScene *this);
  void (__fastcall *terminate)(AbstractScene *this);
  void (__fastcall *onCreation)(AbstractScene *this);
  void (__fastcall *onLeave)(AbstractScene *this);
  void (__fastcall *onGameEventNotification)(AbstractScene *this, ui::GameEventNotification);
  void (__fastcall *_handleDirtyVisualTree)(AbstractScene *this, bool);
  void (__fastcall *leaveScreen)(AbstractScene *this);
  void (__fastcall *tick)(AbstractScene *this, int, int);
  void (__fastcall *updateEvents)(AbstractScene *this);
  void (__fastcall *applyInput)(AbstractScene *this, float);
  void (__fastcall *update)(AbstractScene *this, long double);
  void (__fastcall *frameUpdate)(AbstractScene *this, MinecraftUIFrameUpdateContext *);
  void (__fastcall *preRenderUpdate)(AbstractScene *this, ScreenContext *);
  void (__fastcall *prepareFrame)(AbstractScene *this, ScreenContext *);
  void (__fastcall *render)(AbstractScene *this, ScreenContext *, const FrameRenderObject *);
  void (__fastcall *postRenderUpdate)(AbstractScene *this, ScreenContext *);
  void (__fastcall *setupAndRender)(AbstractScene *this, ScreenContext *);
  void (__fastcall *handleInputModeChanged)(AbstractScene *this, InputMode);
  void (__fastcall *handleHoloInputModeChanged)(AbstractScene *this, HoloUIInputMode);
  void (__fastcall *handleButtonPress)(AbstractScene *this, unsigned int, FocusImpact);
  void (__fastcall *handleButtonRelease)(AbstractScene *this, unsigned int, FocusImpact);
  void (__fastcall *handleRawInputEvent)(AbstractScene *this, int, RawInputType, ButtonState, bool);
  bool (__fastcall *handlePointerLocation)(AbstractScene *this, const PointerLocationEventData *, FocusImpact);
  void (__fastcall *handlePointerPressed)(AbstractScene *this, bool);
  void (__fastcall *handleDirection)(AbstractScene *this, DirectionId, float, float, FocusImpact);
  bool (__fastcall *handleBackEvent)(AbstractScene *this, bool);
  void (__fastcall *handleTextChar)(AbstractScene *this, const std::string *, bool, FocusImpact);
  void (__fastcall *handleCaretLocation)(AbstractScene *this, int, FocusImpact);
  void (__fastcall *setTextboxText)(AbstractScene *this, const std::string *);
  void (__fastcall *onKeyboardDismissed)(AbstractScene *this);
  void (__fastcall *onKeyboardDisabled)(AbstractScene *this);
  void (__fastcall *handleLicenseChanged)(AbstractScene *this);
  void (__fastcall *handleIdentityGained)(AbstractScene *this);
  void (__fastcall *handleIdentityLost)(AbstractScene *this);
  void (__fastcall *handleGazeGestureInput)(AbstractScene *this, __int16, float, float, float, FocusImpact);
  void (__fastcall *handleDictationEvent)(AbstractScene *this, const std::string *);
  void (__fastcall *handleCommandEvent)(AbstractScene *this, const VoiceCommand *);
  bool (__fastcall *renderGameBehind)(AbstractScene *this);
  bool (__fastcall *absorbsInput)(AbstractScene *this);
  bool (__fastcall *closeOnPlayerHurt)(AbstractScene *this);
  bool (__fastcall *isModal)(AbstractScene *this);
  bool (__fastcall *isShowingMenu)(AbstractScene *this);
  bool (__fastcall *shouldStealMouse)(AbstractScene *this);
  bool (__fastcall *screenIsNotFlushable)(AbstractScene *this);
  bool (__fastcall *alwaysAcceptsInput)(AbstractScene *this);
  bool (__fastcall *screenDrawsLast)(AbstractScene *this);
  bool (__fastcall *isPlayScreen)(AbstractScene *this);
  bool (__fastcall *renderOnlyWhenTopMost)(AbstractScene *this);
  bool (__fastcall *lowFreqRendering)(AbstractScene *this);
  bool (__fastcall *ignoreAsTop)(AbstractScene *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(AbstractScene *this);
  bool (__fastcall *shouldUpdateWhenSuspended)(AbstractScene *this);
  int (__fastcall *getWidth)(AbstractScene *this);
  int (__fastcall *getHeight)(AbstractScene *this);
  void (__fastcall *reload)(AbstractScene *this);
  const RectangleArea *(__fastcall *getRenderingAABB)(AbstractScene *this);
  EyeRenderingModeBit (__fastcall *getEyeRenderingMode)(AbstractScene *this);
  ui::SceneType (__fastcall *getSceneType)(AbstractScene *this);
  std::string *(__fastcall *getScreenName)(AbstractScene *this, std::string *result);
  std::string *(__fastcall *getRoute)(AbstractScene *this, std::string *result);
  std::string *(__fastcall *getScreenTelemetryName)(AbstractScene *this, std::string *result);
  void (__fastcall *addEventProperties)(AbstractScene *this, std::unordered_map&lt;std::string,std::string&gt; *);
  int (__fastcall *getScreenVersion)(AbstractScene *this);
  void (__fastcall *processBufferedTextCharEvents)(AbstractScene *this, const std::vector&lt;TextCharEventData&gt; *);
  bool (__fastcall *getShouldSendEvents)(AbstractScene *this);
  void (__fastcall *setShouldSendEvents)(AbstractScene *this, bool);
  bool (__fastcall *getWantsTextOnly)(AbstractScene *this);
  void (__fastcall *setWantsTextOnly)(AbstractScene *this, bool);
  void (__fastcall *onDelete)(AbstractScene *this, CachedScenes *, TaskGroup *);
  bool (__fastcall *isGamepadCursorEnabled)(AbstractScene *this);
  bool (__fastcall *isGamepadDeflectionModeEnabled)(AbstractScene *this);
  const glm::tvec2&lt;float,0&gt; *(__fastcall *getGamepadCursorPosition)(AbstractScene *this);
  void (__fastcall *cleanInputComponents)(AbstractScene *this);
  std::weak_ptr&lt;AbstractSceneProxy&gt; *(__fastcall *getProxy)(AbstractScene *this, std::weak_ptr&lt;AbstractSceneProxy&gt; *result);
  bool (__fastcall *canBePushed)(AbstractScene *this);
  bool (__fastcall *canBePopped)(AbstractScene *this);
  bool (__fastcall *canBeTransitioned)(AbstractScene *this);
  void (__fastcall *onScreenExit)(AbstractScene *this, bool, bool);
  void (__fastcall *onScreenEntrance)(AbstractScene *this, bool, bool);
  bool (__fastcall *isEntering)(AbstractScene *this);
  bool (__fastcall *isExiting)(AbstractScene *this);
  void (__fastcall *schedulePop)(AbstractScene *this);
  bool (__fastcall *isTerminating)(AbstractScene *this);
  bool (__fastcall *loadScreenImmediately)(AbstractScene *this);
  bool (__fastcall *forceUpdateActiveSceneStackWhenPushed)(AbstractScene *this);
  bool (__fastcall *hasFinishedLoading)(AbstractScene *this);
  void (__fastcall *sendScreenEvent)(AbstractScene *this, const std::string *, const std::string *);
  void (__fastcall *setDebugFeature)(AbstractScene *this, UIDebugCommandFeature, bool);
  void (__fastcall *setScreenState)(AbstractScene *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
};

</code></pre></div><h3 id="hbui-routematcher-defaultentry"><a href="#hbui-routematcher-defaultentry" class="header-anchor">#</a> <code>hbui::RouteMatcher::DefaultEntry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::RouteMatcher::DefaultEntry
{
  const std::string baseScreenId;
  const std::string route;
};

</code></pre></div><h3 id="hbui-routematcher"><a href="#hbui-routematcher" class="header-anchor">#</a> <code>hbui::RouteMatcher</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::RouteMatcher : hbui::IRouteMatcher
{
  std::vector&lt;hbui::RouteMatcher::Entry&gt; mEntries;
  std::vector&lt;hbui::RouteMatcher::DefaultEntry&gt; mDefaultRoutes;
};

</code></pre></div><h3 id="hbui-routematcher-vtbl"><a href="#hbui-routematcher-vtbl" class="header-anchor">#</a> <code>hbui::RouteMatcher_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::RouteMatcher_vtbl
{
  void (__fastcall *~IRouteMatcher)(hbui::IRouteMatcher *this);
  void (__fastcall *add)(hbui::IRouteMatcher *this, const std::string *, const std::basic_regex&lt;char,std::regex_traits&lt;char&gt; &gt; *, hbui::RouteType, hbui::RouteMode, std::function&lt;void __cdecl(std::string const &amp;)&gt;);
  void (__fastcall *addDefault)(hbui::IRouteMatcher *this, const std::string *, const std::string *);
  void (__fastcall *resolve)(hbui::IRouteMatcher *this, const std::string *);
  bool (__fastcall *isSupported)(hbui::IRouteMatcher *this, const std::string *);
  bool (__fastcall *areCompatible)(hbui::IRouteMatcher *this, const std::string *, const std::string *);
  bool (__fastcall *isRouteInDirectory)(hbui::IRouteMatcher *this, const std::string *, const std::string *);
  std::optional&lt;std::string &gt; *(__fastcall *getDefaultRouteForFile)(hbui::IRouteMatcher *this, std::optional&lt;std::string &gt; *result, const std::string *);
  std::optional&lt;std::string &gt; *(__fastcall *getDefaultRouteForDirectory)(hbui::IRouteMatcher *this, std::optional&lt;std::string &gt; *result, const std::string *);
  std::optional&lt;enum hbui::RouteType&gt; *(__fastcall *getRouteType)(hbui::IRouteMatcher *this, std::optional&lt;enum hbui::RouteType&gt; *result, const std::string *);
  std::optional&lt;enum hbui::RouteMode&gt; *(__fastcall *getRouteMode)(hbui::IRouteMatcher *this, std::optional&lt;enum hbui::RouteMode&gt; *result, const std::string *);
};

</code></pre></div><h3 id="hitresultcomponent"><a href="#hitresultcomponent" class="header-anchor">#</a> <code>HitResultComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HitResultComponent : IEntityComponent
{
  std::unique_ptr&lt;IHitResultContainer&gt; mHitResults;
};

</code></pre></div><h3 id="httprequestinternal"><a href="#httprequestinternal" class="header-anchor">#</a> <code>HTTPRequestInternal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HTTPRequestInternal : std::enable_shared_from_this&lt;HTTPRequestInternal&gt;
{
  HTTPRequestInternal_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="httprequestinternal-vtbl"><a href="#httprequestinternal-vtbl" class="header-anchor">#</a> <code>HTTPRequestInternal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HTTPRequestInternal_vtbl
{
  void (__fastcall *~HTTPRequestInternal)(HTTPRequestInternal *this);
};

</code></pre></div><h3 id="httprequestcancelsource"><a href="#httprequestcancelsource" class="header-anchor">#</a> <code>HTTPRequestCancelSource</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HTTPRequestCancelSource
{
  HTTPRequestCancelSource_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="httprequestcancelsource-vtbl"><a href="#httprequestcancelsource-vtbl" class="header-anchor">#</a> <code>HTTPRequestCancelSource_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HTTPRequestCancelSource_vtbl
{
  void (__fastcall *~HTTPRequestCancelSource)(HTTPRequestCancelSource *this);
  void (__fastcall *cancel)(HTTPRequestCancelSource *this);
};

</code></pre></div><h3 id="hbui-tapgestureparameters"><a href="#hbui-tapgestureparameters" class="header-anchor">#</a> <code>hbui::TapGestureParameters</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(8)) hbui::TapGestureParameters
{
  unsigned int maxTouches;
  long double timeToleranceMs;
  float distanceToleranceCm;
};

</code></pre></div><h3 id="hbui-flinggestureparameters"><a href="#hbui-flinggestureparameters" class="header-anchor">#</a> <code>hbui::FlingGestureParameters</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(8)) hbui::FlingGestureParameters
{
  unsigned int minTouches;
  unsigned int maxTouches;
  long double maxIntervalBetweenMovesMs;
  float minDistanceCm;
};

</code></pre></div><h3 id="hbui-pangestureparameters"><a href="#hbui-pangestureparameters" class="header-anchor">#</a> <code>hbui::PanGestureParameters</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct hbui::PanGestureParameters
{
  unsigned int minTouches;
  unsigned int maxTouches;
  float minDistanceCm;
};

</code></pre></div><h3 id="hbui-gestureparameters"><a href="#hbui-gestureparameters" class="header-anchor">#</a> <code>hbui::GestureParameters</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(8)) hbui::GestureParameters
{
  hbui::TapGestureParameters tapParameters;
  hbui::FlingGestureParameters flingParameters;
  hbui::PanGestureParameters panParameters;
};

</code></pre></div><h3 id="hitresultsystem"><a href="#hitresultsystem" class="header-anchor">#</a> <code>HitResultSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HitResultSystem : ITickingSystem
{
};

</code></pre></div><h3 id="hitresultsystem-vtbl"><a href="#hitresultsystem-vtbl" class="header-anchor">#</a> <code>HitResultSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HitResultSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="holographicpostrenderer"><a href="#holographicpostrenderer" class="header-anchor">#</a> <code>HolographicPostRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HolographicPostRenderer : MinecraftUICustomRenderer
{
  mce::MaterialPtr mUIQuadMaterial;
  mce::MaterialPtr mUIHudMaterial;
  mce::MaterialPtr mLevelQuadMaterial;
  mce::MaterialPtr mUIFillColorMaterial;
  float mUIWidth;
  float mUIHeight;
  float mLevelMeshWidth;
  float mLevelMeshHeight;
  mce::Mesh mUIQuadMesh;
  mce::Mesh mLevelMesh;
};

</code></pre></div><h3 id="holographicpostrenderer-vtbl"><a href="#holographicpostrenderer-vtbl" class="header-anchor">#</a> <code>HolographicPostRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HolographicPostRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="hotbarwiperenderer"><a href="#hotbarwiperenderer" class="header-anchor">#</a> <code>HotBarWipeRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HotBarWipeRenderer : MinecraftUICustomRenderer
{
};

</code></pre></div><h3 id="hotbarwiperenderer-vtbl"><a href="#hotbarwiperenderer-vtbl" class="header-anchor">#</a> <code>HotBarWipeRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HotBarWipeRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
  void (__fastcall *drawRectangle)(HotBarWipeRenderer *this, ScreenContext *, UIControl *, float, const mce::Color *, RectangleArea *);
  int (__fastcall *getHotBarIndex)(HotBarWipeRenderer *this, UIControl *);
};

</code></pre></div><h3 id="hotbarcooldownrenderer"><a href="#hotbarcooldownrenderer" class="header-anchor">#</a> <code>HotBarCooldownRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HotBarCooldownRenderer : HotBarWipeRenderer
{
};

</code></pre></div><h3 id="hotbarcooldownrenderer-vtbl"><a href="#hotbarcooldownrenderer-vtbl" class="header-anchor">#</a> <code>HotBarCooldownRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HotBarCooldownRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
  void (__fastcall *drawRectangle)(HotBarWipeRenderer *this, ScreenContext *, UIControl *, float, const mce::Color *, RectangleArea *);
  int (__fastcall *getHotBarIndex)(HotBarWipeRenderer *this, UIControl *);
};

</code></pre></div><h3 id="hotbardroprenderer"><a href="#hotbardroprenderer" class="header-anchor">#</a> <code>HotBarDropRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HotBarDropRenderer : HotBarWipeRenderer
{
};

</code></pre></div><h3 id="hotbardroprenderer-vtbl"><a href="#hotbardroprenderer-vtbl" class="header-anchor">#</a> <code>HotBarDropRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HotBarDropRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
  void (__fastcall *drawRectangle)(HotBarWipeRenderer *this, ScreenContext *, UIControl *, float, const mce::Color *, RectangleArea *);
  int (__fastcall *getHotBarIndex)(HotBarWipeRenderer *this, UIControl *);
};

</code></pre></div><h3 id="hovertextrenderer"><a href="#hovertextrenderer" class="header-anchor">#</a> <code>HoverTextRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HoverTextRenderer : MinecraftUICustomRenderer
{
  std::string mContent;
  std::string mFilteredContent;
  glm::tvec2&lt;float,0&gt; mCursorPosition;
  glm::tvec2&lt;float,0&gt; mOffset;
  glm::tvec2&lt;float,0&gt; mBoxDimensions;
  mce::MaterialPtr mBlitMat;
  std::unique_ptr&lt;NinePatchLayer&gt; mLayer;
};

</code></pre></div><h3 id="hovertextrenderer-vtbl"><a href="#hovertextrenderer-vtbl" class="header-anchor">#</a> <code>HoverTextRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HoverTextRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="hudarmorrenderer"><a href="#hudarmorrenderer" class="header-anchor">#</a> <code>HudArmorRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudArmorRenderer : MinecraftUICustomRenderer
{
  bool mHasLoadedTextures;
  mce::TexturePtr mEmptyArmorTexture;
  mce::TexturePtr mHalfArmorTexture;
  mce::TexturePtr mFullArmorTexture;
};

</code></pre></div><h3 id="hudarmorrenderer-vtbl"><a href="#hudarmorrenderer-vtbl" class="header-anchor">#</a> <code>HudArmorRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HudArmorRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="hudbubblesrenderer"><a href="#hudbubblesrenderer" class="header-anchor">#</a> <code>HudBubblesRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudBubblesRenderer : MinecraftUICustomRenderer
{
  bool mHasLoadedTextures;
  mce::TexturePtr mBubbleFullTexture;
  mce::TexturePtr mBubblePopTexture;
};

</code></pre></div><h3 id="hudbubblesrenderer-vtbl"><a href="#hudbubblesrenderer-vtbl" class="header-anchor">#</a> <code>HudBubblesRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HudBubblesRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="hudcamerarenderer"><a href="#hudcamerarenderer" class="header-anchor">#</a> <code>HudCameraRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HudCameraRenderer : MinecraftUICustomRenderer, CameraCallbacks
{
  _BYTE mState[4];
  float mShowTime;
  mce::TexturePtr mPhotoTexture;
  mce::MaterialPtr mColorMaterial;
  mce::MaterialPtr mTexMaterial;
  bool mImmediatePicture;
};

</code></pre></div><h3 id="hudcamerarenderer-vtbl"><a href="#hudcamerarenderer-vtbl" class="header-anchor">#</a> <code>HudCameraRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HudCameraRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="hudcursorrenderer"><a href="#hudcursorrenderer" class="header-anchor">#</a> <code>HudCursorRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudCursorRenderer : MinecraftUICustomRenderer
{
  mce::MaterialPtr mCrosshairMat;
  mce::TexturePtr mCrosshair;
};

</code></pre></div><h3 id="hudcursorrenderer-vtbl"><a href="#hudcursorrenderer-vtbl" class="header-anchor">#</a> <code>HudCursorRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HudCursorRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="huddebugoverlayrenderer-workerstatssnapshot"><a href="#huddebugoverlayrenderer-workerstatssnapshot" class="header-anchor">#</a> <code>HudDebugOverlayRenderer::WorkerStatsSnapshot</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudDebugOverlayRenderer::WorkerStatsSnapshot
{
  unsigned __int64 queued;
  unsigned __int64 reQueued;
  unsigned __int64 processed;
  unsigned __int64 noops;
  unsigned __int64 maxQueued;
  unsigned __int64 sorts;
  unsigned __int64 waits;
};

</code></pre></div><h3 id="huddebugoverlayrenderer-workerstats"><a href="#huddebugoverlayrenderer-workerstats" class="header-anchor">#</a> <code>HudDebugOverlayRenderer::WorkerStats</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudDebugOverlayRenderer::WorkerStats
{
  HudDebugOverlayRenderer::WorkerStatsSnapshot last;
  HudDebugOverlayRenderer::WorkerStatsSnapshot curr;
};

</code></pre></div><h3 id="huddebugoverlayrenderer-taskstatssnapshot"><a href="#huddebugoverlayrenderer-taskstatssnapshot" class="header-anchor">#</a> <code>HudDebugOverlayRenderer::TaskStatsSnapshot</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudDebugOverlayRenderer::TaskStatsSnapshot
{
  unsigned __int64 count;
  unsigned __int64 maxCount;
};

</code></pre></div><h3 id="huddebugoverlayrenderer-taskstats"><a href="#huddebugoverlayrenderer-taskstats" class="header-anchor">#</a> <code>HudDebugOverlayRenderer::TaskStats</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudDebugOverlayRenderer::TaskStats
{
  HudDebugOverlayRenderer::TaskStatsSnapshot last;
  HudDebugOverlayRenderer::TaskStatsSnapshot curr;
};

</code></pre></div><h3 id="huddebugoverlayrenderer-spinlockmetrics"><a href="#huddebugoverlayrenderer-spinlockmetrics" class="header-anchor">#</a> <code>HudDebugOverlayRenderer::SpinLockMetrics</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HudDebugOverlayRenderer::SpinLockMetrics
{
  unsigned __int64 contention;
  unsigned __int64 contentionBlocked;
  unsigned __int64 blockedTicks;
  unsigned __int64 blockedTicksMax;
  unsigned __int64 yields;
  unsigned __int64 lockCount;
  unsigned __int64 lockTicks;
  unsigned __int64 lockTicksMax;
};

</code></pre></div><h3 id="huddebugoverlayrenderer-spinlockstats"><a href="#huddebugoverlayrenderer-spinlockstats" class="header-anchor">#</a> <code>HudDebugOverlayRenderer::SpinLockStats</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HudDebugOverlayRenderer::SpinLockStats
{
  HudDebugOverlayRenderer::SpinLockMetrics last;
  HudDebugOverlayRenderer::SpinLockMetrics curr;
};

</code></pre></div><h3 id="huddebugoverlayrenderer"><a href="#huddebugoverlayrenderer" class="header-anchor">#</a> <code>HudDebugOverlayRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudDebugOverlayRenderer
{
  mce::MaterialPtr mDebugDepthArrayTextureMaterial;
  std::unordered_map&lt;BackgroundWorker *,HudDebugOverlayRenderer::WorkerStats&gt; mWorkerStats;
  std::unordered_map&lt;BackgroundWorker *,HudDebugOverlayRenderer::WorkerStats&gt; mCurrentWorkerStats;
  HudDebugOverlayRenderer::TaskStats mTaskStats;
  HudDebugOverlayRenderer::SpinLockStats mSpinLockStats;
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mLastUpdateTime;
};

</code></pre></div><h3 id="hudheartrenderer"><a href="#hudheartrenderer" class="header-anchor">#</a> <code>HudHeartRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudHeartRenderer : MinecraftUICustomRenderer
{
  bool mHasLoadedTextures;
  mce::TexturePtr mHeartBackgroundTexture;
  mce::TexturePtr mHeartBlinkTexture;
  mce::TexturePtr mHeartFullTexture;
  mce::TexturePtr mHeartHalfTexture;
  mce::TexturePtr mHeartPoisonFullTexture;
  mce::TexturePtr mHeartPoisonHalfTexture;
  mce::TexturePtr mHeartWitherFullTexture;
  mce::TexturePtr mHeartWitherHalfTexture;
  mce::TexturePtr mHeartAbsorptionFullTexture;
  mce::TexturePtr mHeartAbsorptionHalfTexture;
  mce::TexturePtr mHeartFlashFullTexture;
  mce::TexturePtr mHeartFlashHalfTexture;
  mce::TexturePtr mHeartPoisonFlashFullTexture;
  mce::TexturePtr mHeartPoisonFlashHalfTexture;
  mce::TexturePtr mHeartWitherFlashFullTexture;
  mce::TexturePtr mHeartWitherFlashHalfTexture;
};

</code></pre></div><h3 id="hudheartrenderer-vtbl"><a href="#hudheartrenderer-vtbl" class="header-anchor">#</a> <code>HudHeartRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HudHeartRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="hudhorseheartrenderer"><a href="#hudhorseheartrenderer" class="header-anchor">#</a> <code>HudHorseHeartRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudHorseHeartRenderer : MinecraftUICustomRenderer
{
  bool mHasLoadedTextures;
  mce::TexturePtr mHeartHorseBackgroundTexture;
  mce::TexturePtr mHeartHorseBlinkTexture;
  mce::TexturePtr mHeartHorseFullTexture;
  mce::TexturePtr mHeartHorseHalfTexture;
  mce::TexturePtr mHeartHorseFlashFullTexture;
  mce::TexturePtr mHeartHorseFlashHalfTexture;
};

</code></pre></div><h3 id="hudhorseheartrenderer-vtbl"><a href="#hudhorseheartrenderer-vtbl" class="header-anchor">#</a> <code>HudHorseHeartRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HudHorseHeartRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="hudhorsejumprenderer"><a href="#hudhorsejumprenderer" class="header-anchor">#</a> <code>HudHorseJumpRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HudHorseJumpRenderer : MinecraftUICustomRenderer
{
  mce::TexturePtr mHorseJumpEmpty;
  mce::TexturePtr mHorseJumpFull;
  bool mHasLoadedTextures;
};

</code></pre></div><h3 id="hudhorsejumprenderer-vtbl"><a href="#hudhorsejumprenderer-vtbl" class="header-anchor">#</a> <code>HudHorseJumpRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HudHorseJumpRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="hudhungerrenderer"><a href="#hudhungerrenderer" class="header-anchor">#</a> <code>HudHungerRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudHungerRenderer : MinecraftUICustomRenderer
{
  int mTickCount;
  bool mHasLoadedTextures;
  mce::TexturePtr gHungerBackgroundTexture;
  mce::TexturePtr gHungerBlinkTexture;
  mce::TexturePtr gHungerEffectBackgroundTexture;
  mce::TexturePtr gHungerFullTexture;
  mce::TexturePtr gHungerHalfTexture;
  mce::TexturePtr gHungerFlashFullTexture;
  mce::TexturePtr gHungerFlashHalfTexture;
  mce::TexturePtr gHungerEffectFullTexture;
  mce::TexturePtr gHungerEffectHalfTexture;
  mce::TexturePtr gHungerEffectFlashFullTexture;
  mce::TexturePtr gHungerEffectFlashHalfTexture;
};

</code></pre></div><h3 id="hudhungerrenderer-vtbl"><a href="#hudhungerrenderer-vtbl" class="header-anchor">#</a> <code>HudHungerRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HudHungerRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="hudmobeffectsrenderer"><a href="#hudmobeffectsrenderer" class="header-anchor">#</a> <code>HudMobEffectsRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudMobEffectsRenderer : MinecraftUICustomRenderer
{
};

</code></pre></div><h3 id="hudmobeffectsrenderer-vtbl"><a href="#hudmobeffectsrenderer-vtbl" class="header-anchor">#</a> <code>HudMobEffectsRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HudMobEffectsRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="hudplayerrenderer"><a href="#hudplayerrenderer" class="header-anchor">#</a> <code>HudPlayerRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudPlayerRenderer : MinecraftUICustomRenderer
{
  float mRenderTime;
  float mLastTimeStamp;
  std::vector&lt;int&gt; mPlayerArmorState;
};

</code></pre></div><h3 id="hudplayerrenderer-vtbl"><a href="#hudplayerrenderer-vtbl" class="header-anchor">#</a> <code>HudPlayerRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HudPlayerRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="hudprogressrenderer"><a href="#hudprogressrenderer" class="header-anchor">#</a> <code>HudProgressRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HudProgressRenderer : MinecraftUICustomRenderer
{
  float mProgressAlpha;
};

</code></pre></div><h3 id="hudprogressrenderer-vtbl"><a href="#hudprogressrenderer-vtbl" class="header-anchor">#</a> <code>HudProgressRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HudProgressRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="hudvignetterenderer"><a href="#hudvignetterenderer" class="header-anchor">#</a> <code>HudVignetteRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudVignetteRenderer : MinecraftUICustomRenderer
{
  float mLastVignetteOpacity;
  float mLastAB;
  mce::Mesh mVignette;
};

</code></pre></div><h3 id="hudvignetterenderer-vtbl"><a href="#hudvignetterenderer-vtbl" class="header-anchor">#</a> <code>HudVignetteRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HudVignetteRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="hbui-facetbase-hbui-achievementsfacet"><a href="#hbui-facetbase-hbui-achievementsfacet" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::AchievementsFacet&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetBase&lt;hbui::AchievementsFacet&gt; : hbui::IFacet
{
};

</code></pre></div><h3 id="hbui-facetbase-hbui-achievementsfacet-vtbl"><a href="#hbui-facetbase-hbui-achievementsfacet-vtbl" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::AchievementsFacet&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FacetBase&lt;hbui::AchievementsFacet&gt;_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-achievementsfacet-facetachievementdata"><a href="#hbui-achievementsfacet-facetachievementdata" class="header-anchor">#</a> <code>hbui::AchievementsFacet::FacetAchievementData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) hbui::AchievementsFacet::FacetAchievementData
{
  std::string mId;
  std::string mAchievementName;
  std::string mDescription;
  int mGamerScore;
  __int64 mDateUnlocked;
  std::string mAchievementImageURL;
  bool mIsLocked;
  bool mIsSecret;
  float mProgressCompleted;
  float mProgressTarget;
  std::string mPersonaRewardId;
  bool mHasPersonaReward;
  bool mIsPersonaRewardOwned;
  std::string mPersonaRewardName;
  std::string mPersonaRewardImageURL;
  persona::Rarity mPersonaRewardRarity;
};

</code></pre></div><h3 id="hbui-achievementsfacet-facetplayerachievementdata"><a href="#hbui-achievementsfacet-facetplayerachievementdata" class="header-anchor">#</a> <code>hbui::AchievementsFacet::FacetPlayerAchievementData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::AchievementsFacet::FacetPlayerAchievementData
{
  int mAchievementsUnlocked;
  int mMaxAchievements;
  int mTimePlayed;
  int mCurrGamerScore;
  int mMaxGamerScore;
  std::vector&lt;hbui::AchievementsFacet::FacetAchievementData&gt; mAchievementData;
};

</code></pre></div><h3 id="hbui-achievementsfacet"><a href="#hbui-achievementsfacet" class="header-anchor">#</a> <code>hbui::AchievementsFacet</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::AchievementsFacet : hbui::FacetBase&lt;hbui::AchievementsFacet&gt;
{
  IClientInstance *mClient;
  hbui::ResourceRegistry *mResourceRegistry;
  std::unordered_map&lt;Core::PathBuffer&lt;std::string &gt;,std::string,std::hash&lt;Core::PathBuffer&lt;std::string &gt; &gt;,std::equal_to&lt;Core::PathBuffer&lt;std::string &gt; &gt;,std::allocator&lt;std::pair&lt;Core::PathBuffer&lt;std::string &gt; const ,std::string &gt; &gt; &gt; mRegisteredResources;
  hbui::AchievementsFacet::AchievementFacetStatus mStatus;
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mLastRefresh;
  hbui::AchievementsFacet::FacetPlayerAchievementData mFacetPlayerAchievementData;
  persona::PersonaPieceCollectionModel *mPersonaPieceCollectionModel;
};

</code></pre></div><h3 id="hbui-achievementsfacet-vtbl"><a href="#hbui-achievementsfacet-vtbl" class="header-anchor">#</a> <code>hbui::AchievementsFacet_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::AchievementsFacet_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-facetbase-hbui-deviceinformationfacet"><a href="#hbui-facetbase-hbui-deviceinformationfacet" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::DeviceInformationFacet&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetBase&lt;hbui::DeviceInformationFacet&gt; : hbui::IFacet
{
};

</code></pre></div><h3 id="hbui-facetbase-hbui-deviceinformationfacet-vtbl"><a href="#hbui-facetbase-hbui-deviceinformationfacet-vtbl" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::DeviceInformationFacet&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FacetBase&lt;hbui::DeviceInformationFacet&gt;_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-deviceinformationfacet"><a href="#hbui-deviceinformationfacet" class="header-anchor">#</a> <code>hbui::DeviceInformationFacet</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) hbui::DeviceInformationFacet : hbui::FacetBase&lt;hbui::DeviceInformationFacet&gt;, AppPlatformListener
{
  bool mIsDirty;
  const IClientInstance *mClientInstance;
  _BYTE mPlatform[1];
  std::vector&lt;enum hbui::InputMethod&gt; mInputMethods;
  bool mIsLowMemoryDevice;
  float mPixelsPerMillimeter;
  int mGuiScale;
  int mGuiScaleModifier;
  int mGuiScaleBase;
};

</code></pre></div><h3 id="hbui-deviceinformationfacet-vtbl"><a href="#hbui-deviceinformationfacet-vtbl" class="header-anchor">#</a> <code>hbui::DeviceInformationFacet_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::DeviceInformationFacet_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-facetbase-hbui-featureflagsfacet"><a href="#hbui-facetbase-hbui-featureflagsfacet" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::FeatureFlagsFacet&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetBase&lt;hbui::FeatureFlagsFacet&gt; : hbui::IFacet
{
};

</code></pre></div><h3 id="hbui-facetbase-hbui-featureflagsfacet-vtbl"><a href="#hbui-facetbase-hbui-featureflagsfacet-vtbl" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::FeatureFlagsFacet&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FacetBase&lt;hbui::FeatureFlagsFacet&gt;_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-featureflagsfacet"><a href="#hbui-featureflagsfacet" class="header-anchor">#</a> <code>hbui::FeatureFlagsFacet</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FeatureFlagsFacet : hbui::FacetBase&lt;hbui::FeatureFlagsFacet&gt;
{
  std::vector&lt;std::string&gt; mFeatureFlags;
};

</code></pre></div><h3 id="hbui-featureflagsfacet-vtbl"><a href="#hbui-featureflagsfacet-vtbl" class="header-anchor">#</a> <code>hbui::FeatureFlagsFacet_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FeatureFlagsFacet_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-facetbase-hbui-inputfacet"><a href="#hbui-facetbase-hbui-inputfacet" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::InputFacet&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetBase&lt;hbui::InputFacet&gt; : hbui::IFacet
{
};

</code></pre></div><h3 id="hbui-facetbase-hbui-inputfacet-vtbl"><a href="#hbui-facetbase-hbui-inputfacet-vtbl" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::InputFacet&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FacetBase&lt;hbui::InputFacet&gt;_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-inputfacet"><a href="#hbui-inputfacet" class="header-anchor">#</a> <code>hbui::InputFacet</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::InputFacet : hbui::FacetBase&lt;hbui::InputFacet&gt;
{
  IClientInstance *mClientInstance;
  bool mIsDirty;
  Bedrock::PubSub::ScopedSubscription mSwapABOptionSubscription;
  Bedrock::PubSub::ScopedSubscription mSwapXYOptionSubscription;
  bool mAcceptInputFromAllControllers;
  int mGameControllerId;
  std::string mGameControllerIdString;
  bool mSwapABButtons;
  bool mSwapXYButtons;
  _BYTE mCurrentInputType[1];
  InputMode mCachedInputMode;
};

</code></pre></div><h3 id="hbui-inputfacet-vtbl"><a href="#hbui-inputfacet-vtbl" class="header-anchor">#</a> <code>hbui::InputFacet_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::InputFacet_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-facetbase-hbui-legacyscreenfacet"><a href="#hbui-facetbase-hbui-legacyscreenfacet" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::LegacyScreenFacet&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetBase&lt;hbui::LegacyScreenFacet&gt; : hbui::IFacet
{
};

</code></pre></div><h3 id="hbui-facetbase-hbui-legacyscreenfacet-vtbl"><a href="#hbui-facetbase-hbui-legacyscreenfacet-vtbl" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::LegacyScreenFacet&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FacetBase&lt;hbui::LegacyScreenFacet&gt;_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-legacyscreenfacet"><a href="#hbui-legacyscreenfacet" class="header-anchor">#</a> <code>hbui::LegacyScreenFacet</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::LegacyScreenFacet : hbui::FacetBase&lt;hbui::LegacyScreenFacet&gt;
{
  IScreenController *mScreenController;
};

</code></pre></div><h3 id="hbui-legacyscreenfacet-vtbl"><a href="#hbui-legacyscreenfacet-vtbl" class="header-anchor">#</a> <code>hbui::LegacyScreenFacet_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::LegacyScreenFacet_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-facetbase-hbui-localefacet"><a href="#hbui-facetbase-hbui-localefacet" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::LocaleFacet&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetBase&lt;hbui::LocaleFacet&gt; : hbui::IFacet
{
};

</code></pre></div><h3 id="hbui-facetbase-hbui-localefacet-vtbl"><a href="#hbui-facetbase-hbui-localefacet-vtbl" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::LocaleFacet&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FacetBase&lt;hbui::LocaleFacet&gt;_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-localefacet"><a href="#hbui-localefacet" class="header-anchor">#</a> <code>hbui::LocaleFacet</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::LocaleFacet : hbui::FacetBase&lt;hbui::LocaleFacet&gt;, AppPlatformListener
{
  bool mIsDirty;
  Option *mLanguageOption;
  Bedrock::PubSub::ScopedSubscription mLanguageOptionSubscription;
  std::string mLocale;
};

</code></pre></div><h3 id="hbui-localefacet-vtbl"><a href="#hbui-localefacet-vtbl" class="header-anchor">#</a> <code>hbui::LocaleFacet_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::LocaleFacet_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-facetbase-hbui-localworldsfacet"><a href="#hbui-facetbase-hbui-localworldsfacet" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::LocalWorldsFacet&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetBase&lt;hbui::LocalWorldsFacet&gt; : hbui::IFacet
{
};

</code></pre></div><h3 id="hbui-facetbase-hbui-localworldsfacet-vtbl"><a href="#hbui-facetbase-hbui-localworldsfacet-vtbl" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::LocalWorldsFacet&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FacetBase&lt;hbui::LocalWorldsFacet&gt;_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-localworld"><a href="#hbui-localworld" class="header-anchor">#</a> <code>hbui::LocalWorld</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::LocalWorld
{
  std::string id;
  std::string title;
  std::string imageURL;
};

</code></pre></div><h3 id="hbui-localworldsfacet"><a href="#hbui-localworldsfacet" class="header-anchor">#</a> <code>hbui::LocalWorldsFacet</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::LocalWorldsFacet : hbui::FacetBase&lt;hbui::LocalWorldsFacet&gt;
{
  std::vector&lt;hbui::LocalWorld&gt; mLocalWorlds;
  ILocalWorldsProvider *mLocalWorldsProvider;
};

</code></pre></div><h3 id="hbui-localworldsfacet-vtbl"><a href="#hbui-localworldsfacet-vtbl" class="header-anchor">#</a> <code>hbui::LocalWorldsFacet_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::LocalWorldsFacet_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-facetbase-hbui-safezonefacet"><a href="#hbui-facetbase-hbui-safezonefacet" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::SafeZoneFacet&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetBase&lt;hbui::SafeZoneFacet&gt; : hbui::IFacet
{
};

</code></pre></div><h3 id="hbui-facetbase-hbui-safezonefacet-vtbl"><a href="#hbui-facetbase-hbui-safezonefacet-vtbl" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::SafeZoneFacet&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FacetBase&lt;hbui::SafeZoneFacet&gt;_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-optionwrapper-float"><a href="#hbui-optionwrapper-float" class="header-anchor">#</a> <code>hbui::OptionWrapper&lt;float&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::OptionWrapper&lt;float&gt;
{
  Option *mOption;
  Bedrock::PubSub::ScopedSubscription mOptionSubscription;
};

</code></pre></div><h3 id="hbui-safezonefacet"><a href="#hbui-safezonefacet" class="header-anchor">#</a> <code>hbui::SafeZoneFacet</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::SafeZoneFacet : hbui::FacetBase&lt;hbui::SafeZoneFacet&gt;
{
  bool mIsDirty;
  float mSafeZoneX;
  float mSafeZoneY;
  float mScreenPositionX;
  float mScreenPositionY;
  hbui::OptionWrapper&lt;float&gt; mSafeZoneXOption;
  hbui::OptionWrapper&lt;float&gt; mSafeZoneYOption;
  hbui::OptionWrapper&lt;float&gt; mScreenPositionXOption;
  hbui::OptionWrapper&lt;float&gt; mScreenPositionYOption;
};

</code></pre></div><h3 id="hbui-safezonefacet-vtbl"><a href="#hbui-safezonefacet-vtbl" class="header-anchor">#</a> <code>hbui::SafeZoneFacet_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::SafeZoneFacet_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-facetbase-hbui-screenreaderfacet"><a href="#hbui-facetbase-hbui-screenreaderfacet" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::ScreenReaderFacet&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetBase&lt;hbui::ScreenReaderFacet&gt; : hbui::IFacet
{
};

</code></pre></div><h3 id="hbui-facetbase-hbui-screenreaderfacet-vtbl"><a href="#hbui-facetbase-hbui-screenreaderfacet-vtbl" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::ScreenReaderFacet&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FacetBase&lt;hbui::ScreenReaderFacet&gt;_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-screenreaderfacet"><a href="#hbui-screenreaderfacet" class="header-anchor">#</a> <code>hbui::ScreenReaderFacet</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::ScreenReaderFacet : hbui::FacetBase&lt;hbui::ScreenReaderFacet&gt;
{
  IClientInstance *mClientInstance;
  bool mIsDirty;
  bool mIsChatTextToSpeechEnabled;
  bool mIsUITextToSpeechEnabled;
  Bedrock::PubSub::ScopedSubscription mChatOptionSubscription;
  Bedrock::PubSub::ScopedSubscription mUIOptionSubscription;
};

</code></pre></div><h3 id="hbui-screenreaderfacet-vtbl"><a href="#hbui-screenreaderfacet-vtbl" class="header-anchor">#</a> <code>hbui::ScreenReaderFacet_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::ScreenReaderFacet_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-facetbase-hbui-soundfacet"><a href="#hbui-facetbase-hbui-soundfacet" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::SoundFacet&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetBase&lt;hbui::SoundFacet&gt; : hbui::IFacet
{
};

</code></pre></div><h3 id="hbui-facetbase-hbui-soundfacet-vtbl"><a href="#hbui-facetbase-hbui-soundfacet-vtbl" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::SoundFacet&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FacetBase&lt;hbui::SoundFacet&gt;_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-soundfacet"><a href="#hbui-soundfacet" class="header-anchor">#</a> <code>hbui::SoundFacet</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::SoundFacet : hbui::FacetBase&lt;hbui::SoundFacet&gt;
{
  Bedrock::NonOwnerPointer&lt;SoundPlayerInterface&gt; mSoundPlayer;
};

</code></pre></div><h3 id="hbui-soundfacet-vtbl"><a href="#hbui-soundfacet-vtbl" class="header-anchor">#</a> <code>hbui::SoundFacet_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::SoundFacet_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-facetbase-hbui-splitscreenfacet"><a href="#hbui-facetbase-hbui-splitscreenfacet" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::SplitScreenFacet&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetBase&lt;hbui::SplitScreenFacet&gt; : hbui::IFacet
{
};

</code></pre></div><h3 id="hbui-facetbase-hbui-splitscreenfacet-vtbl"><a href="#hbui-facetbase-hbui-splitscreenfacet-vtbl" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::SplitScreenFacet&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FacetBase&lt;hbui::SplitScreenFacet&gt;_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-splitscreenfacet"><a href="#hbui-splitscreenfacet" class="header-anchor">#</a> <code>hbui::SplitScreenFacet</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) hbui::SplitScreenFacet : hbui::FacetBase&lt;hbui::SplitScreenFacet&gt;
{
  bool mIsDirty;
  IMinecraftGame *mMinecraftGame;
  int mSplitScreenPosition;
  int mActivePlayers;
  SplitScreenDirection mSplitScreenDirection;
};

</code></pre></div><h3 id="hbui-splitscreenfacet-vtbl"><a href="#hbui-splitscreenfacet-vtbl" class="header-anchor">#</a> <code>hbui::SplitScreenFacet_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::SplitScreenFacet_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-facetbase-hbui-toastfacet"><a href="#hbui-facetbase-hbui-toastfacet" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::ToastFacet&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetBase&lt;hbui::ToastFacet&gt; : hbui::IFacet
{
};

</code></pre></div><h3 id="hbui-facetbase-hbui-toastfacet-vtbl"><a href="#hbui-facetbase-hbui-toastfacet-vtbl" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::ToastFacet&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FacetBase&lt;hbui::ToastFacet&gt;_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-toastfacet"><a href="#hbui-toastfacet" class="header-anchor">#</a> <code>hbui::ToastFacet</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::ToastFacet : hbui::FacetBase&lt;hbui::ToastFacet&gt;
{
  ToastManager *mToastManager;
};

</code></pre></div><h3 id="hbui-toastfacet-vtbl"><a href="#hbui-toastfacet-vtbl" class="header-anchor">#</a> <code>hbui::ToastFacet_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::ToastFacet_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-facetbase-hbui-userfacet"><a href="#hbui-facetbase-hbui-userfacet" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::UserFacet&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetBase&lt;hbui::UserFacet&gt; : hbui::IFacet
{
};

</code></pre></div><h3 id="hbui-facetbase-hbui-userfacet-vtbl"><a href="#hbui-facetbase-hbui-userfacet-vtbl" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::UserFacet&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FacetBase&lt;hbui::UserFacet&gt;_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-userfacet"><a href="#hbui-userfacet" class="header-anchor">#</a> <code>hbui::UserFacet</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::UserFacet : hbui::FacetBase&lt;hbui::UserFacet&gt;
{
  std::string mName;
  std::string mProfilePicturePath;
  IClientInstance *mClientInstance;
  std::string mOriginalProfilePicturePath;
};

</code></pre></div><h3 id="hbui-userfacet-vtbl"><a href="#hbui-userfacet-vtbl" class="header-anchor">#</a> <code>hbui::UserFacet_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::UserFacet_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-facetregistry"><a href="#hbui-facetregistry" class="header-anchor">#</a> <code>hbui::FacetRegistry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetRegistry : hbui::IFacetRegistry
{
  std::vector&lt;hbui::FacetRegistry::FacetEntry&gt; mFacets;
};

</code></pre></div><h3 id="hbui-facetregistry-vtbl"><a href="#hbui-facetregistry-vtbl" class="header-anchor">#</a> <code>hbui::FacetRegistry_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FacetRegistry_vtbl
{
  void (__fastcall *~IFacetRegistry)(hbui::IFacetRegistry *this);
  void (__fastcall *registerFacet)(hbui::IFacetRegistry *this, const std::string *, const std::function&lt;std::unique_ptr&lt;hbui::IFacet&gt; __cdecl(void)&gt; *);
  std::optional&lt;enum hbui::IFacetRegistry::Error&gt; *(__fastcall *activateFacet)(hbui::IFacetRegistry *this, std::optional&lt;enum hbui::IFacetRegistry::Error&gt; *result, hbui::FacetBinder *, const std::string *);
  std::optional&lt;enum hbui::IFacetRegistry::Error&gt; *(__fastcall *deactivateFacet)(hbui::IFacetRegistry *this, std::optional&lt;enum hbui::IFacetRegistry::Error&gt; *result, hbui::FacetBinder *, const std::string *);
  void (__fastcall *deactivateAllFacets)(hbui::IFacetRegistry *this, hbui::FacetBinder *);
  void (__fastcall *bind)(hbui::IFacetRegistry *this, hbui::FacetBinder *);
  void (__fastcall *update)(hbui::IFacetRegistry *this, hbui::FacetBinder *);
};

</code></pre></div><h3 id="hbui-testfacet-complextype"><a href="#hbui-testfacet-complextype" class="header-anchor">#</a> <code>hbui::TestFacet::ComplexType</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct hbui::TestFacet::ComplexType
{
  int nestedNumber;
};

</code></pre></div><h3 id="hbui-facetbase-hbui-testfacet"><a href="#hbui-facetbase-hbui-testfacet" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::TestFacet&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetBase&lt;hbui::TestFacet&gt; : hbui::IFacet
{
};

</code></pre></div><h3 id="hbui-facetbase-hbui-testfacet-vtbl"><a href="#hbui-facetbase-hbui-testfacet-vtbl" class="header-anchor">#</a> <code>hbui::FacetBase&lt;hbui::TestFacet&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FacetBase&lt;hbui::TestFacet&gt;_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-testfacet"><a href="#hbui-testfacet" class="header-anchor">#</a> <code>hbui::TestFacet</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) hbui::TestFacet : hbui::FacetBase&lt;hbui::TestFacet&gt;
{
  unsigned int mIncrementingNumber;
  int mShallowNumber;
  std::string mShallowString;
  hbui::TestFacet::ComplexType mShallowComplexType;
  std::vector&lt;hbui::TestFacet::ComplexType&gt; mNestedTypeArray;
  bool mIsDirty;
  bool mShouldAutoIncrement;
};

</code></pre></div><h3 id="hbui-testfacet-vtbl"><a href="#hbui-testfacet-vtbl" class="header-anchor">#</a> <code>hbui::TestFacet_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::TestFacet_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-optionwrapper-float-ctor-l5-lambda-5e7c5eb415c6d84f19e6135729d9635d"><a href="#hbui-optionwrapper-float-ctor-l5-lambda-5e7c5eb415c6d84f19e6135729d9635d" class="header-anchor">#</a> <code>hbui::OptionWrapper&lt;float&gt;::{ctor}::__l5::&lt;lambda_5e7c5eb415c6d84f19e6135729d9635d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::OptionWrapper&lt;float&gt;::{ctor}::__l5::&lt;lambda_5e7c5eb415c6d84f19e6135729d9635d&gt;
{
  hbui::OptionWrapper&lt;float&gt; *const __this;
  float *value;
  bool *isDirty;
};

</code></pre></div><h3 id="hbui-facetregistry-bind-l2-lambda-6cf8e22b1f259530c328b3a73be09bd3"><a href="#hbui-facetregistry-bind-l2-lambda-6cf8e22b1f259530c328b3a73be09bd3" class="header-anchor">#</a> <code>hbui::FacetRegistry::bind::__l2::&lt;lambda_6cf8e22b1f259530c328b3a73be09bd3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetRegistry::bind::__l2::&lt;lambda_6cf8e22b1f259530c328b3a73be09bd3&gt;
{
  hbui::FacetRegistry *const __this;
  hbui::FacetBinder *binder;
};

</code></pre></div><h3 id="hbui-facetregistry-bind-l2-lambda-6066c263a20a7513df33bbb78d085ae3"><a href="#hbui-facetregistry-bind-l2-lambda-6066c263a20a7513df33bbb78d085ae3" class="header-anchor">#</a> <code>hbui::FacetRegistry::bind::__l2::&lt;lambda_6066c263a20a7513df33bbb78d085ae3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetRegistry::bind::__l2::&lt;lambda_6066c263a20a7513df33bbb78d085ae3&gt;
{
  hbui::FacetRegistry *const __this;
  hbui::FacetBinder *binder;
};

</code></pre></div><h3 id="hbui-splitscreenfacet-ctor-l2-lambda-a3896d9a4b97bcf25b659c18160e311f"><a href="#hbui-splitscreenfacet-ctor-l2-lambda-a3896d9a4b97bcf25b659c18160e311f" class="header-anchor">#</a> <code>hbui::SplitScreenFacet::{ctor}::__l2::&lt;lambda_a3896d9a4b97bcf25b659c18160e311f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::SplitScreenFacet::{ctor}::__l2::&lt;lambda_a3896d9a4b97bcf25b659c18160e311f&gt;
{
  hbui::SplitScreenFacet *const __this;
  const IClientInstance *clientInstance;
};

</code></pre></div><h3 id="hbui-screenreaderfacet-registerobservers-l8-lambda-5ae2404388e2ae8d14c2c1abb873009d"><a href="#hbui-screenreaderfacet-registerobservers-l8-lambda-5ae2404388e2ae8d14c2c1abb873009d" class="header-anchor">#</a> <code>hbui::ScreenReaderFacet::_registerObservers::__l8::&lt;lambda_5ae2404388e2ae8d14c2c1abb873009d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::ScreenReaderFacet::_registerObservers::__l8::&lt;lambda_5ae2404388e2ae8d14c2c1abb873009d&gt;
{
  hbui::ScreenReaderFacet *const __this;
};

</code></pre></div><h3 id="hbui-screenreaderfacet-registerobservers-l5-lambda-ff6107dbe840263fd2607a3531d764fb"><a href="#hbui-screenreaderfacet-registerobservers-l5-lambda-ff6107dbe840263fd2607a3531d764fb" class="header-anchor">#</a> <code>hbui::ScreenReaderFacet::_registerObservers::__l5::&lt;lambda_ff6107dbe840263fd2607a3531d764fb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::ScreenReaderFacet::_registerObservers::__l5::&lt;lambda_ff6107dbe840263fd2607a3531d764fb&gt;
{
  hbui::ScreenReaderFacet *const __this;
};

</code></pre></div><h3 id="hbui-localefacet-registerobservers-l5-lambda-34070cf23042ac96cc4b06279f26c9e2"><a href="#hbui-localefacet-registerobservers-l5-lambda-34070cf23042ac96cc4b06279f26c9e2" class="header-anchor">#</a> <code>hbui::LocaleFacet::_registerObservers::__l5::&lt;lambda_34070cf23042ac96cc4b06279f26c9e2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::LocaleFacet::_registerObservers::__l5::&lt;lambda_34070cf23042ac96cc4b06279f26c9e2&gt;
{
  hbui::LocaleFacet *const __this;
};

</code></pre></div><h3 id="hbui-inputfacet-registerobservers-l10-lambda-3b26e34c65f70ca7014fa632ac7bfb5b"><a href="#hbui-inputfacet-registerobservers-l10-lambda-3b26e34c65f70ca7014fa632ac7bfb5b" class="header-anchor">#</a> <code>hbui::InputFacet::_registerObservers::__l10::&lt;lambda_3b26e34c65f70ca7014fa632ac7bfb5b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::InputFacet::_registerObservers::__l10::&lt;lambda_3b26e34c65f70ca7014fa632ac7bfb5b&gt;
{
  hbui::InputFacet *const __this;
};

</code></pre></div><h3 id="hbui-inputfacet-registerobservers-l6-lambda-ad7d2f101c9885bd05e57617f5a1d792"><a href="#hbui-inputfacet-registerobservers-l6-lambda-ad7d2f101c9885bd05e57617f5a1d792" class="header-anchor">#</a> <code>hbui::InputFacet::_registerObservers::__l6::&lt;lambda_ad7d2f101c9885bd05e57617f5a1d792&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::InputFacet::_registerObservers::__l6::&lt;lambda_ad7d2f101c9885bd05e57617f5a1d792&gt;
{
  hbui::InputFacet *const __this;
};

</code></pre></div><h3 id="hbui-facetbase-scriptapi-scriptenginefacet"><a href="#hbui-facetbase-scriptapi-scriptenginefacet" class="header-anchor">#</a> <code>hbui::FacetBase&lt;ScriptApi::ScriptEngineFacet&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetBase&lt;ScriptApi::ScriptEngineFacet&gt; : hbui::IFacet
{
};

</code></pre></div><h3 id="hbui-facetbase-scriptapi-scriptenginefacet-vtbl"><a href="#hbui-facetbase-scriptapi-scriptenginefacet-vtbl" class="header-anchor">#</a> <code>hbui::FacetBase&lt;ScriptApi::ScriptEngineFacet&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FacetBase&lt;ScriptApi::ScriptEngineFacet&gt;_vtbl
{
  void (__fastcall *~IFacet)(hbui::IFacet *this);
  void (__fastcall *bindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *unbindFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  void (__fastcall *updateFacet)(hbui::IFacet *this, hbui::FacetBinder *);
  bool (__fastcall *update)(hbui::IFacet *this);
};

</code></pre></div><h3 id="hbui-toucheventdata"><a href="#hbui-toucheventdata" class="header-anchor">#</a> <code>hbui::TouchEventData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::TouchEventData
{
  Vec2 pos;
  unsigned int id;
  hbui::TouchEventData::EventType type;
};

</code></pre></div><h3 id="hbui-gestureeventdata-unnamed-type-pandetails"><a href="#hbui-gestureeventdata-unnamed-type-pandetails" class="header-anchor">#</a> <code>hbui::GestureEventData::&lt;unnamed_type_panDetails&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::GestureEventData::&lt;unnamed_type_panDetails&gt;
{
  Vec2 delta;
};

</code></pre></div><h3 id="hbui-gestureeventdata-unnamed-type-flingdetails"><a href="#hbui-gestureeventdata-unnamed-type-flingdetails" class="header-anchor">#</a> <code>hbui::GestureEventData::&lt;unnamed_type_flingDetails&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct hbui::GestureEventData::&lt;unnamed_type_flingDetails&gt;
{
  float duration;
};

</code></pre></div><h3 id="hbui-gestureeventdata"><a href="#hbui-gestureeventdata" class="header-anchor">#</a> <code>hbui::GestureEventData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::GestureEventData
{
  hbui::GestureEventData::&lt;unnamed_type_panDetails&gt; panDetails;
  hbui::GestureEventData::&lt;unnamed_type_flingDetails&gt; flingDetails;
  Vec2 currentLocation;
  Vec2 startLocation;
  _BYTE type[4];
};

</code></pre></div><h3 id="hbui-gesturerecognizerbase-toucheventdatawithcurrentpos"><a href="#hbui-gesturerecognizerbase-toucheventdatawithcurrentpos" class="header-anchor">#</a> <code>hbui::GestureRecognizerBase::TouchEventDataWithCurrentPos</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::GestureRecognizerBase::TouchEventDataWithCurrentPos
{
  hbui::TouchEventData touchEventData;
  Vec2 currentPos;
};

</code></pre></div><h3 id="hbui-gesturerecognizerbase"><a href="#hbui-gesturerecognizerbase" class="header-anchor">#</a> <code>hbui::GestureRecognizerBase</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) hbui::GestureRecognizerBase
{
  hbui::GestureRecognizerBase_vtbl *__vftable /*VFT*/;
  hbui::IGestureListener *mGestureListener;
  std::vector&lt;hbui::GestureRecognizerBase::TouchEventDataWithCurrentPos&gt; mTrackingTouches;
  std::vector&lt;hbui::GestureRecognizerBase::TouchEventDataWithCurrentPos&gt; mTrackedTouchesWithinTouchesToRecognize;
  float mPixelsPerCm;
  std::function&lt;double __cdecl(void)&gt; mGetTimeS;
  hbui::GestureRecognizerBase::GestureRecognizerState mState;
  bool mEnabled;
  bool mSentTouchesBegan;
  bool mSentTouchesMoved;
  bool mSentTouchesEnded;
  int mPriority;
};

</code></pre></div><h3 id="hbui-gesturerecognizerbase-vtbl"><a href="#hbui-gesturerecognizerbase-vtbl" class="header-anchor">#</a> <code>hbui::GestureRecognizerBase_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::GestureRecognizerBase_vtbl
{
  void (__fastcall *~GestureRecognizerBase)(hbui::GestureRecognizerBase *this);
  void (__fastcall *onTouchesBegan)(hbui::GestureRecognizerBase *this, const std::vector&lt;hbui::TouchEventData&gt; *);
  void (__fastcall *onTouchesMoved)(hbui::GestureRecognizerBase *this, const std::vector&lt;hbui::GestureRecognizerBase::TouchEventDataWithCurrentPos&gt; *);
  void (__fastcall *onTouchesEnded)(hbui::GestureRecognizerBase *this, const std::vector&lt;hbui::GestureRecognizerBase::TouchEventDataWithCurrentPos&gt; *);
  void (__fastcall *onGestureRecognized)(hbui::GestureRecognizerBase *this);
};

</code></pre></div><h3 id="hbui-igesturelistener"><a href="#hbui-igesturelistener" class="header-anchor">#</a> <code>hbui::IGestureListener</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::IGestureListener
{
  hbui::IGestureListener_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="hbui-igesturelistener-vtbl"><a href="#hbui-igesturelistener-vtbl" class="header-anchor">#</a> <code>hbui::IGestureListener_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::IGestureListener_vtbl
{
  void (__fastcall *~IGestureListener)(hbui::IGestureListener *this);
  void (__fastcall *onPanRecognized)(hbui::IGestureListener *this, const Vec2 *, const Vec2 *, const Vec2 *);
  void (__fastcall *onPanCompleted)(hbui::IGestureListener *this, const Vec2 *);
  void (__fastcall *onFlingCompleted)(hbui::IGestureListener *this, const Vec2 *, const Vec2 *, float);
  void (__fastcall *onTapRecognized)(hbui::IGestureListener *this, const Vec2 *);
};

</code></pre></div><h3 id="hbui-flingrecognizer"><a href="#hbui-flingrecognizer" class="header-anchor">#</a> <code>hbui::FlingRecognizer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FlingRecognizer : hbui::GestureRecognizerBase
{
  const unsigned __int64 mMinimumNumberOfTouches;
  const unsigned __int64 mMaximumNumberOfTouches;
  const long double mMaxFlingIntervalBetweenMovesS;
  const float mMinDistanceToFlingCm;
  Vec2 mPreviousLocation;
  long double mPreviousTouchTimeForGesture;
  long double mFlingStartTime;
  Vec2 mFlingStart;
};

</code></pre></div><h3 id="hbui-flingrecognizer-vtbl"><a href="#hbui-flingrecognizer-vtbl" class="header-anchor">#</a> <code>hbui::FlingRecognizer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::FlingRecognizer_vtbl
{
  void (__fastcall *~GestureRecognizerBase)(hbui::GestureRecognizerBase *this);
  void (__fastcall *onTouchesBegan)(hbui::GestureRecognizerBase *this, const std::vector&lt;hbui::TouchEventData&gt; *);
  void (__fastcall *onTouchesMoved)(hbui::GestureRecognizerBase *this, const std::vector&lt;hbui::GestureRecognizerBase::TouchEventDataWithCurrentPos&gt; *);
  void (__fastcall *onTouchesEnded)(hbui::GestureRecognizerBase *this, const std::vector&lt;hbui::GestureRecognizerBase::TouchEventDataWithCurrentPos&gt; *);
  void (__fastcall *onGestureRecognized)(hbui::GestureRecognizerBase *this);
};

</code></pre></div><h3 id="hbui-itouchsystem"><a href="#hbui-itouchsystem" class="header-anchor">#</a> <code>hbui::ITouchSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::ITouchSystem
{
  hbui::ITouchSystem_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="hbui-itouchsystem-vtbl"><a href="#hbui-itouchsystem-vtbl" class="header-anchor">#</a> <code>hbui::ITouchSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::ITouchSystem_vtbl
{
  void (__fastcall *~ITouchSystem)(hbui::ITouchSystem *this);
  void (__fastcall *sendTouchEvents)(hbui::ITouchSystem *this, const std::vector&lt;hbui::TouchEventData&gt; *);
  void (__fastcall *sendGestureEvent)(hbui::ITouchSystem *this, const hbui::GestureEventData *);
};

</code></pre></div><h3 id="hbui-gesturemanager"><a href="#hbui-gesturemanager" class="header-anchor">#</a> <code>hbui::GestureManager</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::GestureManager
{
  std::vector&lt;std::unique_ptr&lt;hbui::GestureRecognizerBase&gt;&gt; mRecognizers;
};

</code></pre></div><h3 id="hbui-gesturepolicy"><a href="#hbui-gesturepolicy" class="header-anchor">#</a> <code>hbui::GesturePolicy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::GesturePolicy : hbui::IGestureListener
{
  hbui::ITouchSystem *mTouchSystem;
  hbui::GestureManager mGestureManager;
};

</code></pre></div><h3 id="hbui-gesturepolicy-vtbl"><a href="#hbui-gesturepolicy-vtbl" class="header-anchor">#</a> <code>hbui::GesturePolicy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::GesturePolicy_vtbl
{
  void (__fastcall *~IGestureListener)(hbui::IGestureListener *this);
  void (__fastcall *onPanRecognized)(hbui::IGestureListener *this, const Vec2 *, const Vec2 *, const Vec2 *);
  void (__fastcall *onPanCompleted)(hbui::IGestureListener *this, const Vec2 *);
  void (__fastcall *onFlingCompleted)(hbui::IGestureListener *this, const Vec2 *, const Vec2 *, float);
  void (__fastcall *onTapRecognized)(hbui::IGestureListener *this, const Vec2 *);
};

</code></pre></div><h3 id="hbui-taprecognizer"><a href="#hbui-taprecognizer" class="header-anchor">#</a> <code>hbui::TapRecognizer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::TapRecognizer : hbui::GestureRecognizerBase
{
  const unsigned int mMaximumNumberOfTouches;
  const long double mTimeToleranceS;
  const float mTapDistanceToleranceCm;
  Vec2 mStartPoint;
  long double mLastTouchTimestamp;
};

</code></pre></div><h3 id="hbui-taprecognizer-vtbl"><a href="#hbui-taprecognizer-vtbl" class="header-anchor">#</a> <code>hbui::TapRecognizer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::TapRecognizer_vtbl
{
  void (__fastcall *~GestureRecognizerBase)(hbui::GestureRecognizerBase *this);
  void (__fastcall *onTouchesBegan)(hbui::GestureRecognizerBase *this, const std::vector&lt;hbui::TouchEventData&gt; *);
  void (__fastcall *onTouchesMoved)(hbui::GestureRecognizerBase *this, const std::vector&lt;hbui::GestureRecognizerBase::TouchEventDataWithCurrentPos&gt; *);
  void (__fastcall *onTouchesEnded)(hbui::GestureRecognizerBase *this, const std::vector&lt;hbui::GestureRecognizerBase::TouchEventDataWithCurrentPos&gt; *);
  void (__fastcall *onGestureRecognized)(hbui::GestureRecognizerBase *this);
};

</code></pre></div><h3 id="hbui-panrecognizer"><a href="#hbui-panrecognizer" class="header-anchor">#</a> <code>hbui::PanRecognizer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::PanRecognizer : hbui::GestureRecognizerBase
{
  const unsigned __int64 mMinimumNumberOfTouches;
  const unsigned __int64 mMaximumNumberOfTouches;
  const float mMinDistanceToPanCm;
  float mTotalDeltaMovementInCm;
  Vec2 mPreviousLocation;
  Vec2 mStartPoint;
  Vec2 mEndPoint;
  Vec2 mDeltaTranslation;
};

</code></pre></div><h3 id="hbui-panrecognizer-vtbl"><a href="#hbui-panrecognizer-vtbl" class="header-anchor">#</a> <code>hbui::PanRecognizer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::PanRecognizer_vtbl
{
  void (__fastcall *~GestureRecognizerBase)(hbui::GestureRecognizerBase *this);
  void (__fastcall *onTouchesBegan)(hbui::GestureRecognizerBase *this, const std::vector&lt;hbui::TouchEventData&gt; *);
  void (__fastcall *onTouchesMoved)(hbui::GestureRecognizerBase *this, const std::vector&lt;hbui::GestureRecognizerBase::TouchEventDataWithCurrentPos&gt; *);
  void (__fastcall *onTouchesEnded)(hbui::GestureRecognizerBase *this, const std::vector&lt;hbui::GestureRecognizerBase::TouchEventDataWithCurrentPos&gt; *);
  void (__fastcall *onGestureRecognized)(hbui::GestureRecognizerBase *this);
};

</code></pre></div><h3 id="hummingbirdui-registertoggleobservers-l8-lambda-65fa83552ca5e7be58a344e69c942bb3"><a href="#hummingbirdui-registertoggleobservers-l8-lambda-65fa83552ca5e7be58a344e69c942bb3" class="header-anchor">#</a> <code>HummingbirdUI::_registerToggleObservers::__l8::&lt;lambda_65fa83552ca5e7be58a344e69c942bb3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HummingbirdUI::_registerToggleObservers::__l8::&lt;lambda_65fa83552ca5e7be58a344e69c942bb3&gt;
{
  HummingbirdUI *const __this;
};

</code></pre></div><h3 id="hummingbirdui-registertoggleobservers-l5-lambda-ede23b58d9466ab0eecaabf665c4ae6f"><a href="#hummingbirdui-registertoggleobservers-l5-lambda-ede23b58d9466ab0eecaabf665c4ae6f" class="header-anchor">#</a> <code>HummingbirdUI::_registerToggleObservers::__l5::&lt;lambda_ede23b58d9466ab0eecaabf665c4ae6f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HummingbirdUI::_registerToggleObservers::__l5::&lt;lambda_ede23b58d9466ab0eecaabf665c4ae6f&gt;
{
  HummingbirdUI *const __this;
};

</code></pre></div><h3 id="hummingbirdui-registertoggleobservers-l2-lambda-04aa32db8b81ea2ad470eb40b776b578"><a href="#hummingbirdui-registertoggleobservers-l2-lambda-04aa32db8b81ea2ad470eb40b776b578" class="header-anchor">#</a> <code>HummingbirdUI::_registerToggleObservers::__l2::&lt;lambda_04aa32db8b81ea2ad470eb40b776b578&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HummingbirdUI::_registerToggleObservers::__l2::&lt;lambda_04aa32db8b81ea2ad470eb40b776b578&gt;
{
  HummingbirdUI *const __this;
};

</code></pre></div><h3 id="hbui-scene-init-l2-lambda-a0f580796429890ad766443cc20dda62"><a href="#hbui-scene-init-l2-lambda-a0f580796429890ad766443cc20dda62" class="header-anchor">#</a> <code>hbui::Scene::init::__l2::&lt;lambda_a0f580796429890ad766443cc20dda62&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::Scene::init::__l2::&lt;lambda_a0f580796429890ad766443cc20dda62&gt;
{
};

</code></pre></div><h3 id="hbui-scene-init-l2-lambda-b0e36d1425fd16211c03af30c4297f0b"><a href="#hbui-scene-init-l2-lambda-b0e36d1425fd16211c03af30c4297f0b" class="header-anchor">#</a> <code>hbui::Scene::init::__l2::&lt;lambda_b0e36d1425fd16211c03af30c4297f0b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::Scene::init::__l2::&lt;lambda_b0e36d1425fd16211c03af30c4297f0b&gt;
{
};

</code></pre></div><h3 id="hbui-scene-init-l2-lambda-c102446960817e9a9b5b64dd6cc74790"><a href="#hbui-scene-init-l2-lambda-c102446960817e9a9b5b64dd6cc74790" class="header-anchor">#</a> <code>hbui::Scene::init::__l2::&lt;lambda_c102446960817e9a9b5b64dd6cc74790&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::Scene::init::__l2::&lt;lambda_c102446960817e9a9b5b64dd6cc74790&gt;
{
  hbui::Scene *const __this;
};

</code></pre></div><h3 id="hbui-sceneprovider-createscene-l2-lambda-b8946bc37d35e6137b2e4d7a3bcc47ca"><a href="#hbui-sceneprovider-createscene-l2-lambda-b8946bc37d35e6137b2e4d7a3bcc47ca" class="header-anchor">#</a> <code>hbui::SceneProvider::createScene::__l2::&lt;lambda_b8946bc37d35e6137b2e4d7a3bcc47ca&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::SceneProvider::createScene::__l2::&lt;lambda_b8946bc37d35e6137b2e4d7a3bcc47ca&gt;
{
  ISceneStack *sceneStack;
};

</code></pre></div><h3 id="hbui-gamepadstate"><a href="#hbui-gamepadstate" class="header-anchor">#</a> <code>hbui::GamepadState</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::GamepadState
{
  int gamepadId;
  std::array&lt;enum hbui::GamepadButtonState,33&gt; buttonStates;
  std::array&lt;float,33&gt; buttonValues;
  std::array&lt;float,4&gt; axisStates;
};

</code></pre></div><h3 id="hbui-gamecontrollerinputhandler"><a href="#hbui-gamecontrollerinputhandler" class="header-anchor">#</a> <code>hbui::GameControllerInputHandler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) hbui::GameControllerInputHandler
{
  IGameControllerManager *mGameControllerManager;
  std::vector&lt;hbui::GamepadState&gt; mGamepadStates;
  bool mWasActiveLastTime;
};

</code></pre></div><h3 id="hbui-igamepadsystem"><a href="#hbui-igamepadsystem" class="header-anchor">#</a> <code>hbui::IGamepadSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::IGamepadSystem
{
  hbui::IGamepadSystem_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="hbui-igamepadsystem-vtbl"><a href="#hbui-igamepadsystem-vtbl" class="header-anchor">#</a> <code>hbui::IGamepadSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::IGamepadSystem_vtbl
{
  void (__fastcall *~IGamepadSystem)(hbui::IGamepadSystem *this);
  void (__fastcall *registerGamepad)(hbui::IGamepadSystem *this, int, const std::string *);
  void (__fastcall *unregisterGamepad)(hbui::IGamepadSystem *this, int);
  void (__fastcall *updateGamepadState)(hbui::IGamepadSystem *this, hbui::GamepadState *, float);
  void (__fastcall *updateGamepadStateExtended)(hbui::IGamepadSystem *this, const hbui::GamepadState *, float);
};

</code></pre></div><h3 id="hbui-itouchinput"><a href="#hbui-itouchinput" class="header-anchor">#</a> <code>hbui::ITouchInput</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::ITouchInput
{
  hbui::ITouchInput_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="hbui-itouchinput-vtbl"><a href="#hbui-itouchinput-vtbl" class="header-anchor">#</a> <code>hbui::ITouchInput_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ hbui::ITouchInput_vtbl
{
  void (__fastcall *~ITouchInput)(hbui::ITouchInput *this);
  const std::vector&lt;int&gt; *(__fastcall *getActivePointerIdsThisUpdate)(hbui::ITouchInput *this, const std::vector&lt;int&gt; *result);
  __int16 (__fastcall *getX)(hbui::ITouchInput *this, int);
  __int16 (__fastcall *getY)(hbui::ITouchInput *this, int);
  bool (__fastcall *isPressed)(hbui::ITouchInput *this, int);
  bool (__fastcall *isEdgeTouch)(hbui::ITouchInput *this, int);
  bool (__fastcall *isPointerDown)(hbui::ITouchInput *this, int);
};

</code></pre></div><h3 id="hbui-activetouch"><a href="#hbui-activetouch" class="header-anchor">#</a> <code>hbui::ActiveTouch</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) hbui::ActiveTouch
{
  int id;
  Vec2 origin;
  Vec2 currentLocation;
  bool hasMoved;
};

</code></pre></div><h3 id="hbui-touchinputhandler"><a href="#hbui-touchinputhandler" class="header-anchor">#</a> <code>hbui::TouchInputHandler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::TouchInputHandler
{
  std::unique_ptr&lt;hbui::ITouchInput&gt; mTouchInput;
  std::unique_ptr&lt;hbui::ITouchSystem&gt; mTouchSystem;
  std::unique_ptr&lt;hbui::GesturePolicy&gt; mGesturePolicy;
  std::vector&lt;hbui::ActiveTouch&gt; mActiveTouches;
};

</code></pre></div><h3 id="hbui-routerconfiguration-addachievementsroutetomatcher-l5-lambda-81c8189686239e53df73b08a181027a5"><a href="#hbui-routerconfiguration-addachievementsroutetomatcher-l5-lambda-81c8189686239e53df73b08a181027a5" class="header-anchor">#</a> <code>hbui::RouterConfiguration::_addAchievementsRouteToMatcher::__l5::&lt;lambda_81c8189686239e53df73b08a181027a5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::RouterConfiguration::_addAchievementsRouteToMatcher::__l5::&lt;lambda_81c8189686239e53df73b08a181027a5&gt;
{
  SceneFactory *sceneFactory;
  ISceneStack *sceneStack;
};

</code></pre></div><h3 id="hbui-routerconfiguration-addpersonaroutetomatcher-l9-lambda-4e587607a05bd4df095d17592af911f5"><a href="#hbui-routerconfiguration-addpersonaroutetomatcher-l9-lambda-4e587607a05bd4df095d17592af911f5" class="header-anchor">#</a> <code>hbui::RouterConfiguration::_addPersonaRouteToMatcher::__l9::&lt;lambda_4e587607a05bd4df095d17592af911f5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::RouterConfiguration::_addPersonaRouteToMatcher::__l9::&lt;lambda_4e587607a05bd4df095d17592af911f5&gt;
{
  SceneFactory *sceneFactory;
  ISceneStack *sceneStack;
};

</code></pre></div><h3 id="hbui-routerconfiguration-createoutofgameroutematcher-l9-lambda-e7171c66b973a5665fbb403dbb2c2862"><a href="#hbui-routerconfiguration-createoutofgameroutematcher-l9-lambda-e7171c66b973a5665fbb403dbb2c2862" class="header-anchor">#</a> <code>hbui::RouterConfiguration::createOutOfGameRouteMatcher::__l9::&lt;lambda_e7171c66b973a5665fbb403dbb2c2862&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::RouterConfiguration::createOutOfGameRouteMatcher::__l9::&lt;lambda_e7171c66b973a5665fbb403dbb2c2862&gt;
{
  SceneFactory *sceneFactory;
  ISceneStack *sceneStack;
  const hbui::Route *routeEntry;
};

</code></pre></div><h3 id="hbui-routerconfiguration-createingameroutematcher-l9-lambda-b1e01b8ba6fa85f066e412929aa6b2d5"><a href="#hbui-routerconfiguration-createingameroutematcher-l9-lambda-b1e01b8ba6fa85f066e412929aa6b2d5" class="header-anchor">#</a> <code>hbui::RouterConfiguration::createInGameRouteMatcher::__l9::&lt;lambda_b1e01b8ba6fa85f066e412929aa6b2d5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::RouterConfiguration::createInGameRouteMatcher::__l9::&lt;lambda_b1e01b8ba6fa85f066e412929aa6b2d5&gt;
{
  SceneFactory *sceneFactory;
  ISceneStack *sceneStack;
  const hbui::Route *routeEntry;
};

</code></pre></div><h3 id="hbui-router-onchange-l2-lambda-ca382762252883c93e5f24dc2b0c8635"><a href="#hbui-router-onchange-l2-lambda-ca382762252883c93e5f24dc2b0c8635" class="header-anchor">#</a> <code>hbui::Router::_onChange::__l2::&lt;lambda_ca382762252883c93e5f24dc2b0c8635&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) hbui::Router::_onChange::__l2::&lt;lambda_ca382762252883c93e5f24dc2b0c8635&gt;
{
  const std::optional&lt;hbui::RouterLocation&gt; previousLocation;
  const hbui::RouterLocation currentLocation;
  const hbui::RouterAction action;
};

</code></pre></div><h3 id="hbui-loadjsonfromhybridresources-l6-lambda-44461f9abae851eab9a9c18a435bebbd"><a href="#hbui-loadjsonfromhybridresources-l6-lambda-44461f9abae851eab9a9c18a435bebbd" class="header-anchor">#</a> <code>hbui::loadJsonFromHybridResources::__l6::&lt;lambda_44461f9abae851eab9a9c18a435bebbd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::loadJsonFromHybridResources::__l6::&lt;lambda_44461f9abae851eab9a9c18a435bebbd&gt;
{
  std::string *resourceStream;
};

</code></pre></div><h3 id="hdrcalibrationscreencontroller"><a href="#hdrcalibrationscreencontroller" class="header-anchor">#</a> <code>HdrCalibrationScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HdrCalibrationScreenController : MinecraftScreenController
{
  float mCalibrationSliderPercent;
};

</code></pre></div><h3 id="hdrcalibrationscreencontroller-vtbl"><a href="#hdrcalibrationscreencontroller-vtbl" class="header-anchor">#</a> <code>HdrCalibrationScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HdrCalibrationScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="howtoplayscreencontroller"><a href="#howtoplayscreencontroller" class="header-anchor">#</a> <code>HowToPlayScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HowToPlayScreenController : MainMenuScreenController
{
  std::string mCurrentTabTitle;
  HowToPlayTopicIndex mCurrentTab;
  HowToPlayTopicIndex mInitialTab;
  bool mInitialTabSelected;
};

</code></pre></div><h3 id="howtoplayscreencontroller-vtbl"><a href="#howtoplayscreencontroller-vtbl" class="header-anchor">#</a> <code>HowToPlayScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HowToPlayScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="howtoplayscreencontrollerproxycallbacks"><a href="#howtoplayscreencontrollerproxycallbacks" class="header-anchor">#</a> <code>HowToPlayScreenControllerProxyCallbacks</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenControllerProxyCallbacks
{
  std::function&lt;void __cdecl(int)&gt; mChangeTab;
};

</code></pre></div><h3 id="howtoplayscreencontrollerproxy"><a href="#howtoplayscreencontrollerproxy" class="header-anchor">#</a> <code>HowToPlayScreenControllerProxy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenControllerProxy : ScreenControllerProxy
{
  const HowToPlayScreenControllerProxyCallbacks mCallbacks;
};

</code></pre></div><h3 id="howtoplayscreencontrollerproxy-vtbl"><a href="#howtoplayscreencontrollerproxy-vtbl" class="header-anchor">#</a> <code>HowToPlayScreenControllerProxy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HowToPlayScreenControllerProxy_vtbl
{
  void (__fastcall *~ScreenControllerProxy)(ScreenControllerProxy *this);
};

</code></pre></div><h3 id="howtoplayscreencontroller-registereventhandlers-l2-lambda-df79304cc9649fb67bf9353cd28ebf6e"><a href="#howtoplayscreencontroller-registereventhandlers-l2-lambda-df79304cc9649fb67bf9353cd28ebf6e" class="header-anchor">#</a> <code>HowToPlayScreenController::_registerEventHandlers::__l2::&lt;lambda_df79304cc9649fb67bf9353cd28ebf6e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenController::_registerEventHandlers::__l2::&lt;lambda_df79304cc9649fb67bf9353cd28ebf6e&gt;
{
  HowToPlayScreenController *const __this;
};

</code></pre></div><h3 id="howtoplayscreencontroller-registereventhandlers-l2-lambda-8ed3ed5e7ff5517b92878b3114b94405"><a href="#howtoplayscreencontroller-registereventhandlers-l2-lambda-8ed3ed5e7ff5517b92878b3114b94405" class="header-anchor">#</a> <code>HowToPlayScreenController::_registerEventHandlers::__l2::&lt;lambda_8ed3ed5e7ff5517b92878b3114b94405&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenController::_registerEventHandlers::__l2::&lt;lambda_8ed3ed5e7ff5517b92878b3114b94405&gt;
{
  HowToPlayScreenController *const __this;
};

</code></pre></div><h3 id="howtoplayscreencontroller-registercontrollercallbacks-l2-lambda-3df758b5b4c13cd9b28dec94ab6a2f24"><a href="#howtoplayscreencontroller-registercontrollercallbacks-l2-lambda-3df758b5b4c13cd9b28dec94ab6a2f24" class="header-anchor">#</a> <code>HowToPlayScreenController::_registerControllerCallbacks::__l2::&lt;lambda_3df758b5b4c13cd9b28dec94ab6a2f24&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenController::_registerControllerCallbacks::__l2::&lt;lambda_3df758b5b4c13cd9b28dec94ab6a2f24&gt;
{
  HowToPlayScreenController *const __this;
};

</code></pre></div><h3 id="howtoplayscreencontroller-registercontrollercallbacks-l2-lambda-3df758b5b4c13cd9b28dec94ab6a2f24-l2-lambda-696e9f1d37641dc281f8ace2b56e28eb"><a href="#howtoplayscreencontroller-registercontrollercallbacks-l2-lambda-3df758b5b4c13cd9b28dec94ab6a2f24-l2-lambda-696e9f1d37641dc281f8ace2b56e28eb" class="header-anchor">#</a> <code>HowToPlayScreenController::_registerControllerCallbacks::__l2::&lt;lambda_3df758b5b4c13cd9b28dec94ab6a2f24&gt;::()::__l2::&lt;lambda_696e9f1d37641dc281f8ace2b56e28eb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenController::_registerControllerCallbacks::__l2::&lt;lambda_3df758b5b4c13cd9b28dec94ab6a2f24&gt;::()::__l2::&lt;lambda_696e9f1d37641dc281f8ace2b56e28eb&gt;
{
  HowToPlayScreenController *const __this;
};

</code></pre></div><h3 id="howtoplayscreencontroller-registerbindings-l2-lambda-98980cad79d6be51a970ed8b8a173214"><a href="#howtoplayscreencontroller-registerbindings-l2-lambda-98980cad79d6be51a970ed8b8a173214" class="header-anchor">#</a> <code>HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_98980cad79d6be51a970ed8b8a173214&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_98980cad79d6be51a970ed8b8a173214&gt;
{
};

</code></pre></div><h3 id="howtoplayscreencontroller-registerbindings-l2-lambda-3e638c576b835e1ca482eeb052965021"><a href="#howtoplayscreencontroller-registerbindings-l2-lambda-3e638c576b835e1ca482eeb052965021" class="header-anchor">#</a> <code>HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_3e638c576b835e1ca482eeb052965021&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_3e638c576b835e1ca482eeb052965021&gt;
{
  HowToPlayScreenController *const __this;
};

</code></pre></div><h3 id="howtoplayscreencontroller-registerbindings-l2-lambda-7df109e05f81532ad44d42e1d67f6a9e"><a href="#howtoplayscreencontroller-registerbindings-l2-lambda-7df109e05f81532ad44d42e1d67f6a9e" class="header-anchor">#</a> <code>HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_7df109e05f81532ad44d42e1d67f6a9e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_7df109e05f81532ad44d42e1d67f6a9e&gt;
{
  HowToPlayScreenController *const __this;
};

</code></pre></div><h3 id="howtoplayscreencontroller-registerbindings-l2-lambda-09d820a0cb2cc4cac0a8a8313d479d20"><a href="#howtoplayscreencontroller-registerbindings-l2-lambda-09d820a0cb2cc4cac0a8a8313d479d20" class="header-anchor">#</a> <code>HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_09d820a0cb2cc4cac0a8a8313d479d20&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_09d820a0cb2cc4cac0a8a8313d479d20&gt;
{
  HowToPlayScreenController *const __this;
};

</code></pre></div><h3 id="howtoplayscreencontroller-registerbindings-l2-lambda-e03c3214a50b8f20f4a5670fcc3b81ff"><a href="#howtoplayscreencontroller-registerbindings-l2-lambda-e03c3214a50b8f20f4a5670fcc3b81ff" class="header-anchor">#</a> <code>HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_e03c3214a50b8f20f4a5670fcc3b81ff&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_e03c3214a50b8f20f4a5670fcc3b81ff&gt;
{
  HowToPlayScreenController *const __this;
};

</code></pre></div><h3 id="howtoplayscreencontroller-registerbindings-l2-lambda-9ce3b3187c64fdea79f2e075c2b0e68c"><a href="#howtoplayscreencontroller-registerbindings-l2-lambda-9ce3b3187c64fdea79f2e075c2b0e68c" class="header-anchor">#</a> <code>HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_9ce3b3187c64fdea79f2e075c2b0e68c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_9ce3b3187c64fdea79f2e075c2b0e68c&gt;
{
  HowToPlayScreenController *const __this;
};

</code></pre></div><h3 id="howtoplayscreencontroller-registerbindings-l2-lambda-a893d1a64f2d99f078fe2b0ca5f81962"><a href="#howtoplayscreencontroller-registerbindings-l2-lambda-a893d1a64f2d99f078fe2b0ca5f81962" class="header-anchor">#</a> <code>HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_a893d1a64f2d99f078fe2b0ca5f81962&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_a893d1a64f2d99f078fe2b0ca5f81962&gt;
{
  HowToPlayScreenController *const __this;
};

</code></pre></div><h3 id="howtoplayscreencontroller-registerbindings-l2-lambda-013a21fcd39d0c31c90d5c67a77acc75"><a href="#howtoplayscreencontroller-registerbindings-l2-lambda-013a21fcd39d0c31c90d5c67a77acc75" class="header-anchor">#</a> <code>HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_013a21fcd39d0c31c90d5c67a77acc75&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_013a21fcd39d0c31c90d5c67a77acc75&gt;
{
  HowToPlayScreenController *const __this;
};

</code></pre></div><h3 id="howtoplayscreencontroller-registerbindings-l2-lambda-dd5bc4d1a3b691c61f18e7e5ff239919"><a href="#howtoplayscreencontroller-registerbindings-l2-lambda-dd5bc4d1a3b691c61f18e7e5ff239919" class="header-anchor">#</a> <code>HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_dd5bc4d1a3b691c61f18e7e5ff239919&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_dd5bc4d1a3b691c61f18e7e5ff239919&gt;
{
  HowToPlayScreenController *const __this;
};

</code></pre></div><h3 id="howtoplayscreencontroller-registerbindings-l2-lambda-cc9c32b4c0f9d03fa404b76987170fd6"><a href="#howtoplayscreencontroller-registerbindings-l2-lambda-cc9c32b4c0f9d03fa404b76987170fd6" class="header-anchor">#</a> <code>HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_cc9c32b4c0f9d03fa404b76987170fd6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_cc9c32b4c0f9d03fa404b76987170fd6&gt;
{
  HowToPlayScreenController *const __this;
};

</code></pre></div><h3 id="howtoplayscreencontroller-registerbindings-l2-lambda-2082268c4a2becb732c3d6439028974e"><a href="#howtoplayscreencontroller-registerbindings-l2-lambda-2082268c4a2becb732c3d6439028974e" class="header-anchor">#</a> <code>HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_2082268c4a2becb732c3d6439028974e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_2082268c4a2becb732c3d6439028974e&gt;
{
  HowToPlayScreenController *const __this;
};

</code></pre></div><h3 id="howtoplayscreencontroller-registerbindings-l2-lambda-291b19c5d96adffbb9e7233717fc17be"><a href="#howtoplayscreencontroller-registerbindings-l2-lambda-291b19c5d96adffbb9e7233717fc17be" class="header-anchor">#</a> <code>HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_291b19c5d96adffbb9e7233717fc17be&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_291b19c5d96adffbb9e7233717fc17be&gt;
{
  HowToPlayScreenController *const __this;
};

</code></pre></div><h3 id="howtoplayscreencontroller-registerbindings-l2-lambda-15a24123e7032ce14c4f6a0cddfb6aec"><a href="#howtoplayscreencontroller-registerbindings-l2-lambda-15a24123e7032ce14c4f6a0cddfb6aec" class="header-anchor">#</a> <code>HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_15a24123e7032ce14c4f6a0cddfb6aec&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_15a24123e7032ce14c4f6a0cddfb6aec&gt;
{
  HowToPlayScreenController *const __this;
};

</code></pre></div><h3 id="howtoplayscreencontroller-registerbindings-l2-lambda-ebc5cd8dba9baf966beeb4271f47b30c"><a href="#howtoplayscreencontroller-registerbindings-l2-lambda-ebc5cd8dba9baf966beeb4271f47b30c" class="header-anchor">#</a> <code>HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_ebc5cd8dba9baf966beeb4271f47b30c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenController::_registerBindings::__l2::&lt;lambda_ebc5cd8dba9baf966beeb4271f47b30c&gt;
{
  HowToPlayScreenController *const __this;
};

</code></pre></div><h3 id="howtoplayscreencontroller-ctor-l2-lambda-1a1204ee0fbb79e5ac63c518e03feff6"><a href="#howtoplayscreencontroller-ctor-l2-lambda-1a1204ee0fbb79e5ac63c518e03feff6" class="header-anchor">#</a> <code>HowToPlayScreenController::{ctor}::__l2::&lt;lambda_1a1204ee0fbb79e5ac63c518e03feff6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HowToPlayScreenController::{ctor}::__l2::&lt;lambda_1a1204ee0fbb79e5ac63c518e03feff6&gt;
{
  HowToPlayScreenController *const __this;
};

</code></pre></div><h3 id="hdrcalibrationscreencontroller-registerbindings-l2-lambda-0090d31c2cd362a2b64f1c680f920a17"><a href="#hdrcalibrationscreencontroller-registerbindings-l2-lambda-0090d31c2cd362a2b64f1c680f920a17" class="header-anchor">#</a> <code>HdrCalibrationScreenController::_registerBindings::__l2::&lt;lambda_0090d31c2cd362a2b64f1c680f920a17&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HdrCalibrationScreenController::_registerBindings::__l2::&lt;lambda_0090d31c2cd362a2b64f1c680f920a17&gt;
{
  HdrCalibrationScreenController *const __this;
};

</code></pre></div><h3 id="hdrcalibrationscreencontroller-registerbindings-l2-lambda-af0e07900b26df6861fa15ee3c18d3c2"><a href="#hdrcalibrationscreencontroller-registerbindings-l2-lambda-af0e07900b26df6861fa15ee3c18d3c2" class="header-anchor">#</a> <code>HdrCalibrationScreenController::_registerBindings::__l2::&lt;lambda_af0e07900b26df6861fa15ee3c18d3c2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HdrCalibrationScreenController::_registerBindings::__l2::&lt;lambda_af0e07900b26df6861fa15ee3c18d3c2&gt;
{
  HdrCalibrationScreenController *const __this;
};

</code></pre></div><h3 id="hdrcalibrationscreencontroller-registereventhandlers-l2-lambda-e31c3805daa310b61ad09c3ee7e5a55a"><a href="#hdrcalibrationscreencontroller-registereventhandlers-l2-lambda-e31c3805daa310b61ad09c3ee7e5a55a" class="header-anchor">#</a> <code>HdrCalibrationScreenController::_registerEventHandlers::__l2::&lt;lambda_e31c3805daa310b61ad09c3ee7e5a55a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HdrCalibrationScreenController::_registerEventHandlers::__l2::&lt;lambda_e31c3805daa310b61ad09c3ee7e5a55a&gt;
{
  HdrCalibrationScreenController *const __this;
};

</code></pre></div><h3 id="hdrcalibrationscreencontroller-registereventhandlers-l2-lambda-d5a504e56c9f0309e2a9176fd48019d0"><a href="#hdrcalibrationscreencontroller-registereventhandlers-l2-lambda-d5a504e56c9f0309e2a9176fd48019d0" class="header-anchor">#</a> <code>HdrCalibrationScreenController::_registerEventHandlers::__l2::&lt;lambda_d5a504e56c9f0309e2a9176fd48019d0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HdrCalibrationScreenController::_registerEventHandlers::__l2::&lt;lambda_d5a504e56c9f0309e2a9176fd48019d0&gt;
{
  HdrCalibrationScreenController *const __this;
};

</code></pre></div><h3 id="hudscreencontroller-vtbl"><a href="#hudscreencontroller-vtbl" class="header-anchor">#</a> <code>HudScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HudScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="hudscreencontroller-registertooltips-l5-lambda-612dea3e7018646313e2faa32f42c26e"><a href="#hudscreencontroller-registertooltips-l5-lambda-612dea3e7018646313e2faa32f42c26e" class="header-anchor">#</a> <code>HudScreenController::_registerTooltips::__l5::&lt;lambda_612dea3e7018646313e2faa32f42c26e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudScreenController::_registerTooltips::__l5::&lt;lambda_612dea3e7018646313e2faa32f42c26e&gt;
{
};

</code></pre></div><h3 id="hudscreencontroller-registertooltips-l5-lambda-2915616f499390bbcede6846322347ad"><a href="#hudscreencontroller-registertooltips-l5-lambda-2915616f499390bbcede6846322347ad" class="header-anchor">#</a> <code>HudScreenController::_registerTooltips::__l5::&lt;lambda_2915616f499390bbcede6846322347ad&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudScreenController::_registerTooltips::__l5::&lt;lambda_2915616f499390bbcede6846322347ad&gt;
{
};

</code></pre></div><h3 id="hudscreencontroller-registertooltips-l5-lambda-7f648107bc38bb342441c4168205c24d"><a href="#hudscreencontroller-registertooltips-l5-lambda-7f648107bc38bb342441c4168205c24d" class="header-anchor">#</a> <code>HudScreenController::_registerTooltips::__l5::&lt;lambda_7f648107bc38bb342441c4168205c24d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudScreenController::_registerTooltips::__l5::&lt;lambda_7f648107bc38bb342441c4168205c24d&gt;
{
};

</code></pre></div><h3 id="hudscreencontroller-registertooltips-l5-lambda-c8ef105c332367b5272a0c12f091592c"><a href="#hudscreencontroller-registertooltips-l5-lambda-c8ef105c332367b5272a0c12f091592c" class="header-anchor">#</a> <code>HudScreenController::_registerTooltips::__l5::&lt;lambda_c8ef105c332367b5272a0c12f091592c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudScreenController::_registerTooltips::__l5::&lt;lambda_c8ef105c332367b5272a0c12f091592c&gt;
{
};

</code></pre></div><h3 id="hudscreencontroller-registertooltips-l2-lambda-aa7f61a620b28af03619de18f5f993b4"><a href="#hudscreencontroller-registertooltips-l2-lambda-aa7f61a620b28af03619de18f5f993b4" class="header-anchor">#</a> <code>HudScreenController::_registerTooltips::__l2::&lt;lambda_aa7f61a620b28af03619de18f5f993b4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudScreenController::_registerTooltips::__l2::&lt;lambda_aa7f61a620b28af03619de18f5f993b4&gt;
{
};

</code></pre></div><h3 id="hudscreencontroller-registereventhandlers-l2-lambda-fcb18562d72831645bebf861fdbf02a3"><a href="#hudscreencontroller-registereventhandlers-l2-lambda-fcb18562d72831645bebf861fdbf02a3" class="header-anchor">#</a> <code>HudScreenController::_registerEventHandlers::__l2::&lt;lambda_fcb18562d72831645bebf861fdbf02a3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudScreenController::_registerEventHandlers::__l2::&lt;lambda_fcb18562d72831645bebf861fdbf02a3&gt;
{
  HudScreenController *const __this;
};

</code></pre></div><h3 id="hudscreencontroller-registereventhandlers-l2-lambda-33ace497c08bbdbd85bf4001f20e22e6"><a href="#hudscreencontroller-registereventhandlers-l2-lambda-33ace497c08bbdbd85bf4001f20e22e6" class="header-anchor">#</a> <code>HudScreenController::_registerEventHandlers::__l2::&lt;lambda_33ace497c08bbdbd85bf4001f20e22e6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudScreenController::_registerEventHandlers::__l2::&lt;lambda_33ace497c08bbdbd85bf4001f20e22e6&gt;
{
  HudScreenController *const __this;
};

</code></pre></div><h3 id="hudscreencontroller-registereventhandlers-l2-lambda-9f199990a0b5ca789dab498388215a16"><a href="#hudscreencontroller-registereventhandlers-l2-lambda-9f199990a0b5ca789dab498388215a16" class="header-anchor">#</a> <code>HudScreenController::_registerEventHandlers::__l2::&lt;lambda_9f199990a0b5ca789dab498388215a16&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudScreenController::_registerEventHandlers::__l2::&lt;lambda_9f199990a0b5ca789dab498388215a16&gt;
{
  HudScreenController *const __this;
};

</code></pre></div><h3 id="hudscreencontroller-registereventhandlers-l2-lambda-dac0e6bb1a7406d99e29528a46bd7e58"><a href="#hudscreencontroller-registereventhandlers-l2-lambda-dac0e6bb1a7406d99e29528a46bd7e58" class="header-anchor">#</a> <code>HudScreenController::_registerEventHandlers::__l2::&lt;lambda_dac0e6bb1a7406d99e29528a46bd7e58&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudScreenController::_registerEventHandlers::__l2::&lt;lambda_dac0e6bb1a7406d99e29528a46bd7e58&gt;
{
  HudScreenController *const __this;
};

</code></pre></div><h3 id="hudscreencontroller-registereventhandlers-l2-lambda-4fd4c19a1f90e062769f9cb8be417707"><a href="#hudscreencontroller-registereventhandlers-l2-lambda-4fd4c19a1f90e062769f9cb8be417707" class="header-anchor">#</a> <code>HudScreenController::_registerEventHandlers::__l2::&lt;lambda_4fd4c19a1f90e062769f9cb8be417707&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudScreenController::_registerEventHandlers::__l2::&lt;lambda_4fd4c19a1f90e062769f9cb8be417707&gt;
{
  HudScreenController *const __this;
};

</code></pre></div><h3 id="hudscreencontroller-registereventhandlers-l4-lambda-da91a43e8ee85cc522816548750ccfb3"><a href="#hudscreencontroller-registereventhandlers-l4-lambda-da91a43e8ee85cc522816548750ccfb3" class="header-anchor">#</a> <code>HudScreenController::_registerEventHandlers::__l4::&lt;lambda_da91a43e8ee85cc522816548750ccfb3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HudScreenController::_registerEventHandlers::__l4::&lt;lambda_da91a43e8ee85cc522816548750ccfb3&gt;
{
  HudScreenController *const __this;
  int i;
};

</code></pre></div><h3 id="hudscreencontroller-registereventhandlers-l2-lambda-a93ebc1a35c9b83cd387ef55c5566cff"><a href="#hudscreencontroller-registereventhandlers-l2-lambda-a93ebc1a35c9b83cd387ef55c5566cff" class="header-anchor">#</a> <code>HudScreenController::_registerEventHandlers::__l2::&lt;lambda_a93ebc1a35c9b83cd387ef55c5566cff&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudScreenController::_registerEventHandlers::__l2::&lt;lambda_a93ebc1a35c9b83cd387ef55c5566cff&gt;
{
  HudScreenController *const __this;
};

</code></pre></div><h3 id="hudscreencontroller-registereventhandlers-l2-lambda-4819de47fe36d9e12608ee0f8134edf8"><a href="#hudscreencontroller-registereventhandlers-l2-lambda-4819de47fe36d9e12608ee0f8134edf8" class="header-anchor">#</a> <code>HudScreenController::_registerEventHandlers::__l2::&lt;lambda_4819de47fe36d9e12608ee0f8134edf8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudScreenController::_registerEventHandlers::__l2::&lt;lambda_4819de47fe36d9e12608ee0f8134edf8&gt;
{
  HudScreenController *const __this;
};

</code></pre></div><h3 id="hudscreencontroller-registereventhandlers-l2-lambda-df72e0e5dae7626d909fab6738c73a52"><a href="#hudscreencontroller-registereventhandlers-l2-lambda-df72e0e5dae7626d909fab6738c73a52" class="header-anchor">#</a> <code>HudScreenController::_registerEventHandlers::__l2::&lt;lambda_df72e0e5dae7626d909fab6738c73a52&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudScreenController::_registerEventHandlers::__l2::&lt;lambda_df72e0e5dae7626d909fab6738c73a52&gt;
{
  HudScreenController *const __this;
};

</code></pre></div><h3 id="hudscreencontroller-registereventhandlers-l2-lambda-9cf50b366d8387dd95be8c064fd6b39b"><a href="#hudscreencontroller-registereventhandlers-l2-lambda-9cf50b366d8387dd95be8c064fd6b39b" class="header-anchor">#</a> <code>HudScreenController::_registerEventHandlers::__l2::&lt;lambda_9cf50b366d8387dd95be8c064fd6b39b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudScreenController::_registerEventHandlers::__l2::&lt;lambda_9cf50b366d8387dd95be8c064fd6b39b&gt;
{
  HudScreenController *const __this;
};

</code></pre></div><h3 id="hudscreencontroller-registereventhandlers-l2-lambda-e639e2da445daa176c2ec1175dd978eb"><a href="#hudscreencontroller-registereventhandlers-l2-lambda-e639e2da445daa176c2ec1175dd978eb" class="header-anchor">#</a> <code>HudScreenController::_registerEventHandlers::__l2::&lt;lambda_e639e2da445daa176c2ec1175dd978eb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudScreenController::_registerEventHandlers::__l2::&lt;lambda_e639e2da445daa176c2ec1175dd978eb&gt;
{
  HudScreenController *const __this;
};

</code></pre></div><h3 id="hudscreencontroller-selectslot-l2-lambda-1c7e7760850e81b8138b17aa3d0e7ea6"><a href="#hudscreencontroller-selectslot-l2-lambda-1c7e7760850e81b8138b17aa3d0e7ea6" class="header-anchor">#</a> <code>HudScreenController::_selectSlot::__l2::&lt;lambda_1c7e7760850e81b8138b17aa3d0e7ea6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudScreenController::_selectSlot::__l2::&lt;lambda_1c7e7760850e81b8138b17aa3d0e7ea6&gt;
{
  int *slot;
};

</code></pre></div><h3 id="hudscreencontroller-ctor-l2-lambda-524a1af1e618de3686b438edfbe6d5e4"><a href="#hudscreencontroller-ctor-l2-lambda-524a1af1e618de3686b438edfbe6d5e4" class="header-anchor">#</a> <code>HudScreenController::{ctor}::__l2::&lt;lambda_524a1af1e618de3686b438edfbe6d5e4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudScreenController::{ctor}::__l2::&lt;lambda_524a1af1e618de3686b438edfbe6d5e4&gt;
{
  HudScreenController *const __this;
};

</code></pre></div><h3 id="holouiscreensetupcleanupstrategy"><a href="#holouiscreensetupcleanupstrategy" class="header-anchor">#</a> <code>HoloUIScreenSetupCleanupStrategy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HoloUIScreenSetupCleanupStrategy : AbstractScreenSetupCleanupStrategy
{
  IClientInstance *mClient;
  Matrix mLastMatrixPatch;
};

</code></pre></div><h3 id="holouiscreensetupcleanupstrategy-vtbl"><a href="#holouiscreensetupcleanupstrategy-vtbl" class="header-anchor">#</a> <code>HoloUIScreenSetupCleanupStrategy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HoloUIScreenSetupCleanupStrategy_vtbl
{
  void (__fastcall *~AbstractScreenSetupCleanupStrategy)(AbstractScreenSetupCleanupStrategy *this);
  void (__fastcall *setupScreen)(AbstractScreenSetupCleanupStrategy *this, ScreenContext *);
  void (__fastcall *cleanupScreen)(AbstractScreenSetupCleanupStrategy *this, ScreenContext *);
  EyeRenderingModeBit (__fastcall *getEyeRenderingMode)(AbstractScreenSetupCleanupStrategy *this);
  Matrix *(__fastcall *_generateMatrixPatch)(HoloUIScreenSetupCleanupStrategy *this, Matrix *result);
};

</code></pre></div><h3 id="holohudscreensetupcleanupstrategy"><a href="#holohudscreensetupcleanupstrategy" class="header-anchor">#</a> <code>HoloHUDScreenSetupCleanupStrategy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HoloHUDScreenSetupCleanupStrategy : HoloUIScreenSetupCleanupStrategy
{
};

</code></pre></div><h3 id="holohudscreensetupcleanupstrategy-vtbl"><a href="#holohudscreensetupcleanupstrategy-vtbl" class="header-anchor">#</a> <code>HoloHUDScreenSetupCleanupStrategy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HoloHUDScreenSetupCleanupStrategy_vtbl
{
  void (__fastcall *~AbstractScreenSetupCleanupStrategy)(AbstractScreenSetupCleanupStrategy *this);
  void (__fastcall *setupScreen)(AbstractScreenSetupCleanupStrategy *this, ScreenContext *);
  void (__fastcall *cleanupScreen)(AbstractScreenSetupCleanupStrategy *this, ScreenContext *);
  EyeRenderingModeBit (__fastcall *getEyeRenderingMode)(AbstractScreenSetupCleanupStrategy *this);
  Matrix *(__fastcall *_generateMatrixPatch)(HoloUIScreenSetupCleanupStrategy *this, Matrix *result);
};

</code></pre></div><h3 id="holoingameuiscreensetupcleanupstrategy"><a href="#holoingameuiscreensetupcleanupstrategy" class="header-anchor">#</a> <code>HoloIngameUIScreenSetupCleanupStrategy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HoloIngameUIScreenSetupCleanupStrategy : AbstractScreenSetupCleanupStrategy
{
  IClientInstance *mClient;
  Matrix mLastMatrixPatch;
};

</code></pre></div><h3 id="holoingameuiscreensetupcleanupstrategy-vtbl"><a href="#holoingameuiscreensetupcleanupstrategy-vtbl" class="header-anchor">#</a> <code>HoloIngameUIScreenSetupCleanupStrategy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HoloIngameUIScreenSetupCleanupStrategy_vtbl
{
  void (__fastcall *~AbstractScreenSetupCleanupStrategy)(AbstractScreenSetupCleanupStrategy *this);
  void (__fastcall *setupScreen)(AbstractScreenSetupCleanupStrategy *this, ScreenContext *);
  void (__fastcall *cleanupScreen)(AbstractScreenSetupCleanupStrategy *this, ScreenContext *);
  EyeRenderingModeBit (__fastcall *getEyeRenderingMode)(AbstractScreenSetupCleanupStrategy *this);
  Matrix *(__fastcall *_generateMatrixPatch)(HoloIngameUIScreenSetupCleanupStrategy *this, Matrix *result);
};

</code></pre></div><h3 id="holoplayspacesetupcleanupstrategy"><a href="#holoplayspacesetupcleanupstrategy" class="header-anchor">#</a> <code>HoloPlayspaceSetupCleanupStrategy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HoloPlayspaceSetupCleanupStrategy : AbstractScreenSetupCleanupStrategy
{
  IClientInstance *mClient;
  Matrix mLastMatrixPatch;
};

</code></pre></div><h3 id="holoplayspacesetupcleanupstrategy-vtbl"><a href="#holoplayspacesetupcleanupstrategy-vtbl" class="header-anchor">#</a> <code>HoloPlayspaceSetupCleanupStrategy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HoloPlayspaceSetupCleanupStrategy_vtbl
{
  void (__fastcall *~AbstractScreenSetupCleanupStrategy)(AbstractScreenSetupCleanupStrategy *this);
  void (__fastcall *setupScreen)(AbstractScreenSetupCleanupStrategy *this, ScreenContext *);
  void (__fastcall *cleanupScreen)(AbstractScreenSetupCleanupStrategy *this, ScreenContext *);
  EyeRenderingModeBit (__fastcall *getEyeRenderingMode)(AbstractScreenSetupCleanupStrategy *this);
};

</code></pre></div><h3 id="holorealitysetupcleanupstrategy"><a href="#holorealitysetupcleanupstrategy" class="header-anchor">#</a> <code>HoloRealitySetupCleanupStrategy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HoloRealitySetupCleanupStrategy : AbstractScreenSetupCleanupStrategy
{
  IClientInstance *mClient;
  Matrix mLastMatrixPatch;
};

</code></pre></div><h3 id="holorealitysetupcleanupstrategy-vtbl"><a href="#holorealitysetupcleanupstrategy-vtbl" class="header-anchor">#</a> <code>HoloRealitySetupCleanupStrategy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HoloRealitySetupCleanupStrategy_vtbl
{
  void (__fastcall *~AbstractScreenSetupCleanupStrategy)(AbstractScreenSetupCleanupStrategy *this);
  void (__fastcall *setupScreen)(AbstractScreenSetupCleanupStrategy *this, ScreenContext *);
  void (__fastcall *cleanupScreen)(AbstractScreenSetupCleanupStrategy *this, ScreenContext *);
  EyeRenderingModeBit (__fastcall *getEyeRenderingMode)(AbstractScreenSetupCleanupStrategy *this);
};

</code></pre></div><h3 id="holoscreensetupcleanupstrategy"><a href="#holoscreensetupcleanupstrategy" class="header-anchor">#</a> <code>HoloScreenSetupCleanupStrategy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HoloScreenSetupCleanupStrategy : AbstractScreenSetupCleanupStrategy
{
  Matrix mLastMatrixPatch;
};

</code></pre></div><h3 id="holoscreensetupcleanupstrategy-vtbl"><a href="#holoscreensetupcleanupstrategy-vtbl" class="header-anchor">#</a> <code>HoloScreenSetupCleanupStrategy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HoloScreenSetupCleanupStrategy_vtbl
{
  void (__fastcall *~AbstractScreenSetupCleanupStrategy)(AbstractScreenSetupCleanupStrategy *this);
  void (__fastcall *setupScreen)(AbstractScreenSetupCleanupStrategy *this, ScreenContext *);
  void (__fastcall *cleanupScreen)(AbstractScreenSetupCleanupStrategy *this, ScreenContext *);
  EyeRenderingModeBit (__fastcall *getEyeRenderingMode)(AbstractScreenSetupCleanupStrategy *this);
};

</code></pre></div><h3 id="holoviewersetupcleanupstrategy"><a href="#holoviewersetupcleanupstrategy" class="header-anchor">#</a> <code>HoloViewerSetupCleanupStrategy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HoloViewerSetupCleanupStrategy : AbstractScreenSetupCleanupStrategy
{
  IClientInstance *mClient;
  Matrix mLastMatrixPatch;
};

</code></pre></div><h3 id="holoviewersetupcleanupstrategy-vtbl"><a href="#holoviewersetupcleanupstrategy-vtbl" class="header-anchor">#</a> <code>HoloViewerSetupCleanupStrategy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HoloViewerSetupCleanupStrategy_vtbl
{
  void (__fastcall *~AbstractScreenSetupCleanupStrategy)(AbstractScreenSetupCleanupStrategy *this);
  void (__fastcall *setupScreen)(AbstractScreenSetupCleanupStrategy *this, ScreenContext *);
  void (__fastcall *cleanupScreen)(AbstractScreenSetupCleanupStrategy *this, ScreenContext *);
  EyeRenderingModeBit (__fastcall *getEyeRenderingMode)(AbstractScreenSetupCleanupStrategy *this);
};

</code></pre></div><h3 id="hitbox"><a href="#hitbox" class="header-anchor">#</a> <code>Hitbox</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Hitbox
{
  Vec3 mPivot;
  AABB mAabb;
};

</code></pre></div><h3 id="hangingactor"><a href="#hangingactor" class="header-anchor">#</a> <code>HangingActor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HangingActor : Actor
{
  int mDir;
  int mCheckInterval;
};

</code></pre></div><h3 id="hangingactor-vtbl"><a href="#hangingactor-vtbl" class="header-anchor">#</a> <code>HangingActor_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HangingActor_vtbl
{
  bool (__fastcall *hasComponent)(Actor *this, const HashedString *);
  void (__fastcall *reloadHardcoded)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadHardcodedClient)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *initializeComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *_serverInitItemStackIds)(Actor *this);
  void (__fastcall *_doInitialMove)(Actor *this);
  bool (__fastcall *checkAllSensitiveWords)(Actor *this);
  bool (__fastcall *checkNameTag)(Actor *this);
  void (__fastcall *~Actor)(Actor *this);
  void (__fastcall *reset)(Actor *this);
  int (__fastcall *getOnDeathExperience)(Actor *this);
  ActorType (__fastcall *getOwnerEntityType)(Actor *this);
  void (__fastcall *remove)(Actor *this);
  void (__fastcall *setPos)(Actor *this, const Vec3 *);
  const PredictedMovementValues *(__fastcall *getPredictedMovementValues)(Actor *this);
  const Vec3 *(__fastcall *getPos)(Actor *this);
  const Vec3 *(__fastcall *getPosOld)(Actor *this);
  const Vec3 *(__fastcall *getPosExtrapolated)(Actor *this, const Vec3 *result, float);
  Vec3 *(__fastcall *getAttachPos)(Actor *this, Vec3 *result, ActorLocation, float);
  Vec3 *(__fastcall *getFiringPos)(Actor *this, Vec3 *result);
  void (__fastcall *setRot)(Actor *this, const Vec2 *);
  void (__fastcall *move)(Actor *this, IActorMovementProxy *, const Vec3 *);
  void (__fastcall *move)(Actor *this, const Vec3 *);
  Vec3 *(__fastcall *getInterpolatedRidingPosition)(Actor *this, Vec3 *result, float);
  float (__fastcall *getInterpolatedBodyRot)(Actor *this, float);
  float (__fastcall *getInterpolatedHeadRot)(Actor *this, float);
  float (__fastcall *getInterpolatedBodyYaw)(Actor *this, float);
  float (__fastcall *getYawSpeedInDegreesPerSecond)(Actor *this);
  float (__fastcall *getInterpolatedWalkAnimSpeed)(Actor *this, float);
  Vec3 *(__fastcall *getInterpolatedRidingOffset)(Actor *this, Vec3 *result, float);
  void (__fastcall *checkBlockCollisions)(Actor *this);
  void (__fastcall *checkBlockCollisions)(Actor *this, const AABB *, std::function&lt;void __cdecl(BlockSource &amp;,Block const &amp;,BlockPos const &amp;,Actor &amp;)&gt;);
  bool (__fastcall *isFireImmune)(Actor *this);
  bool (__fastcall *breaksFallingBlocks)(Actor *this);
  void (__fastcall *blockedByShield)(Actor *this, const ActorDamageSource *, Actor *);
  void (__fastcall *teleportTo)(Actor *this, const Vec3 *, bool, int, int, const ActorUniqueID *);
  bool (__fastcall *tryTeleportTo)(Actor *this, const Vec3 *, bool, bool, int, int);
  void (__fastcall *chorusFruitTeleport)(Actor *this, Vec3 *);
  void (__fastcall *lerpTo)(Actor *this, const Vec3 *, const Vec2 *, int);
  void (__fastcall *lerpMotion)(Actor *this, const Vec3 *);
  std::unique_ptr&lt;AddActorBasePacket&gt; *(__fastcall *getAddPacket)(Actor *this, std::unique_ptr&lt;AddActorBasePacket&gt; *result);
  void (__fastcall *normalTick)(Actor *this);
  void (__fastcall *baseTick)(Actor *this);
  void (__fastcall *rideTick)(Actor *this);
  void (__fastcall *positionRider)(Actor *this, Actor *, float);
  float (__fastcall *getRidingHeight)(Actor *this);
  bool (__fastcall *startRiding)(Actor *this, Actor *);
  void (__fastcall *addRider)(Actor *this, Actor *);
  void (__fastcall *flagRiderToRemove)(Actor *this, Actor *);
  std::string *(__fastcall *getExitTip)(Actor *this, std::string *result, const std::string *, InputMode);
  bool (__fastcall *intersects)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *, float);
  bool (__fastcall *isInWall)(Actor *this);
  bool (__fastcall *isInvisible)(Actor *this);
  bool (__fastcall *canShowNameTag)(Actor *this);
  bool (__fastcall *canExistInPeaceful)(Actor *this);
  void (__fastcall *setNameTagVisible)(Actor *this, bool);
  const std::string *(__fastcall *getNameTag)(Actor *this);
  unsigned __int64 (__fastcall *getNameTagAsHash)(Actor *this);
  std::string *(__fastcall *getFormattedNameTag)(Actor *this, std::string *result);
  void (__fastcall *filterFormattedNameTag)(Actor *this, const UIProfanityContext *);
  void (__fastcall *setNameTag)(Actor *this, const std::string *);
  bool (__fastcall *getAlwaysShowNameTag)(Actor *this);
  void (__fastcall *setScoreTag)(Actor *this, const std::string *);
  const std::string *(__fastcall *getScoreTag)(Actor *this);
  bool (__fastcall *isInWater)(Actor *this);
  bool (__fastcall *hasEnteredWater)(Actor *this);
  bool (__fastcall *isImmersedInWater)(Actor *this);
  bool (__fastcall *isInWaterOrRain)(Actor *this);
  bool (__fastcall *isInLava)(Actor *this);
  bool (__fastcall *isUnderLiquid)(Actor *this, MaterialType);
  bool (__fastcall *isOverWater)(Actor *this);
  void (__fastcall *makeStuckInBlock)(Actor *this, const Vec3 *);
  float (__fastcall *getCameraOffset)(Actor *this);
  float (__fastcall *getShadowHeightOffs)(Actor *this);
  float (__fastcall *getShadowRadius)(Actor *this);
  Vec3 *(__fastcall *getHeadLookVector)(Actor *this, Vec3 *result, float);
  bool (__fastcall *canSeeInvisible)(Actor *this);
  bool (__fastcall *canSee)(Actor *this, const Vec3 *);
  bool (__fastcall *canSee)(Actor *this, const Actor *);
  bool (__fastcall *isSkyLit)(Actor *this, float);
  float (__fastcall *getBrightness)(Actor *this, float);
  bool (__fastcall *interactPreventDefault)(Actor *this);
  void (__fastcall *playerTouch)(Actor *this, Player *);
  void (__fastcall *onAboveBubbleColumn)(Actor *this, const bool);
  void (__fastcall *onInsideBubbleColumn)(Actor *this, const bool);
  bool (__fastcall *isImmobile)(Actor *this);
  bool (__fastcall *isSilent)(Actor *this);
  bool (__fastcall *isPickable)(Actor *this);
  bool (__fastcall *isFishable)(Actor *this);
  bool (__fastcall *isSleeping)(Actor *this);
  bool (__fastcall *isShootable)(Actor *this);
  void (__fastcall *setSneaking)(Actor *this, bool);
  bool (__fastcall *isBlocking)(Actor *this);
  bool (__fastcall *isDamageBlocked)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *isAlive)(Actor *this);
  bool (__fastcall *isOnFire)(Actor *this);
  bool (__fastcall *isOnHotBlock)(Actor *this);
  bool (__fastcall *isCreativeModeAllowed)(Actor *this);
  bool (__fastcall *isSurfaceMob)(Actor *this);
  bool (__fastcall *isTargetable)(Actor *this);
  bool (__fastcall *isLocalPlayer)(Actor *this);
  bool (__fastcall *isPlayer)(Actor *this);
  bool (__fastcall *canAttack)(Actor *this, Actor *, bool);
  void (__fastcall *setTarget)(Actor *this, Actor *);
  Actor *(__fastcall *findAttackTarget)(Actor *this);
  bool (__fastcall *isValidTarget)(Actor *this, Actor *);
  bool (__fastcall *attack)(Actor *this, Actor *);
  void (__fastcall *performRangedAttack)(Actor *this, Actor *, float);
  void (__fastcall *adjustDamageAmount)(Actor *this, int *);
  int (__fastcall *getEquipmentCount)(Actor *this);
  void (__fastcall *setOwner)(Actor *this, const ActorUniqueID);
  void (__fastcall *setSitting)(Actor *this, bool);
  void (__fastcall *onTame)(Actor *this);
  void (__fastcall *onFailedTame)(Actor *this);
  int (__fastcall *getInventorySize)(Actor *this);
  int (__fastcall *getEquipSlots)(Actor *this);
  int (__fastcall *getChestSlots)(Actor *this);
  void (__fastcall *setStanding)(Actor *this, bool);
  bool (__fastcall *canPowerJump)(Actor *this);
  void (__fastcall *setCanPowerJump)(Actor *this, bool);
  bool (__fastcall *isJumping)(Actor *this);
  bool (__fastcall *isEnchanted)(Actor *this);
  void (__fastcall *rideJumped)(Actor *this);
  void (__fastcall *rideLanded)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *shouldRender)(Actor *this);
  bool (__fastcall *isInvulnerableTo)(Actor *this, const ActorDamageSource *);
  ActorDamageCause (__fastcall *getBlockDamageCause)(Actor *this, const Block *);
  void (__fastcall *actuallyHurt)(Actor *this, int, const ActorDamageSource *, bool);
  void (__fastcall *animateHurt)(Actor *this);
  bool (__fastcall *doFireHurt)(Actor *this, int);
  void (__fastcall *onLightningHit)(Actor *this);
  void (__fastcall *onBounceStarted)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *feed)(Actor *this, int);
  void (__fastcall *handleEntityEvent)(Actor *this, ActorEvent, int);
  float (__fastcall *getPickRadius)(Actor *this);
  const HashedString *(__fastcall *getActorRendererId)(Actor *this);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const ItemStack *, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int);
  void (__fastcall *despawn)(Actor *this);
  void (__fastcall *killed)(Actor *this, Actor *);
  void (__fastcall *awardKillScore)(Actor *this, Actor *, int);
  void (__fastcall *setArmor)(Actor *this, ArmorSlot, const ItemStack *);
  const ItemStack *(__fastcall *getArmor)(Actor *this, ArmorSlot);
  ArmorMaterialType (__fastcall *getArmorMaterialTypeInSlot)(Actor *this, ArmorSlot);
  ArmorTextureType (__fastcall *getArmorMaterialTextureTypeInSlot)(Actor *this, ArmorSlot);
  float (__fastcall *getArmorColorInSlot)(Actor *this, ArmorSlot, int);
  const ItemStack *(__fastcall *getEquippedSlot)(Actor *this, EquipmentSlot);
  void (__fastcall *setEquippedSlot)(Actor *this, EquipmentSlot, const ItemStack *);
  const ItemStack *(__fastcall *getCarriedItem)(Actor *this);
  void (__fastcall *setCarriedItem)(Actor *this, const ItemStack *);
  void (__fastcall *setOffhandSlot)(Actor *this, const ItemStack *);
  const ItemStack *(__fastcall *getEquippedTotem)(Actor *this);
  bool (__fastcall *consumeTotem)(Actor *this);
  bool (__fastcall *save)(Actor *this, CompoundTag *);
  void (__fastcall *saveWithoutId)(Actor *this, CompoundTag *);
  bool (__fastcall *load)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *loadLinks)(Actor *this, const CompoundTag *, std::vector&lt;ActorLink&gt; *, DataLoadHelper *);
  ActorType (__fastcall *getEntityTypeId)(Actor *this);
  const HashedString *(__fastcall *queryEntityRenderer)(Actor *this);
  ActorUniqueID *(__fastcall *getSourceUniqueID)(Actor *this, ActorUniqueID *result);
  void (__fastcall *setOnFire)(Actor *this, int);
  AABB *(__fastcall *getHandleWaterAABB)(Actor *this, AABB *result);
  void (__fastcall *handleInsidePortal)(Actor *this, const BlockPos *);
  int (__fastcall *getPortalCooldown)(Actor *this);
  int (__fastcall *getPortalWaitTime)(Actor *this);
  AutomaticID&lt;Dimension,int&gt; *(__fastcall *getDimensionId)(Actor *this, AutomaticID&lt;Dimension,int&gt; *result);
  bool (__fastcall *canChangeDimensions)(Actor *this);
  void (__fastcall *changeDimension)(Actor *this, const ChangeDimensionPacket *);
  void (__fastcall *changeDimension)(Actor *this, AutomaticID&lt;Dimension,int&gt;, bool);
  ActorUniqueID *(__fastcall *getControllingPlayer)(Actor *this, ActorUniqueID *result);
  void (__fastcall *checkFallDamage)(Actor *this, float, bool);
  void (__fastcall *causeFallDamage)(Actor *this, float);
  void (__fastcall *handleFallDistanceOnServer)(Actor *this, float, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, int, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, const Block *, bool);
  void (__fastcall *onSynchedDataUpdate)(Actor *this, int);
  bool (__fastcall *canAddRider)(Actor *this, Actor *);
  bool (__fastcall *canPickupItem)(Actor *this, const ItemStack *);
  bool (__fastcall *canBePulledIntoVehicle)(Actor *this);
  bool (__fastcall *inCaravan)(Actor *this);
  bool (__fastcall *isLeashableType)(Actor *this);
  void (__fastcall *tickLeash)(Actor *this);
  void (__fastcall *sendMotionPacketIfNeeded)(Actor *this);
  bool (__fastcall *canSynchronizeNewEntity)(Actor *this);
  bool (__fastcall *stopRiding)(Actor *this, bool, bool, bool, bool);
  void (__fastcall *startSwimming)(Actor *this);
  void (__fastcall *stopSwimming)(Actor *this);
  void (__fastcall *buildDebugInfo)(Actor *this, std::string *);
  CommandPermissionLevel (__fastcall *getCommandPermissionLevel)(Actor *this);
  AttributeInstance *(__fastcall *getMutableAttribute)(Actor *this, const Attribute *);
  const AttributeInstance *(__fastcall *getAttribute)(Actor *this, const Attribute *);
  int (__fastcall *getDeathTime)(Actor *this);
  void (__fastcall *heal)(Actor *this, int);
  bool (__fastcall *isInvertedHealAndHarm)(Actor *this);
  bool (__fastcall *canBeAffected)(Actor *this, const MobEffectInstance *);
  bool (__fastcall *canBeAffected)(Actor *this, int);
  bool (__fastcall *canBeAffectedByArrow)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectAdded)(Actor *this, MobEffectInstance *);
  void (__fastcall *onEffectUpdated)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectRemoved)(Actor *this, MobEffectInstance *);
  AnimationComponent *(__fastcall *getAnimationComponent)(Actor *this);
  void (__fastcall *openContainerComponent)(Actor *this, Player *);
  void (__fastcall *swing)(Actor *this);
  void (__fastcall *useItem)(Actor *this, ItemStackBase *, ItemUseMethod, bool);
  bool (__fastcall *hasOutputSignal)(Actor *this, unsigned __int8);
  int (__fastcall *getOutputSignal)(Actor *this);
  void (__fastcall *getDebugText)(Actor *this, std::vector&lt;std::string&gt; *);
  float (__fastcall *getMapDecorationRotation)(Actor *this);
  float (__fastcall *getRiderYRotation)(Actor *this, const Actor *);
  float (__fastcall *getYHeadRot)(Actor *this);
  bool (__fastcall *isWorldBuilder)(Actor *this);
  bool (__fastcall *isCreative)(Actor *this);
  bool (__fastcall *isAdventure)(Actor *this);
  bool (__fastcall *add)(Actor *this, ItemStack *);
  bool (__fastcall *drop)(Actor *this, const ItemStack *, bool);
  bool (__fastcall *getInteraction)(Actor *this, Player *, ActorInteraction *, const Vec3 *);
  bool (__fastcall *canDestroyBlock)(Actor *this, const Block *);
  void (__fastcall *setAuxValue)(Actor *this, int);
  void (__fastcall *setSize)(Actor *this, float, float);
  int (__fastcall *getLifeSpan)(Actor *this);
  void (__fastcall *onOrphan)(Actor *this);
  void (__fastcall *wobble)(Actor *this);
  bool (__fastcall *wasHurt)(Actor *this);
  void (__fastcall *startSpinAttack)(Actor *this);
  void (__fastcall *stopSpinAttack)(Actor *this);
  void (__fastcall *setDamageNearbyMobs)(Actor *this, bool);
  bool (__fastcall *hasCritBox)(Actor *this);
  bool (__fastcall *isCritHit)(Actor *this);
  void (__fastcall *renderDebugServerState)(Actor *this, const Options *);
  void (__fastcall *reloadLootTable)(Actor *this, const EquipmentTableDefinition *);
  void (__fastcall *reloadLootTable)(Actor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(Actor *this);
  void (__fastcall *kill)(Actor *this);
  void (__fastcall *die)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *shouldTick)(Actor *this);
  std::shared_ptr&lt;IActorMovementProxy&gt; *(__fastcall *createMovementProxy)(Actor *this, std::shared_ptr&lt;IActorMovementProxy&gt; *result);
  void (__fastcall *updateEntitySpecificMolangVariables)(Actor *this, RenderParams *);
  bool (__fastcall *shouldTryMakeStepSound)(Actor *this);
  float (__fastcall *getNextStep)(Actor *this, const float);
  bool (__fastcall *canMakeStepSound)(Actor *this);
  void (__fastcall *outOfWorld)(Actor *this);
  bool (__fastcall *_hurt)(Actor *this, const ActorDamageSource *, int, bool, bool);
  void (__fastcall *markHurt)(Actor *this);
  void (__fastcall *readAdditionalSaveData)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *addAdditionalSaveData)(Actor *this, CompoundTag *);
  void (__fastcall *_playStepSound)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *_playFlySound)(Actor *this, const BlockPos *, const Block *);
  bool (__fastcall *_makeFlySound)(Actor *this);
  void (__fastcall *checkInsideBlocks)(Actor *this, float);
  void (__fastcall *pushOutOfBlocks)(Actor *this, const Vec3 *);
  bool (__fastcall *updateWaterState)(Actor *this);
  void (__fastcall *doWaterSplashEffect)(Actor *this);
  void (__fastcall *spawnTrailBubbles)(Actor *this);
  void (__fastcall *updateInsideBlock)(Actor *this);
  LootTable *(__fastcall *getLootTable)(Actor *this);
  LootTable *(__fastcall *getDefaultLootTable)(Actor *this);
  void (__fastcall *_removeRider)(Actor *this, const ActorUniqueID *, bool, bool, bool);
  void (__fastcall *_onSizeUpdated)(Actor *this);
  void (__fastcall *_doAutoAttackOnTouch)(Actor *this, Actor *);
  void (__fastcall *setDir)(HangingActor *this, int);
  int (__fastcall *getWidth)(HangingActor *this);
  int (__fastcall *getHeight)(HangingActor *this);
  void (__fastcall *dropItem)(HangingActor *this);
  bool (__fastcall *placeHangingEntity)(HangingActor *this, BlockSource *, int);
  bool (__fastcall *wouldSurvive)(HangingActor *this, BlockSource *);
};

</code></pre></div><h3 id="humanoidmodel"><a href="#humanoidmodel" class="header-anchor">#</a> <code>HumanoidModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HumanoidModel : Model
{
  mce::MaterialPtr mArmor;
  mce::MaterialPtr mArmorLeather;
  mce::MaterialPtr mArmorEnchanted;
  mce::MaterialPtr mArmorLeatherEnchanted;
  ModelPart mHead;
  ModelPart mHat;
  ModelPart mBody;
  ModelPart mRightArm;
  ModelPart mLeftArm;
  ModelPart mRightLeg;
  ModelPart mLeftLeg;
  ModelPart mRightItem;
  ModelPart mLeftItem;
  ModelPart mWaist;
  ModelPart mBottom;
  ModelPart mBodyArmorOffset;
  ModelPart mHelmetArmorOffset;
  ModelPart mRightArmArmorOffset;
  ModelPart mLeftArmArmorOffset;
  ModelPart mRightBootArmorOffset;
  ModelPart mLeftBootArmorOffset;
  ModelPart mWaistArmorOffset;
  ModelPart mRightLegArmorOffset;
  ModelPart mLeftLegArmorOffset;
  bool mDamageNearbyMobs;
  bool mSneaking;
  float mSwimAmount;
  float mChargeAmount;
  bool mBowAndArrow;
  bool mCrossbow;
  bool mMainHandShield;
  bool mOffHandShield;
  bool mSpear;
  bool mCharging;
  bool mIsGliding;
  float mGlidingSpeedValue;
  float mUseItemStartupProgress;
  float mUseItemIntervalProgress;
  int mUseItemInvervalAxis;
  float mShieldBlockProgress;
  SkinAdjustments mSkinAdjustments;
  std::array&lt;ModelPart *,13&gt; mBindParts;
  SkinAdjustments mBaseSkinAdjustments;
  float mHoldingHand[2];
};

</code></pre></div><h3 id="humanoidmodel-vtbl"><a href="#humanoidmodel-vtbl" class="header-anchor">#</a> <code>HumanoidModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HumanoidModel_vtbl
{
  void (__fastcall *~AppPlatformListener)(AppPlatformListener *this);
  void (__fastcall *onLowMemory)(AppPlatformListener *this);
  void (__fastcall *onAppPaused)(AppPlatformListener *this);
  void (__fastcall *onAppUnpaused)(AppPlatformListener *this);
  void (__fastcall *onAppPreSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppResumed)(AppPlatformListener *this);
  void (__fastcall *onAppFocusLost)(AppPlatformListener *this);
  void (__fastcall *onAppFocusGained)(AppPlatformListener *this);
  void (__fastcall *onAppTerminated)(AppPlatformListener *this);
  void (__fastcall *onOperationModeChanged)(AppPlatformListener *this, const OperationMode);
  void (__fastcall *onPerformanceModeChanged)(AppPlatformListener *this, const bool);
  void (__fastcall *onPushNotificationReceived)(AppPlatformListener *this, const PushNotificationMessage *);
  void (__fastcall *onResizeBegin)(AppPlatformListener *this);
  void (__fastcall *onResizeEnd)(AppPlatformListener *this);
  void (__fastcall *onDeviceLost)(AppPlatformListener *this);
  void (__fastcall *clear)(Model *this);
  void (__fastcall *preDraw)(Model *this, ScreenContext *);
  void (__fastcall *postDraw)(Model *this, ScreenContext *);
  void (__fastcall *render)(Model *this, BaseActorRenderContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *render)(Model *this, BaseActorRenderContext *);
  void (__fastcall *render)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *render)(Model *this, ScreenContext *);
  void (__fastcall *setupAnim)(Model *this);
  void (__fastcall *setupAnim)(Model *this, float, float, float, float, float, float);
  void (__fastcall *prepareMobModel)(Model *this, Mob *, float, float, float);
  Vec3 *(__fastcall *getLeashOffsetPosition)(Model *this, Vec3 *result, bool);
  void (__fastcall *renderAniModel)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float, MatrixStack::MatrixStackRef *);
  void (__fastcall *renderMod)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *youngTransform)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float, MatrixStack::MatrixStackRef *);
  float (__fastcall *getHeightAdjustment)(Model *this);
  AABB *(__fastcall *buildAABB)(Model *this, AABB *result);
  void (__fastcall *renderAniModel)(HumanoidModel *this, ScreenContext *, int, float, float);
};

</code></pre></div><h3 id="horsemodel"><a href="#horsemodel" class="header-anchor">#</a> <code>HorseModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseModel : Model
{
  mce::MaterialPtr mDefaultMaterial;
  mce::MaterialPtr mLeatherArmorMaterial;
  mce::MaterialPtr mSaddleMaterial;
  mce::MaterialPtr mHairMaterial;
  ModelPart Head;
  ModelPart UMouth;
  ModelPart LMouth;
  ModelPart Ear1;
  ModelPart Ear2;
  ModelPart MuleEarL;
  ModelPart MuleEarR;
  ModelPart Neck;
  ModelPart HeadSaddle;
  ModelPart Mane;
  ModelPart Body;
  ModelPart TailA;
  ModelPart TailB;
  ModelPart TailC;
  ModelPart Leg1A;
  ModelPart Leg1B;
  ModelPart Leg1C;
  ModelPart Leg2A;
  ModelPart Leg2B;
  ModelPart Leg2C;
  ModelPart Leg3A;
  ModelPart Leg3B;
  ModelPart Leg3C;
  ModelPart Leg4A;
  ModelPart Leg4B;
  ModelPart Leg4C;
  ModelPart Bag1;
  ModelPart Bag2;
  ModelPart Saddle;
  ModelPart SaddleB;
  ModelPart SaddleC;
  ModelPart SaddleL;
  ModelPart SaddleL2;
  ModelPart SaddleR;
  ModelPart SaddleR2;
  ModelPart SaddleMouthL;
  ModelPart SaddleMouthR;
  ModelPart SaddleMouthLine;
  ModelPart SaddleMouthLineR;
};

</code></pre></div><h3 id="horsemodel-vtbl"><a href="#horsemodel-vtbl" class="header-anchor">#</a> <code>HorseModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HorseModel_vtbl
{
  void (__fastcall *~AppPlatformListener)(AppPlatformListener *this);
  void (__fastcall *onLowMemory)(AppPlatformListener *this);
  void (__fastcall *onAppPaused)(AppPlatformListener *this);
  void (__fastcall *onAppUnpaused)(AppPlatformListener *this);
  void (__fastcall *onAppPreSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppResumed)(AppPlatformListener *this);
  void (__fastcall *onAppFocusLost)(AppPlatformListener *this);
  void (__fastcall *onAppFocusGained)(AppPlatformListener *this);
  void (__fastcall *onAppTerminated)(AppPlatformListener *this);
  void (__fastcall *onOperationModeChanged)(AppPlatformListener *this, const OperationMode);
  void (__fastcall *onPerformanceModeChanged)(AppPlatformListener *this, const bool);
  void (__fastcall *onPushNotificationReceived)(AppPlatformListener *this, const PushNotificationMessage *);
  void (__fastcall *onResizeBegin)(AppPlatformListener *this);
  void (__fastcall *onResizeEnd)(AppPlatformListener *this);
  void (__fastcall *onDeviceLost)(AppPlatformListener *this);
  void (__fastcall *clear)(Model *this);
  void (__fastcall *preDraw)(Model *this, ScreenContext *);
  void (__fastcall *postDraw)(Model *this, ScreenContext *);
  void (__fastcall *render)(Model *this, BaseActorRenderContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *render)(Model *this, BaseActorRenderContext *);
  void (__fastcall *render)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *render)(Model *this, ScreenContext *);
  void (__fastcall *setupAnim)(Model *this);
  void (__fastcall *setupAnim)(Model *this, float, float, float, float, float, float);
  void (__fastcall *prepareMobModel)(Model *this, Mob *, float, float, float);
  Vec3 *(__fastcall *getLeashOffsetPosition)(Model *this, Vec3 *result, bool);
  void (__fastcall *renderAniModel)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float, MatrixStack::MatrixStackRef *);
  void (__fastcall *renderMod)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *youngTransform)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float, MatrixStack::MatrixStackRef *);
  float (__fastcall *getHeightAdjustment)(Model *this);
  AABB *(__fastcall *buildAABB)(Model *this, AABB *result);
};

</code></pre></div><h3 id="horse"><a href="#horse" class="header-anchor">#</a> <code>Horse</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Horse : Animal
{
  std::string layerTextureHashName;
  std::string layerTextureLayers[3];
  bool mHasReproduced;
  bool mLandedOnGround;
  float mEatAnim;
  float mEatAnimO;
  float mStandAnim;
  float mStandAnimO;
  float mMouthAnim;
  float mMouthAnimO;
  int mCountEating;
  int mMouthCounter;
  int mStandCounter;
  int mSprintCounter;
  int mGallopSoundCounter;
  int mTailCounter;
};

</code></pre></div><h3 id="horsemodelv2"><a href="#horsemodelv2" class="header-anchor">#</a> <code>HorseModelV2</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HorseModelV2 : Model
{
  mce::MaterialPtr mDefaultMaterial;
  mce::MaterialPtr mLeatherArmorMaterial;
  mce::MaterialPtr mSaddleMaterial;
  mce::MaterialPtr mHairMaterial;
  Vec3 mRestFrontLegPos;
  Vec3 mRestBagPos;
  ModelPart mHead;
  ModelPart mUMouth;
  ModelPart mEar1;
  ModelPart mEar2;
  ModelPart mMuleEarL;
  ModelPart mMuleEarR;
  ModelPart mNeck;
  ModelPart mHeadSaddle;
  ModelPart mMane;
  ModelPart mBody;
  ModelPart mTailA;
  ModelPart mLeg1A;
  ModelPart mLeg2A;
  ModelPart mLeg3A;
  ModelPart mLeg4A;
  ModelPart mBag1;
  ModelPart mBag2;
  ModelPart mSaddle;
  ModelPart mSaddleB;
  ModelPart mSaddleC;
  ModelPart mSaddleL;
  ModelPart mSaddleL2;
  ModelPart mSaddleR;
  ModelPart mSaddleR2;
  ModelPart mSaddleMouthL;
  ModelPart mSaddleMouthR;
  ModelPart mSaddleMouthLine;
  ModelPart mSaddleMouthLineR;
  float mBabyLegInitialUpscale;
};

</code></pre></div><h3 id="horsemodelv2-vtbl"><a href="#horsemodelv2-vtbl" class="header-anchor">#</a> <code>HorseModelV2_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HorseModelV2_vtbl
{
  void (__fastcall *~AppPlatformListener)(AppPlatformListener *this);
  void (__fastcall *onLowMemory)(AppPlatformListener *this);
  void (__fastcall *onAppPaused)(AppPlatformListener *this);
  void (__fastcall *onAppUnpaused)(AppPlatformListener *this);
  void (__fastcall *onAppPreSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppResumed)(AppPlatformListener *this);
  void (__fastcall *onAppFocusLost)(AppPlatformListener *this);
  void (__fastcall *onAppFocusGained)(AppPlatformListener *this);
  void (__fastcall *onAppTerminated)(AppPlatformListener *this);
  void (__fastcall *onOperationModeChanged)(AppPlatformListener *this, const OperationMode);
  void (__fastcall *onPerformanceModeChanged)(AppPlatformListener *this, const bool);
  void (__fastcall *onPushNotificationReceived)(AppPlatformListener *this, const PushNotificationMessage *);
  void (__fastcall *onResizeBegin)(AppPlatformListener *this);
  void (__fastcall *onResizeEnd)(AppPlatformListener *this);
  void (__fastcall *onDeviceLost)(AppPlatformListener *this);
  void (__fastcall *clear)(Model *this);
  void (__fastcall *preDraw)(Model *this, ScreenContext *);
  void (__fastcall *postDraw)(Model *this, ScreenContext *);
  void (__fastcall *render)(Model *this, BaseActorRenderContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *render)(Model *this, BaseActorRenderContext *);
  void (__fastcall *render)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *render)(Model *this, ScreenContext *);
  void (__fastcall *setupAnim)(Model *this);
  void (__fastcall *setupAnim)(Model *this, float, float, float, float, float, float);
  void (__fastcall *prepareMobModel)(Model *this, Mob *, float, float, float);
  Vec3 *(__fastcall *getLeashOffsetPosition)(Model *this, Vec3 *result, bool);
  void (__fastcall *renderAniModel)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float, MatrixStack::MatrixStackRef *);
  void (__fastcall *renderMod)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *youngTransform)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float, MatrixStack::MatrixStackRef *);
  float (__fastcall *getHeightAdjustment)(Model *this);
  AABB *(__fastcall *buildAABB)(Model *this, AABB *result);
};

</code></pre></div><h3 id="heartparticle"><a href="#heartparticle" class="header-anchor">#</a> <code>HeartParticle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HeartParticle : Particle
{
  float oSize;
};

</code></pre></div><h3 id="heartparticle-vtbl"><a href="#heartparticle-vtbl" class="header-anchor">#</a> <code>HeartParticle_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HeartParticle_vtbl
{
  void (__fastcall *init)(Particle *this, const Vec3 *, const Vec3 *, int, ParticleEngine *);
  void (__fastcall *addTagData)(Particle *this, const CompoundTag *);
  void (__fastcall *~Particle)(Particle *this);
  void (__fastcall *normalTick)(Particle *this);
  void (__fastcall *tessellate)(Particle *this, const ParticleRenderContext *);
  const mce::TexturePtr *(__fastcall *getParticleTexture)(Particle *this);
  mce::Color *(__fastcall *getParticleLightColor)(Particle *this, mce::Color *result, float, const LightTexture *);
  void (__fastcall *setEmittingEntity)(Particle *this, Actor *);
  bool (__fastcall *_shouldUpdateVertexData)(Particle *this, float);
};

</code></pre></div><h3 id="hugeexplosionparticle"><a href="#hugeexplosionparticle" class="header-anchor">#</a> <code>HugeExplosionParticle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HugeExplosionParticle : Particle
{
  int baseTex;
};

</code></pre></div><h3 id="hugeexplosionparticle-vtbl"><a href="#hugeexplosionparticle-vtbl" class="header-anchor">#</a> <code>HugeExplosionParticle_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HugeExplosionParticle_vtbl
{
  void (__fastcall *init)(Particle *this, const Vec3 *, const Vec3 *, int, ParticleEngine *);
  void (__fastcall *addTagData)(Particle *this, const CompoundTag *);
  void (__fastcall *~Particle)(Particle *this);
  void (__fastcall *normalTick)(Particle *this);
  void (__fastcall *tessellate)(Particle *this, const ParticleRenderContext *);
  const mce::TexturePtr *(__fastcall *getParticleTexture)(Particle *this);
  mce::Color *(__fastcall *getParticleLightColor)(Particle *this, mce::Color *result, float, const LightTexture *);
  void (__fastcall *setEmittingEntity)(Particle *this, Actor *);
  bool (__fastcall *_shouldUpdateVertexData)(Particle *this, float);
};

</code></pre></div><h3 id="hugeexplosionseedparticle"><a href="#hugeexplosionseedparticle" class="header-anchor">#</a> <code>HugeExplosionSeedParticle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HugeExplosionSeedParticle : Particle
{
};

</code></pre></div><h3 id="hugeexplosionseedparticle-vtbl"><a href="#hugeexplosionseedparticle-vtbl" class="header-anchor">#</a> <code>HugeExplosionSeedParticle_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HugeExplosionSeedParticle_vtbl
{
  void (__fastcall *init)(Particle *this, const Vec3 *, const Vec3 *, int, ParticleEngine *);
  void (__fastcall *addTagData)(Particle *this, const CompoundTag *);
  void (__fastcall *~Particle)(Particle *this);
  void (__fastcall *normalTick)(Particle *this);
  void (__fastcall *tessellate)(Particle *this, const ParticleRenderContext *);
  const mce::TexturePtr *(__fastcall *getParticleTexture)(Particle *this);
  mce::Color *(__fastcall *getParticleLightColor)(Particle *this, mce::Color *result, float, const LightTexture *);
  void (__fastcall *setEmittingEntity)(Particle *this, Actor *);
  bool (__fastcall *_shouldUpdateVertexData)(Particle *this, float);
};

</code></pre></div><h3 id="happyvillagerparticle"><a href="#happyvillagerparticle" class="header-anchor">#</a> <code>HappyVillagerParticle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HappyVillagerParticle : SuspendedTownParticle
{
};

</code></pre></div><h3 id="happyvillagerparticle-vtbl"><a href="#happyvillagerparticle-vtbl" class="header-anchor">#</a> <code>HappyVillagerParticle_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HappyVillagerParticle_vtbl
{
  void (__fastcall *init)(Particle *this, const Vec3 *, const Vec3 *, int, ParticleEngine *);
  void (__fastcall *addTagData)(Particle *this, const CompoundTag *);
  void (__fastcall *~Particle)(Particle *this);
  void (__fastcall *normalTick)(Particle *this);
  void (__fastcall *tessellate)(Particle *this, const ParticleRenderContext *);
  const mce::TexturePtr *(__fastcall *getParticleTexture)(Particle *this);
  mce::Color *(__fastcall *getParticleLightColor)(Particle *this, mce::Color *result, float, const LightTexture *);
  void (__fastcall *setEmittingEntity)(Particle *this, Actor *);
  bool (__fastcall *_shouldUpdateVertexData)(Particle *this, float);
};

</code></pre></div><h3 id="huskmodel"><a href="#huskmodel" class="header-anchor">#</a> <code>HuskModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HuskModel : ZombieModel
{
  mce::MaterialPtr mHuskMaterial;
  mce::MaterialPtr mClothesMaterial;
  ModelPart mHat;
  ModelPart mLeftSleeve;
  ModelPart mRightSleeve;
};

</code></pre></div><h3 id="huskmodel-vtbl"><a href="#huskmodel-vtbl" class="header-anchor">#</a> <code>HuskModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HuskModel_vtbl
{
  void (__fastcall *~AppPlatformListener)(AppPlatformListener *this);
  void (__fastcall *onLowMemory)(AppPlatformListener *this);
  void (__fastcall *onAppPaused)(AppPlatformListener *this);
  void (__fastcall *onAppUnpaused)(AppPlatformListener *this);
  void (__fastcall *onAppPreSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppResumed)(AppPlatformListener *this);
  void (__fastcall *onAppFocusLost)(AppPlatformListener *this);
  void (__fastcall *onAppFocusGained)(AppPlatformListener *this);
  void (__fastcall *onAppTerminated)(AppPlatformListener *this);
  void (__fastcall *onOperationModeChanged)(AppPlatformListener *this, const OperationMode);
  void (__fastcall *onPerformanceModeChanged)(AppPlatformListener *this, const bool);
  void (__fastcall *onPushNotificationReceived)(AppPlatformListener *this, const PushNotificationMessage *);
  void (__fastcall *onResizeBegin)(AppPlatformListener *this);
  void (__fastcall *onResizeEnd)(AppPlatformListener *this);
  void (__fastcall *onDeviceLost)(AppPlatformListener *this);
  void (__fastcall *clear)(Model *this);
  void (__fastcall *preDraw)(Model *this, ScreenContext *);
  void (__fastcall *postDraw)(Model *this, ScreenContext *);
  void (__fastcall *render)(Model *this, BaseActorRenderContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *render)(Model *this, BaseActorRenderContext *);
  void (__fastcall *render)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *render)(Model *this, ScreenContext *);
  void (__fastcall *setupAnim)(Model *this);
  void (__fastcall *setupAnim)(Model *this, float, float, float, float, float, float);
  void (__fastcall *prepareMobModel)(Model *this, Mob *, float, float, float);
  Vec3 *(__fastcall *getLeashOffsetPosition)(Model *this, Vec3 *result, bool);
  void (__fastcall *renderAniModel)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float, MatrixStack::MatrixStackRef *);
  void (__fastcall *renderMod)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *youngTransform)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float, MatrixStack::MatrixStackRef *);
  float (__fastcall *getHeightAdjustment)(Model *this);
  AABB *(__fastcall *buildAABB)(Model *this, AABB *result);
  void (__fastcall *renderAniModel)(HumanoidModel *this, ScreenContext *, int, float, float);
};

</code></pre></div><h3 id="humanoidmonster"><a href="#humanoidmonster" class="header-anchor">#</a> <code>HumanoidMonster</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HumanoidMonster : Monster
{
  AttackState mState;
};

</code></pre></div><h3 id="horsearmoritem"><a href="#horsearmoritem" class="header-anchor">#</a> <code>HorseArmorItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HorseArmorItem : Item
{
  const int mDefense;
  const int mModelIndex;
  _BYTE mTier[4];
};

</code></pre></div><h3 id="horserenderer"><a href="#horserenderer" class="header-anchor">#</a> <code>HorseRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseRenderer : MobRenderer
{
  mce::TexturePtr mHorseTypeTextures[5];
  mce::TexturePtr mHorseVariantTextures[7];
  mce::TexturePtr mHorseMarkingTextures[5];
  mce::TexturePtr mHorseArmorTextures[5];
};

</code></pre></div><h3 id="horserenderer-vtbl"><a href="#horserenderer-vtbl" class="header-anchor">#</a> <code>HorseRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HorseRenderer_vtbl
{
  void (__fastcall *~ActorShaderManager)(ActorShaderManager *this);
  mce::Color *(__fastcall *_getOverlayColor)(ActorShaderManager *this, mce::Color *result, Actor *, float);
  void (__fastcall *render)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderDebug)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderEffects)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderTrading)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *, float);
  void (__fastcall *renderFlame)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderLeash)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderWaterHole)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *addAdditionalRenderingIfNeeded)(ActorRenderer *this, mce::TextureGroup *);
  void (__fastcall *renderWeaponEffect)(ActorRenderer *this, BaseActorRenderContext *, Actor *);
  void (__fastcall *renderBindEffects)(ActorRenderer *this, BaseActorRenderContext *, Actor *);
  AABB *(__fastcall *getRenderBounds)(ActorRenderer *this, AABB *result, const Actor *);
  Vec3 *(__fastcall *getLeashOffset)(ActorRenderer *this, Vec3 *result, Actor *, float, float, float, bool, bool);
  void (__fastcall *setIsOnScreen)(ActorRenderer *this, Actor *, const bool, float);
  bool (__fastcall *shouldUpdateBonesAndEffectsIfOffScreen)(ActorRenderer *this, RenderParams *);
  bool (__fastcall *shouldUpdateEffectsIfOffScreen)(ActorRenderer *this, RenderParams *);
  void (__fastcall *_bindModelEffectRender)(ActorRenderer *this, BaseActorRenderContext *, Mob *);
  void (__fastcall *prepareCarriedItem)(MobRenderer *this, Model *, Mob *, const ItemStack *);
  void (__fastcall *setupPosition)(MobRenderer *this, const Actor *, const Vec3 *, Matrix *);
  void (__fastcall *setupRotations)(MobRenderer *this, const Actor *, float, float, Matrix *, float);
  float (__fastcall *getAttackAnim)(MobRenderer *this, Mob *, float);
  float (__fastcall *getBob)(MobRenderer *this, Mob *, float);
  float (__fastcall *getFlipDegrees)(MobRenderer *this, const Mob *);
  void (__fastcall *setupScale)(MobRenderer *this, const Mob *, Matrix *, float);
  void (__fastcall *renderModel)(MobRenderer *this, BaseActorRenderContext *, ActorRenderData *, Model *, const gsl::span&lt;mce::ClientTexture const *,-1&gt;, const unsigned __int64);
  void (__fastcall *additionalRendering)(MobRenderer *this, BaseActorRenderContext *, Model *, Mob *, float, float, float, float, float, float);
  void (__fastcall *renderLayers)(MobRenderer *this, BaseActorRenderContext *, Actor *, float, float, float, float, float);
  void (__fastcall *drawLayers)(MobRenderer *this, ScreenContext *);
  float (__fastcall *getSneakingHeightOffset)(MobRenderer *this);
  float (__fastcall *getSwimmingHeightOffset)(MobRenderer *this);
  MobRenderer::ArmorPrepareResult *(__fastcall *prepareArmor)(MobRenderer *this, MobRenderer::ArmorPrepareResult *result, ScreenContext *, BaseActorRenderContext *, Mob *, ArmorSlot, Model *, float);
};

</code></pre></div><h3 id="horserendererv2"><a href="#horserendererv2" class="header-anchor">#</a> <code>HorseRendererV2</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseRendererV2 : MobRenderer
{
  mce::TexturePtr mHorseTypeTextures[5];
  mce::TexturePtr mHorseVariantTextures[7];
  mce::TexturePtr mHorseMarkingTextures[5];
  mce::TexturePtr mHorseArmorTextures[5];
};

</code></pre></div><h3 id="horserendererv2-vtbl"><a href="#horserendererv2-vtbl" class="header-anchor">#</a> <code>HorseRendererV2_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HorseRendererV2_vtbl
{
  void (__fastcall *~ActorShaderManager)(ActorShaderManager *this);
  mce::Color *(__fastcall *_getOverlayColor)(ActorShaderManager *this, mce::Color *result, Actor *, float);
  void (__fastcall *render)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderDebug)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderEffects)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderTrading)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *, float);
  void (__fastcall *renderFlame)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderLeash)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderWaterHole)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *addAdditionalRenderingIfNeeded)(ActorRenderer *this, mce::TextureGroup *);
  void (__fastcall *renderWeaponEffect)(ActorRenderer *this, BaseActorRenderContext *, Actor *);
  void (__fastcall *renderBindEffects)(ActorRenderer *this, BaseActorRenderContext *, Actor *);
  AABB *(__fastcall *getRenderBounds)(ActorRenderer *this, AABB *result, const Actor *);
  Vec3 *(__fastcall *getLeashOffset)(ActorRenderer *this, Vec3 *result, Actor *, float, float, float, bool, bool);
  void (__fastcall *setIsOnScreen)(ActorRenderer *this, Actor *, const bool, float);
  bool (__fastcall *shouldUpdateBonesAndEffectsIfOffScreen)(ActorRenderer *this, RenderParams *);
  bool (__fastcall *shouldUpdateEffectsIfOffScreen)(ActorRenderer *this, RenderParams *);
  void (__fastcall *_bindModelEffectRender)(ActorRenderer *this, BaseActorRenderContext *, Mob *);
  void (__fastcall *prepareCarriedItem)(MobRenderer *this, Model *, Mob *, const ItemStack *);
  void (__fastcall *setupPosition)(MobRenderer *this, const Actor *, const Vec3 *, Matrix *);
  void (__fastcall *setupRotations)(MobRenderer *this, const Actor *, float, float, Matrix *, float);
  float (__fastcall *getAttackAnim)(MobRenderer *this, Mob *, float);
  float (__fastcall *getBob)(MobRenderer *this, Mob *, float);
  float (__fastcall *getFlipDegrees)(MobRenderer *this, const Mob *);
  void (__fastcall *setupScale)(MobRenderer *this, const Mob *, Matrix *, float);
  void (__fastcall *renderModel)(MobRenderer *this, BaseActorRenderContext *, ActorRenderData *, Model *, const gsl::span&lt;mce::ClientTexture const *,-1&gt;, const unsigned __int64);
  void (__fastcall *additionalRendering)(MobRenderer *this, BaseActorRenderContext *, Model *, Mob *, float, float, float, float, float, float);
  void (__fastcall *renderLayers)(MobRenderer *this, BaseActorRenderContext *, Actor *, float, float, float, float, float);
  void (__fastcall *drawLayers)(MobRenderer *this, ScreenContext *);
  float (__fastcall *getSneakingHeightOffset)(MobRenderer *this);
  float (__fastcall *getSwimmingHeightOffset)(MobRenderer *this);
  MobRenderer::ArmorPrepareResult *(__fastcall *prepareArmor)(MobRenderer *this, MobRenderer::ArmorPrepareResult *result, ScreenContext *, BaseActorRenderContext *, Mob *, ArmorSlot, Model *, float);
};

</code></pre></div><h3 id="humanoidmobrenderer"><a href="#humanoidmobrenderer" class="header-anchor">#</a> <code>HumanoidMobRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HumanoidMobRenderer : MobRenderer
{
  std::unique_ptr&lt;HumanoidModel&gt; mBabyModel;
  std::unique_ptr&lt;HumanoidModel&gt; mArmorParts1;
  std::unique_ptr&lt;HumanoidModel&gt; mArmorParts2;
  std::unique_ptr&lt;SpinAttackModel&gt; mSpinAttackModel;
  std::vector&lt;mce::TexturePtr&gt; mArmorTextures;
  mce::TexturePtr mSpinAttackTex;
  std::unique_ptr&lt;HumanoidModel&gt; mOriginalArmorModel;
  bool lastCustomArmorHead;
  bool lastCustomArmorBody;
  bool lastCustomArmorLeg;
  bool lastCustomArmorFeet;
};

</code></pre></div><h3 id="humanoidmobrenderer-vtbl"><a href="#humanoidmobrenderer-vtbl" class="header-anchor">#</a> <code>HumanoidMobRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HumanoidMobRenderer_vtbl
{
  void (__fastcall *~ActorShaderManager)(ActorShaderManager *this);
  mce::Color *(__fastcall *_getOverlayColor)(ActorShaderManager *this, mce::Color *result, Actor *, float);
  void (__fastcall *render)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderDebug)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderEffects)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderTrading)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *, float);
  void (__fastcall *renderFlame)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderLeash)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderWaterHole)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *addAdditionalRenderingIfNeeded)(ActorRenderer *this, mce::TextureGroup *);
  void (__fastcall *renderWeaponEffect)(ActorRenderer *this, BaseActorRenderContext *, Actor *);
  void (__fastcall *renderBindEffects)(ActorRenderer *this, BaseActorRenderContext *, Actor *);
  AABB *(__fastcall *getRenderBounds)(ActorRenderer *this, AABB *result, const Actor *);
  Vec3 *(__fastcall *getLeashOffset)(ActorRenderer *this, Vec3 *result, Actor *, float, float, float, bool, bool);
  void (__fastcall *setIsOnScreen)(ActorRenderer *this, Actor *, const bool, float);
  bool (__fastcall *shouldUpdateBonesAndEffectsIfOffScreen)(ActorRenderer *this, RenderParams *);
  bool (__fastcall *shouldUpdateEffectsIfOffScreen)(ActorRenderer *this, RenderParams *);
  void (__fastcall *_bindModelEffectRender)(ActorRenderer *this, BaseActorRenderContext *, Mob *);
  void (__fastcall *prepareCarriedItem)(MobRenderer *this, Model *, Mob *, const ItemStack *);
  void (__fastcall *setupPosition)(MobRenderer *this, const Actor *, const Vec3 *, Matrix *);
  void (__fastcall *setupRotations)(MobRenderer *this, const Actor *, float, float, Matrix *, float);
  float (__fastcall *getAttackAnim)(MobRenderer *this, Mob *, float);
  float (__fastcall *getBob)(MobRenderer *this, Mob *, float);
  float (__fastcall *getFlipDegrees)(MobRenderer *this, const Mob *);
  void (__fastcall *setupScale)(MobRenderer *this, const Mob *, Matrix *, float);
  void (__fastcall *renderModel)(MobRenderer *this, BaseActorRenderContext *, ActorRenderData *, Model *, const gsl::span&lt;mce::ClientTexture const *,-1&gt;, const unsigned __int64);
  void (__fastcall *additionalRendering)(MobRenderer *this, BaseActorRenderContext *, Model *, Mob *, float, float, float, float, float, float);
  void (__fastcall *renderLayers)(MobRenderer *this, BaseActorRenderContext *, Actor *, float, float, float, float, float);
  void (__fastcall *drawLayers)(MobRenderer *this, ScreenContext *);
  float (__fastcall *getSneakingHeightOffset)(MobRenderer *this);
  float (__fastcall *getSwimmingHeightOffset)(MobRenderer *this);
  MobRenderer::ArmorPrepareResult *(__fastcall *prepareArmor)(MobRenderer *this, MobRenderer::ArmorPrepareResult *result, ScreenContext *, BaseActorRenderContext *, Mob *, ArmorSlot, Model *, float);
  void (__fastcall *prepareCarriedOffhandItem)(HumanoidMobRenderer *this, Model *, Mob *, const ItemStack *);
  void (__fastcall *_bindModelRender)(HumanoidMobRenderer *this, BaseActorRenderContext *, HumanoidModel *, Mob *, float, float);
};

</code></pre></div><h3 id="heavyblock"><a href="#heavyblock" class="header-anchor">#</a> <code>HeavyBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HeavyBlock : BlockLegacy
{
};

</code></pre></div><h3 id="heavyblock-vtbl"><a href="#heavyblock-vtbl" class="header-anchor">#</a> <code>HeavyBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HeavyBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  mce::Color *(__fastcall *getDustColor)(HeavyBlock *this, mce::Color *result, const Block *);
  std::string *(__fastcall *getDustParticleName)(HeavyBlock *this, std::string *result, const Block *);
  bool (__fastcall *falling)(HeavyBlock *this);
  void (__fastcall *onLand)(HeavyBlock *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isFreeToFall)(HeavyBlock *this, BlockSource *, const BlockPos *);
  void (__fastcall *startFalling)(HeavyBlock *this, BlockSource *, const BlockPos *, const Block *, bool);
};

</code></pre></div><h3 id="hurtownersubcomponent"><a href="#hurtownersubcomponent" class="header-anchor">#</a> <code>HurtOwnerSubcomponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) HurtOwnerSubcomponent : OnHitSubcomponent
{
  float mOwnerDamage;
  bool mKnockback;
  bool mIgnite;
};

</code></pre></div><h3 id="hurtownersubcomponent-vtbl"><a href="#hurtownersubcomponent-vtbl" class="header-anchor">#</a> <code>HurtOwnerSubcomponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HurtOwnerSubcomponent_vtbl
{
  void (__fastcall *~OnHitSubcomponent)(OnHitSubcomponent *this);
  void (__fastcall *readfromJSON)(OnHitSubcomponent *this, Json::Value *);
  void (__fastcall *writetoJSON)(OnHitSubcomponent *this, Json::Value *);
  void (__fastcall *doOnHitEffect)(OnHitSubcomponent *this, Actor *, ProjectileComponent *);
  const char *(__fastcall *getName)(OnHitSubcomponent *this);
};

</code></pre></div><h3 id="hydrateitemrequest-cachemetadata"><a href="#hydrateitemrequest-cachemetadata" class="header-anchor">#</a> <code>HydrateItemRequest::CacheMetadata</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HydrateItemRequest::CacheMetadata
{
  std::string mLastModifiedDate;
  std::string mCacheWriteDate;
  std::string mEntityTag;
};

</code></pre></div><h3 id="hydrateitemrequest"><a href="#hydrateitemrequest" class="header-anchor">#</a> <code>HydrateItemRequest</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HydrateItemRequest : CachedRequest
{
  std::shared_ptr&lt;CatalogBackend&gt; mBackend;
  const std::string mAcceptLanguage;
  HydrateParams mParams;
  std::unique_ptr&lt;HydrateResponseCallbackHandler&gt; mHydrateResponse;
  HydrateItemRequest::CacheMetadata mCacheMetadata;
};

</code></pre></div><h3 id="hydrateitemrequest-vtbl"><a href="#hydrateitemrequest-vtbl" class="header-anchor">#</a> <code>HydrateItemRequest_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HydrateItemRequest_vtbl
{
  void (__fastcall *~RequestHandler)(RequestHandler *this);
  void (__fastcall *send)(RequestHandler *this);
  void (__fastcall *sendCachedRequest)(RequestHandler *this);
  bool (__fastcall *update)(RequestHandler *this);
  bool (__fastcall *isDone)(RequestHandler *this);
  void (__fastcall *onComplete)(RequestHandler *this);
  bool (__fastcall *canSendRequest)(RequestHandler *this);
  void (__fastcall *fireTelemetry)(RequestHandler *this, IMinecraftEventing *);
};

</code></pre></div><h3 id="hidcontroller"><a href="#hidcontroller" class="header-anchor">#</a> <code>HIDController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HIDController : Bedrock::Input::KeyboardEventProcessor
{
  std::unique_ptr&lt;Bedrock::SignalReceiver&gt; mSignalRcvr;
  TextEditContext mEditContext;
  bool mTextboxIsFocused;
  bool mTextboxIsSelected;
  bool mIsMultiline;
};

</code></pre></div><h3 id="hidcontroller-vtbl"><a href="#hidcontroller-vtbl" class="header-anchor">#</a> <code>HIDController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HIDController_vtbl
{
  void (__fastcall *~KeyboardEventProcessor)(Bedrock::Input::KeyboardEventProcessor *this);
  void (__fastcall *onKeyDown)(Bedrock::Input::KeyboardEventProcessor *this, int);
  void (__fastcall *onKeyUp)(Bedrock::Input::KeyboardEventProcessor *this, int);
  void (__fastcall *setIMEEnabled)(HIDController *this, bool);
};

</code></pre></div><h3 id="hidcontrollerwin32"><a href="#hidcontrollerwin32" class="header-anchor">#</a> <code>HIDControllerWin32</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HIDControllerWin32 : HIDController
{
  HWND__ *mHWnd;
};

</code></pre></div><h3 id="hidcontrollerwin32-vtbl"><a href="#hidcontrollerwin32-vtbl" class="header-anchor">#</a> <code>HIDControllerWin32_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HIDControllerWin32_vtbl
{
  void (__fastcall *~KeyboardEventProcessor)(Bedrock::Input::KeyboardEventProcessor *this);
  void (__fastcall *onKeyDown)(Bedrock::Input::KeyboardEventProcessor *this, int);
  void (__fastcall *onKeyUp)(Bedrock::Input::KeyboardEventProcessor *this, int);
  void (__fastcall *setIMEEnabled)(HIDController *this, bool);
};

</code></pre></div><h3 id="hitresultcontainer-localplayercontainer"><a href="#hitresultcontainer-localplayercontainer" class="header-anchor">#</a> <code>HitResultContainer::LocalPlayerContainer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HitResultContainer::LocalPlayerContainer : IHitResultContainer
{
  std::vector&lt;std::pair&lt;HitResult,HitResult&gt;&gt; mHits;
};

</code></pre></div><h3 id="hitresultcontainer-localplayercontainer-vtbl"><a href="#hitresultcontainer-localplayercontainer-vtbl" class="header-anchor">#</a> <code>HitResultContainer::LocalPlayerContainer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HitResultContainer::LocalPlayerContainer_vtbl
{
  void (__fastcall *~IHitResultContainer)(IHitResultContainer *this);
  void (__fastcall *addHitResult)(IHitResultContainer *this, HitResult, HitResult);
  void (__fastcall *clear)(IHitResultContainer *this);
  gsl::span&lt;std::pair&lt;HitResult,HitResult&gt; const ,-1&gt; *(__fastcall *getHits)(IHitResultContainer *this, gsl::span&lt;std::pair&lt;HitResult,HitResult&gt; const ,-1&gt; *result);
};

</code></pre></div><h3 id="homesystem"><a href="#homesystem" class="header-anchor">#</a> <code>HomeSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HomeSystem : ITickingSystem
{
};

</code></pre></div><h3 id="homesystem-vtbl"><a href="#homesystem-vtbl" class="header-anchor">#</a> <code>HomeSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HomeSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="httprequestcancelsourceabort"><a href="#httprequestcancelsourceabort" class="header-anchor">#</a> <code>HTTPRequestCancelSourceAbort</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HTTPRequestCancelSourceAbort : HTTPRequestCancelSource
{
  std::mutex mRequestsMutex;
  std::vector&lt;gsl::not_null&lt;HTTPRequest *&gt;&gt; mRequests;
};

</code></pre></div><h3 id="httprequestcancelsourceabort-vtbl"><a href="#httprequestcancelsourceabort-vtbl" class="header-anchor">#</a> <code>HTTPRequestCancelSourceAbort_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HTTPRequestCancelSourceAbort_vtbl
{
  void (__fastcall *~HTTPRequestCancelSource)(HTTPRequestCancelSource *this);
  void (__fastcall *cancel)(HTTPRequestCancelSource *this);
};

</code></pre></div><h3 id="healablecomponent"><a href="#healablecomponent" class="header-anchor">#</a> <code>HealableComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HealableComponent : IEntityComponent
{
};

</code></pre></div><h3 id="hidecomponent"><a href="#hidecomponent" class="header-anchor">#</a> <code>HideComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HideComponent
{
  bool mIsInRaid;
  bool mReactToBell;
};

</code></pre></div><h3 id="hitboxdefinition"><a href="#hitboxdefinition" class="header-anchor">#</a> <code>HitboxDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HitboxDefinition
{
  std::vector&lt;Hitbox&gt; mHitboxes;
};

</code></pre></div><h3 id="hitboxjson"><a href="#hitboxjson" class="header-anchor">#</a> <code>HitboxJson</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HitboxJson
{
  Vec3 mPivot;
  float mWidth;
  float mHeight;
};

</code></pre></div><h3 id="homedefinition"><a href="#homedefinition" class="header-anchor">#</a> <code>HomeDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HomeDefinition
{
  int mRestrictionRadius;
  std::vector&lt;std::string&gt; mHomeBlockNames;
};

</code></pre></div><h3 id="hopperdefinition"><a href="#hopperdefinition" class="header-anchor">#</a> <code>HopperDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HopperDefinition
{
};

</code></pre></div><h3 id="hopper"><a href="#hopper" class="header-anchor">#</a> <code>Hopper</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Hopper
{
  int mCooldownTime;
  bool mTransferedFromChestMinecart;
  bool mIsEntity;
  bool mCanHopperIn;
  bool mCanHopperOut;
  bool mCanTriggerPullInEvent;
  bool mCanTriggerPullOutEvent;
  int mMoveItemSpeed;
};

</code></pre></div><h3 id="hoppercomponent"><a href="#hoppercomponent" class="header-anchor">#</a> <code>HopperComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HopperComponent : Hopper
{
  BlockPos mLastPosition;
};

</code></pre></div><h3 id="hurtonconditiondefinition"><a href="#hurtonconditiondefinition" class="header-anchor">#</a> <code>HurtOnConditionDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HurtOnConditionDefinition
{
  std::vector&lt;DamageCondition&gt; mDamageConditions;
};

</code></pre></div><h3 id="homedefinition-buildschema-l2-lambda-2ca5030ea1b6b39672c73b4b66f2fe15"><a href="#homedefinition-buildschema-l2-lambda-2ca5030ea1b6b39672c73b4b66f2fe15" class="header-anchor">#</a> <code>HomeDefinition::buildSchema::__l2::&lt;lambda_2ca5030ea1b6b39672c73b4b66f2fe15&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HomeDefinition::buildSchema::__l2::&lt;lambda_2ca5030ea1b6b39672c73b4b66f2fe15&gt;
{
};

</code></pre></div><h3 id="healablecomponent-getinteraction-l20-lambda-2e4b6d19d8e2cc25bfd90a4348859777"><a href="#healablecomponent-getinteraction-l20-lambda-2e4b6d19d8e2cc25bfd90a4348859777" class="header-anchor">#</a> <code>HealableComponent::getInteraction::__l20::&lt;lambda_2e4b6d19d8e2cc25bfd90a4348859777&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HealableComponent::getInteraction::__l20::&lt;lambda_2e4b6d19d8e2cc25bfd90a4348859777&gt;
{
  Player *player;
  Actor *owner;
  std::_Vector_const_iterator&lt;std::_Vector_val&lt;std::_Simple_types&lt;FeedItem&gt; &gt; &gt; healableItemIter;
  HealableComponent *const __this;
};

</code></pre></div><h3 id="hopmovecontrol"><a href="#hopmovecontrol" class="header-anchor">#</a> <code>HopMoveControl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HopMoveControl : MoveControl
{
  int mJumpDelayTicks;
};

</code></pre></div><h3 id="hopmovecontrol-vtbl"><a href="#hopmovecontrol-vtbl" class="header-anchor">#</a> <code>HopMoveControl_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HopMoveControl_vtbl
{
  void (__fastcall *~Control)(Control *this);
  void (__fastcall *initializeInternal)(MoveControl *this, Mob *, MoveControlDescription *);
  void (__fastcall *tick)(MoveControl *this, MoveControlComponent *, Mob *);
  void (__fastcall *setWantedPosition)(MoveControl *this, MoveControlComponent *, Mob *, const Vec3 *, float);
};

</code></pre></div><h3 id="hovermovecontrol"><a href="#hovermovecontrol" class="header-anchor">#</a> <code>HoverMoveControl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HoverMoveControl : MoveControl
{
};

</code></pre></div><h3 id="hovermovecontrol-vtbl"><a href="#hovermovecontrol-vtbl" class="header-anchor">#</a> <code>HoverMoveControl_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HoverMoveControl_vtbl
{
  void (__fastcall *~Control)(Control *this);
  void (__fastcall *initializeInternal)(MoveControl *this, Mob *, MoveControlDescription *);
  void (__fastcall *tick)(MoveControl *this, MoveControlComponent *, Mob *);
  void (__fastcall *setWantedPosition)(MoveControl *this, MoveControlComponent *, Mob *, const Vec3 *, float);
};

</code></pre></div><h3 id="hoverpathnavigation"><a href="#hoverpathnavigation" class="header-anchor">#</a> <code>HoverPathNavigation</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HoverPathNavigation : PathNavigation
{
  bool mCanPathFromAir;
};

</code></pre></div><h3 id="hoverpathnavigation-vtbl"><a href="#hoverpathnavigation-vtbl" class="header-anchor">#</a> <code>HoverPathNavigation_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HoverPathNavigation_vtbl
{
  void (__fastcall *~PathNavigation)(PathNavigation *this);
  void (__fastcall *initializeInternal)(PathNavigation *this, Mob *, NavigationDescription *);
  void (__fastcall *tick)(PathNavigation *this, NavigationComponent *, Mob *);
  Vec3 *(__fastcall *getTempMobPos)(PathNavigation *this, Vec3 *result, const Mob *);
  std::unique_ptr&lt;Path&gt; *(__fastcall *createPath)(PathNavigation *this, std::unique_ptr&lt;Path&gt; *result, NavigationComponent *, Mob *, Actor *);
  std::unique_ptr&lt;Path&gt; *(__fastcall *createPath)(PathNavigation *this, std::unique_ptr&lt;Path&gt; *result, NavigationComponent *, Mob *, const Vec3 *);
  bool (__fastcall *moveTo)(PathNavigation *this, NavigationComponent *, Mob *, std::unique_ptr&lt;Path&gt;, float);
  bool (__fastcall *moveTo)(PathNavigation *this, NavigationComponent *, Mob *, Actor *, float);
  bool (__fastcall *moveTo)(PathNavigation *this, NavigationComponent *, Mob *, const Vec3 *, float);
  void (__fastcall *stop)(PathNavigation *this, NavigationComponent *, Mob *);
  bool (__fastcall *travel)(PathNavigation *this, NavigationComponent *, Mob *, float *, float *, float *);
  bool (__fastcall *canUpdatePath)(PathNavigation *this, const Mob *);
  void (__fastcall *updatePath)(PathNavigation *this, NavigationComponent *, Mob *);
};

</code></pre></div><h3 id="hurtonconditioncomponent"><a href="#hurtonconditioncomponent" class="header-anchor">#</a> <code>HurtOnConditionComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HurtOnConditionComponent : IEntityComponent
{
};

</code></pre></div><h3 id="hurtonconditionsystem"><a href="#hurtonconditionsystem" class="header-anchor">#</a> <code>HurtOnConditionSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HurtOnConditionSystem : ITickingSystem
{
};

</code></pre></div><h3 id="hurtonconditionsystem-vtbl"><a href="#hurtonconditionsystem-vtbl" class="header-anchor">#</a> <code>HurtOnConditionSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HurtOnConditionSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="hurtbytargetgoal"><a href="#hurtbytargetgoal" class="header-anchor">#</a> <code>HurtByTargetGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HurtByTargetGoal : TargetGoal
{
};

</code></pre></div><h3 id="hurtbytargetgoal-vtbl"><a href="#hurtbytargetgoal-vtbl" class="header-anchor">#</a> <code>HurtByTargetGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HurtByTargetGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
  bool (__fastcall *_canAttack)(TargetGoal *this, Mob *, Actor *, bool, bool, const MobDescriptor **);
  void (__fastcall *alertOther)(HurtByTargetGoal *this, Mob *, Mob *);
};

</code></pre></div><h3 id="haveitemdefinition"><a href="#haveitemdefinition" class="header-anchor">#</a> <code>HaveItemDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HaveItemDefinition : BehaviorDefinition
{
  std::string mItemName;
  int mItemCount;
  std::string mItemNameId;
  std::string mItemCountId;
};

</code></pre></div><h3 id="haveitemdefinition-vtbl"><a href="#haveitemdefinition-vtbl" class="header-anchor">#</a> <code>HaveItemDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HaveItemDefinition_vtbl
{
  void (__fastcall *~BehaviorDefinition)(BehaviorDefinition *this);
  void (__fastcall *load)(BehaviorDefinition *this, Json::Value, const BehaviorFactory *);
  std::unique_ptr&lt;BehaviorNode&gt; *(__fastcall *createNode)(BehaviorDefinition *this, std::unique_ptr&lt;BehaviorNode&gt; *result, Actor *, const BehaviorFactory *, BehaviorNode *, BehaviorData *);
};

</code></pre></div><h3 id="haveitemnode"><a href="#haveitemnode" class="header-anchor">#</a> <code>HaveItemNode</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HaveItemNode : BehaviorNode
{
  std::string mItemName;
  int mItemCount;
};

</code></pre></div><h3 id="haveitemnode-vtbl"><a href="#haveitemnode-vtbl" class="header-anchor">#</a> <code>HaveItemNode_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HaveItemNode_vtbl
{
  void (__fastcall *~BehaviorNode)(BehaviorNode *this);
  BehaviorStatus (__fastcall *tick)(BehaviorNode *this, Actor *);
  void (__fastcall *initializeFromDefinition)(BehaviorNode *this, Actor *);
};

</code></pre></div><h3 id="hopperblockactor"><a href="#hopperblockactor" class="header-anchor">#</a> <code>HopperBlockActor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HopperBlockActor : BlockActor, Container, Hopper
{
  ItemStack mItems[5];
  Tick mLastTick;
};

</code></pre></div><h3 id="hopperblockactor-vtbl"><a href="#hopperblockactor-vtbl" class="header-anchor">#</a> <code>HopperBlockActor_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HopperBlockActor_vtbl
{
  void (__fastcall *~BlockActor)(BlockActor *this);
  void (__fastcall *load)(BlockActor *this, Level *, const CompoundTag *, DataLoadHelper *);
  bool (__fastcall *save)(BlockActor *this, CompoundTag *);
  bool (__fastcall *saveItemInstanceData)(BlockActor *this, CompoundTag *);
  void (__fastcall *saveBlockData)(BlockActor *this, CompoundTag *, BlockSource *);
  void (__fastcall *loadBlockData)(BlockActor *this, const CompoundTag *, BlockSource *, DataLoadHelper *);
  void (__fastcall *onCustomTagLoadDone)(BlockActor *this, BlockSource *);
  void (__fastcall *tick)(BlockActor *this, BlockSource *);
  bool (__fastcall *isFinished)(BlockActor *this);
  void (__fastcall *onChanged)(BlockActor *this, BlockSource *);
  bool (__fastcall *isMovable)(BlockActor *this, BlockSource *);
  bool (__fastcall *isCustomNameSaved)(BlockActor *this);
  bool (__fastcall *onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *, const Player *);
  void (__fastcall *onPlace)(BlockActor *this, BlockSource *);
  void (__fastcall *onMove)(BlockActor *this);
  void (__fastcall *onRemoved)(BlockActor *this, BlockSource *);
  void (__fastcall *triggerEvent)(BlockActor *this, int, int);
  void (__fastcall *clearCache)(BlockActor *this);
  void (__fastcall *onNeighborChanged)(BlockActor *this, BlockSource *, const BlockPos *);
  float (__fastcall *getShadowRadius)(BlockActor *this, BlockSource *);
  bool (__fastcall *hasAlphaLayer)(BlockActor *this);
  BlockActor *(__fastcall *getCrackEntity)(BlockActor *this, BlockSource *, const BlockPos *);
  void (__fastcall *getDebugText)(BlockActor *this, std::vector&lt;std::string&gt; *, const BlockPos *);
  const std::string *(__fastcall *getCustomName)(BlockActor *this);
  const std::string *(__fastcall *getFilteredCustomName)(BlockActor *this, const UIProfanityContext *);
  std::string *(__fastcall *getName)(BlockActor *this, std::string *result);
  void (__fastcall *setCustomName)(BlockActor *this, const std::string *);
  std::string *(__fastcall *getImmersiveReaderText)(BlockActor *this, std::string *result, BlockSource *);
  int (__fastcall *getRepairCost)(BlockActor *this);
  PistonBlockActor *(__fastcall *getOwningPiston)(BlockActor *this, BlockSource *);
  const Container *(__fastcall *getContainer)(BlockActor *this);
  Container *(__fastcall *getContainer)(BlockActor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(BlockActor *this);
  void (__fastcall *checkWordsOnChunkLoad)(BlockActor *this, LevelChunk *);
  void (__fastcall *checkWordsOnUpdate)(BlockActor *this, Player *);
  void (__fastcall *onChunkLoaded)(BlockActor *this, LevelChunk *);
  void (__fastcall *onChunkUnloaded)(BlockActor *this, LevelChunk *);
  std::unique_ptr&lt;BlockActorDataPacket&gt; *(__fastcall *_getUpdatePacket)(BlockActor *this, std::unique_ptr&lt;BlockActorDataPacket&gt; *result, BlockSource *);
  void (__fastcall *_onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *);
  bool (__fastcall *_playerCanUpdate)(BlockActor *this, const Player *);
};

</code></pre></div><h3 id="hopper-pushoutitems-l11-lambda-8021f23895e628ed9b3c2f2406f50b3b"><a href="#hopper-pushoutitems-l11-lambda-8021f23895e628ed9b3c2f2406f50b3b" class="header-anchor">#</a> <code>Hopper::_pushOutItems::__l11::&lt;lambda_8021f23895e628ed9b3c2f2406f50b3b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Hopper::_pushOutItems::__l11::&lt;lambda_8021f23895e628ed9b3c2f2406f50b3b&gt;
{
  const Vec3 *position;
  BlockActor **attachedBlockEntity;
  bool *canHopperOut;
  BlockSource *region;
};

</code></pre></div><h3 id="hopper-trypullinitemsfromabovecontainer-l14-lambda-cfa17afae7045b99dd77cd1780d5e42b"><a href="#hopper-trypullinitemsfromabovecontainer-l14-lambda-cfa17afae7045b99dd77cd1780d5e42b" class="header-anchor">#</a> <code>Hopper::_tryPullInItemsFromAboveContainer::__l14::&lt;lambda_cfa17afae7045b99dd77cd1780d5e42b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Hopper::_tryPullInItemsFromAboveContainer::__l14::&lt;lambda_cfa17afae7045b99dd77cd1780d5e42b&gt;
{
  const Vec3 *pos;
  BlockActor **aboveBlockEntity;
  bool *canHopperIn;
  BlockSource *region;
};

</code></pre></div><h3 id="healthattributedelegate"><a href="#healthattributedelegate" class="header-anchor">#</a> <code>HealthAttributeDelegate</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HealthAttributeDelegate : AttributeInstanceDelegate
{
  int mTickCounter;
  Mob *mMob;
};

</code></pre></div><h3 id="healthattributedelegate-vtbl"><a href="#healthattributedelegate-vtbl" class="header-anchor">#</a> <code>HealthAttributeDelegate_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HealthAttributeDelegate_vtbl
{
  void (__fastcall *~AttributeInstanceDelegate)(AttributeInstanceDelegate *this);
  void (__fastcall *tick)(AttributeInstanceDelegate *this);
  void (__fastcall *notify)(AttributeInstanceDelegate *this, __int64);
  bool (__fastcall *change)(AttributeInstanceDelegate *this, float, float, AttributeBuffInfo);
  float (__fastcall *getBuffValue)(AttributeInstanceDelegate *this, const AttributeBuff *);
};

</code></pre></div><h3 id="hungerattributedelegate"><a href="#hungerattributedelegate" class="header-anchor">#</a> <code>HungerAttributeDelegate</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HungerAttributeDelegate : AttributeInstanceDelegate
{
  int mActionTickTimer;
  int mTickCounter;
  float mLastFoodLevel;
  Player *mPlayer;
};

</code></pre></div><h3 id="hungerattributedelegate-vtbl"><a href="#hungerattributedelegate-vtbl" class="header-anchor">#</a> <code>HungerAttributeDelegate_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HungerAttributeDelegate_vtbl
{
  void (__fastcall *~AttributeInstanceDelegate)(AttributeInstanceDelegate *this);
  void (__fastcall *tick)(AttributeInstanceDelegate *this);
  void (__fastcall *notify)(AttributeInstanceDelegate *this, __int64);
  bool (__fastcall *change)(AttributeInstanceDelegate *this, float, float, AttributeBuffInfo);
  float (__fastcall *getBuffValue)(AttributeInstanceDelegate *this, const AttributeBuff *);
};

</code></pre></div><h3 id="horseequipvalidationstate"><a href="#horseequipvalidationstate" class="header-anchor">#</a> <code>HorseEquipValidationState</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseEquipValidationState
{
  std::vector&lt;ItemDescriptor&gt; armorAllowedItems;
  std::vector&lt;ItemDescriptor&gt; saddleAllowedItems;
};

</code></pre></div><h3 id="hudcontainermodel"><a href="#hudcontainermodel" class="header-anchor">#</a> <code>HudContainerModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudContainerModel : ContainerModel
{
  Player *mPlayer;
};

</code></pre></div><h3 id="hudcontainermodel-vtbl"><a href="#hudcontainermodel-vtbl" class="header-anchor">#</a> <code>HudContainerModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HudContainerModel_vtbl
{
  void (__fastcall *containerContentChanged)(ContainerContentChangeListener *this, int);
  void (__fastcall *~ContainerContentChangeListener)(ContainerContentChangeListener *this);
  void (__fastcall *containerAddCallback)(ContainerContentChangeListener *this, Container *);
  void (__fastcall *containerRemoveCallback)(ContainerContentChangeListener *this, Container *);
  void (__fastcall *postInit)(ContainerModel *this);
  void (__fastcall *releaseResources)(ContainerModel *this);
  int (__fastcall *getContainerSize)(ContainerModel *this);
  int (__fastcall *getFilteredContainerSize)(ContainerModel *this);
  void (__fastcall *tick)(ContainerModel *this, int);
  ContainerWeakRef *(__fastcall *getContainerWeakRef)(ContainerModel *this, ContainerWeakRef *result);
  const ItemStack *(__fastcall *getItemStack)(ContainerModel *this, int);
  const std::vector&lt;ItemStack&gt; *(__fastcall *getItems)(ContainerModel *this);
  const ItemInstance *(__fastcall *getItemInstance)(ContainerModel *this, int);
  const ItemStackBase *(__fastcall *getItemStackBase)(ContainerModel *this, int);
  bool (__fastcall *isItemInstanceBased)(ContainerModel *this);
  void (__fastcall *setItem)(ContainerModel *this, int, const ItemStack *);
  bool (__fastcall *isValid)(ContainerModel *this);
  bool (__fastcall *isItemFiltered)(ContainerModel *this, const ItemStackBase *);
  bool (__fastcall *isExpanableItemFiltered)(ContainerModel *this, int);
  ContainerExpandStatus (__fastcall *getItemExpandStatus)(ContainerModel *this, int);
  const std::string *(__fastcall *getItemGroupName)(ContainerModel *this, int);
  void (__fastcall *switchItemExpando)(ContainerModel *this, int);
  Container *(__fastcall *_getContainer)(ContainerModel *this);
  int (__fastcall *_getContainerOffset)(ContainerModel *this);
  void (__fastcall *_onItemChanged)(ContainerModel *this, int, const ItemStack *, const ItemStack *);
};

</code></pre></div><h3 id="hangingactoritem"><a href="#hangingactoritem" class="header-anchor">#</a> <code>HangingActorItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HangingActorItem : Item
{
  ActorType mEntityType;
};

</code></pre></div><h3 id="hatchetitem"><a href="#hatchetitem" class="header-anchor">#</a> <code>HatchetItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HatchetItem : DiggerItem
{
};

</code></pre></div><h3 id="hoeitem"><a href="#hoeitem" class="header-anchor">#</a> <code>HoeItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HoeItem : DiggerItem
{
};

</code></pre></div><h3 id="hopperblock"><a href="#hopperblock" class="header-anchor">#</a> <code>HopperBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HopperBlock : ActorBlock
{
};

</code></pre></div><h3 id="hopperblock-vtbl"><a href="#hopperblock-vtbl" class="header-anchor">#</a> <code>HopperBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HopperBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
};

</code></pre></div><h3 id="hayblockblock"><a href="#hayblockblock" class="header-anchor">#</a> <code>HayBlockBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HayBlockBlock : RotatedPillarBlock
{
};

</code></pre></div><h3 id="hayblockblock-vtbl"><a href="#hayblockblock-vtbl" class="header-anchor">#</a> <code>HayBlockBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HayBlockBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="honeyblock"><a href="#honeyblock" class="header-anchor">#</a> <code>HoneyBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HoneyBlock : BlockLegacy
{
};

</code></pre></div><h3 id="honeyblock-vtbl"><a href="#honeyblock-vtbl" class="header-anchor">#</a> <code>HoneyBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HoneyBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="honeycombblock"><a href="#honeycombblock" class="header-anchor">#</a> <code>HoneycombBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HoneycombBlock : BlockLegacy
{
};

</code></pre></div><h3 id="honeycombblock-vtbl"><a href="#honeycombblock-vtbl" class="header-anchor">#</a> <code>HoneycombBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HoneycombBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="hugemushroomblock"><a href="#hugemushroomblock" class="header-anchor">#</a> <code>HugeMushroomBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HugeMushroomBlock : BlockLegacy
{
  _BYTE mType[4];
};

</code></pre></div><h3 id="hugemushroomblock-vtbl"><a href="#hugemushroomblock-vtbl" class="header-anchor">#</a> <code>HugeMushroomBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HugeMushroomBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="hugemushroomfeature-vtbl"><a href="#hugemushroomfeature-vtbl" class="header-anchor">#</a> <code>HugeMushroomFeature_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HugeMushroomFeature_vtbl
{
  void (__fastcall *~IFeature)(IFeature *this);
  std::optional&lt;BlockPos&gt; *(__fastcall *place)(IFeature *this, std::optional&lt;BlockPos&gt; *result, IBlockWorldGenAPI *, const BlockPos *, Random *, RenderParams *);
  std::string *(__fastcall *getStructureName)(IFeature *this, std::string *result);
  bool (__fastcall *parse)(IFeature *this, const rapidjson::GenericValue&lt;rapidjson::UTF8&lt;char&gt;,rapidjson::MemoryPoolAllocator&lt;rapidjson::CrtAllocator&gt; &gt; *, IWorldRegistriesProvider *);
  bool (__fastcall *place)(Feature *this, BlockSource *, const BlockPos *, Random *);
};

</code></pre></div><h3 id="hugefungusfeature-vtbl"><a href="#hugefungusfeature-vtbl" class="header-anchor">#</a> <code>HugeFungusFeature_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HugeFungusFeature_vtbl
{
  void (__fastcall *~IFeature)(IFeature *this);
  std::optional&lt;BlockPos&gt; *(__fastcall *place)(IFeature *this, std::optional&lt;BlockPos&gt; *result, IBlockWorldGenAPI *, const BlockPos *, Random *, RenderParams *);
  std::string *(__fastcall *getStructureName)(IFeature *this, std::string *result);
  bool (__fastcall *parse)(IFeature *this, const rapidjson::GenericValue&lt;rapidjson::UTF8&lt;char&gt;,rapidjson::MemoryPoolAllocator&lt;rapidjson::CrtAllocator&gt; &gt; *, IWorldRegistriesProvider *);
  bool (__fastcall *place)(Feature *this, BlockSource *, const BlockPos *, Random *);
};

</code></pre></div><h3 id="httprequestinternalwininet"><a href="#httprequestinternalwininet" class="header-anchor">#</a> <code>HTTPRequestInternalWinInet</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HTTPRequestInternalWinInet : HTTPRequestInternal
{
  HTTPRequest *mParentRequest;
  std::wstring_convert&lt;std::codecvt_utf8_utf16&lt;wchar_t,1114111,0&gt;,wchar_t,std::allocator&lt;wchar_t&gt;,std::allocator&lt;char&gt; &gt; ws_converter;
  Microsoft::WRL::ComPtr&lt;IXMLHTTPRequest2&gt; spXHR;
  Microsoft::WRL::ComPtr&lt;CXMLHttpRequest2Callback&gt; spXhrCallback;
  Microsoft::WRL::ComPtr&lt;CXMLHttpRequestPostStream&gt; spXhrPostStream;
  HTTPRequestCancelSourceAbort *mCancelSource;
  bool mAborted;
};

</code></pre></div><h3 id="httprequestinternalwininet-vtbl"><a href="#httprequestinternalwininet-vtbl" class="header-anchor">#</a> <code>HTTPRequestInternalWinInet_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HTTPRequestInternalWinInet_vtbl
{
  void (__fastcall *~HTTPRequestInternal)(HTTPRequestInternal *this);
};

</code></pre></div><h3 id="hvideoinputdevicenv"><a href="#hvideoinputdevicenv" class="header-anchor">#</a> <code>HVIDEOINPUTDEVICENV__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HVIDEOINPUTDEVICENV__
{
  int unused;
};

</code></pre></div><h3 id="hgpunv"><a href="#hgpunv" class="header-anchor">#</a> <code>HGPUNV__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HGPUNV__
{
  int unused;
};

</code></pre></div><h3 id="hpbufferext"><a href="#hpbufferext" class="header-anchor">#</a> <code>HPBUFFEREXT__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HPBUFFEREXT__
{
  int unused;
};

</code></pre></div><h3 id="hpbufferarb"><a href="#hpbufferarb" class="header-anchor">#</a> <code>HPBUFFERARB__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HPBUFFERARB__
{
  int unused;
};

</code></pre></div><h3 id="hvideooutputdevicenv"><a href="#hvideooutputdevicenv" class="header-anchor">#</a> <code>HVIDEOOUTPUTDEVICENV__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HVIDEOOUTPUTDEVICENV__
{
  int unused;
};

</code></pre></div><h3 id="hpvideodev"><a href="#hpvideodev" class="header-anchor">#</a> <code>HPVIDEODEV__</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HPVIDEODEV__
{
  int unused;
};

</code></pre></div><h3 id="horsescreencontroller"><a href="#horsescreencontroller" class="header-anchor">#</a> <code>HorseScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HorseScreenController : BlockContainerScreenController
{
  bool mChestTabOpen;
};

</code></pre></div><h3 id="horsescreencontroller-vtbl"><a href="#horsescreencontroller-vtbl" class="header-anchor">#</a> <code>HorseScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HorseScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
  void (__fastcall *_handlePlaceAll)(ContainerScreenController *this, const std::string *, int);
  void (__fastcall *_handlePlaceOne)(ContainerScreenController *this, const std::string *, int);
  void (__fastcall *_handleSelectSlot)(ContainerScreenController *this, const std::string *, int);
  const SelectedSlotInfo *(__fastcall *_getSelectedSlotInfo)(ContainerScreenController *this, const SelectedSlotInfo *result);
  const ItemStack *(__fastcall *_getItemStack)(ContainerScreenController *this, const std::string *, int);
  const ItemStackBase *(__fastcall *_getVisualItemStack)(ContainerScreenController *this, const std::string *, int);
  const ItemStackBase *(__fastcall *_getTakeableItemStackBase)(ContainerScreenController *this, const std::string *, int);
  ui::ViewRequest (__fastcall *_onContainerSlotHovered)(ContainerScreenController *this, const std::string *, int);
  ui::ViewRequest (__fastcall *_onContainerSlotSelected)(ContainerScreenController *this, const std::string *, int);
  ui::ViewRequest (__fastcall *_onContainerSlotPressed)(ContainerScreenController *this, const std::string *, int);
  bool (__fastcall *_shouldSwap)(ContainerScreenController *this, const std::string *, int, const std::string *, int);
  std::string *(__fastcall *_getCollectionName)(ContainerScreenController *this, std::string *result, UIPropertyBag *);
  bool (__fastcall *_canSplit)(ContainerScreenController *this, const std::string *, int);
  void (__fastcall *_sendFlyingItem)(ContainerScreenController *this, const ItemStackBase *, const std::string *, int, const std::string *, int);
  void (__fastcall *_registerCoalesceOrder)(ContainerScreenController *this);
  void (__fastcall *_registerAutoPlaceOrder)(ContainerScreenController *this);
};

</code></pre></div><h3 id="horsecontainermanagermodel"><a href="#horsecontainermanagermodel" class="header-anchor">#</a> <code>HorseContainerManagerModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseContainerManagerModel : LevelContainerManagerModel
{
  std::weak_ptr&lt;ContainerModel&gt; mEquipContainerModel;
};

</code></pre></div><h3 id="horsecontainermanagermodel-vtbl"><a href="#horsecontainermanagermodel-vtbl" class="header-anchor">#</a> <code>HorseContainerManagerModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HorseContainerManagerModel_vtbl
{
  void (__fastcall *~IContainerManager)(IContainerManager *this);
  ContainerID (__fastcall *getContainerId)(IContainerManager *this);
  void (__fastcall *setContainerId)(IContainerManager *this, ContainerID);
  ContainerType (__fastcall *getContainerType)(IContainerManager *this);
  void (__fastcall *setContainerType)(IContainerManager *this, ContainerType);
  void (__fastcall *serverInitItemStackIds)(IContainerManager *this);
  std::vector&lt;ItemStack&gt; *(__fastcall *getItemCopies)(IContainerManager *this, std::vector&lt;ItemStack&gt; *result);
  void (__fastcall *setSlot)(IContainerManager *this, int, const ItemStack *, bool);
  const ItemStack *(__fastcall *getSlot)(IContainerManager *this, int);
  void (__fastcall *setData)(IContainerManager *this, int, int);
  void (__fastcall *broadcastChanges)(IContainerManager *this);
  bool (__fastcall *validateContainer)(IContainerManager *this);
  bool (__fastcall *isValid)(ContainerManagerModel *this, float);
  ContainerScreenContext *(__fastcall *_postInit)(ContainerManagerModel *this, ContainerScreenContext *result);
};

</code></pre></div><h3 id="horsecontainermanagercontroller"><a href="#horsecontainermanagercontroller" class="header-anchor">#</a> <code>HorseContainerManagerController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HorseContainerManagerController : ContainerManagerController
{
  std::weak_ptr&lt;HorseContainerManagerModel&gt; mHorseContainerManagerModel;
  bool mIsEquipTabOpen;
};

</code></pre></div><h3 id="horsecontainermanagercontroller-vtbl"><a href="#horsecontainermanagercontroller-vtbl" class="header-anchor">#</a> <code>HorseContainerManagerController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HorseContainerManagerController_vtbl
{
  void (__fastcall *~ContainerManagerController)(ContainerManagerController *this);
  void (__fastcall *registerContainerCallbacks)(ContainerManagerController *this);
  const ItemStackBase *(__fastcall *getTakeableItemStackBase)(ContainerManagerController *this, const SlotData *);
  void (__fastcall *handleTakeAmount)(ContainerManagerController *this, const SlotData *, int, const SlotData *);
  void (__fastcall *handleTakeAll)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handlePlaceAll)(ContainerManagerController *this, const SelectedSlotInfo *, const SlotData *);
  void (__fastcall *handleTakeHalf)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handlePlaceOne)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handlePlaceAmount)(ContainerManagerController *this, const SlotData *, int, const SlotData *);
  int (__fastcall *handleAutoPlace)(ContainerManagerController *this, const SlotData *, int, const std::vector&lt;AutoPlaceItem&gt; *, std::vector&lt;AutoPlaceResult&gt; *);
  int (__fastcall *handleAutoPlaceStack)(ContainerManagerController *this, const SlotData *, ItemTakeType, const std::vector&lt;AutoPlaceItem&gt; *, std::vector&lt;AutoPlaceResult&gt; *);
  void (__fastcall *handleSplitSingle)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handleSplitMultiple)(ContainerManagerController *this, const SelectedSlotInfo *, const ItemInstance *, const SlotData *);
  void (__fastcall *handleCoalesce)(ContainerManagerController *this, const SlotData *, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *handleSwap)(ContainerManagerController *this, const SlotData *, const SlotData *);
  bool (__fastcall *handleDrop)(ContainerManagerController *this, const SlotData *, const ItemTransferAmount);
  bool (__fastcall *handleDestroy)(ContainerManagerController *this, const SlotData *, const ItemTransferAmount);
  bool (__fastcall *handleDestroy)(ContainerManagerController *this, const SelectedSlotInfo *, const ItemTransferAmount);
  bool (__fastcall *handleConsume)(ContainerManagerController *this, const SlotData *, const ItemTransferAmount);
  void (__fastcall *handleAddToStack)(ContainerManagerController *this, const SlotData *, const SlotData *, ItemTakeType);
  void (__fastcall *closeContainers)(ContainerManagerController *this);
  const std::vector&lt;ContainerSplitControl&gt; *(__fastcall *getSplitItems)(ContainerManagerController *this);
  bool (__fastcall *isOutputSlot)(ContainerManagerController *this, const std::string *);
  void (__fastcall *_onItemTransferredFrom)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
  void (__fastcall *_onItemTransferredTo)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
  void (__fastcall *_onItemAcquired)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
  void (__fastcall *_onItemPlaced)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
};

</code></pre></div><h3 id="horsescreencontroller-ctor-l2-lambda-af5fa2530f826d5d08def04c7eb5cee0"><a href="#horsescreencontroller-ctor-l2-lambda-af5fa2530f826d5d08def04c7eb5cee0" class="header-anchor">#</a> <code>HorseScreenController::{ctor}::__l2::&lt;lambda_af5fa2530f826d5d08def04c7eb5cee0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseScreenController::{ctor}::__l2::&lt;lambda_af5fa2530f826d5d08def04c7eb5cee0&gt;
{
  HorseScreenController *const __this;
};

</code></pre></div><h3 id="horsescreencontroller-ctor-l2-lambda-80c6e5409393cca0fc5a377974added3"><a href="#horsescreencontroller-ctor-l2-lambda-80c6e5409393cca0fc5a377974added3" class="header-anchor">#</a> <code>HorseScreenController::{ctor}::__l2::&lt;lambda_80c6e5409393cca0fc5a377974added3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseScreenController::{ctor}::__l2::&lt;lambda_80c6e5409393cca0fc5a377974added3&gt;
{
  HorseScreenController *const __this;
};

</code></pre></div><h3 id="horsescreencontroller-ctor-l2-lambda-025986612949938973253e99816d0a0c"><a href="#horsescreencontroller-ctor-l2-lambda-025986612949938973253e99816d0a0c" class="header-anchor">#</a> <code>HorseScreenController::{ctor}::__l2::&lt;lambda_025986612949938973253e99816d0a0c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseScreenController::{ctor}::__l2::&lt;lambda_025986612949938973253e99816d0a0c&gt;
{
  HorseScreenController *const __this;
};

</code></pre></div><h3 id="horsescreencontroller-ctor-l2-lambda-d80db6b9e9a3d13343bb578caa017e7a"><a href="#horsescreencontroller-ctor-l2-lambda-d80db6b9e9a3d13343bb578caa017e7a" class="header-anchor">#</a> <code>HorseScreenController::{ctor}::__l2::&lt;lambda_d80db6b9e9a3d13343bb578caa017e7a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseScreenController::{ctor}::__l2::&lt;lambda_d80db6b9e9a3d13343bb578caa017e7a&gt;
{
  HorseScreenController *const __this;
};

</code></pre></div><h3 id="horsescreencontroller-ctor-l2-lambda-32008c64cf8e1a2b5f1a9adf16734b12"><a href="#horsescreencontroller-ctor-l2-lambda-32008c64cf8e1a2b5f1a9adf16734b12" class="header-anchor">#</a> <code>HorseScreenController::{ctor}::__l2::&lt;lambda_32008c64cf8e1a2b5f1a9adf16734b12&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseScreenController::{ctor}::__l2::&lt;lambda_32008c64cf8e1a2b5f1a9adf16734b12&gt;
{
  const ActorUniqueID uniqueId;
};

</code></pre></div><h3 id="horsescreencontroller-ctor-l2-lambda-f366e4756a3ad1e14c2b165ae3e1cce7"><a href="#horsescreencontroller-ctor-l2-lambda-f366e4756a3ad1e14c2b165ae3e1cce7" class="header-anchor">#</a> <code>HorseScreenController::{ctor}::__l2::&lt;lambda_f366e4756a3ad1e14c2b165ae3e1cce7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseScreenController::{ctor}::__l2::&lt;lambda_f366e4756a3ad1e14c2b165ae3e1cce7&gt;
{
  HorseScreenController *const __this;
};

</code></pre></div><h3 id="horsescreencontroller-ctor-l2-lambda-70e96ef0b510e7e22cd1bec90fd98052"><a href="#horsescreencontroller-ctor-l2-lambda-70e96ef0b510e7e22cd1bec90fd98052" class="header-anchor">#</a> <code>HorseScreenController::{ctor}::__l2::&lt;lambda_70e96ef0b510e7e22cd1bec90fd98052&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseScreenController::{ctor}::__l2::&lt;lambda_70e96ef0b510e7e22cd1bec90fd98052&gt;
{
  bool carpet;
  bool saddle;
};

</code></pre></div><h3 id="horsescreencontroller-ctor-l2-lambda-aae33fb3c021b427366010e85d724955"><a href="#horsescreencontroller-ctor-l2-lambda-aae33fb3c021b427366010e85d724955" class="header-anchor">#</a> <code>HorseScreenController::{ctor}::__l2::&lt;lambda_aae33fb3c021b427366010e85d724955&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseScreenController::{ctor}::__l2::&lt;lambda_aae33fb3c021b427366010e85d724955&gt;
{
  bool carpet;
  bool saddle;
};

</code></pre></div><h3 id="horsescreencontroller-ctor-l2-lambda-c826454155f9e06315851f1096cfd6e3"><a href="#horsescreencontroller-ctor-l2-lambda-c826454155f9e06315851f1096cfd6e3" class="header-anchor">#</a> <code>HorseScreenController::{ctor}::__l2::&lt;lambda_c826454155f9e06315851f1096cfd6e3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseScreenController::{ctor}::__l2::&lt;lambda_c826454155f9e06315851f1096cfd6e3&gt;
{
  bool carpet;
};

</code></pre></div><h3 id="horsescreencontroller-ctor-l2-lambda-29032eead47001b61f3051162f12b0a4"><a href="#horsescreencontroller-ctor-l2-lambda-29032eead47001b61f3051162f12b0a4" class="header-anchor">#</a> <code>HorseScreenController::{ctor}::__l2::&lt;lambda_29032eead47001b61f3051162f12b0a4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseScreenController::{ctor}::__l2::&lt;lambda_29032eead47001b61f3051162f12b0a4&gt;
{
  bool armor;
  bool carpet;
  bool saddle;
};

</code></pre></div><h3 id="horsescreencontroller-ctor-l2-lambda-fb3a37bc67e2165084c025dfaaa0634c"><a href="#horsescreencontroller-ctor-l2-lambda-fb3a37bc67e2165084c025dfaaa0634c" class="header-anchor">#</a> <code>HorseScreenController::{ctor}::__l2::&lt;lambda_fb3a37bc67e2165084c025dfaaa0634c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseScreenController::{ctor}::__l2::&lt;lambda_fb3a37bc67e2165084c025dfaaa0634c&gt;
{
  bool armor;
  bool carpet;
  bool saddle;
};

</code></pre></div><h3 id="horsescreencontroller-ctor-l2-lambda-fb9ac15c96cbbb5498e516bbd1f5ec92"><a href="#horsescreencontroller-ctor-l2-lambda-fb9ac15c96cbbb5498e516bbd1f5ec92" class="header-anchor">#</a> <code>HorseScreenController::{ctor}::__l2::&lt;lambda_fb9ac15c96cbbb5498e516bbd1f5ec92&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseScreenController::{ctor}::__l2::&lt;lambda_fb9ac15c96cbbb5498e516bbd1f5ec92&gt;
{
  bool armor;
  bool carpet;
};

</code></pre></div><h3 id="horsescreencontroller-ctor-l2-lambda-8428b03acd8d82eba9ca1912315ce62f"><a href="#horsescreencontroller-ctor-l2-lambda-8428b03acd8d82eba9ca1912315ce62f" class="header-anchor">#</a> <code>HorseScreenController::{ctor}::__l2::&lt;lambda_8428b03acd8d82eba9ca1912315ce62f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseScreenController::{ctor}::__l2::&lt;lambda_8428b03acd8d82eba9ca1912315ce62f&gt;
{
  bool saddle;
};

</code></pre></div><h3 id="horsescreencontroller-ctor-l2-lambda-af0dac77beec41d4c248848aad34ecc4"><a href="#horsescreencontroller-ctor-l2-lambda-af0dac77beec41d4c248848aad34ecc4" class="header-anchor">#</a> <code>HorseScreenController::{ctor}::__l2::&lt;lambda_af0dac77beec41d4c248848aad34ecc4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseScreenController::{ctor}::__l2::&lt;lambda_af0dac77beec41d4c248848aad34ecc4&gt;
{
  HorseScreenController *const __this;
};

</code></pre></div><h3 id="horsescreencontroller-ctor-l2-lambda-b4fd066aa479ddd11366c1ab3ac22cad"><a href="#horsescreencontroller-ctor-l2-lambda-b4fd066aa479ddd11366c1ab3ac22cad" class="header-anchor">#</a> <code>HorseScreenController::{ctor}::__l2::&lt;lambda_b4fd066aa479ddd11366c1ab3ac22cad&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseScreenController::{ctor}::__l2::&lt;lambda_b4fd066aa479ddd11366c1ab3ac22cad&gt;
{
  HorseScreenController *const __this;
};

</code></pre></div><h3 id="horsescreencontroller-ctor-l2-lambda-64713f98632f01bc3921ea3e304729ed"><a href="#horsescreencontroller-ctor-l2-lambda-64713f98632f01bc3921ea3e304729ed" class="header-anchor">#</a> <code>HorseScreenController::{ctor}::__l2::&lt;lambda_64713f98632f01bc3921ea3e304729ed&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseScreenController::{ctor}::__l2::&lt;lambda_64713f98632f01bc3921ea3e304729ed&gt;
{
  HorseScreenController *const __this;
};

</code></pre></div><h3 id="hoppercontainermanagermodel"><a href="#hoppercontainermanagermodel" class="header-anchor">#</a> <code>HopperContainerManagerModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HopperContainerManagerModel : LevelContainerManagerModel
{
};

</code></pre></div><h3 id="hoppercontainermanagermodel-vtbl"><a href="#hoppercontainermanagermodel-vtbl" class="header-anchor">#</a> <code>HopperContainerManagerModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HopperContainerManagerModel_vtbl
{
  void (__fastcall *~IContainerManager)(IContainerManager *this);
  ContainerID (__fastcall *getContainerId)(IContainerManager *this);
  void (__fastcall *setContainerId)(IContainerManager *this, ContainerID);
  ContainerType (__fastcall *getContainerType)(IContainerManager *this);
  void (__fastcall *setContainerType)(IContainerManager *this, ContainerType);
  void (__fastcall *serverInitItemStackIds)(IContainerManager *this);
  std::vector&lt;ItemStack&gt; *(__fastcall *getItemCopies)(IContainerManager *this, std::vector&lt;ItemStack&gt; *result);
  void (__fastcall *setSlot)(IContainerManager *this, int, const ItemStack *, bool);
  const ItemStack *(__fastcall *getSlot)(IContainerManager *this, int);
  void (__fastcall *setData)(IContainerManager *this, int, int);
  void (__fastcall *broadcastChanges)(IContainerManager *this);
  bool (__fastcall *validateContainer)(IContainerManager *this);
  bool (__fastcall *isValid)(ContainerManagerModel *this, float);
  ContainerScreenContext *(__fastcall *_postInit)(ContainerManagerModel *this, ContainerScreenContext *result);
};

</code></pre></div><h3 id="hoppersystem"><a href="#hoppersystem" class="header-anchor">#</a> <code>HopperSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HopperSystem : ITickingSystem
{
};

</code></pre></div><h3 id="hoppersystem-vtbl"><a href="#hoppersystem-vtbl" class="header-anchor">#</a> <code>HopperSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HopperSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="harvestfarmblockdefinition"><a href="#harvestfarmblockdefinition" class="header-anchor">#</a> <code>HarvestFarmBlockDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HarvestFarmBlockDefinition : BaseGoalDefinition
{
  float mMaximumSecondsUntilSearch;
  float mSearchCooldownMaximumSeconds;
  float mTaskCooldownSeconds;
  int mSearchCount;
  int mSearchHeight;
  int mSearchRange;
  float mGoalRadius;
  float mSpeedModifier;
};

</code></pre></div><h3 id="harvestfarmblockdefinition-vtbl"><a href="#harvestfarmblockdefinition-vtbl" class="header-anchor">#</a> <code>HarvestFarmBlockDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HarvestFarmBlockDefinition_vtbl
{
  void (__fastcall *~BaseGoalDefinition)(BaseGoalDefinition *this);
  bool (__fastcall *validateMobType)(BaseGoalDefinition *this, Mob *);
  bool (__fastcall *validate)(BaseGoalDefinition *this, Mob *);
};

</code></pre></div><h3 id="harvestfarmblockgoal"><a href="#harvestfarmblockgoal" class="header-anchor">#</a> <code>HarvestFarmBlockGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HarvestFarmBlockGoal : BaseMoveToBlockGoal
{
  int mMaximumTicksUntilSearch;
  int mSearchCooldownMaximumTicks;
  int mTaskCooldownTicks;
  int mInventorySeedsIndex;
  _BYTE mCurrentTask[4];
};

</code></pre></div><h3 id="harvestfarmblockgoal-vtbl"><a href="#harvestfarmblockgoal-vtbl" class="header-anchor">#</a> <code>HarvestFarmBlockGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HarvestFarmBlockGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
  bool (__fastcall *hasReachedTarget)(BaseMoveToGoal *this);
  bool (__fastcall *isValidTarget)(BaseMoveToGoal *this, BlockSource *, const BlockPos *);
  int (__fastcall *_nextStartTick)(BaseMoveToGoal *this);
  bool (__fastcall *_canReach)(BaseMoveToGoal *this, const BlockPos *);
  void (__fastcall *_moveToBlock)(BaseMoveToGoal *this);
  Vec3 *(__fastcall *_getTargetPosition)(BaseMoveToGoal *this, Vec3 *result);
  unsigned __int64 (__fastcall *_getRepathTime)(BaseMoveToGoal *this);
  bool (__fastcall *findTargetBlock)(BaseMoveToBlockGoal *this);
};

</code></pre></div><h3 id="hidegoal"><a href="#hidegoal" class="header-anchor">#</a> <code>HideGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) HideGoal : MoveToPOIGoal
{
  __int16 mHideAttempts;
};

</code></pre></div><h3 id="hidegoal-vtbl"><a href="#hidegoal-vtbl" class="header-anchor">#</a> <code>HideGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HideGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
  bool (__fastcall *hasReachedTarget)(BaseMoveToGoal *this);
  bool (__fastcall *isValidTarget)(BaseMoveToGoal *this, BlockSource *, const BlockPos *);
  int (__fastcall *_nextStartTick)(BaseMoveToGoal *this);
  bool (__fastcall *_canReach)(BaseMoveToGoal *this, const BlockPos *);
  void (__fastcall *_moveToBlock)(BaseMoveToGoal *this);
  Vec3 *(__fastcall *_getTargetPosition)(BaseMoveToGoal *this, Vec3 *result);
  unsigned __int64 (__fastcall *_getRepathTime)(BaseMoveToGoal *this);
  bool (__fastcall *getPOI)(MoveToPOIGoal *this, POIType);
  std::weak_ptr&lt;POIInstance&gt; *(__fastcall *_getOwnedPOI)(MoveToPOIGoal *this, std::weak_ptr&lt;POIInstance&gt; *result, POIType);
};

</code></pre></div><h3 id="holdgroundgoal"><a href="#holdgroundgoal" class="header-anchor">#</a> <code>HoldGroundGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HoldGroundGoal : Goal
{
  Mob *mMob;
  TempEPtr&lt;Actor&gt; mLookAt;
  float mHostileRadiusSqr;
  bool mBroadcast;
  float mBroadcastRange;
  const DefinitionTrigger mWithinRangeEvent;
};

</code></pre></div><h3 id="holdgroundgoal-vtbl"><a href="#holdgroundgoal-vtbl" class="header-anchor">#</a> <code>HoldGroundGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HoldGroundGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="hovergoal"><a href="#hovergoal" class="header-anchor">#</a> <code>HoverGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HoverGoal : Goal
{
  Mob *mMob;
  float mSpeedMultiplier;
  Vec3 mStartPos;
};

</code></pre></div><h3 id="hovergoal-vtbl"><a href="#hovergoal-vtbl" class="header-anchor">#</a> <code>HoverGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HoverGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="horsecontainermanagermodel-postinit-l5-lambda-1ff89581375038258850ba975b22babe"><a href="#horsecontainermanagermodel-postinit-l5-lambda-1ff89581375038258850ba975b22babe" class="header-anchor">#</a> <code>HorseContainerManagerModel::_postInit::__l5::&lt;lambda_1ff89581375038258850ba975b22babe&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseContainerManagerModel::_postInit::__l5::&lt;lambda_1ff89581375038258850ba975b22babe&gt;
{
  HorseContainerManagerModel *const __this;
};

</code></pre></div><h3 id="horsecontainermanagermodel-postinit-l5-lambda-89ec054521d8a3163489de1362af6a58"><a href="#horsecontainermanagermodel-postinit-l5-lambda-89ec054521d8a3163489de1362af6a58" class="header-anchor">#</a> <code>HorseContainerManagerModel::_postInit::__l5::&lt;lambda_89ec054521d8a3163489de1362af6a58&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HorseContainerManagerModel::_postInit::__l5::&lt;lambda_89ec054521d8a3163489de1362af6a58&gt;
{
  HorseContainerManagerModel *const __this;
};

</code></pre></div><h3 id="hellfirefeature-vtbl"><a href="#hellfirefeature-vtbl" class="header-anchor">#</a> <code>HellFireFeature_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HellFireFeature_vtbl
{
  void (__fastcall *~IFeature)(IFeature *this);
  std::optional&lt;BlockPos&gt; *(__fastcall *place)(IFeature *this, std::optional&lt;BlockPos&gt; *result, IBlockWorldGenAPI *, const BlockPos *, Random *, RenderParams *);
  std::string *(__fastcall *getStructureName)(IFeature *this, std::string *result);
  bool (__fastcall *parse)(IFeature *this, const rapidjson::GenericValue&lt;rapidjson::UTF8&lt;char&gt;,rapidjson::MemoryPoolAllocator&lt;rapidjson::CrtAllocator&gt; &gt; *, IWorldRegistriesProvider *);
  bool (__fastcall *place)(Feature *this, BlockSource *, const BlockPos *, Random *);
};

</code></pre></div><h3 id="hellspringfeature-vtbl"><a href="#hellspringfeature-vtbl" class="header-anchor">#</a> <code>HellSpringFeature_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HellSpringFeature_vtbl
{
  void (__fastcall *~IFeature)(IFeature *this);
  std::optional&lt;BlockPos&gt; *(__fastcall *place)(IFeature *this, std::optional&lt;BlockPos&gt; *result, IBlockWorldGenAPI *, const BlockPos *, Random *, RenderParams *);
  std::string *(__fastcall *getStructureName)(IFeature *this, std::string *result);
  bool (__fastcall *parse)(IFeature *this, const rapidjson::GenericValue&lt;rapidjson::UTF8&lt;char&gt;,rapidjson::MemoryPoolAllocator&lt;rapidjson::CrtAllocator&gt; &gt; *, IWorldRegistriesProvider *);
  bool (__fastcall *place)(Feature *this, BlockSource *, const BlockPos *, Random *);
};

</code></pre></div><h3 id="huff-entropy-encoder"><a href="#huff-entropy-encoder" class="header-anchor">#</a> <code>huff_entropy_encoder</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct huff_entropy_encoder
{
  jpeg_entropy_encoder pub;
  _BYTE saved[20];
  __declspec(align(8)) unsigned int restarts_to_go;
  int next_restart_num;
  c_derived_tbl *dc_derived_tbls[4];
  c_derived_tbl *ac_derived_tbls[4];
  int *dc_count_ptrs[4];
  int *ac_count_ptrs[4];
  unsigned __int8 gather_statistics;
  unsigned __int8 *next_output_byte;
  unsigned __int64 free_in_buffer;
  jpeg_compress_struct *cinfo;
  int ac_tbl_no;
  unsigned int EOBRUN;
  unsigned int BE;
  char *bit_buffer;
};

</code></pre></div><h3 id="huff-entropy-decoder"><a href="#huff-entropy-decoder" class="header-anchor">#</a> <code>huff_entropy_decoder</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct huff_entropy_decoder
{
  jpeg_entropy_decoder pub;
  bitread_perm_state bitstate;
  _BYTE saved[20];
  unsigned __int8 insufficient_data;
  unsigned int restarts_to_go;
  d_derived_tbl *derived_tbls[4];
  d_derived_tbl *ac_derived_tbl;
  d_derived_tbl *dc_derived_tbls[4];
  d_derived_tbl *ac_derived_tbls[4];
  d_derived_tbl *dc_cur_tbls[10];
  d_derived_tbl *ac_cur_tbls[10];
  int coef_limit[10];
};

</code></pre></div><h3 id="huffmanencodingtreenode"><a href="#huffmanencodingtreenode" class="header-anchor">#</a> <code>HuffmanEncodingTreeNode</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct HuffmanEncodingTreeNode
{
  unsigned __int8 value;
  unsigned int weight;
  HuffmanEncodingTreeNode *left;
  HuffmanEncodingTreeNode *right;
  HuffmanEncodingTreeNode *parent;
};

</code></pre></div><h3 id="hudhorsejumprenderer-render-l2-lambda-f26f6b421c5d8a48941cbbe5d0c0ad83"><a href="#hudhorsejumprenderer-render-l2-lambda-f26f6b421c5d8a48941cbbe5d0c0ad83" class="header-anchor">#</a> <code>HudHorseJumpRenderer::render::__l2::&lt;lambda_f26f6b421c5d8a48941cbbe5d0c0ad83&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudHorseJumpRenderer::render::__l2::&lt;lambda_f26f6b421c5d8a48941cbbe5d0c0ad83&gt;
{
  float *uSize;
  float *vSize;
  int *u;
  int *v;
};

</code></pre></div><h3 id="hudplayerrenderer-render-l11-lambda-3c8a26f25fde2aa3aadba65938c29373-l2-literal"><a href="#hudplayerrenderer-render-l11-lambda-3c8a26f25fde2aa3aadba65938c29373-l2-literal" class="header-anchor">#</a> <code>HudPlayerRenderer::render::__l11::&lt;lambda_3c8a26f25fde2aa3aadba65938c29373&gt;::()::__l2::Literal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudPlayerRenderer::render::__l11::&lt;lambda_3c8a26f25fde2aa3aadba65938c29373&gt;::()::__l2::Literal
{
};

</code></pre></div><h3 id="hudplayerrenderer-render-l11-lambda-ee7b0def6be5201d2193da1373b2d92c-l2-literal"><a href="#hudplayerrenderer-render-l11-lambda-ee7b0def6be5201d2193da1373b2d92c-l2-literal" class="header-anchor">#</a> <code>HudPlayerRenderer::render::__l11::&lt;lambda_ee7b0def6be5201d2193da1373b2d92c&gt;::()::__l2::Literal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudPlayerRenderer::render::__l11::&lt;lambda_ee7b0def6be5201d2193da1373b2d92c&gt;::()::__l2::Literal
{
};

</code></pre></div><h3 id="hudplayerrenderer-render-l11-lambda-7c138ce959f7ff186fa0298c49f4fbf1-l2-literal"><a href="#hudplayerrenderer-render-l11-lambda-7c138ce959f7ff186fa0298c49f4fbf1-l2-literal" class="header-anchor">#</a> <code>HudPlayerRenderer::render::__l11::&lt;lambda_7c138ce959f7ff186fa0298c49f4fbf1&gt;::()::__l2::Literal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudPlayerRenderer::render::__l11::&lt;lambda_7c138ce959f7ff186fa0298c49f4fbf1&gt;::()::__l2::Literal
{
};

</code></pre></div><h3 id="hudmobeffectsrenderer-render-l24-lambda-8b8e8c379e3d3ef9f9c7f588b3d37ae9"><a href="#hudmobeffectsrenderer-render-l24-lambda-8b8e8c379e3d3ef9f9c7f588b3d37ae9" class="header-anchor">#</a> <code>HudMobEffectsRenderer::render::__l24::&lt;lambda_8b8e8c379e3d3ef9f9c7f588b3d37ae9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudMobEffectsRenderer::render::__l24::&lt;lambda_8b8e8c379e3d3ef9f9c7f588b3d37ae9&gt;
{
  int *ux;
  int *vy;
  float *uvWidth;
  float *uvHeight;
  float *us;
  float *vs;
};

</code></pre></div><h3 id="hudplayerrenderer-render-l11-lambda-3c8a26f25fde2aa3aadba65938c29373"><a href="#hudplayerrenderer-render-l11-lambda-3c8a26f25fde2aa3aadba65938c29373" class="header-anchor">#</a> <code>HudPlayerRenderer::render::__l11::&lt;lambda_3c8a26f25fde2aa3aadba65938c29373&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudPlayerRenderer::render::__l11::&lt;lambda_3c8a26f25fde2aa3aadba65938c29373&gt;
{
};

</code></pre></div><h3 id="hudplayerrenderer-render-l11-lambda-7c138ce959f7ff186fa0298c49f4fbf1"><a href="#hudplayerrenderer-render-l11-lambda-7c138ce959f7ff186fa0298c49f4fbf1" class="header-anchor">#</a> <code>HudPlayerRenderer::render::__l11::&lt;lambda_7c138ce959f7ff186fa0298c49f4fbf1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudPlayerRenderer::render::__l11::&lt;lambda_7c138ce959f7ff186fa0298c49f4fbf1&gt;
{
};

</code></pre></div><h3 id="hudplayerrenderer-render-l11-lambda-ee7b0def6be5201d2193da1373b2d92c"><a href="#hudplayerrenderer-render-l11-lambda-ee7b0def6be5201d2193da1373b2d92c" class="header-anchor">#</a> <code>HudPlayerRenderer::render::__l11::&lt;lambda_ee7b0def6be5201d2193da1373b2d92c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudPlayerRenderer::render::__l11::&lt;lambda_ee7b0def6be5201d2193da1373b2d92c&gt;
{
};

</code></pre></div><h3 id="hbui-facetregistry-registerfacet-l2-lambda-bd9bb8f2cadf3b0f10a80c7e81deb91c"><a href="#hbui-facetregistry-registerfacet-l2-lambda-bd9bb8f2cadf3b0f10a80c7e81deb91c" class="header-anchor">#</a> <code>hbui::FacetRegistry::registerFacet::__l2::&lt;lambda_bd9bb8f2cadf3b0f10a80c7e81deb91c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetRegistry::registerFacet::__l2::&lt;lambda_bd9bb8f2cadf3b0f10a80c7e81deb91c&gt;
{
  const std::string *name;
};

</code></pre></div><h3 id="hbui-facetregistry-activatefacet-l2-lambda-9a9590cfcd6a92ccbb29c3aa72aee23c"><a href="#hbui-facetregistry-activatefacet-l2-lambda-9a9590cfcd6a92ccbb29c3aa72aee23c" class="header-anchor">#</a> <code>hbui::FacetRegistry::activateFacet::__l2::&lt;lambda_9a9590cfcd6a92ccbb29c3aa72aee23c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetRegistry::activateFacet::__l2::&lt;lambda_9a9590cfcd6a92ccbb29c3aa72aee23c&gt;
{
  const std::string *name;
};

</code></pre></div><h3 id="hbui-facetregistry-deactivatefacet-l2-lambda-f70eba82a047d5efe865983ea2888497"><a href="#hbui-facetregistry-deactivatefacet-l2-lambda-f70eba82a047d5efe865983ea2888497" class="header-anchor">#</a> <code>hbui::FacetRegistry::deactivateFacet::__l2::&lt;lambda_f70eba82a047d5efe865983ea2888497&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::FacetRegistry::deactivateFacet::__l2::&lt;lambda_f70eba82a047d5efe865983ea2888497&gt;
{
  const std::string *name;
};

</code></pre></div><h3 id="hummingbirdui-unregisterrouteconfigurationchangecallback-l2-lambda-3e88f95f6d5af2b53e78952b635e1bb8"><a href="#hummingbirdui-unregisterrouteconfigurationchangecallback-l2-lambda-3e88f95f6d5af2b53e78952b635e1bb8" class="header-anchor">#</a> <code>HummingbirdUI::unregisterRouteConfigurationChangeCallback::__l2::&lt;lambda_3e88f95f6d5af2b53e78952b635e1bb8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HummingbirdUI::unregisterRouteConfigurationChangeCallback::__l2::&lt;lambda_3e88f95f6d5af2b53e78952b635e1bb8&gt;
{
  void *token;
};

</code></pre></div><h3 id="hbui-routematcher-match-l2-lambda-fa4836dab5b272682811c18a65ff5f30"><a href="#hbui-routematcher-match-l2-lambda-fa4836dab5b272682811c18a65ff5f30" class="header-anchor">#</a> <code>hbui::RouteMatcher::_match::__l2::&lt;lambda_fa4836dab5b272682811c18a65ff5f30&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::RouteMatcher::_match::__l2::&lt;lambda_fa4836dab5b272682811c18a65ff5f30&gt;
{
  const std::string route;
};

</code></pre></div><h3 id="hbui-routerconfiguration-addroute-l2-lambda-9d53e344a0271a1458e6afaa48e7f0d5"><a href="#hbui-routerconfiguration-addroute-l2-lambda-9d53e344a0271a1458e6afaa48e7f0d5" class="header-anchor">#</a> <code>hbui::RouterConfiguration::_addRoute::__l2::&lt;lambda_9d53e344a0271a1458e6afaa48e7f0d5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj hbui::RouterConfiguration::_addRoute::__l2::&lt;lambda_9d53e344a0271a1458e6afaa48e7f0d5&gt;
{
  const std::string *route;
};

</code></pre></div><h3 id="hudscreencontroller-updatetitletext-l14-lambda-348b4ca9d695a98721f80bb664a775dd"><a href="#hudscreencontroller-updatetitletext-l14-lambda-348b4ca9d695a98721f80bb664a775dd" class="header-anchor">#</a> <code>HudScreenController::_updateTitleText::__l14::&lt;lambda_348b4ca9d695a98721f80bb664a775dd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HudScreenController::_updateTitleText::__l14::&lt;lambda_348b4ca9d695a98721f80bb664a775dd&gt;
{
};

</code></pre></div><h3 id="hitresultsystem-tick-l2-lambda-ad1d02461820c9e892f4d2da456e3aa6"><a href="#hitresultsystem-tick-l2-lambda-ad1d02461820c9e892f4d2da456e3aa6" class="header-anchor">#</a> <code>HitResultSystem::tick::__l2::&lt;lambda_ad1d02461820c9e892f4d2da456e3aa6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HitResultSystem::tick::__l2::&lt;lambda_ad1d02461820c9e892f4d2da456e3aa6&gt;
{
};

</code></pre></div><h3 id="healablecomponent-getinteraction-l2-lambda-90c5c6f55d8f131a1d67e74a13742cae"><a href="#healablecomponent-getinteraction-l2-lambda-90c5c6f55d8f131a1d67e74a13742cae" class="header-anchor">#</a> <code>HealableComponent::getInteraction::__l2::&lt;lambda_90c5c6f55d8f131a1d67e74a13742cae&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HealableComponent::getInteraction::__l2::&lt;lambda_90c5c6f55d8f131a1d67e74a13742cae&gt;
{
  const ItemStack *item;
};

</code></pre></div><h3 id="homecomponent-tick-l2-lambda-ea3f16251f6d40785ec8bf72849f1501"><a href="#homecomponent-tick-l2-lambda-ea3f16251f6d40785ec8bf72849f1501" class="header-anchor">#</a> <code>HomeComponent::tick::__l2::&lt;lambda_ea3f16251f6d40785ec8bf72849f1501&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HomeComponent::tick::__l2::&lt;lambda_ea3f16251f6d40785ec8bf72849f1501&gt;
{
  const BlockLegacy *blockAtHomePos;
};

</code></pre></div><h3 id="heavyblock-animatetick-l11-lambda-34dbdd8a4780ed8cc471ac95c73990c9-l2-literal"><a href="#heavyblock-animatetick-l11-lambda-34dbdd8a4780ed8cc471ac95c73990c9-l2-literal" class="header-anchor">#</a> <code>HeavyBlock::animateTick::__l11::&lt;lambda_34dbdd8a4780ed8cc471ac95c73990c9&gt;::()::__l2::Literal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HeavyBlock::animateTick::__l11::&lt;lambda_34dbdd8a4780ed8cc471ac95c73990c9&gt;::()::__l2::Literal
{
};

</code></pre></div><h3 id="heavyblock-animatetick-l11-lambda-34dbdd8a4780ed8cc471ac95c73990c9"><a href="#heavyblock-animatetick-l11-lambda-34dbdd8a4780ed8cc471ac95c73990c9" class="header-anchor">#</a> <code>HeavyBlock::animateTick::__l11::&lt;lambda_34dbdd8a4780ed8cc471ac95c73990c9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj HeavyBlock::animateTick::__l11::&lt;lambda_34dbdd8a4780ed8cc471ac95c73990c9&gt;
{
};

</code></pre></div><h3 id="horse-vtbl"><a href="#horse-vtbl" class="header-anchor">#</a> <code>Horse_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Horse_vtbl
{
  bool (__fastcall *hasComponent)(Actor *this, const HashedString *);
  void (__fastcall *reloadHardcoded)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadHardcodedClient)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *initializeComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *_serverInitItemStackIds)(Actor *this);
  void (__fastcall *_doInitialMove)(Actor *this);
  bool (__fastcall *checkAllSensitiveWords)(Actor *this);
  bool (__fastcall *checkNameTag)(Actor *this);
  void (__fastcall *~Actor)(Actor *this);
  void (__fastcall *reset)(Actor *this);
  int (__fastcall *getOnDeathExperience)(Actor *this);
  ActorType (__fastcall *getOwnerEntityType)(Actor *this);
  void (__fastcall *remove)(Actor *this);
  void (__fastcall *setPos)(Actor *this, const Vec3 *);
  const PredictedMovementValues *(__fastcall *getPredictedMovementValues)(Actor *this);
  const Vec3 *(__fastcall *getPos)(Actor *this);
  const Vec3 *(__fastcall *getPosOld)(Actor *this);
  const Vec3 *(__fastcall *getPosExtrapolated)(Actor *this, const Vec3 *result, float);
  Vec3 *(__fastcall *getAttachPos)(Actor *this, Vec3 *result, ActorLocation, float);
  Vec3 *(__fastcall *getFiringPos)(Actor *this, Vec3 *result);
  void (__fastcall *setRot)(Actor *this, const Vec2 *);
  void (__fastcall *move)(Actor *this, IActorMovementProxy *, const Vec3 *);
  void (__fastcall *move)(Actor *this, const Vec3 *);
  Vec3 *(__fastcall *getInterpolatedRidingPosition)(Actor *this, Vec3 *result, float);
  float (__fastcall *getInterpolatedBodyRot)(Actor *this, float);
  float (__fastcall *getInterpolatedHeadRot)(Actor *this, float);
  float (__fastcall *getInterpolatedBodyYaw)(Actor *this, float);
  float (__fastcall *getYawSpeedInDegreesPerSecond)(Actor *this);
  float (__fastcall *getInterpolatedWalkAnimSpeed)(Actor *this, float);
  Vec3 *(__fastcall *getInterpolatedRidingOffset)(Actor *this, Vec3 *result, float);
  void (__fastcall *checkBlockCollisions)(Actor *this);
  void (__fastcall *checkBlockCollisions)(Actor *this, const AABB *, std::function&lt;void __cdecl(BlockSource &amp;,Block const &amp;,BlockPos const &amp;,Actor &amp;)&gt;);
  bool (__fastcall *isFireImmune)(Actor *this);
  bool (__fastcall *breaksFallingBlocks)(Actor *this);
  void (__fastcall *blockedByShield)(Actor *this, const ActorDamageSource *, Actor *);
  void (__fastcall *teleportTo)(Actor *this, const Vec3 *, bool, int, int, const ActorUniqueID *);
  bool (__fastcall *tryTeleportTo)(Actor *this, const Vec3 *, bool, bool, int, int);
  void (__fastcall *chorusFruitTeleport)(Actor *this, Vec3 *);
  void (__fastcall *lerpTo)(Actor *this, const Vec3 *, const Vec2 *, int);
  void (__fastcall *lerpMotion)(Actor *this, const Vec3 *);
  std::unique_ptr&lt;AddActorBasePacket&gt; *(__fastcall *getAddPacket)(Actor *this, std::unique_ptr&lt;AddActorBasePacket&gt; *result);
  void (__fastcall *normalTick)(Actor *this);
  void (__fastcall *baseTick)(Actor *this);
  void (__fastcall *rideTick)(Actor *this);
  void (__fastcall *positionRider)(Actor *this, Actor *, float);
  float (__fastcall *getRidingHeight)(Actor *this);
  bool (__fastcall *startRiding)(Actor *this, Actor *);
  void (__fastcall *addRider)(Actor *this, Actor *);
  void (__fastcall *flagRiderToRemove)(Actor *this, Actor *);
  std::string *(__fastcall *getExitTip)(Actor *this, std::string *result, const std::string *, InputMode);
  bool (__fastcall *intersects)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *, float);
  bool (__fastcall *isInWall)(Actor *this);
  bool (__fastcall *isInvisible)(Actor *this);
  bool (__fastcall *canShowNameTag)(Actor *this);
  bool (__fastcall *canExistInPeaceful)(Actor *this);
  void (__fastcall *setNameTagVisible)(Actor *this, bool);
  const std::string *(__fastcall *getNameTag)(Actor *this);
  unsigned __int64 (__fastcall *getNameTagAsHash)(Actor *this);
  std::string *(__fastcall *getFormattedNameTag)(Actor *this, std::string *result);
  void (__fastcall *filterFormattedNameTag)(Actor *this, const UIProfanityContext *);
  void (__fastcall *setNameTag)(Actor *this, const std::string *);
  bool (__fastcall *getAlwaysShowNameTag)(Actor *this);
  void (__fastcall *setScoreTag)(Actor *this, const std::string *);
  const std::string *(__fastcall *getScoreTag)(Actor *this);
  bool (__fastcall *isInWater)(Actor *this);
  bool (__fastcall *hasEnteredWater)(Actor *this);
  bool (__fastcall *isImmersedInWater)(Actor *this);
  bool (__fastcall *isInWaterOrRain)(Actor *this);
  bool (__fastcall *isInLava)(Actor *this);
  bool (__fastcall *isUnderLiquid)(Actor *this, MaterialType);
  bool (__fastcall *isOverWater)(Actor *this);
  void (__fastcall *makeStuckInBlock)(Actor *this, const Vec3 *);
  float (__fastcall *getCameraOffset)(Actor *this);
  float (__fastcall *getShadowHeightOffs)(Actor *this);
  float (__fastcall *getShadowRadius)(Actor *this);
  Vec3 *(__fastcall *getHeadLookVector)(Actor *this, Vec3 *result, float);
  bool (__fastcall *canSeeInvisible)(Actor *this);
  bool (__fastcall *canSee)(Actor *this, const Vec3 *);
  bool (__fastcall *canSee)(Actor *this, const Actor *);
  bool (__fastcall *isSkyLit)(Actor *this, float);
  float (__fastcall *getBrightness)(Actor *this, float);
  bool (__fastcall *interactPreventDefault)(Actor *this);
  void (__fastcall *playerTouch)(Actor *this, Player *);
  void (__fastcall *onAboveBubbleColumn)(Actor *this, const bool);
  void (__fastcall *onInsideBubbleColumn)(Actor *this, const bool);
  bool (__fastcall *isImmobile)(Actor *this);
  bool (__fastcall *isSilent)(Actor *this);
  bool (__fastcall *isPickable)(Actor *this);
  bool (__fastcall *isFishable)(Actor *this);
  bool (__fastcall *isSleeping)(Actor *this);
  bool (__fastcall *isShootable)(Actor *this);
  void (__fastcall *setSneaking)(Actor *this, bool);
  bool (__fastcall *isBlocking)(Actor *this);
  bool (__fastcall *isDamageBlocked)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *isAlive)(Actor *this);
  bool (__fastcall *isOnFire)(Actor *this);
  bool (__fastcall *isOnHotBlock)(Actor *this);
  bool (__fastcall *isCreativeModeAllowed)(Actor *this);
  bool (__fastcall *isSurfaceMob)(Actor *this);
  bool (__fastcall *isTargetable)(Actor *this);
  bool (__fastcall *isLocalPlayer)(Actor *this);
  bool (__fastcall *isPlayer)(Actor *this);
  bool (__fastcall *canAttack)(Actor *this, Actor *, bool);
  void (__fastcall *setTarget)(Actor *this, Actor *);
  Actor *(__fastcall *findAttackTarget)(Actor *this);
  bool (__fastcall *isValidTarget)(Actor *this, Actor *);
  bool (__fastcall *attack)(Actor *this, Actor *);
  void (__fastcall *performRangedAttack)(Actor *this, Actor *, float);
  void (__fastcall *adjustDamageAmount)(Actor *this, int *);
  int (__fastcall *getEquipmentCount)(Actor *this);
  void (__fastcall *setOwner)(Actor *this, const ActorUniqueID);
  void (__fastcall *setSitting)(Actor *this, bool);
  void (__fastcall *onTame)(Actor *this);
  void (__fastcall *onFailedTame)(Actor *this);
  int (__fastcall *getInventorySize)(Actor *this);
  int (__fastcall *getEquipSlots)(Actor *this);
  int (__fastcall *getChestSlots)(Actor *this);
  void (__fastcall *setStanding)(Actor *this, bool);
  bool (__fastcall *canPowerJump)(Actor *this);
  void (__fastcall *setCanPowerJump)(Actor *this, bool);
  bool (__fastcall *isJumping)(Actor *this);
  bool (__fastcall *isEnchanted)(Actor *this);
  void (__fastcall *rideJumped)(Actor *this);
  void (__fastcall *rideLanded)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *shouldRender)(Actor *this);
  bool (__fastcall *isInvulnerableTo)(Actor *this, const ActorDamageSource *);
  ActorDamageCause (__fastcall *getBlockDamageCause)(Actor *this, const Block *);
  void (__fastcall *actuallyHurt)(Actor *this, int, const ActorDamageSource *, bool);
  void (__fastcall *animateHurt)(Actor *this);
  bool (__fastcall *doFireHurt)(Actor *this, int);
  void (__fastcall *onLightningHit)(Actor *this);
  void (__fastcall *onBounceStarted)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *feed)(Actor *this, int);
  void (__fastcall *handleEntityEvent)(Actor *this, ActorEvent, int);
  float (__fastcall *getPickRadius)(Actor *this);
  const HashedString *(__fastcall *getActorRendererId)(Actor *this);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const ItemStack *, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int);
  void (__fastcall *despawn)(Actor *this);
  void (__fastcall *killed)(Actor *this, Actor *);
  void (__fastcall *awardKillScore)(Actor *this, Actor *, int);
  void (__fastcall *setArmor)(Actor *this, ArmorSlot, const ItemStack *);
  const ItemStack *(__fastcall *getArmor)(Actor *this, ArmorSlot);
  ArmorMaterialType (__fastcall *getArmorMaterialTypeInSlot)(Actor *this, ArmorSlot);
  ArmorTextureType (__fastcall *getArmorMaterialTextureTypeInSlot)(Actor *this, ArmorSlot);
  float (__fastcall *getArmorColorInSlot)(Actor *this, ArmorSlot, int);
  const ItemStack *(__fastcall *getEquippedSlot)(Actor *this, EquipmentSlot);
  void (__fastcall *setEquippedSlot)(Actor *this, EquipmentSlot, const ItemStack *);
  const ItemStack *(__fastcall *getCarriedItem)(Actor *this);
  void (__fastcall *setCarriedItem)(Actor *this, const ItemStack *);
  void (__fastcall *setOffhandSlot)(Actor *this, const ItemStack *);
  const ItemStack *(__fastcall *getEquippedTotem)(Actor *this);
  bool (__fastcall *consumeTotem)(Actor *this);
  bool (__fastcall *save)(Actor *this, CompoundTag *);
  void (__fastcall *saveWithoutId)(Actor *this, CompoundTag *);
  bool (__fastcall *load)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *loadLinks)(Actor *this, const CompoundTag *, std::vector&lt;ActorLink&gt; *, DataLoadHelper *);
  ActorType (__fastcall *getEntityTypeId)(Actor *this);
  const HashedString *(__fastcall *queryEntityRenderer)(Actor *this);
  ActorUniqueID *(__fastcall *getSourceUniqueID)(Actor *this, ActorUniqueID *result);
  void (__fastcall *setOnFire)(Actor *this, int);
  AABB *(__fastcall *getHandleWaterAABB)(Actor *this, AABB *result);
  void (__fastcall *handleInsidePortal)(Actor *this, const BlockPos *);
  int (__fastcall *getPortalCooldown)(Actor *this);
  int (__fastcall *getPortalWaitTime)(Actor *this);
  AutomaticID&lt;Dimension,int&gt; *(__fastcall *getDimensionId)(Actor *this, AutomaticID&lt;Dimension,int&gt; *result);
  bool (__fastcall *canChangeDimensions)(Actor *this);
  void (__fastcall *changeDimension)(Actor *this, const ChangeDimensionPacket *);
  void (__fastcall *changeDimension)(Actor *this, AutomaticID&lt;Dimension,int&gt;, bool);
  ActorUniqueID *(__fastcall *getControllingPlayer)(Actor *this, ActorUniqueID *result);
  void (__fastcall *checkFallDamage)(Actor *this, float, bool);
  void (__fastcall *causeFallDamage)(Actor *this, float);
  void (__fastcall *handleFallDistanceOnServer)(Actor *this, float, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, int, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, const Block *, bool);
  void (__fastcall *onSynchedDataUpdate)(Actor *this, int);
  bool (__fastcall *canAddRider)(Actor *this, Actor *);
  bool (__fastcall *canPickupItem)(Actor *this, const ItemStack *);
  bool (__fastcall *canBePulledIntoVehicle)(Actor *this);
  bool (__fastcall *inCaravan)(Actor *this);
  bool (__fastcall *isLeashableType)(Actor *this);
  void (__fastcall *tickLeash)(Actor *this);
  void (__fastcall *sendMotionPacketIfNeeded)(Actor *this);
  bool (__fastcall *canSynchronizeNewEntity)(Actor *this);
  bool (__fastcall *stopRiding)(Actor *this, bool, bool, bool, bool);
  void (__fastcall *startSwimming)(Actor *this);
  void (__fastcall *stopSwimming)(Actor *this);
  void (__fastcall *buildDebugInfo)(Actor *this, std::string *);
  CommandPermissionLevel (__fastcall *getCommandPermissionLevel)(Actor *this);
  AttributeInstance *(__fastcall *getMutableAttribute)(Actor *this, const Attribute *);
  const AttributeInstance *(__fastcall *getAttribute)(Actor *this, const Attribute *);
  int (__fastcall *getDeathTime)(Actor *this);
  void (__fastcall *heal)(Actor *this, int);
  bool (__fastcall *isInvertedHealAndHarm)(Actor *this);
  bool (__fastcall *canBeAffected)(Actor *this, const MobEffectInstance *);
  bool (__fastcall *canBeAffected)(Actor *this, int);
  bool (__fastcall *canBeAffectedByArrow)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectAdded)(Actor *this, MobEffectInstance *);
  void (__fastcall *onEffectUpdated)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectRemoved)(Actor *this, MobEffectInstance *);
  AnimationComponent *(__fastcall *getAnimationComponent)(Actor *this);
  void (__fastcall *openContainerComponent)(Actor *this, Player *);
  void (__fastcall *swing)(Actor *this);
  void (__fastcall *useItem)(Actor *this, ItemStackBase *, ItemUseMethod, bool);
  bool (__fastcall *hasOutputSignal)(Actor *this, unsigned __int8);
  int (__fastcall *getOutputSignal)(Actor *this);
  void (__fastcall *getDebugText)(Actor *this, std::vector&lt;std::string&gt; *);
  float (__fastcall *getMapDecorationRotation)(Actor *this);
  float (__fastcall *getRiderYRotation)(Actor *this, const Actor *);
  float (__fastcall *getYHeadRot)(Actor *this);
  bool (__fastcall *isWorldBuilder)(Actor *this);
  bool (__fastcall *isCreative)(Actor *this);
  bool (__fastcall *isAdventure)(Actor *this);
  bool (__fastcall *add)(Actor *this, ItemStack *);
  bool (__fastcall *drop)(Actor *this, const ItemStack *, bool);
  bool (__fastcall *getInteraction)(Actor *this, Player *, ActorInteraction *, const Vec3 *);
  bool (__fastcall *canDestroyBlock)(Actor *this, const Block *);
  void (__fastcall *setAuxValue)(Actor *this, int);
  void (__fastcall *setSize)(Actor *this, float, float);
  int (__fastcall *getLifeSpan)(Actor *this);
  void (__fastcall *onOrphan)(Actor *this);
  void (__fastcall *wobble)(Actor *this);
  bool (__fastcall *wasHurt)(Actor *this);
  void (__fastcall *startSpinAttack)(Actor *this);
  void (__fastcall *stopSpinAttack)(Actor *this);
  void (__fastcall *setDamageNearbyMobs)(Actor *this, bool);
  bool (__fastcall *hasCritBox)(Actor *this);
  bool (__fastcall *isCritHit)(Actor *this);
  void (__fastcall *renderDebugServerState)(Actor *this, const Options *);
  void (__fastcall *reloadLootTable)(Actor *this, const EquipmentTableDefinition *);
  void (__fastcall *reloadLootTable)(Actor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(Actor *this);
  void (__fastcall *kill)(Actor *this);
  void (__fastcall *die)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *shouldTick)(Actor *this);
  std::shared_ptr&lt;IActorMovementProxy&gt; *(__fastcall *createMovementProxy)(Actor *this, std::shared_ptr&lt;IActorMovementProxy&gt; *result);
  void (__fastcall *updateEntitySpecificMolangVariables)(Actor *this, RenderParams *);
  bool (__fastcall *shouldTryMakeStepSound)(Actor *this);
  float (__fastcall *getNextStep)(Actor *this, const float);
  bool (__fastcall *canMakeStepSound)(Actor *this);
  void (__fastcall *outOfWorld)(Actor *this);
  bool (__fastcall *_hurt)(Actor *this, const ActorDamageSource *, int, bool, bool);
  void (__fastcall *markHurt)(Actor *this);
  void (__fastcall *readAdditionalSaveData)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *addAdditionalSaveData)(Actor *this, CompoundTag *);
  void (__fastcall *_playStepSound)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *_playFlySound)(Actor *this, const BlockPos *, const Block *);
  bool (__fastcall *_makeFlySound)(Actor *this);
  void (__fastcall *checkInsideBlocks)(Actor *this, float);
  void (__fastcall *pushOutOfBlocks)(Actor *this, const Vec3 *);
  bool (__fastcall *updateWaterState)(Actor *this);
  void (__fastcall *doWaterSplashEffect)(Actor *this);
  void (__fastcall *spawnTrailBubbles)(Actor *this);
  void (__fastcall *updateInsideBlock)(Actor *this);
  LootTable *(__fastcall *getLootTable)(Actor *this);
  LootTable *(__fastcall *getDefaultLootTable)(Actor *this);
  void (__fastcall *_removeRider)(Actor *this, const ActorUniqueID *, bool, bool, bool);
  void (__fastcall *_onSizeUpdated)(Actor *this);
  void (__fastcall *_doAutoAttackOnTouch)(Actor *this, Actor *);
  void (__fastcall *knockback)(Mob *this, Actor *, int, float, float, float, float, float);
  void (__fastcall *resolveDeathLoot)(Mob *this, int, const ActorDamageSource *);
  void (__fastcall *spawnAnim)(Mob *this);
  void (__fastcall *setSleeping)(Mob *this, bool);
  void (__fastcall *setSprinting)(Mob *this, bool);
  void (__fastcall *playAmbientSound)(Mob *this);
  LevelSoundEvent (__fastcall *getAmbientSound)(Mob *this);
  int (__fastcall *getAmbientSoundPostponeTicks)(Mob *this);
  int (__fastcall *getAmbientSoundPostponeTicksRange)(Mob *this);
  const TextureUVCoordinateSet *(__fastcall *getItemInHandIcon)(Mob *this, const ItemStack *, int);
  float (__fastcall *getSpeed)(Mob *this);
  void (__fastcall *setSpeed)(Mob *this, float);
  float (__fastcall *getJumpPower)(Mob *this);
  bool (__fastcall *hurtEffects)(Mob *this, const ActorDamageSource *, int, bool, bool);
  int (__fastcall *getMeleeWeaponDamageBonus)(Mob *this, Mob *);
  int (__fastcall *getMeleeKnockbackBonus)(Mob *this);
  void (__fastcall *travel)(Mob *this, IMobMovementProxy *, float, float, float);
  void (__fastcall *travel)(Mob *this, float, float, float);
  void (__fastcall *applyFinalFriction)(Mob *this, float, bool);
  void (__fastcall *updateWalkAnim)(Mob *this);
  void (__fastcall *aiStep)(Mob *this, IMobMovementProxy *);
  void (__fastcall *aiStep)(Mob *this);
  void (__fastcall *pushActors)(Mob *this);
  void (__fastcall *lookAt)(Mob *this, Actor *, float, float);
  bool (__fastcall *isLookingAtAnEntity)(Mob *this);
  bool (__fastcall *checkSpawnRules)(Mob *this, bool);
  bool (__fastcall *checkSpawnObstruction)(Mob *this);
  float (__fastcall *getAttackAnim)(Mob *this, float);
  int (__fastcall *getItemUseDuration)(Mob *this);
  float (__fastcall *getItemUseStartupProgress)(Mob *this);
  float (__fastcall *getItemUseIntervalProgress)(Mob *this);
  int (__fastcall *getItemuseIntervalAxis)(Mob *this);
  int (__fastcall *getTimeAlongSwing)(Mob *this);
  void (__fastcall *ate)(Mob *this);
  float (__fastcall *getMaxHeadXRot)(Mob *this);
  Mob *(__fastcall *getLastHurtByMob)(Mob *this);
  void (__fastcall *setLastHurtByMob)(Mob *this, Mob *);
  Player *(__fastcall *getLastHurtByPlayer)(Mob *this);
  void (__fastcall *setLastHurtByPlayer)(Mob *this, Player *);
  Mob *(__fastcall *getLastHurtMob)(Mob *this);
  void (__fastcall *setLastHurtMob)(Mob *this, Actor *);
  bool (__fastcall *isAlliedTo)(Mob *this, Mob *);
  bool (__fastcall *doHurtTarget)(Mob *this, Actor *);
  bool (__fastcall *canBeControlledByRider)(Mob *this);
  void (__fastcall *leaveCaravan)(Mob *this);
  void (__fastcall *joinCaravan)(Mob *this, Mob *);
  bool (__fastcall *hasCaravanTail)(Mob *this);
  ActorUniqueID *(__fastcall *getCaravanHead)(Mob *this, ActorUniqueID *result);
  int (__fastcall *getArmorValue)(Mob *this);
  float (__fastcall *getArmorCoverPercentage)(Mob *this);
  void (__fastcall *hurtArmor)(Mob *this, const ActorDamageSource *, int, const std::bitset&lt;4&gt; *);
  void (__fastcall *hurtArmor)(Mob *this, const ActorDamageSource *, int);
  void (__fastcall *hurtArmorSlot)(Mob *this, const ActorDamageSource *, int, ArmorSlot);
  void (__fastcall *setDamagedArmor)(Mob *this, ArmorSlot, const ItemStack *);
  void (__fastcall *sendArmorDamage)(Mob *this, const std::bitset&lt;4&gt; *);
  void (__fastcall *sendArmor)(Mob *this, const std::bitset&lt;4&gt; *);
  void (__fastcall *containerChanged)(Mob *this, int);
  void (__fastcall *updateEquipment)(Mob *this);
  int (__fastcall *clearEquipment)(Mob *this);
  std::vector&lt;ItemStack const *&gt; *(__fastcall *getAllArmor)(Mob *this, std::vector&lt;ItemStack const *&gt; *result);
  std::vector&lt;int&gt; *(__fastcall *getAllArmorID)(Mob *this, std::vector&lt;int&gt; *result);
  std::vector&lt;ItemStack const *&gt; *(__fastcall *getAllHand)(Mob *this, std::vector&lt;ItemStack const *&gt; *result);
  std::vector&lt;ItemStack const *&gt; *(__fastcall *getAllEquipment)(Mob *this, std::vector&lt;ItemStack const *&gt; *result);
  int (__fastcall *getArmorTypeHash)(Mob *this);
  void (__fastcall *dropEquipmentOnDeath)(Mob *this);
  void (__fastcall *dropEquipmentOnDeath)(Mob *this, const ActorDamageSource *, int);
  void (__fastcall *clearVanishEnchantedItemsOnDeath)(Mob *this);
  void (__fastcall *sendInventory)(Mob *this, bool);
  int (__fastcall *getDamageAfterMagicAbsorb)(Mob *this, const ActorDamageSource *, int);
  bool (__fastcall *createAIGoals)(Mob *this);
  void (__fastcall *onBorn)(Mob *this, Actor *, Actor *);
  bool (__fastcall *setItemSlot)(Mob *this, EquipmentSlot, const ItemStack *);
  void (__fastcall *setTransitioningSitting)(Mob *this, bool);
  void (__fastcall *attackAnimation)(Mob *this, Actor *, float);
  int (__fastcall *getAttackTime)(Mob *this);
  float (__fastcall *_getWalkTargetValue)(Mob *this, const BlockPos *);
  bool (__fastcall *canExistWhenDisallowMob)(Mob *this);
  bool (__fastcall *useNewAi)(Mob *this);
  void (__fastcall *ascendLadder)(Mob *this);
  void (__fastcall *ascendScaffolding)(Mob *this);
  void (__fastcall *descendScaffolding)(Mob *this);
  void (__fastcall *dropContainer)(Mob *this);
  std::unique_ptr&lt;BodyControl&gt; *(__fastcall *initBodyControl)(Mob *this, std::unique_ptr&lt;BodyControl&gt; *result);
  void (__fastcall *jumpFromGround)(Mob *this, IMobMovementProxy *);
  void (__fastcall *jumpFromGround)(Mob *this);
  void (__fastcall *updateAi)(Mob *this);
  void (__fastcall *newServerAiStep)(Mob *this);
  void (__fastcall *_serverAiMobStep)(Mob *this);
  int (__fastcall *getDamageAfterEnchantReduction)(Mob *this, const ActorDamageSource *, int);
  int (__fastcall *getDamageAfterArmorAbsorb)(Mob *this, const ActorDamageSource *, int);
  void (__fastcall *dropBags)(Mob *this);
  void (__fastcall *tickDeath)(Mob *this);
  void (__fastcall *updateGliding)(Mob *this);
  bool (__fastcall *_allowAscendingScaffolding)(Mob *this);
  void (__fastcall *setType)(Horse *this, int);
  int (__fastcall *getType)(Horse *this);
  void (__fastcall *setHorseEating)(Horse *this, bool);
  float (__fastcall *getEatAnim)(Horse *this, float);
  float (__fastcall *getStandAnim)(Horse *this, float);
  float (__fastcall *getMouthAnim)(Horse *this, float);
  bool (__fastcall *canWearArmor)(Horse *this);
  bool (__fastcall *getHasReproduced)(Horse *this);
  void (__fastcall *setBred)(Horse *this, bool);
  void (__fastcall *setReproduced)(Horse *this, bool);
  bool (__fastcall *isAmuletHorse)(Horse *this);
  bool (__fastcall *isUndead)(Horse *this);
  bool (__fastcall *isSterile)(Horse *this);
  bool (__fastcall *isAdult)(Horse *this);
  bool (__fastcall *isHorseEating)(Horse *this);
  bool (__fastcall *isBred)(Horse *this);
  void (__fastcall *makeMad)(Horse *this);
  int (__fastcall *nameYOffset)(Horse *this);
  bool (__fastcall *tameToPlayer)(Horse *this, Player *, bool);
  std::string *(__fastcall *getMadSound)(Horse *this, std::string *result);
};

</code></pre></div><h3 id="humanoidmonster-vtbl"><a href="#humanoidmonster-vtbl" class="header-anchor">#</a> <code>HumanoidMonster_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ HumanoidMonster_vtbl
{
  bool (__fastcall *hasComponent)(Actor *this, const HashedString *);
  void (__fastcall *reloadHardcoded)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadHardcodedClient)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *initializeComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *_serverInitItemStackIds)(Actor *this);
  void (__fastcall *_doInitialMove)(Actor *this);
  bool (__fastcall *checkAllSensitiveWords)(Actor *this);
  bool (__fastcall *checkNameTag)(Actor *this);
  void (__fastcall *~Actor)(Actor *this);
  void (__fastcall *reset)(Actor *this);
  int (__fastcall *getOnDeathExperience)(Actor *this);
  ActorType (__fastcall *getOwnerEntityType)(Actor *this);
  void (__fastcall *remove)(Actor *this);
  void (__fastcall *setPos)(Actor *this, const Vec3 *);
  const PredictedMovementValues *(__fastcall *getPredictedMovementValues)(Actor *this);
  const Vec3 *(__fastcall *getPos)(Actor *this);
  const Vec3 *(__fastcall *getPosOld)(Actor *this);
  const Vec3 *(__fastcall *getPosExtrapolated)(Actor *this, const Vec3 *result, float);
  Vec3 *(__fastcall *getAttachPos)(Actor *this, Vec3 *result, ActorLocation, float);
  Vec3 *(__fastcall *getFiringPos)(Actor *this, Vec3 *result);
  void (__fastcall *setRot)(Actor *this, const Vec2 *);
  void (__fastcall *move)(Actor *this, IActorMovementProxy *, const Vec3 *);
  void (__fastcall *move)(Actor *this, const Vec3 *);
  Vec3 *(__fastcall *getInterpolatedRidingPosition)(Actor *this, Vec3 *result, float);
  float (__fastcall *getInterpolatedBodyRot)(Actor *this, float);
  float (__fastcall *getInterpolatedHeadRot)(Actor *this, float);
  float (__fastcall *getInterpolatedBodyYaw)(Actor *this, float);
  float (__fastcall *getYawSpeedInDegreesPerSecond)(Actor *this);
  float (__fastcall *getInterpolatedWalkAnimSpeed)(Actor *this, float);
  Vec3 *(__fastcall *getInterpolatedRidingOffset)(Actor *this, Vec3 *result, float);
  void (__fastcall *checkBlockCollisions)(Actor *this);
  void (__fastcall *checkBlockCollisions)(Actor *this, const AABB *, std::function&lt;void __cdecl(BlockSource &amp;,Block const &amp;,BlockPos const &amp;,Actor &amp;)&gt;);
  bool (__fastcall *isFireImmune)(Actor *this);
  bool (__fastcall *breaksFallingBlocks)(Actor *this);
  void (__fastcall *blockedByShield)(Actor *this, const ActorDamageSource *, Actor *);
  void (__fastcall *teleportTo)(Actor *this, const Vec3 *, bool, int, int, const ActorUniqueID *);
  bool (__fastcall *tryTeleportTo)(Actor *this, const Vec3 *, bool, bool, int, int);
  void (__fastcall *chorusFruitTeleport)(Actor *this, Vec3 *);
  void (__fastcall *lerpTo)(Actor *this, const Vec3 *, const Vec2 *, int);
  void (__fastcall *lerpMotion)(Actor *this, const Vec3 *);
  std::unique_ptr&lt;AddActorBasePacket&gt; *(__fastcall *getAddPacket)(Actor *this, std::unique_ptr&lt;AddActorBasePacket&gt; *result);
  void (__fastcall *normalTick)(Actor *this);
  void (__fastcall *baseTick)(Actor *this);
  void (__fastcall *rideTick)(Actor *this);
  void (__fastcall *positionRider)(Actor *this, Actor *, float);
  float (__fastcall *getRidingHeight)(Actor *this);
  bool (__fastcall *startRiding)(Actor *this, Actor *);
  void (__fastcall *addRider)(Actor *this, Actor *);
  void (__fastcall *flagRiderToRemove)(Actor *this, Actor *);
  std::string *(__fastcall *getExitTip)(Actor *this, std::string *result, const std::string *, InputMode);
  bool (__fastcall *intersects)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *, float);
  bool (__fastcall *isInWall)(Actor *this);
  bool (__fastcall *isInvisible)(Actor *this);
  bool (__fastcall *canShowNameTag)(Actor *this);
  bool (__fastcall *canExistInPeaceful)(Actor *this);
  void (__fastcall *setNameTagVisible)(Actor *this, bool);
  const std::string *(__fastcall *getNameTag)(Actor *this);
  unsigned __int64 (__fastcall *getNameTagAsHash)(Actor *this);
  std::string *(__fastcall *getFormattedNameTag)(Actor *this, std::string *result);
  void (__fastcall *filterFormattedNameTag)(Actor *this, const UIProfanityContext *);
  void (__fastcall *setNameTag)(Actor *this, const std::string *);
  bool (__fastcall *getAlwaysShowNameTag)(Actor *this);
  void (__fastcall *setScoreTag)(Actor *this, const std::string *);
  const std::string *(__fastcall *getScoreTag)(Actor *this);
  bool (__fastcall *isInWater)(Actor *this);
  bool (__fastcall *hasEnteredWater)(Actor *this);
  bool (__fastcall *isImmersedInWater)(Actor *this);
  bool (__fastcall *isInWaterOrRain)(Actor *this);
  bool (__fastcall *isInLava)(Actor *this);
  bool (__fastcall *isUnderLiquid)(Actor *this, MaterialType);
  bool (__fastcall *isOverWater)(Actor *this);
  void (__fastcall *makeStuckInBlock)(Actor *this, const Vec3 *);
  float (__fastcall *getCameraOffset)(Actor *this);
  float (__fastcall *getShadowHeightOffs)(Actor *this);
  float (__fastcall *getShadowRadius)(Actor *this);
  Vec3 *(__fastcall *getHeadLookVector)(Actor *this, Vec3 *result, float);
  bool (__fastcall *canSeeInvisible)(Actor *this);
  bool (__fastcall *canSee)(Actor *this, const Vec3 *);
  bool (__fastcall *canSee)(Actor *this, const Actor *);
  bool (__fastcall *isSkyLit)(Actor *this, float);
  float (__fastcall *getBrightness)(Actor *this, float);
  bool (__fastcall *interactPreventDefault)(Actor *this);
  void (__fastcall *playerTouch)(Actor *this, Player *);
  void (__fastcall *onAboveBubbleColumn)(Actor *this, const bool);
  void (__fastcall *onInsideBubbleColumn)(Actor *this, const bool);
  bool (__fastcall *isImmobile)(Actor *this);
  bool (__fastcall *isSilent)(Actor *this);
  bool (__fastcall *isPickable)(Actor *this);
  bool (__fastcall *isFishable)(Actor *this);
  bool (__fastcall *isSleeping)(Actor *this);
  bool (__fastcall *isShootable)(Actor *this);
  void (__fastcall *setSneaking)(Actor *this, bool);
  bool (__fastcall *isBlocking)(Actor *this);
  bool (__fastcall *isDamageBlocked)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *isAlive)(Actor *this);
  bool (__fastcall *isOnFire)(Actor *this);
  bool (__fastcall *isOnHotBlock)(Actor *this);
  bool (__fastcall *isCreativeModeAllowed)(Actor *this);
  bool (__fastcall *isSurfaceMob)(Actor *this);
  bool (__fastcall *isTargetable)(Actor *this);
  bool (__fastcall *isLocalPlayer)(Actor *this);
  bool (__fastcall *isPlayer)(Actor *this);
  bool (__fastcall *canAttack)(Actor *this, Actor *, bool);
  void (__fastcall *setTarget)(Actor *this, Actor *);
  Actor *(__fastcall *findAttackTarget)(Actor *this);
  bool (__fastcall *isValidTarget)(Actor *this, Actor *);
  bool (__fastcall *attack)(Actor *this, Actor *);
  void (__fastcall *performRangedAttack)(Actor *this, Actor *, float);
  void (__fastcall *adjustDamageAmount)(Actor *this, int *);
  int (__fastcall *getEquipmentCount)(Actor *this);
  void (__fastcall *setOwner)(Actor *this, const ActorUniqueID);
  void (__fastcall *setSitting)(Actor *this, bool);
  void (__fastcall *onTame)(Actor *this);
  void (__fastcall *onFailedTame)(Actor *this);
  int (__fastcall *getInventorySize)(Actor *this);
  int (__fastcall *getEquipSlots)(Actor *this);
  int (__fastcall *getChestSlots)(Actor *this);
  void (__fastcall *setStanding)(Actor *this, bool);
  bool (__fastcall *canPowerJump)(Actor *this);
  void (__fastcall *setCanPowerJump)(Actor *this, bool);
  bool (__fastcall *isJumping)(Actor *this);
  bool (__fastcall *isEnchanted)(Actor *this);
  void (__fastcall *rideJumped)(Actor *this);
  void (__fastcall *rideLanded)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *shouldRender)(Actor *this);
  bool (__fastcall *isInvulnerableTo)(Actor *this, const ActorDamageSource *);
  ActorDamageCause (__fastcall *getBlockDamageCause)(Actor *this, const Block *);
  void (__fastcall *actuallyHurt)(Actor *this, int, const ActorDamageSource *, bool);
  void (__fastcall *animateHurt)(Actor *this);
  bool (__fastcall *doFireHurt)(Actor *this, int);
  void (__fastcall *onLightningHit)(Actor *this);
  void (__fastcall *onBounceStarted)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *feed)(Actor *this, int);
  void (__fastcall *handleEntityEvent)(Actor *this, ActorEvent, int);
  float (__fastcall *getPickRadius)(Actor *this);
  const HashedString *(__fastcall *getActorRendererId)(Actor *this);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const ItemStack *, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int);
  void (__fastcall *despawn)(Actor *this);
  void (__fastcall *killed)(Actor *this, Actor *);
  void (__fastcall *awardKillScore)(Actor *this, Actor *, int);
  void (__fastcall *setArmor)(Actor *this, ArmorSlot, const ItemStack *);
  const ItemStack *(__fastcall *getArmor)(Actor *this, ArmorSlot);
  ArmorMaterialType (__fastcall *getArmorMaterialTypeInSlot)(Actor *this, ArmorSlot);
  ArmorTextureType (__fastcall *getArmorMaterialTextureTypeInSlot)(Actor *this, ArmorSlot);
  float (__fastcall *getArmorColorInSlot)(Actor *this, ArmorSlot, int);
  const ItemStack *(__fastcall *getEquippedSlot)(Actor *this, EquipmentSlot);
  void (__fastcall *setEquippedSlot)(Actor *this, EquipmentSlot, const ItemStack *);
  const ItemStack *(__fastcall *getCarriedItem)(Actor *this);
  void (__fastcall *setCarriedItem)(Actor *this, const ItemStack *);
  void (__fastcall *setOffhandSlot)(Actor *this, const ItemStack *);
  const ItemStack *(__fastcall *getEquippedTotem)(Actor *this);
  bool (__fastcall *consumeTotem)(Actor *this);
  bool (__fastcall *save)(Actor *this, CompoundTag *);
  void (__fastcall *saveWithoutId)(Actor *this, CompoundTag *);
  bool (__fastcall *load)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *loadLinks)(Actor *this, const CompoundTag *, std::vector&lt;ActorLink&gt; *, DataLoadHelper *);
  ActorType (__fastcall *getEntityTypeId)(Actor *this);
  const HashedString *(__fastcall *queryEntityRenderer)(Actor *this);
  ActorUniqueID *(__fastcall *getSourceUniqueID)(Actor *this, ActorUniqueID *result);
  void (__fastcall *setOnFire)(Actor *this, int);
  AABB *(__fastcall *getHandleWaterAABB)(Actor *this, AABB *result);
  void (__fastcall *handleInsidePortal)(Actor *this, const BlockPos *);
  int (__fastcall *getPortalCooldown)(Actor *this);
  int (__fastcall *getPortalWaitTime)(Actor *this);
  AutomaticID&lt;Dimension,int&gt; *(__fastcall *getDimensionId)(Actor *this, AutomaticID&lt;Dimension,int&gt; *result);
  bool (__fastcall *canChangeDimensions)(Actor *this);
  void (__fastcall *changeDimension)(Actor *this, const ChangeDimensionPacket *);
  void (__fastcall *changeDimension)(Actor *this, AutomaticID&lt;Dimension,int&gt;, bool);
  ActorUniqueID *(__fastcall *getControllingPlayer)(Actor *this, ActorUniqueID *result);
  void (__fastcall *checkFallDamage)(Actor *this, float, bool);
  void (__fastcall *causeFallDamage)(Actor *this, float);
  void (__fastcall *handleFallDistanceOnServer)(Actor *this, float, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, int, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, const Block *, bool);
  void (__fastcall *onSynchedDataUpdate)(Actor *this, int);
  bool (__fastcall *canAddRider)(Actor *this, Actor *);
  bool (__fastcall *canPickupItem)(Actor *this, const ItemStack *);
  bool (__fastcall *canBePulledIntoVehicle)(Actor *this);
  bool (__fastcall *inCaravan)(Actor *this);
  bool (__fastcall *isLeashableType)(Actor *this);
  void (__fastcall *tickLeash)(Actor *this);
  void (__fastcall *sendMotionPacketIfNeeded)(Actor *this);
  bool (__fastcall *canSynchronizeNewEntity)(Actor *this);
  bool (__fastcall *stopRiding)(Actor *this, bool, bool, bool, bool);
  void (__fastcall *startSwimming)(Actor *this);
  void (__fastcall *stopSwimming)(Actor *this);
  void (__fastcall *buildDebugInfo)(Actor *this, std::string *);
  CommandPermissionLevel (__fastcall *getCommandPermissionLevel)(Actor *this);
  AttributeInstance *(__fastcall *getMutableAttribute)(Actor *this, const Attribute *);
  const AttributeInstance *(__fastcall *getAttribute)(Actor *this, const Attribute *);
  int (__fastcall *getDeathTime)(Actor *this);
  void (__fastcall *heal)(Actor *this, int);
  bool (__fastcall *isInvertedHealAndHarm)(Actor *this);
  bool (__fastcall *canBeAffected)(Actor *this, const MobEffectInstance *);
  bool (__fastcall *canBeAffected)(Actor *this, int);
  bool (__fastcall *canBeAffectedByArrow)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectAdded)(Actor *this, MobEffectInstance *);
  void (__fastcall *onEffectUpdated)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectRemoved)(Actor *this, MobEffectInstance *);
  AnimationComponent *(__fastcall *getAnimationComponent)(Actor *this);
  void (__fastcall *openContainerComponent)(Actor *this, Player *);
  void (__fastcall *swing)(Actor *this);
  void (__fastcall *useItem)(Actor *this, ItemStackBase *, ItemUseMethod, bool);
  bool (__fastcall *hasOutputSignal)(Actor *this, unsigned __int8);
  int (__fastcall *getOutputSignal)(Actor *this);
  void (__fastcall *getDebugText)(Actor *this, std::vector&lt;std::string&gt; *);
  float (__fastcall *getMapDecorationRotation)(Actor *this);
  float (__fastcall *getRiderYRotation)(Actor *this, const Actor *);
  float (__fastcall *getYHeadRot)(Actor *this);
  bool (__fastcall *isWorldBuilder)(Actor *this);
  bool (__fastcall *isCreative)(Actor *this);
  bool (__fastcall *isAdventure)(Actor *this);
  bool (__fastcall *add)(Actor *this, ItemStack *);
  bool (__fastcall *drop)(Actor *this, const ItemStack *, bool);
  bool (__fastcall *getInteraction)(Actor *this, Player *, ActorInteraction *, const Vec3 *);
  bool (__fastcall *canDestroyBlock)(Actor *this, const Block *);
  void (__fastcall *setAuxValue)(Actor *this, int);
  void (__fastcall *setSize)(Actor *this, float, float);
  int (__fastcall *getLifeSpan)(Actor *this);
  void (__fastcall *onOrphan)(Actor *this);
  void (__fastcall *wobble)(Actor *this);
  bool (__fastcall *wasHurt)(Actor *this);
  void (__fastcall *startSpinAttack)(Actor *this);
  void (__fastcall *stopSpinAttack)(Actor *this);
  void (__fastcall *setDamageNearbyMobs)(Actor *this, bool);
  bool (__fastcall *hasCritBox)(Actor *this);
  bool (__fastcall *isCritHit)(Actor *this);
  void (__fastcall *renderDebugServerState)(Actor *this, const Options *);
  void (__fastcall *reloadLootTable)(Actor *this, const EquipmentTableDefinition *);
  void (__fastcall *reloadLootTable)(Actor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(Actor *this);
  void (__fastcall *kill)(Actor *this);
  void (__fastcall *die)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *shouldTick)(Actor *this);
  std::shared_ptr&lt;IActorMovementProxy&gt; *(__fastcall *createMovementProxy)(Actor *this, std::shared_ptr&lt;IActorMovementProxy&gt; *result);
  void (__fastcall *updateEntitySpecificMolangVariables)(Actor *this, RenderParams *);
  bool (__fastcall *shouldTryMakeStepSound)(Actor *this);
  float (__fastcall *getNextStep)(Actor *this, const float);
  bool (__fastcall *canMakeStepSound)(Actor *this);
  void (__fastcall *outOfWorld)(Actor *this);
  bool (__fastcall *_hurt)(Actor *this, const ActorDamageSource *, int, bool, bool);
  void (__fastcall *markHurt)(Actor *this);
  void (__fastcall *readAdditionalSaveData)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *addAdditionalSaveData)(Actor *this, CompoundTag *);
  void (__fastcall *_playStepSound)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *_playFlySound)(Actor *this, const BlockPos *, const Block *);
  bool (__fastcall *_makeFlySound)(Actor *this);
  void (__fastcall *checkInsideBlocks)(Actor *this, float);
  void (__fastcall *pushOutOfBlocks)(Actor *this, const Vec3 *);
  bool (__fastcall *updateWaterState)(Actor *this);
  void (__fastcall *doWaterSplashEffect)(Actor *this);
  void (__fastcall *spawnTrailBubbles)(Actor *this);
  void (__fastcall *updateInsideBlock)(Actor *this);
  LootTable *(__fastcall *getLootTable)(Actor *this);
  LootTable *(__fastcall *getDefaultLootTable)(Actor *this);
  void (__fastcall *_removeRider)(Actor *this, const ActorUniqueID *, bool, bool, bool);
  void (__fastcall *_onSizeUpdated)(Actor *this);
  void (__fastcall *_doAutoAttackOnTouch)(Actor *this, Actor *);
  void (__fastcall *knockback)(Mob *this, Actor *, int, float, float, float, float, float);
  void (__fastcall *resolveDeathLoot)(Mob *this, int, const ActorDamageSource *);
  void (__fastcall *spawnAnim)(Mob *this);
  void (__fastcall *setSleeping)(Mob *this, bool);
  void (__fastcall *setSprinting)(Mob *this, bool);
  void (__fastcall *playAmbientSound)(Mob *this);
  LevelSoundEvent (__fastcall *getAmbientSound)(Mob *this);
  int (__fastcall *getAmbientSoundPostponeTicks)(Mob *this);
  int (__fastcall *getAmbientSoundPostponeTicksRange)(Mob *this);
  const TextureUVCoordinateSet *(__fastcall *getItemInHandIcon)(Mob *this, const ItemStack *, int);
  float (__fastcall *getSpeed)(Mob *this);
  void (__fastcall *setSpeed)(Mob *this, float);
  float (__fastcall *getJumpPower)(Mob *this);
  bool (__fastcall *hurtEffects)(Mob *this, const ActorDamageSource *, int, bool, bool);
  int (__fastcall *getMeleeWeaponDamageBonus)(Mob *this, Mob *);
  int (__fastcall *getMeleeKnockbackBonus)(Mob *this);
  void (__fastcall *travel)(Mob *this, IMobMovementProxy *, float, float, float);
  void (__fastcall *travel)(Mob *this, float, float, float);
  void (__fastcall *applyFinalFriction)(Mob *this, float, bool);
  void (__fastcall *updateWalkAnim)(Mob *this);
  void (__fastcall *aiStep)(Mob *this, IMobMovementProxy *);
  void (__fastcall *aiStep)(Mob *this);
  void (__fastcall *pushActors)(Mob *this);
  void (__fastcall *lookAt)(Mob *this, Actor *, float, float);
  bool (__fastcall *isLookingAtAnEntity)(Mob *this);
  bool (__fastcall *checkSpawnRules)(Mob *this, bool);
  bool (__fastcall *checkSpawnObstruction)(Mob *this);
  float (__fastcall *getAttackAnim)(Mob *this, float);
  int (__fastcall *getItemUseDuration)(Mob *this);
  float (__fastcall *getItemUseStartupProgress)(Mob *this);
  float (__fastcall *getItemUseIntervalProgress)(Mob *this);
  int (__fastcall *getItemuseIntervalAxis)(Mob *this);
  int (__fastcall *getTimeAlongSwing)(Mob *this);
  void (__fastcall *ate)(Mob *this);
  float (__fastcall *getMaxHeadXRot)(Mob *this);
  Mob *(__fastcall *getLastHurtByMob)(Mob *this);
  void (__fastcall *setLastHurtByMob)(Mob *this, Mob *);
  Player *(__fastcall *getLastHurtByPlayer)(Mob *this);
  void (__fastcall *setLastHurtByPlayer)(Mob *this, Player *);
  Mob *(__fastcall *getLastHurtMob)(Mob *this);
  void (__fastcall *setLastHurtMob)(Mob *this, Actor *);
  bool (__fastcall *isAlliedTo)(Mob *this, Mob *);
  bool (__fastcall *doHurtTarget)(Mob *this, Actor *);
  bool (__fastcall *canBeControlledByRider)(Mob *this);
  void (__fastcall *leaveCaravan)(Mob *this);
  void (__fastcall *joinCaravan)(Mob *this, Mob *);
  bool (__fastcall *hasCaravanTail)(Mob *this);
  ActorUniqueID *(__fastcall *getCaravanHead)(Mob *this, ActorUniqueID *result);
  int (__fastcall *getArmorValue)(Mob *this);
  float (__fastcall *getArmorCoverPercentage)(Mob *this);
  void (__fastcall *hurtArmor)(Mob *this, const ActorDamageSource *, int, const std::bitset&lt;4&gt; *);
  void (__fastcall *hurtArmor)(Mob *this, const ActorDamageSource *, int);
  void (__fastcall *hurtArmorSlot)(Mob *this, const ActorDamageSource *, int, ArmorSlot);
  void (__fastcall *setDamagedArmor)(Mob *this, ArmorSlot, const ItemStack *);
  void (__fastcall *sendArmorDamage)(Mob *this, const std::bitset&lt;4&gt; *);
  void (__fastcall *sendArmor)(Mob *this, const std::bitset&lt;4&gt; *);
  void (__fastcall *containerChanged)(Mob *this, int);
  void (__fastcall *updateEquipment)(Mob *this);
  int (__fastcall *clearEquipment)(Mob *this);
  std::vector&lt;ItemStack const *&gt; *(__fastcall *getAllArmor)(Mob *this, std::vector&lt;ItemStack const *&gt; *result);
  std::vector&lt;int&gt; *(__fastcall *getAllArmorID)(Mob *this, std::vector&lt;int&gt; *result);
  std::vector&lt;ItemStack const *&gt; *(__fastcall *getAllHand)(Mob *this, std::vector&lt;ItemStack const *&gt; *result);
  std::vector&lt;ItemStack const *&gt; *(__fastcall *getAllEquipment)(Mob *this, std::vector&lt;ItemStack const *&gt; *result);
  int (__fastcall *getArmorTypeHash)(Mob *this);
  void (__fastcall *dropEquipmentOnDeath)(Mob *this);
  void (__fastcall *dropEquipmentOnDeath)(Mob *this, const ActorDamageSource *, int);
  void (__fastcall *clearVanishEnchantedItemsOnDeath)(Mob *this);
  void (__fastcall *sendInventory)(Mob *this, bool);
  int (__fastcall *getDamageAfterMagicAbsorb)(Mob *this, const ActorDamageSource *, int);
  bool (__fastcall *createAIGoals)(Mob *this);
  void (__fastcall *onBorn)(Mob *this, Actor *, Actor *);
  bool (__fastcall *setItemSlot)(Mob *this, EquipmentSlot, const ItemStack *);
  void (__fastcall *setTransitioningSitting)(Mob *this, bool);
  void (__fastcall *attackAnimation)(Mob *this, Actor *, float);
  int (__fastcall *getAttackTime)(Mob *this);
  float (__fastcall *_getWalkTargetValue)(Mob *this, const BlockPos *);
  bool (__fastcall *canExistWhenDisallowMob)(Mob *this);
  bool (__fastcall *useNewAi)(Mob *this);
  void (__fastcall *ascendLadder)(Mob *this);
  void (__fastcall *ascendScaffolding)(Mob *this);
  void (__fastcall *descendScaffolding)(Mob *this);
  void (__fastcall *dropContainer)(Mob *this);
  std::unique_ptr&lt;BodyControl&gt; *(__fastcall *initBodyControl)(Mob *this, std::unique_ptr&lt;BodyControl&gt; *result);
  void (__fastcall *jumpFromGround)(Mob *this, IMobMovementProxy *);
  void (__fastcall *jumpFromGround)(Mob *this);
  void (__fastcall *updateAi)(Mob *this);
  void (__fastcall *newServerAiStep)(Mob *this);
  void (__fastcall *_serverAiMobStep)(Mob *this);
  int (__fastcall *getDamageAfterEnchantReduction)(Mob *this, const ActorDamageSource *, int);
  int (__fastcall *getDamageAfterArmorAbsorb)(Mob *this, const ActorDamageSource *, int);
  void (__fastcall *dropBags)(Mob *this);
  void (__fastcall *tickDeath)(Mob *this);
  void (__fastcall *updateGliding)(Mob *this);
  bool (__fastcall *_allowAscendingScaffolding)(Mob *this);
  bool (__fastcall *isDarkEnoughToSpawn)(Monster *this);
};

</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      
      <a href="/mcstructure/1.16.201/structure/G.html" class="prev">
        G
      </a></span> <span class="next"><a href="/mcstructure/1.16.201/structure/I.html">
        I
      </a>
      
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/mcstructure/assets/js/app.56b0ab36.js" defer></script><script src="/mcstructure/assets/js/2.56e23786.js" defer></script><script src="/mcstructure/assets/js/113.a961fd7d.js" defer></script>
  </body>
</html>
