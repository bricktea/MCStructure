<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>S~3 | MC TIL</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Some structure and enum information for minecraft bedrock edition.">
    
    <link rel="preload" href="/mcstructure/assets/css/0.styles.5de0a167.css" as="style"><link rel="preload" href="/mcstructure/assets/js/app.56b0ab36.js" as="script"><link rel="preload" href="/mcstructure/assets/js/2.56e23786.js" as="script"><link rel="preload" href="/mcstructure/assets/js/139.5e9afeaa.js" as="script"><link rel="prefetch" href="/mcstructure/assets/js/10.dda8da32.js"><link rel="prefetch" href="/mcstructure/assets/js/100.d193fca3.js"><link rel="prefetch" href="/mcstructure/assets/js/101.324df8d1.js"><link rel="prefetch" href="/mcstructure/assets/js/102.81d32953.js"><link rel="prefetch" href="/mcstructure/assets/js/103.bafffe55.js"><link rel="prefetch" href="/mcstructure/assets/js/104.4a4116d4.js"><link rel="prefetch" href="/mcstructure/assets/js/105.ee5ab7c3.js"><link rel="prefetch" href="/mcstructure/assets/js/106.16520c01.js"><link rel="prefetch" href="/mcstructure/assets/js/107.e4e2fef9.js"><link rel="prefetch" href="/mcstructure/assets/js/108.9771cecd.js"><link rel="prefetch" href="/mcstructure/assets/js/109.07a059f8.js"><link rel="prefetch" href="/mcstructure/assets/js/11.84aff5f4.js"><link rel="prefetch" href="/mcstructure/assets/js/110.79e73184.js"><link rel="prefetch" href="/mcstructure/assets/js/111.735fe11b.js"><link rel="prefetch" href="/mcstructure/assets/js/112.5b8c9633.js"><link rel="prefetch" href="/mcstructure/assets/js/113.a961fd7d.js"><link rel="prefetch" href="/mcstructure/assets/js/114.f46e6ac6.js"><link rel="prefetch" href="/mcstructure/assets/js/115.29d129b9.js"><link rel="prefetch" href="/mcstructure/assets/js/116.0761604d.js"><link rel="prefetch" href="/mcstructure/assets/js/117.8fa51bbe.js"><link rel="prefetch" href="/mcstructure/assets/js/118.65b68c09.js"><link rel="prefetch" href="/mcstructure/assets/js/119.0b88b1c0.js"><link rel="prefetch" href="/mcstructure/assets/js/12.fb0b2343.js"><link rel="prefetch" href="/mcstructure/assets/js/120.6514cc60.js"><link rel="prefetch" href="/mcstructure/assets/js/121.30792057.js"><link rel="prefetch" href="/mcstructure/assets/js/122.ac6c9052.js"><link rel="prefetch" href="/mcstructure/assets/js/123.9dde14ff.js"><link rel="prefetch" href="/mcstructure/assets/js/124.1b8cd48f.js"><link rel="prefetch" href="/mcstructure/assets/js/125.ba14f223.js"><link rel="prefetch" href="/mcstructure/assets/js/126.5dd69ba6.js"><link rel="prefetch" href="/mcstructure/assets/js/127.32df8d72.js"><link rel="prefetch" href="/mcstructure/assets/js/128.aa9a14cc.js"><link rel="prefetch" href="/mcstructure/assets/js/129.d7a703a5.js"><link rel="prefetch" href="/mcstructure/assets/js/13.b8437649.js"><link rel="prefetch" href="/mcstructure/assets/js/130.d8f7ecf5.js"><link rel="prefetch" href="/mcstructure/assets/js/131.0c1d33fe.js"><link rel="prefetch" href="/mcstructure/assets/js/132.8b6e6ff3.js"><link rel="prefetch" href="/mcstructure/assets/js/133.f999118d.js"><link rel="prefetch" href="/mcstructure/assets/js/134.bc4a2893.js"><link rel="prefetch" href="/mcstructure/assets/js/135.e6e793b3.js"><link rel="prefetch" href="/mcstructure/assets/js/136.c50dcaff.js"><link rel="prefetch" href="/mcstructure/assets/js/137.209d5c8a.js"><link rel="prefetch" href="/mcstructure/assets/js/138.3eed47db.js"><link rel="prefetch" href="/mcstructure/assets/js/14.c94aa248.js"><link rel="prefetch" href="/mcstructure/assets/js/140.ac85c96f.js"><link rel="prefetch" href="/mcstructure/assets/js/141.82f0f06f.js"><link rel="prefetch" href="/mcstructure/assets/js/142.08052153.js"><link rel="prefetch" href="/mcstructure/assets/js/143.97d16176.js"><link rel="prefetch" href="/mcstructure/assets/js/144.66c74f2b.js"><link rel="prefetch" href="/mcstructure/assets/js/145.58e96ed1.js"><link rel="prefetch" href="/mcstructure/assets/js/146.4c73b3b4.js"><link rel="prefetch" href="/mcstructure/assets/js/147.0e0e09a7.js"><link rel="prefetch" href="/mcstructure/assets/js/148.a8c2c253.js"><link rel="prefetch" href="/mcstructure/assets/js/149.99f1b4f1.js"><link rel="prefetch" href="/mcstructure/assets/js/15.fd6df6e3.js"><link rel="prefetch" href="/mcstructure/assets/js/16.855c8adf.js"><link rel="prefetch" href="/mcstructure/assets/js/17.860009b0.js"><link rel="prefetch" href="/mcstructure/assets/js/18.63105a6b.js"><link rel="prefetch" href="/mcstructure/assets/js/19.fbddb16b.js"><link rel="prefetch" href="/mcstructure/assets/js/20.605578ab.js"><link rel="prefetch" href="/mcstructure/assets/js/21.1e5adf90.js"><link rel="prefetch" href="/mcstructure/assets/js/22.29bfa69a.js"><link rel="prefetch" href="/mcstructure/assets/js/23.566201a2.js"><link rel="prefetch" href="/mcstructure/assets/js/24.d912e845.js"><link rel="prefetch" href="/mcstructure/assets/js/25.8885d257.js"><link rel="prefetch" href="/mcstructure/assets/js/26.8409713f.js"><link rel="prefetch" href="/mcstructure/assets/js/27.49cb5267.js"><link rel="prefetch" href="/mcstructure/assets/js/28.2a890355.js"><link rel="prefetch" href="/mcstructure/assets/js/29.6ea7598b.js"><link rel="prefetch" href="/mcstructure/assets/js/3.50967458.js"><link rel="prefetch" href="/mcstructure/assets/js/30.1a3c3902.js"><link rel="prefetch" href="/mcstructure/assets/js/31.24ec9e8b.js"><link rel="prefetch" href="/mcstructure/assets/js/32.40831503.js"><link rel="prefetch" href="/mcstructure/assets/js/33.6602f7d9.js"><link rel="prefetch" href="/mcstructure/assets/js/34.75d333d9.js"><link rel="prefetch" href="/mcstructure/assets/js/35.84bf3e5a.js"><link rel="prefetch" href="/mcstructure/assets/js/36.fe4e7307.js"><link rel="prefetch" href="/mcstructure/assets/js/37.b2ee95ad.js"><link rel="prefetch" href="/mcstructure/assets/js/38.c03d5dee.js"><link rel="prefetch" href="/mcstructure/assets/js/39.a60df6e0.js"><link rel="prefetch" href="/mcstructure/assets/js/4.f5835878.js"><link rel="prefetch" href="/mcstructure/assets/js/40.6322a006.js"><link rel="prefetch" href="/mcstructure/assets/js/41.420acfde.js"><link rel="prefetch" href="/mcstructure/assets/js/42.a4ef9cfe.js"><link rel="prefetch" href="/mcstructure/assets/js/43.660cc3cf.js"><link rel="prefetch" href="/mcstructure/assets/js/44.683fc1e0.js"><link rel="prefetch" href="/mcstructure/assets/js/45.f27a9ad0.js"><link rel="prefetch" href="/mcstructure/assets/js/46.9f9edd2c.js"><link rel="prefetch" href="/mcstructure/assets/js/47.fd3ae547.js"><link rel="prefetch" href="/mcstructure/assets/js/48.375f8f97.js"><link rel="prefetch" href="/mcstructure/assets/js/49.e0d0f024.js"><link rel="prefetch" href="/mcstructure/assets/js/5.e0bd9261.js"><link rel="prefetch" href="/mcstructure/assets/js/50.aa126f14.js"><link rel="prefetch" href="/mcstructure/assets/js/51.e939b03e.js"><link rel="prefetch" href="/mcstructure/assets/js/52.a2d46eef.js"><link rel="prefetch" href="/mcstructure/assets/js/53.72de48c3.js"><link rel="prefetch" href="/mcstructure/assets/js/54.54675155.js"><link rel="prefetch" href="/mcstructure/assets/js/55.8b419ad8.js"><link rel="prefetch" href="/mcstructure/assets/js/56.07af8dcf.js"><link rel="prefetch" href="/mcstructure/assets/js/57.0bedaec9.js"><link rel="prefetch" href="/mcstructure/assets/js/58.37c94f2a.js"><link rel="prefetch" href="/mcstructure/assets/js/59.b0866a6a.js"><link rel="prefetch" href="/mcstructure/assets/js/6.04e2a2d2.js"><link rel="prefetch" href="/mcstructure/assets/js/60.5c5afc8c.js"><link rel="prefetch" href="/mcstructure/assets/js/61.ea56e4d6.js"><link rel="prefetch" href="/mcstructure/assets/js/62.3cb13464.js"><link rel="prefetch" href="/mcstructure/assets/js/63.83c0082d.js"><link rel="prefetch" href="/mcstructure/assets/js/64.2cd02c8b.js"><link rel="prefetch" href="/mcstructure/assets/js/65.c16cc8f2.js"><link rel="prefetch" href="/mcstructure/assets/js/66.ad2d4521.js"><link rel="prefetch" href="/mcstructure/assets/js/67.83e59ab1.js"><link rel="prefetch" href="/mcstructure/assets/js/68.beec9ddd.js"><link rel="prefetch" href="/mcstructure/assets/js/69.b4bc257c.js"><link rel="prefetch" href="/mcstructure/assets/js/7.fd995bdf.js"><link rel="prefetch" href="/mcstructure/assets/js/70.1ea3abef.js"><link rel="prefetch" href="/mcstructure/assets/js/71.3cf65839.js"><link rel="prefetch" href="/mcstructure/assets/js/72.6f64c4ab.js"><link rel="prefetch" href="/mcstructure/assets/js/73.452d7013.js"><link rel="prefetch" href="/mcstructure/assets/js/74.0660e6d9.js"><link rel="prefetch" href="/mcstructure/assets/js/75.b7b5e783.js"><link rel="prefetch" href="/mcstructure/assets/js/76.5fddaea1.js"><link rel="prefetch" href="/mcstructure/assets/js/77.be26bbc6.js"><link rel="prefetch" href="/mcstructure/assets/js/78.0e00fef4.js"><link rel="prefetch" href="/mcstructure/assets/js/79.731c37fb.js"><link rel="prefetch" href="/mcstructure/assets/js/8.1cbf1ff3.js"><link rel="prefetch" href="/mcstructure/assets/js/80.2282d655.js"><link rel="prefetch" href="/mcstructure/assets/js/81.33a53399.js"><link rel="prefetch" href="/mcstructure/assets/js/82.196f3fc3.js"><link rel="prefetch" href="/mcstructure/assets/js/83.e9cb3f05.js"><link rel="prefetch" href="/mcstructure/assets/js/84.35c05041.js"><link rel="prefetch" href="/mcstructure/assets/js/85.16e996b6.js"><link rel="prefetch" href="/mcstructure/assets/js/86.97412bd5.js"><link rel="prefetch" href="/mcstructure/assets/js/87.2244cc28.js"><link rel="prefetch" href="/mcstructure/assets/js/88.f00d5fcc.js"><link rel="prefetch" href="/mcstructure/assets/js/89.13359307.js"><link rel="prefetch" href="/mcstructure/assets/js/9.86a5a003.js"><link rel="prefetch" href="/mcstructure/assets/js/90.3b4668a2.js"><link rel="prefetch" href="/mcstructure/assets/js/91.85f8c578.js"><link rel="prefetch" href="/mcstructure/assets/js/92.c7bfeb53.js"><link rel="prefetch" href="/mcstructure/assets/js/93.87278538.js"><link rel="prefetch" href="/mcstructure/assets/js/94.9636adb8.js"><link rel="prefetch" href="/mcstructure/assets/js/95.49a2df5b.js"><link rel="prefetch" href="/mcstructure/assets/js/96.f84087c6.js"><link rel="prefetch" href="/mcstructure/assets/js/97.777e52ef.js"><link rel="prefetch" href="/mcstructure/assets/js/98.95f637bf.js"><link rel="prefetch" href="/mcstructure/assets/js/99.535a1eab.js">
    <link rel="stylesheet" href="/mcstructure/assets/css/0.styles.5de0a167.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/mcstructure/" class="home-link router-link-active"><!----> <span class="site-name">MC TIL</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/mcstructure/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/Redbeanw44602/mcstructure" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/mcstructure/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/Redbeanw44602/mcstructure" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Struct</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/mcstructure/1.16.201/structure/A.html" class="sidebar-link">A</a></li><li><a href="/mcstructure/1.16.201/structure/A~1.html" class="sidebar-link">A~1</a></li><li><a href="/mcstructure/1.16.201/structure/B.html" class="sidebar-link">B</a></li><li><a href="/mcstructure/1.16.201/structure/B~1.html" class="sidebar-link">B~1</a></li><li><a href="/mcstructure/1.16.201/structure/B~2.html" class="sidebar-link">B~2</a></li><li><a href="/mcstructure/1.16.201/structure/C.html" class="sidebar-link">C</a></li><li><a href="/mcstructure/1.16.201/structure/C~1.html" class="sidebar-link">C~1</a></li><li><a href="/mcstructure/1.16.201/structure/C~2.html" class="sidebar-link">C~2</a></li><li><a href="/mcstructure/1.16.201/structure/C~3.html" class="sidebar-link">C~3</a></li><li><a href="/mcstructure/1.16.201/structure/D.html" class="sidebar-link">D</a></li><li><a href="/mcstructure/1.16.201/structure/D~1.html" class="sidebar-link">D~1</a></li><li><a href="/mcstructure/1.16.201/structure/D~2.html" class="sidebar-link">D~2</a></li><li><a href="/mcstructure/1.16.201/structure/D~3.html" class="sidebar-link">D~3</a></li><li><a href="/mcstructure/1.16.201/structure/D~4.html" class="sidebar-link">D~4</a></li><li><a href="/mcstructure/1.16.201/structure/D~5.html" class="sidebar-link">D~5</a></li><li><a href="/mcstructure/1.16.201/structure/D~6.html" class="sidebar-link">D~6</a></li><li><a href="/mcstructure/1.16.201/structure/D~7.html" class="sidebar-link">D~7</a></li><li><a href="/mcstructure/1.16.201/structure/D~8.html" class="sidebar-link">D~8</a></li><li><a href="/mcstructure/1.16.201/structure/D~9.html" class="sidebar-link">D~9</a></li><li><a href="/mcstructure/1.16.201/structure/D~10.html" class="sidebar-link">D~10</a></li><li><a href="/mcstructure/1.16.201/structure/E.html" class="sidebar-link">E</a></li><li><a href="/mcstructure/1.16.201/structure/E~1.html" class="sidebar-link">E~1</a></li><li><a href="/mcstructure/1.16.201/structure/F.html" class="sidebar-link">F</a></li><li><a href="/mcstructure/1.16.201/structure/F~1.html" class="sidebar-link">F~1</a></li><li><a href="/mcstructure/1.16.201/structure/G.html" class="sidebar-link">G</a></li><li><a href="/mcstructure/1.16.201/structure/H.html" class="sidebar-link">H</a></li><li><a href="/mcstructure/1.16.201/structure/I.html" class="sidebar-link">I</a></li><li><a href="/mcstructure/1.16.201/structure/I~1.html" class="sidebar-link">I~1</a></li><li><a href="/mcstructure/1.16.201/structure/I~2.html" class="sidebar-link">I~2</a></li><li><a href="/mcstructure/1.16.201/structure/J.html" class="sidebar-link">J</a></li><li><a href="/mcstructure/1.16.201/structure/K.html" class="sidebar-link">K</a></li><li><a href="/mcstructure/1.16.201/structure/L.html" class="sidebar-link">L</a></li><li><a href="/mcstructure/1.16.201/structure/L~1.html" class="sidebar-link">L~1</a></li><li><a href="/mcstructure/1.16.201/structure/M.html" class="sidebar-link">M</a></li><li><a href="/mcstructure/1.16.201/structure/M~1.html" class="sidebar-link">M~1</a></li><li><a href="/mcstructure/1.16.201/structure/M~2.html" class="sidebar-link">M~2</a></li><li><a href="/mcstructure/1.16.201/structure/M~3.html" class="sidebar-link">M~3</a></li><li><a href="/mcstructure/1.16.201/structure/N.html" class="sidebar-link">N</a></li><li><a href="/mcstructure/1.16.201/structure/O.html" class="sidebar-link">O</a></li><li><a href="/mcstructure/1.16.201/structure/P.html" class="sidebar-link">P</a></li><li><a href="/mcstructure/1.16.201/structure/P~1.html" class="sidebar-link">P~1</a></li><li><a href="/mcstructure/1.16.201/structure/P~2.html" class="sidebar-link">P~2</a></li><li><a href="/mcstructure/1.16.201/structure/P~3.html" class="sidebar-link">P~3</a></li><li><a href="/mcstructure/1.16.201/structure/Q.html" class="sidebar-link">Q</a></li><li><a href="/mcstructure/1.16.201/structure/R.html" class="sidebar-link">R</a></li><li><a href="/mcstructure/1.16.201/structure/R~1.html" class="sidebar-link">R~1</a></li><li><a href="/mcstructure/1.16.201/structure/R~2.html" class="sidebar-link">R~2</a></li><li><a href="/mcstructure/1.16.201/structure/R~3.html" class="sidebar-link">R~3</a></li><li><a href="/mcstructure/1.16.201/structure/S.html" class="sidebar-link">S</a></li><li><a href="/mcstructure/1.16.201/structure/S~1.html" class="sidebar-link">S~1</a></li><li><a href="/mcstructure/1.16.201/structure/S~2.html" class="sidebar-link">S~2</a></li><li><a href="/mcstructure/1.16.201/structure/S~3.html" aria-current="page" class="active sidebar-link">S~3</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/mcstructure/1.16.201/structure/S~4.html" class="sidebar-link">S~4</a></li><li><a href="/mcstructure/1.16.201/structure/T.html" class="sidebar-link">T</a></li><li><a href="/mcstructure/1.16.201/structure/T~1.html" class="sidebar-link">T~1</a></li><li><a href="/mcstructure/1.16.201/structure/U.html" class="sidebar-link">U</a></li><li><a href="/mcstructure/1.16.201/structure/V.html" class="sidebar-link">V</a></li><li><a href="/mcstructure/1.16.201/structure/W.html" class="sidebar-link">W</a></li><li><a href="/mcstructure/1.16.201/structure/W~1.html" class="sidebar-link">W~1</a></li><li><a href="/mcstructure/1.16.201/structure/X.html" class="sidebar-link">X</a></li><li><a href="/mcstructure/1.16.201/structure/Z.html" class="sidebar-link">Z</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Enums</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="s-3"><a href="#s-3" class="header-anchor">#</a> S~3</h1> <h3 id="stonebuttonblock"><a href="#stonebuttonblock" class="header-anchor">#</a> <code>StoneButtonBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StoneButtonBlock : ButtonBlock
{
};

</code></pre></div><h3 id="stonebuttonblock-vtbl"><a href="#stonebuttonblock-vtbl" class="header-anchor">#</a> <code>StoneButtonBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StoneButtonBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="soulsandblock"><a href="#soulsandblock" class="header-anchor">#</a> <code>SoulSandBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SoulSandBlock : BlockLegacy
{
};

</code></pre></div><h3 id="soulsandblock-vtbl"><a href="#soulsandblock-vtbl" class="header-anchor">#</a> <code>SoulSandBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SoulSandBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="stonebrickblock"><a href="#stonebrickblock" class="header-anchor">#</a> <code>StoneBrickBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StoneBrickBlock : BlockLegacy
{
};

</code></pre></div><h3 id="stonebrickblock-vtbl"><a href="#stonebrickblock-vtbl" class="header-anchor">#</a> <code>StoneBrickBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StoneBrickBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="stainedglasspaneblock"><a href="#stainedglasspaneblock" class="header-anchor">#</a> <code>StainedGlassPaneBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StainedGlassPaneBlock : ThinFenceBlock
{
};

</code></pre></div><h3 id="stainedglasspaneblock-vtbl"><a href="#stainedglasspaneblock-vtbl" class="header-anchor">#</a> <code>StainedGlassPaneBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StainedGlassPaneBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="sealanternblock"><a href="#sealanternblock" class="header-anchor">#</a> <code>SeaLanternBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SeaLanternBlock : BlockLegacy
{
};

</code></pre></div><h3 id="sealanternblock-vtbl"><a href="#sealanternblock-vtbl" class="header-anchor">#</a> <code>SeaLanternBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SeaLanternBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="stoneslabblock2"><a href="#stoneslabblock2" class="header-anchor">#</a> <code>StoneSlabBlock2</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StoneSlabBlock2 : SlabBlock
{
};

</code></pre></div><h3 id="stoneslabblock2-vtbl"><a href="#stoneslabblock2-vtbl" class="header-anchor">#</a> <code>StoneSlabBlock2_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StoneSlabBlock2_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="shulkerboxblock"><a href="#shulkerboxblock" class="header-anchor">#</a> <code>ShulkerBoxBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ShulkerBoxBlock : ChestBlock
{
};

</code></pre></div><h3 id="shulkerboxblock-vtbl"><a href="#shulkerboxblock-vtbl" class="header-anchor">#</a> <code>ShulkerBoxBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ShulkerBoxBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
};

</code></pre></div><h3 id="structurevoid"><a href="#structurevoid" class="header-anchor">#</a> <code>StructureVoid</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureVoid : BlockLegacy
{
};

</code></pre></div><h3 id="structurevoid-vtbl"><a href="#structurevoid-vtbl" class="header-anchor">#</a> <code>StructureVoid_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StructureVoid_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="stainedglassblock"><a href="#stainedglassblock" class="header-anchor">#</a> <code>StainedGlassBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) StainedGlassBlock : BlockLegacy
{
  bool mDoesDrops;
  bool mCanBeUsedInCommands;
};

</code></pre></div><h3 id="stainedglassblock-vtbl"><a href="#stainedglassblock-vtbl" class="header-anchor">#</a> <code>StainedGlassBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StainedGlassBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="stonecutterblock"><a href="#stonecutterblock" class="header-anchor">#</a> <code>StonecutterBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StonecutterBlock : BlockLegacy
{
};

</code></pre></div><h3 id="stonecutterblock-vtbl"><a href="#stonecutterblock-vtbl" class="header-anchor">#</a> <code>StonecutterBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StonecutterBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="structureblock"><a href="#structureblock" class="header-anchor">#</a> <code>StructureBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureBlock : ActorBlock
{
};

</code></pre></div><h3 id="structureblock-vtbl"><a href="#structureblock-vtbl" class="header-anchor">#</a> <code>StructureBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StructureBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
};

</code></pre></div><h3 id="strippedlogblock"><a href="#strippedlogblock" class="header-anchor">#</a> <code>StrippedLogBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StrippedLogBlock : RotatedPillarBlock
{
};

</code></pre></div><h3 id="strippedlogblock-vtbl"><a href="#strippedlogblock-vtbl" class="header-anchor">#</a> <code>StrippedLogBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StrippedLogBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="seapickle"><a href="#seapickle" class="header-anchor">#</a> <code>SeaPickle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SeaPickle : BushBlock
{
};

</code></pre></div><h3 id="seapickle-vtbl"><a href="#seapickle-vtbl" class="header-anchor">#</a> <code>SeaPickle_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SeaPickle_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *checkAlive)(BushBlock *this, BlockSource *, const BlockPos *);
};

</code></pre></div><h3 id="scaffoldingblock"><a href="#scaffoldingblock" class="header-anchor">#</a> <code>ScaffoldingBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScaffoldingBlock : HeavyBlock
{
};

</code></pre></div><h3 id="scaffoldingblock-vtbl"><a href="#scaffoldingblock-vtbl" class="header-anchor">#</a> <code>ScaffoldingBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ScaffoldingBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  mce::Color *(__fastcall *getDustColor)(HeavyBlock *this, mce::Color *result, const Block *);
  std::string *(__fastcall *getDustParticleName)(HeavyBlock *this, std::string *result, const Block *);
  bool (__fastcall *falling)(HeavyBlock *this);
  void (__fastcall *onLand)(HeavyBlock *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isFreeToFall)(HeavyBlock *this, BlockSource *, const BlockPos *);
  void (__fastcall *startFalling)(HeavyBlock *this, BlockSource *, const BlockPos *, const Block *, bool);
};

</code></pre></div><h3 id="stoneslabblock3"><a href="#stoneslabblock3" class="header-anchor">#</a> <code>StoneSlabBlock3</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StoneSlabBlock3 : SlabBlock
{
};

</code></pre></div><h3 id="stoneslabblock3-vtbl"><a href="#stoneslabblock3-vtbl" class="header-anchor">#</a> <code>StoneSlabBlock3_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StoneSlabBlock3_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="stoneslabblock4"><a href="#stoneslabblock4" class="header-anchor">#</a> <code>StoneSlabBlock4</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StoneSlabBlock4 : SlabBlock
{
};

</code></pre></div><h3 id="stoneslabblock4-vtbl"><a href="#stoneslabblock4-vtbl" class="header-anchor">#</a> <code>StoneSlabBlock4_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StoneSlabBlock4_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="smokerblock"><a href="#smokerblock" class="header-anchor">#</a> <code>SmokerBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SmokerBlock : FurnaceBlock
{
};

</code></pre></div><h3 id="smokerblock-vtbl"><a href="#smokerblock-vtbl" class="header-anchor">#</a> <code>SmokerBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SmokerBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
};

</code></pre></div><h3 id="sweetberrybushblock"><a href="#sweetberrybushblock" class="header-anchor">#</a> <code>SweetBerryBushBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SweetBerryBushBlock : BushBlock
{
};

</code></pre></div><h3 id="sweetberrybushblock-vtbl"><a href="#sweetberrybushblock-vtbl" class="header-anchor">#</a> <code>SweetBerryBushBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SweetBerryBushBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *checkAlive)(BushBlock *this, BlockSource *, const BlockPos *);
};

</code></pre></div><h3 id="soultorchblock"><a href="#soultorchblock" class="header-anchor">#</a> <code>SoulTorchBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SoulTorchBlock : TorchBlock
{
};

</code></pre></div><h3 id="soultorchblock-vtbl"><a href="#soultorchblock-vtbl" class="header-anchor">#</a> <code>SoulTorchBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SoulTorchBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="sharedcounter-airblock"><a href="#sharedcounter-airblock" class="header-anchor">#</a> <code>SharedCounter&lt;AirBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;AirBlock&gt;
{
  AirBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-airblock"><a href="#sharedptr-airblock" class="header-anchor">#</a> <code>SharedPtr&lt;AirBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;AirBlock&gt;
{
  SharedCounter&lt;AirBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-stoneblock"><a href="#sharedcounter-stoneblock" class="header-anchor">#</a> <code>SharedCounter&lt;StoneBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;StoneBlock&gt;
{
  StoneBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-stoneblock"><a href="#sharedptr-stoneblock" class="header-anchor">#</a> <code>SharedPtr&lt;StoneBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;StoneBlock&gt;
{
  SharedCounter&lt;StoneBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-grassblock"><a href="#sharedcounter-grassblock" class="header-anchor">#</a> <code>SharedCounter&lt;GrassBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;GrassBlock&gt;
{
  GrassBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-grassblock"><a href="#sharedptr-grassblock" class="header-anchor">#</a> <code>SharedPtr&lt;GrassBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;GrassBlock&gt;
{
  SharedCounter&lt;GrassBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-dirtblock"><a href="#sharedcounter-dirtblock" class="header-anchor">#</a> <code>SharedCounter&lt;DirtBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;DirtBlock&gt;
{
  DirtBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-dirtblock"><a href="#sharedptr-dirtblock" class="header-anchor">#</a> <code>SharedPtr&lt;DirtBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;DirtBlock&gt;
{
  SharedCounter&lt;DirtBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-planksblock"><a href="#sharedcounter-planksblock" class="header-anchor">#</a> <code>SharedCounter&lt;PlanksBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;PlanksBlock&gt;
{
  PlanksBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-planksblock"><a href="#sharedptr-planksblock" class="header-anchor">#</a> <code>SharedPtr&lt;PlanksBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;PlanksBlock&gt;
{
  SharedCounter&lt;PlanksBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-sapling"><a href="#sharedcounter-sapling" class="header-anchor">#</a> <code>SharedCounter&lt;Sapling&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;Sapling&gt;
{
  Sapling *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-sapling"><a href="#sharedptr-sapling" class="header-anchor">#</a> <code>SharedPtr&lt;Sapling&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;Sapling&gt;
{
  SharedCounter&lt;Sapling&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-bedrockblock"><a href="#sharedcounter-bedrockblock" class="header-anchor">#</a> <code>SharedCounter&lt;BedrockBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;BedrockBlock&gt;
{
  BedrockBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-bedrockblock"><a href="#sharedptr-bedrockblock" class="header-anchor">#</a> <code>SharedPtr&lt;BedrockBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;BedrockBlock&gt;
{
  SharedCounter&lt;BedrockBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-liquidblockdynamic"><a href="#sharedcounter-liquidblockdynamic" class="header-anchor">#</a> <code>SharedCounter&lt;LiquidBlockDynamic&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;LiquidBlockDynamic&gt;
{
  LiquidBlockDynamic *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-liquidblockdynamic"><a href="#sharedptr-liquidblockdynamic" class="header-anchor">#</a> <code>SharedPtr&lt;LiquidBlockDynamic&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;LiquidBlockDynamic&gt;
{
  SharedCounter&lt;LiquidBlockDynamic&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-liquidblockstatic"><a href="#sharedcounter-liquidblockstatic" class="header-anchor">#</a> <code>SharedCounter&lt;LiquidBlockStatic&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;LiquidBlockStatic&gt;
{
  LiquidBlockStatic *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-liquidblockstatic"><a href="#sharedptr-liquidblockstatic" class="header-anchor">#</a> <code>SharedPtr&lt;LiquidBlockStatic&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;LiquidBlockStatic&gt;
{
  SharedCounter&lt;LiquidBlockStatic&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-sandblock"><a href="#sharedcounter-sandblock" class="header-anchor">#</a> <code>SharedCounter&lt;SandBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;SandBlock&gt;
{
  SandBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-sandblock"><a href="#sharedptr-sandblock" class="header-anchor">#</a> <code>SharedPtr&lt;SandBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;SandBlock&gt;
{
  SharedCounter&lt;SandBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-gravelblock"><a href="#sharedcounter-gravelblock" class="header-anchor">#</a> <code>SharedCounter&lt;GravelBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;GravelBlock&gt;
{
  GravelBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-gravelblock"><a href="#sharedptr-gravelblock" class="header-anchor">#</a> <code>SharedPtr&lt;GravelBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;GravelBlock&gt;
{
  SharedCounter&lt;GravelBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-oreblock"><a href="#sharedcounter-oreblock" class="header-anchor">#</a> <code>SharedCounter&lt;OreBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;OreBlock&gt;
{
  OreBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-oreblock"><a href="#sharedptr-oreblock" class="header-anchor">#</a> <code>SharedPtr&lt;OreBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;OreBlock&gt;
{
  SharedCounter&lt;OreBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-oldlogblock"><a href="#sharedcounter-oldlogblock" class="header-anchor">#</a> <code>SharedCounter&lt;OldLogBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;OldLogBlock&gt;
{
  OldLogBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-oldlogblock"><a href="#sharedptr-oldlogblock" class="header-anchor">#</a> <code>SharedPtr&lt;OldLogBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;OldLogBlock&gt;
{
  SharedCounter&lt;OldLogBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-oldleafblock"><a href="#sharedcounter-oldleafblock" class="header-anchor">#</a> <code>SharedCounter&lt;OldLeafBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;OldLeafBlock&gt;
{
  OldLeafBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-oldleafblock"><a href="#sharedptr-oldleafblock" class="header-anchor">#</a> <code>SharedPtr&lt;OldLeafBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;OldLeafBlock&gt;
{
  SharedCounter&lt;OldLeafBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-spongeblock"><a href="#sharedcounter-spongeblock" class="header-anchor">#</a> <code>SharedCounter&lt;SpongeBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;SpongeBlock&gt;
{
  SpongeBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-spongeblock"><a href="#sharedptr-spongeblock" class="header-anchor">#</a> <code>SharedPtr&lt;SpongeBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;SpongeBlock&gt;
{
  SharedCounter&lt;SpongeBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-glassblock"><a href="#sharedcounter-glassblock" class="header-anchor">#</a> <code>SharedCounter&lt;GlassBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;GlassBlock&gt;
{
  GlassBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-glassblock"><a href="#sharedptr-glassblock" class="header-anchor">#</a> <code>SharedPtr&lt;GlassBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;GlassBlock&gt;
{
  SharedCounter&lt;GlassBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-dispenserblock"><a href="#sharedcounter-dispenserblock" class="header-anchor">#</a> <code>SharedCounter&lt;DispenserBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;DispenserBlock&gt;
{
  DispenserBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-dispenserblock"><a href="#sharedptr-dispenserblock" class="header-anchor">#</a> <code>SharedPtr&lt;DispenserBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;DispenserBlock&gt;
{
  SharedCounter&lt;DispenserBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-sandstoneblock"><a href="#sharedcounter-sandstoneblock" class="header-anchor">#</a> <code>SharedCounter&lt;SandStoneBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;SandStoneBlock&gt;
{
  SandStoneBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-sandstoneblock"><a href="#sharedptr-sandstoneblock" class="header-anchor">#</a> <code>SharedPtr&lt;SandStoneBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;SandStoneBlock&gt;
{
  SharedCounter&lt;SandStoneBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-noteblock"><a href="#sharedcounter-noteblock" class="header-anchor">#</a> <code>SharedCounter&lt;NoteBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;NoteBlock&gt;
{
  NoteBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-noteblock"><a href="#sharedptr-noteblock" class="header-anchor">#</a> <code>SharedPtr&lt;NoteBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;NoteBlock&gt;
{
  SharedCounter&lt;NoteBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-bedblock"><a href="#sharedcounter-bedblock" class="header-anchor">#</a> <code>SharedCounter&lt;BedBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;BedBlock&gt;
{
  BedBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-bedblock"><a href="#sharedptr-bedblock" class="header-anchor">#</a> <code>SharedPtr&lt;BedBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;BedBlock&gt;
{
  SharedCounter&lt;BedBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-poweredrailblock"><a href="#sharedcounter-poweredrailblock" class="header-anchor">#</a> <code>SharedCounter&lt;PoweredRailBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;PoweredRailBlock&gt;
{
  PoweredRailBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-poweredrailblock"><a href="#sharedptr-poweredrailblock" class="header-anchor">#</a> <code>SharedPtr&lt;PoweredRailBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;PoweredRailBlock&gt;
{
  SharedCounter&lt;PoweredRailBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-detectorrailblock"><a href="#sharedcounter-detectorrailblock" class="header-anchor">#</a> <code>SharedCounter&lt;DetectorRailBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;DetectorRailBlock&gt;
{
  DetectorRailBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-detectorrailblock"><a href="#sharedptr-detectorrailblock" class="header-anchor">#</a> <code>SharedPtr&lt;DetectorRailBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;DetectorRailBlock&gt;
{
  SharedCounter&lt;DetectorRailBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-pistonblock"><a href="#sharedcounter-pistonblock" class="header-anchor">#</a> <code>SharedCounter&lt;PistonBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;PistonBlock&gt;
{
  PistonBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-pistonblock"><a href="#sharedptr-pistonblock" class="header-anchor">#</a> <code>SharedPtr&lt;PistonBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;PistonBlock&gt;
{
  SharedCounter&lt;PistonBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-webblock"><a href="#sharedcounter-webblock" class="header-anchor">#</a> <code>SharedCounter&lt;WebBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;WebBlock&gt;
{
  WebBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-webblock"><a href="#sharedptr-webblock" class="header-anchor">#</a> <code>SharedPtr&lt;WebBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;WebBlock&gt;
{
  SharedCounter&lt;WebBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-tallgrass"><a href="#sharedcounter-tallgrass" class="header-anchor">#</a> <code>SharedCounter&lt;TallGrass&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;TallGrass&gt;
{
  TallGrass *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-tallgrass"><a href="#sharedptr-tallgrass" class="header-anchor">#</a> <code>SharedPtr&lt;TallGrass&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;TallGrass&gt;
{
  SharedCounter&lt;TallGrass&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-deadbush"><a href="#sharedcounter-deadbush" class="header-anchor">#</a> <code>SharedCounter&lt;DeadBush&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;DeadBush&gt;
{
  DeadBush *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-deadbush"><a href="#sharedptr-deadbush" class="header-anchor">#</a> <code>SharedPtr&lt;DeadBush&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;DeadBush&gt;
{
  SharedCounter&lt;DeadBush&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-pistonarmblock"><a href="#sharedcounter-pistonarmblock" class="header-anchor">#</a> <code>SharedCounter&lt;PistonArmBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;PistonArmBlock&gt;
{
  PistonArmBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-pistonarmblock"><a href="#sharedptr-pistonarmblock" class="header-anchor">#</a> <code>SharedPtr&lt;PistonArmBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;PistonArmBlock&gt;
{
  SharedCounter&lt;PistonArmBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-clothblock"><a href="#sharedcounter-clothblock" class="header-anchor">#</a> <code>SharedCounter&lt;ClothBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ClothBlock&gt;
{
  ClothBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-clothblock"><a href="#sharedptr-clothblock" class="header-anchor">#</a> <code>SharedPtr&lt;ClothBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ClothBlock&gt;
{
  SharedCounter&lt;ClothBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-flowerblock"><a href="#sharedcounter-flowerblock" class="header-anchor">#</a> <code>SharedCounter&lt;FlowerBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;FlowerBlock&gt;
{
  FlowerBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-flowerblock"><a href="#sharedptr-flowerblock" class="header-anchor">#</a> <code>SharedPtr&lt;FlowerBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;FlowerBlock&gt;
{
  SharedCounter&lt;FlowerBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-mushroomblock"><a href="#sharedcounter-mushroomblock" class="header-anchor">#</a> <code>SharedCounter&lt;MushroomBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;MushroomBlock&gt;
{
  MushroomBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-mushroomblock"><a href="#sharedptr-mushroomblock" class="header-anchor">#</a> <code>SharedPtr&lt;MushroomBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;MushroomBlock&gt;
{
  SharedCounter&lt;MushroomBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-metalblock"><a href="#sharedcounter-metalblock" class="header-anchor">#</a> <code>SharedCounter&lt;MetalBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;MetalBlock&gt;
{
  MetalBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-metalblock"><a href="#sharedptr-metalblock" class="header-anchor">#</a> <code>SharedPtr&lt;MetalBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;MetalBlock&gt;
{
  SharedCounter&lt;MetalBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-stoneslabblock"><a href="#sharedcounter-stoneslabblock" class="header-anchor">#</a> <code>SharedCounter&lt;StoneSlabBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;StoneSlabBlock&gt;
{
  StoneSlabBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-stoneslabblock"><a href="#sharedptr-stoneslabblock" class="header-anchor">#</a> <code>SharedPtr&lt;StoneSlabBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;StoneSlabBlock&gt;
{
  SharedCounter&lt;StoneSlabBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-tntblock"><a href="#sharedcounter-tntblock" class="header-anchor">#</a> <code>SharedCounter&lt;TntBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;TntBlock&gt;
{
  TntBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-tntblock"><a href="#sharedptr-tntblock" class="header-anchor">#</a> <code>SharedPtr&lt;TntBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;TntBlock&gt;
{
  SharedCounter&lt;TntBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-bookshelfblock"><a href="#sharedcounter-bookshelfblock" class="header-anchor">#</a> <code>SharedCounter&lt;BookshelfBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;BookshelfBlock&gt;
{
  BookshelfBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-bookshelfblock"><a href="#sharedptr-bookshelfblock" class="header-anchor">#</a> <code>SharedPtr&lt;BookshelfBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;BookshelfBlock&gt;
{
  SharedCounter&lt;BookshelfBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-obsidianblock"><a href="#sharedcounter-obsidianblock" class="header-anchor">#</a> <code>SharedCounter&lt;ObsidianBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ObsidianBlock&gt;
{
  ObsidianBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-obsidianblock"><a href="#sharedptr-obsidianblock" class="header-anchor">#</a> <code>SharedPtr&lt;ObsidianBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ObsidianBlock&gt;
{
  SharedCounter&lt;ObsidianBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-torchblock"><a href="#sharedcounter-torchblock" class="header-anchor">#</a> <code>SharedCounter&lt;TorchBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;TorchBlock&gt;
{
  TorchBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-torchblock"><a href="#sharedptr-torchblock" class="header-anchor">#</a> <code>SharedPtr&lt;TorchBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;TorchBlock&gt;
{
  SharedCounter&lt;TorchBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-mobspawnerblock"><a href="#sharedcounter-mobspawnerblock" class="header-anchor">#</a> <code>SharedCounter&lt;MobSpawnerBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;MobSpawnerBlock&gt;
{
  MobSpawnerBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-mobspawnerblock"><a href="#sharedptr-mobspawnerblock" class="header-anchor">#</a> <code>SharedPtr&lt;MobSpawnerBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;MobSpawnerBlock&gt;
{
  SharedCounter&lt;MobSpawnerBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-stairblock"><a href="#sharedcounter-stairblock" class="header-anchor">#</a> <code>SharedCounter&lt;StairBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;StairBlock&gt;
{
  StairBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedcounter-chestblock"><a href="#sharedcounter-chestblock" class="header-anchor">#</a> <code>SharedCounter&lt;ChestBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ChestBlock&gt;
{
  ChestBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-chestblock"><a href="#sharedptr-chestblock" class="header-anchor">#</a> <code>SharedPtr&lt;ChestBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ChestBlock&gt;
{
  SharedCounter&lt;ChestBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-redstonewireblock"><a href="#sharedcounter-redstonewireblock" class="header-anchor">#</a> <code>SharedCounter&lt;RedStoneWireBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;RedStoneWireBlock&gt;
{
  RedStoneWireBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-redstonewireblock"><a href="#sharedptr-redstonewireblock" class="header-anchor">#</a> <code>SharedPtr&lt;RedStoneWireBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;RedStoneWireBlock&gt;
{
  SharedCounter&lt;RedStoneWireBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-workbenchblock"><a href="#sharedcounter-workbenchblock" class="header-anchor">#</a> <code>SharedCounter&lt;WorkbenchBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;WorkbenchBlock&gt;
{
  WorkbenchBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-workbenchblock"><a href="#sharedptr-workbenchblock" class="header-anchor">#</a> <code>SharedPtr&lt;WorkbenchBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;WorkbenchBlock&gt;
{
  SharedCounter&lt;WorkbenchBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-cropblock"><a href="#sharedcounter-cropblock" class="header-anchor">#</a> <code>SharedCounter&lt;CropBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;CropBlock&gt;
{
  CropBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-cropblock"><a href="#sharedptr-cropblock" class="header-anchor">#</a> <code>SharedPtr&lt;CropBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;CropBlock&gt;
{
  SharedCounter&lt;CropBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-farmblock"><a href="#sharedcounter-farmblock" class="header-anchor">#</a> <code>SharedCounter&lt;FarmBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;FarmBlock&gt;
{
  FarmBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-farmblock"><a href="#sharedptr-farmblock" class="header-anchor">#</a> <code>SharedPtr&lt;FarmBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;FarmBlock&gt;
{
  SharedCounter&lt;FarmBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-furnaceblock"><a href="#sharedcounter-furnaceblock" class="header-anchor">#</a> <code>SharedCounter&lt;FurnaceBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;FurnaceBlock&gt;
{
  FurnaceBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-furnaceblock"><a href="#sharedptr-furnaceblock" class="header-anchor">#</a> <code>SharedPtr&lt;FurnaceBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;FurnaceBlock&gt;
{
  SharedCounter&lt;FurnaceBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-signblock"><a href="#sharedcounter-signblock" class="header-anchor">#</a> <code>SharedCounter&lt;SignBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;SignBlock&gt;
{
  SignBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-signblock"><a href="#sharedptr-signblock" class="header-anchor">#</a> <code>SharedPtr&lt;SignBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;SignBlock&gt;
{
  SharedCounter&lt;SignBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-doorblock"><a href="#sharedcounter-doorblock" class="header-anchor">#</a> <code>SharedCounter&lt;DoorBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;DoorBlock&gt;
{
  DoorBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-doorblock"><a href="#sharedptr-doorblock" class="header-anchor">#</a> <code>SharedPtr&lt;DoorBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;DoorBlock&gt;
{
  SharedCounter&lt;DoorBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-ladderblock"><a href="#sharedcounter-ladderblock" class="header-anchor">#</a> <code>SharedCounter&lt;LadderBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;LadderBlock&gt;
{
  LadderBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-ladderblock"><a href="#sharedptr-ladderblock" class="header-anchor">#</a> <code>SharedPtr&lt;LadderBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;LadderBlock&gt;
{
  SharedCounter&lt;LadderBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-railblock"><a href="#sharedcounter-railblock" class="header-anchor">#</a> <code>SharedCounter&lt;RailBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;RailBlock&gt;
{
  RailBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-railblock"><a href="#sharedptr-railblock" class="header-anchor">#</a> <code>SharedPtr&lt;RailBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;RailBlock&gt;
{
  SharedCounter&lt;RailBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-leverblock"><a href="#sharedcounter-leverblock" class="header-anchor">#</a> <code>SharedCounter&lt;LeverBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;LeverBlock&gt;
{
  LeverBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-leverblock"><a href="#sharedptr-leverblock" class="header-anchor">#</a> <code>SharedPtr&lt;LeverBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;LeverBlock&gt;
{
  SharedCounter&lt;LeverBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-pressureplateblock"><a href="#sharedcounter-pressureplateblock" class="header-anchor">#</a> <code>SharedCounter&lt;PressurePlateBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;PressurePlateBlock&gt;
{
  PressurePlateBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-pressureplateblock"><a href="#sharedptr-pressureplateblock" class="header-anchor">#</a> <code>SharedPtr&lt;PressurePlateBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;PressurePlateBlock&gt;
{
  SharedCounter&lt;PressurePlateBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-redstoneoreblock"><a href="#sharedcounter-redstoneoreblock" class="header-anchor">#</a> <code>SharedCounter&lt;RedStoneOreBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;RedStoneOreBlock&gt;
{
  RedStoneOreBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-redstoneoreblock"><a href="#sharedptr-redstoneoreblock" class="header-anchor">#</a> <code>SharedPtr&lt;RedStoneOreBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;RedStoneOreBlock&gt;
{
  SharedCounter&lt;RedStoneOreBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-redstonetorchblock"><a href="#sharedcounter-redstonetorchblock" class="header-anchor">#</a> <code>SharedCounter&lt;RedstoneTorchBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;RedstoneTorchBlock&gt;
{
  RedstoneTorchBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-redstonetorchblock"><a href="#sharedptr-redstonetorchblock" class="header-anchor">#</a> <code>SharedPtr&lt;RedstoneTorchBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;RedstoneTorchBlock&gt;
{
  SharedCounter&lt;RedstoneTorchBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-stonebuttonblock"><a href="#sharedcounter-stonebuttonblock" class="header-anchor">#</a> <code>SharedCounter&lt;StoneButtonBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;StoneButtonBlock&gt;
{
  StoneButtonBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedcounter-topsnowblock"><a href="#sharedcounter-topsnowblock" class="header-anchor">#</a> <code>SharedCounter&lt;TopSnowBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;TopSnowBlock&gt;
{
  TopSnowBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-topsnowblock"><a href="#sharedptr-topsnowblock" class="header-anchor">#</a> <code>SharedPtr&lt;TopSnowBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;TopSnowBlock&gt;
{
  SharedCounter&lt;TopSnowBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-iceblock"><a href="#sharedcounter-iceblock" class="header-anchor">#</a> <code>SharedCounter&lt;IceBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;IceBlock&gt;
{
  IceBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-iceblock"><a href="#sharedptr-iceblock" class="header-anchor">#</a> <code>SharedPtr&lt;IceBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;IceBlock&gt;
{
  SharedCounter&lt;IceBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-snowblock"><a href="#sharedcounter-snowblock" class="header-anchor">#</a> <code>SharedCounter&lt;SnowBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;SnowBlock&gt;
{
  SnowBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-snowblock"><a href="#sharedptr-snowblock" class="header-anchor">#</a> <code>SharedPtr&lt;SnowBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;SnowBlock&gt;
{
  SharedCounter&lt;SnowBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-cactusblock"><a href="#sharedcounter-cactusblock" class="header-anchor">#</a> <code>SharedCounter&lt;CactusBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;CactusBlock&gt;
{
  CactusBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-cactusblock"><a href="#sharedptr-cactusblock" class="header-anchor">#</a> <code>SharedPtr&lt;CactusBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;CactusBlock&gt;
{
  SharedCounter&lt;CactusBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-clayblock"><a href="#sharedcounter-clayblock" class="header-anchor">#</a> <code>SharedCounter&lt;ClayBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ClayBlock&gt;
{
  ClayBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-clayblock"><a href="#sharedptr-clayblock" class="header-anchor">#</a> <code>SharedPtr&lt;ClayBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ClayBlock&gt;
{
  SharedCounter&lt;ClayBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-reedblock"><a href="#sharedcounter-reedblock" class="header-anchor">#</a> <code>SharedCounter&lt;ReedBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ReedBlock&gt;
{
  ReedBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-reedblock"><a href="#sharedptr-reedblock" class="header-anchor">#</a> <code>SharedPtr&lt;ReedBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ReedBlock&gt;
{
  SharedCounter&lt;ReedBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-jukeboxblock"><a href="#sharedcounter-jukeboxblock" class="header-anchor">#</a> <code>SharedCounter&lt;JukeboxBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;JukeboxBlock&gt;
{
  JukeboxBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-jukeboxblock"><a href="#sharedptr-jukeboxblock" class="header-anchor">#</a> <code>SharedPtr&lt;JukeboxBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;JukeboxBlock&gt;
{
  SharedCounter&lt;JukeboxBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-fenceblock"><a href="#sharedcounter-fenceblock" class="header-anchor">#</a> <code>SharedCounter&lt;FenceBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;FenceBlock&gt;
{
  FenceBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-fenceblock"><a href="#sharedptr-fenceblock" class="header-anchor">#</a> <code>SharedPtr&lt;FenceBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;FenceBlock&gt;
{
  SharedCounter&lt;FenceBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-pumpkinblock"><a href="#sharedcounter-pumpkinblock" class="header-anchor">#</a> <code>SharedCounter&lt;PumpkinBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;PumpkinBlock&gt;
{
  PumpkinBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-pumpkinblock"><a href="#sharedptr-pumpkinblock" class="header-anchor">#</a> <code>SharedPtr&lt;PumpkinBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;PumpkinBlock&gt;
{
  SharedCounter&lt;PumpkinBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-netherrackblock"><a href="#sharedcounter-netherrackblock" class="header-anchor">#</a> <code>SharedCounter&lt;NetherrackBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;NetherrackBlock&gt;
{
  NetherrackBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-netherrackblock"><a href="#sharedptr-netherrackblock" class="header-anchor">#</a> <code>SharedPtr&lt;NetherrackBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;NetherrackBlock&gt;
{
  SharedCounter&lt;NetherrackBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-soulsandblock"><a href="#sharedcounter-soulsandblock" class="header-anchor">#</a> <code>SharedCounter&lt;SoulSandBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;SoulSandBlock&gt;
{
  SoulSandBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-soulsandblock"><a href="#sharedptr-soulsandblock" class="header-anchor">#</a> <code>SharedPtr&lt;SoulSandBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;SoulSandBlock&gt;
{
  SharedCounter&lt;SoulSandBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-lightgemblock"><a href="#sharedcounter-lightgemblock" class="header-anchor">#</a> <code>SharedCounter&lt;LightGemBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;LightGemBlock&gt;
{
  LightGemBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-lightgemblock"><a href="#sharedptr-lightgemblock" class="header-anchor">#</a> <code>SharedPtr&lt;LightGemBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;LightGemBlock&gt;
{
  SharedCounter&lt;LightGemBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-portalblock"><a href="#sharedcounter-portalblock" class="header-anchor">#</a> <code>SharedCounter&lt;PortalBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;PortalBlock&gt;
{
  PortalBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-portalblock"><a href="#sharedptr-portalblock" class="header-anchor">#</a> <code>SharedPtr&lt;PortalBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;PortalBlock&gt;
{
  SharedCounter&lt;PortalBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-cakeblock"><a href="#sharedcounter-cakeblock" class="header-anchor">#</a> <code>SharedCounter&lt;CakeBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;CakeBlock&gt;
{
  CakeBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-cakeblock"><a href="#sharedptr-cakeblock" class="header-anchor">#</a> <code>SharedPtr&lt;CakeBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;CakeBlock&gt;
{
  SharedCounter&lt;CakeBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-repeaterblock"><a href="#sharedcounter-repeaterblock" class="header-anchor">#</a> <code>SharedCounter&lt;RepeaterBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;RepeaterBlock&gt;
{
  RepeaterBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-repeaterblock"><a href="#sharedptr-repeaterblock" class="header-anchor">#</a> <code>SharedPtr&lt;RepeaterBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;RepeaterBlock&gt;
{
  SharedCounter&lt;RepeaterBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-invisibleblock"><a href="#sharedcounter-invisibleblock" class="header-anchor">#</a> <code>SharedCounter&lt;InvisibleBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;InvisibleBlock&gt;
{
  InvisibleBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-invisibleblock"><a href="#sharedptr-invisibleblock" class="header-anchor">#</a> <code>SharedPtr&lt;InvisibleBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;InvisibleBlock&gt;
{
  SharedCounter&lt;InvisibleBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-trapdoorblock"><a href="#sharedcounter-trapdoorblock" class="header-anchor">#</a> <code>SharedCounter&lt;TrapDoorBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;TrapDoorBlock&gt;
{
  TrapDoorBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-trapdoorblock"><a href="#sharedptr-trapdoorblock" class="header-anchor">#</a> <code>SharedPtr&lt;TrapDoorBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;TrapDoorBlock&gt;
{
  SharedCounter&lt;TrapDoorBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-monstereggblock"><a href="#sharedcounter-monstereggblock" class="header-anchor">#</a> <code>SharedCounter&lt;MonsterEggBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;MonsterEggBlock&gt;
{
  MonsterEggBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-monstereggblock"><a href="#sharedptr-monstereggblock" class="header-anchor">#</a> <code>SharedPtr&lt;MonsterEggBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;MonsterEggBlock&gt;
{
  SharedCounter&lt;MonsterEggBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-stonebrickblock"><a href="#sharedcounter-stonebrickblock" class="header-anchor">#</a> <code>SharedCounter&lt;StoneBrickBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;StoneBrickBlock&gt;
{
  StoneBrickBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-stonebrickblock"><a href="#sharedptr-stonebrickblock" class="header-anchor">#</a> <code>SharedPtr&lt;StoneBrickBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;StoneBrickBlock&gt;
{
  SharedCounter&lt;StoneBrickBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-hugemushroomblock"><a href="#sharedcounter-hugemushroomblock" class="header-anchor">#</a> <code>SharedCounter&lt;HugeMushroomBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;HugeMushroomBlock&gt;
{
  HugeMushroomBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-hugemushroomblock"><a href="#sharedptr-hugemushroomblock" class="header-anchor">#</a> <code>SharedPtr&lt;HugeMushroomBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;HugeMushroomBlock&gt;
{
  SharedCounter&lt;HugeMushroomBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-thinfenceblock"><a href="#sharedcounter-thinfenceblock" class="header-anchor">#</a> <code>SharedCounter&lt;ThinFenceBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ThinFenceBlock&gt;
{
  ThinFenceBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-thinfenceblock"><a href="#sharedptr-thinfenceblock" class="header-anchor">#</a> <code>SharedPtr&lt;ThinFenceBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ThinFenceBlock&gt;
{
  SharedCounter&lt;ThinFenceBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-melonblock"><a href="#sharedcounter-melonblock" class="header-anchor">#</a> <code>SharedCounter&lt;MelonBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;MelonBlock&gt;
{
  MelonBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-melonblock"><a href="#sharedptr-melonblock" class="header-anchor">#</a> <code>SharedPtr&lt;MelonBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;MelonBlock&gt;
{
  SharedCounter&lt;MelonBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-stemblock"><a href="#sharedcounter-stemblock" class="header-anchor">#</a> <code>SharedCounter&lt;StemBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;StemBlock&gt;
{
  StemBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-stemblock"><a href="#sharedptr-stemblock" class="header-anchor">#</a> <code>SharedPtr&lt;StemBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;StemBlock&gt;
{
  SharedCounter&lt;StemBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-vineblock"><a href="#sharedcounter-vineblock" class="header-anchor">#</a> <code>SharedCounter&lt;VineBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;VineBlock&gt;
{
  VineBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-vineblock"><a href="#sharedptr-vineblock" class="header-anchor">#</a> <code>SharedPtr&lt;VineBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;VineBlock&gt;
{
  SharedCounter&lt;VineBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-fencegateblock"><a href="#sharedcounter-fencegateblock" class="header-anchor">#</a> <code>SharedCounter&lt;FenceGateBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;FenceGateBlock&gt;
{
  FenceGateBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-fencegateblock"><a href="#sharedptr-fencegateblock" class="header-anchor">#</a> <code>SharedPtr&lt;FenceGateBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;FenceGateBlock&gt;
{
  SharedCounter&lt;FenceGateBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-myceliumblock"><a href="#sharedcounter-myceliumblock" class="header-anchor">#</a> <code>SharedCounter&lt;MyceliumBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;MyceliumBlock&gt;
{
  MyceliumBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-myceliumblock"><a href="#sharedptr-myceliumblock" class="header-anchor">#</a> <code>SharedPtr&lt;MyceliumBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;MyceliumBlock&gt;
{
  SharedCounter&lt;MyceliumBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-waterlilyblock"><a href="#sharedcounter-waterlilyblock" class="header-anchor">#</a> <code>SharedCounter&lt;WaterlilyBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;WaterlilyBlock&gt;
{
  WaterlilyBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-waterlilyblock"><a href="#sharedptr-waterlilyblock" class="header-anchor">#</a> <code>SharedPtr&lt;WaterlilyBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;WaterlilyBlock&gt;
{
  SharedCounter&lt;WaterlilyBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-netherwartblock"><a href="#sharedcounter-netherwartblock" class="header-anchor">#</a> <code>SharedCounter&lt;NetherWartBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;NetherWartBlock&gt;
{
  NetherWartBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-netherwartblock"><a href="#sharedptr-netherwartblock" class="header-anchor">#</a> <code>SharedPtr&lt;NetherWartBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;NetherWartBlock&gt;
{
  SharedCounter&lt;NetherWartBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-enchantingtableblock"><a href="#sharedcounter-enchantingtableblock" class="header-anchor">#</a> <code>SharedCounter&lt;EnchantingTableBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;EnchantingTableBlock&gt;
{
  EnchantingTableBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-enchantingtableblock"><a href="#sharedptr-enchantingtableblock" class="header-anchor">#</a> <code>SharedPtr&lt;EnchantingTableBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;EnchantingTableBlock&gt;
{
  SharedCounter&lt;EnchantingTableBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-brewingstandblock"><a href="#sharedcounter-brewingstandblock" class="header-anchor">#</a> <code>SharedCounter&lt;BrewingStandBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;BrewingStandBlock&gt;
{
  BrewingStandBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-brewingstandblock"><a href="#sharedptr-brewingstandblock" class="header-anchor">#</a> <code>SharedPtr&lt;BrewingStandBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;BrewingStandBlock&gt;
{
  SharedCounter&lt;BrewingStandBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-cauldronblock"><a href="#sharedcounter-cauldronblock" class="header-anchor">#</a> <code>SharedCounter&lt;CauldronBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;CauldronBlock&gt;
{
  CauldronBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-cauldronblock"><a href="#sharedptr-cauldronblock" class="header-anchor">#</a> <code>SharedPtr&lt;CauldronBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;CauldronBlock&gt;
{
  SharedCounter&lt;CauldronBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-endportalblock"><a href="#sharedcounter-endportalblock" class="header-anchor">#</a> <code>SharedCounter&lt;EndPortalBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;EndPortalBlock&gt;
{
  EndPortalBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-endportalblock"><a href="#sharedptr-endportalblock" class="header-anchor">#</a> <code>SharedPtr&lt;EndPortalBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;EndPortalBlock&gt;
{
  SharedCounter&lt;EndPortalBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-endportalframeblock"><a href="#sharedcounter-endportalframeblock" class="header-anchor">#</a> <code>SharedCounter&lt;EndPortalFrameBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;EndPortalFrameBlock&gt;
{
  EndPortalFrameBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-endportalframeblock"><a href="#sharedptr-endportalframeblock" class="header-anchor">#</a> <code>SharedPtr&lt;EndPortalFrameBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;EndPortalFrameBlock&gt;
{
  SharedCounter&lt;EndPortalFrameBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-dragoneggblock"><a href="#sharedcounter-dragoneggblock" class="header-anchor">#</a> <code>SharedCounter&lt;DragonEggBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;DragonEggBlock&gt;
{
  DragonEggBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-dragoneggblock"><a href="#sharedptr-dragoneggblock" class="header-anchor">#</a> <code>SharedPtr&lt;DragonEggBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;DragonEggBlock&gt;
{
  SharedCounter&lt;DragonEggBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-redstonelampblock"><a href="#sharedcounter-redstonelampblock" class="header-anchor">#</a> <code>SharedCounter&lt;RedstoneLampBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;RedstoneLampBlock&gt;
{
  RedstoneLampBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-redstonelampblock"><a href="#sharedptr-redstonelampblock" class="header-anchor">#</a> <code>SharedPtr&lt;RedstoneLampBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;RedstoneLampBlock&gt;
{
  SharedCounter&lt;RedstoneLampBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-dropperblock"><a href="#sharedcounter-dropperblock" class="header-anchor">#</a> <code>SharedCounter&lt;DropperBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;DropperBlock&gt;
{
  DropperBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-dropperblock"><a href="#sharedptr-dropperblock" class="header-anchor">#</a> <code>SharedPtr&lt;DropperBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;DropperBlock&gt;
{
  SharedCounter&lt;DropperBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-activatorrailblock"><a href="#sharedcounter-activatorrailblock" class="header-anchor">#</a> <code>SharedCounter&lt;ActivatorRailBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ActivatorRailBlock&gt;
{
  ActivatorRailBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-activatorrailblock"><a href="#sharedptr-activatorrailblock" class="header-anchor">#</a> <code>SharedPtr&lt;ActivatorRailBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ActivatorRailBlock&gt;
{
  SharedCounter&lt;ActivatorRailBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-cocoablock"><a href="#sharedcounter-cocoablock" class="header-anchor">#</a> <code>SharedCounter&lt;CocoaBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;CocoaBlock&gt;
{
  CocoaBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-cocoablock"><a href="#sharedptr-cocoablock" class="header-anchor">#</a> <code>SharedPtr&lt;CocoaBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;CocoaBlock&gt;
{
  SharedCounter&lt;CocoaBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-enderchestblock"><a href="#sharedcounter-enderchestblock" class="header-anchor">#</a> <code>SharedCounter&lt;EnderChestBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;EnderChestBlock&gt;
{
  EnderChestBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-enderchestblock"><a href="#sharedptr-enderchestblock" class="header-anchor">#</a> <code>SharedPtr&lt;EnderChestBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;EnderChestBlock&gt;
{
  SharedCounter&lt;EnderChestBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-tripwirehookblock"><a href="#sharedcounter-tripwirehookblock" class="header-anchor">#</a> <code>SharedCounter&lt;TripWireHookBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;TripWireHookBlock&gt;
{
  TripWireHookBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-tripwirehookblock"><a href="#sharedptr-tripwirehookblock" class="header-anchor">#</a> <code>SharedPtr&lt;TripWireHookBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;TripWireHookBlock&gt;
{
  SharedCounter&lt;TripWireHookBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-tripwireblock"><a href="#sharedcounter-tripwireblock" class="header-anchor">#</a> <code>SharedCounter&lt;TripWireBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;TripWireBlock&gt;
{
  TripWireBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-tripwireblock"><a href="#sharedptr-tripwireblock" class="header-anchor">#</a> <code>SharedPtr&lt;TripWireBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;TripWireBlock&gt;
{
  SharedCounter&lt;TripWireBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-commandblock"><a href="#sharedcounter-commandblock" class="header-anchor">#</a> <code>SharedCounter&lt;CommandBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;CommandBlock&gt;
{
  CommandBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-commandblock"><a href="#sharedptr-commandblock" class="header-anchor">#</a> <code>SharedPtr&lt;CommandBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;CommandBlock&gt;
{
  SharedCounter&lt;CommandBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-beaconblock"><a href="#sharedcounter-beaconblock" class="header-anchor">#</a> <code>SharedCounter&lt;BeaconBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;BeaconBlock&gt;
{
  BeaconBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-beaconblock"><a href="#sharedptr-beaconblock" class="header-anchor">#</a> <code>SharedPtr&lt;BeaconBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;BeaconBlock&gt;
{
  SharedCounter&lt;BeaconBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-wallblock"><a href="#sharedcounter-wallblock" class="header-anchor">#</a> <code>SharedCounter&lt;WallBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;WallBlock&gt;
{
  WallBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-wallblock"><a href="#sharedptr-wallblock" class="header-anchor">#</a> <code>SharedPtr&lt;WallBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;WallBlock&gt;
{
  SharedCounter&lt;WallBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-flowerpotblock"><a href="#sharedcounter-flowerpotblock" class="header-anchor">#</a> <code>SharedCounter&lt;FlowerPotBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;FlowerPotBlock&gt;
{
  FlowerPotBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-flowerpotblock"><a href="#sharedptr-flowerpotblock" class="header-anchor">#</a> <code>SharedPtr&lt;FlowerPotBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;FlowerPotBlock&gt;
{
  SharedCounter&lt;FlowerPotBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-carrotblock"><a href="#sharedcounter-carrotblock" class="header-anchor">#</a> <code>SharedCounter&lt;CarrotBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;CarrotBlock&gt;
{
  CarrotBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-carrotblock"><a href="#sharedptr-carrotblock" class="header-anchor">#</a> <code>SharedPtr&lt;CarrotBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;CarrotBlock&gt;
{
  SharedCounter&lt;CarrotBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-potatoblock"><a href="#sharedcounter-potatoblock" class="header-anchor">#</a> <code>SharedCounter&lt;PotatoBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;PotatoBlock&gt;
{
  PotatoBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-potatoblock"><a href="#sharedptr-potatoblock" class="header-anchor">#</a> <code>SharedPtr&lt;PotatoBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;PotatoBlock&gt;
{
  SharedCounter&lt;PotatoBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-woodbuttonblock"><a href="#sharedcounter-woodbuttonblock" class="header-anchor">#</a> <code>SharedCounter&lt;WoodButtonBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;WoodButtonBlock&gt;
{
  WoodButtonBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-woodbuttonblock"><a href="#sharedptr-woodbuttonblock" class="header-anchor">#</a> <code>SharedPtr&lt;WoodButtonBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;WoodButtonBlock&gt;
{
  SharedCounter&lt;WoodButtonBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-skullblock"><a href="#sharedcounter-skullblock" class="header-anchor">#</a> <code>SharedCounter&lt;SkullBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;SkullBlock&gt;
{
  SkullBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-skullblock"><a href="#sharedptr-skullblock" class="header-anchor">#</a> <code>SharedPtr&lt;SkullBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;SkullBlock&gt;
{
  SharedCounter&lt;SkullBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-anvilblock"><a href="#sharedcounter-anvilblock" class="header-anchor">#</a> <code>SharedCounter&lt;AnvilBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;AnvilBlock&gt;
{
  AnvilBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-anvilblock"><a href="#sharedptr-anvilblock" class="header-anchor">#</a> <code>SharedPtr&lt;AnvilBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;AnvilBlock&gt;
{
  SharedCounter&lt;AnvilBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-weightedpressureplateblock"><a href="#sharedcounter-weightedpressureplateblock" class="header-anchor">#</a> <code>SharedCounter&lt;WeightedPressurePlateBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;WeightedPressurePlateBlock&gt;
{
  WeightedPressurePlateBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-weightedpressureplateblock"><a href="#sharedptr-weightedpressureplateblock" class="header-anchor">#</a> <code>SharedPtr&lt;WeightedPressurePlateBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;WeightedPressurePlateBlock&gt;
{
  SharedCounter&lt;WeightedPressurePlateBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-comparatorblock"><a href="#sharedcounter-comparatorblock" class="header-anchor">#</a> <code>SharedCounter&lt;ComparatorBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ComparatorBlock&gt;
{
  ComparatorBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-comparatorblock"><a href="#sharedptr-comparatorblock" class="header-anchor">#</a> <code>SharedPtr&lt;ComparatorBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ComparatorBlock&gt;
{
  SharedCounter&lt;ComparatorBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-daylightdetectorblock"><a href="#sharedcounter-daylightdetectorblock" class="header-anchor">#</a> <code>SharedCounter&lt;DaylightDetectorBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;DaylightDetectorBlock&gt;
{
  DaylightDetectorBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-daylightdetectorblock"><a href="#sharedptr-daylightdetectorblock" class="header-anchor">#</a> <code>SharedPtr&lt;DaylightDetectorBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;DaylightDetectorBlock&gt;
{
  SharedCounter&lt;DaylightDetectorBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-redstoneblock"><a href="#sharedcounter-redstoneblock" class="header-anchor">#</a> <code>SharedCounter&lt;RedstoneBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;RedstoneBlock&gt;
{
  RedstoneBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-redstoneblock"><a href="#sharedptr-redstoneblock" class="header-anchor">#</a> <code>SharedPtr&lt;RedstoneBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;RedstoneBlock&gt;
{
  SharedCounter&lt;RedstoneBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-hopperblock"><a href="#sharedcounter-hopperblock" class="header-anchor">#</a> <code>SharedCounter&lt;HopperBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;HopperBlock&gt;
{
  HopperBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-hopperblock"><a href="#sharedptr-hopperblock" class="header-anchor">#</a> <code>SharedPtr&lt;HopperBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;HopperBlock&gt;
{
  SharedCounter&lt;HopperBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-quartzblockblock"><a href="#sharedcounter-quartzblockblock" class="header-anchor">#</a> <code>SharedCounter&lt;QuartzBlockBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;QuartzBlockBlock&gt;
{
  QuartzBlockBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-quartzblockblock"><a href="#sharedptr-quartzblockblock" class="header-anchor">#</a> <code>SharedPtr&lt;QuartzBlockBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;QuartzBlockBlock&gt;
{
  SharedCounter&lt;QuartzBlockBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-woodslabblock"><a href="#sharedcounter-woodslabblock" class="header-anchor">#</a> <code>SharedCounter&lt;WoodSlabBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;WoodSlabBlock&gt;
{
  WoodSlabBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-woodslabblock"><a href="#sharedptr-woodslabblock" class="header-anchor">#</a> <code>SharedPtr&lt;WoodSlabBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;WoodSlabBlock&gt;
{
  SharedCounter&lt;WoodSlabBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-coloredblock"><a href="#sharedcounter-coloredblock" class="header-anchor">#</a> <code>SharedCounter&lt;ColoredBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ColoredBlock&gt;
{
  ColoredBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-coloredblock"><a href="#sharedptr-coloredblock" class="header-anchor">#</a> <code>SharedPtr&lt;ColoredBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ColoredBlock&gt;
{
  SharedCounter&lt;ColoredBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-stainedglasspaneblock"><a href="#sharedcounter-stainedglasspaneblock" class="header-anchor">#</a> <code>SharedCounter&lt;StainedGlassPaneBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;StainedGlassPaneBlock&gt;
{
  StainedGlassPaneBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-stainedglasspaneblock"><a href="#sharedptr-stainedglasspaneblock" class="header-anchor">#</a> <code>SharedPtr&lt;StainedGlassPaneBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;StainedGlassPaneBlock&gt;
{
  SharedCounter&lt;StainedGlassPaneBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-newleafblock"><a href="#sharedcounter-newleafblock" class="header-anchor">#</a> <code>SharedCounter&lt;NewLeafBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;NewLeafBlock&gt;
{
  NewLeafBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-newleafblock"><a href="#sharedptr-newleafblock" class="header-anchor">#</a> <code>SharedPtr&lt;NewLeafBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;NewLeafBlock&gt;
{
  SharedCounter&lt;NewLeafBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-newlogblock"><a href="#sharedcounter-newlogblock" class="header-anchor">#</a> <code>SharedCounter&lt;NewLogBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;NewLogBlock&gt;
{
  NewLogBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-newlogblock"><a href="#sharedptr-newlogblock" class="header-anchor">#</a> <code>SharedPtr&lt;NewLogBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;NewLogBlock&gt;
{
  SharedCounter&lt;NewLogBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-slimeblock"><a href="#sharedcounter-slimeblock" class="header-anchor">#</a> <code>SharedCounter&lt;SlimeBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;SlimeBlock&gt;
{
  SlimeBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-slimeblock"><a href="#sharedptr-slimeblock" class="header-anchor">#</a> <code>SharedPtr&lt;SlimeBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;SlimeBlock&gt;
{
  SharedCounter&lt;SlimeBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-prismarineblock"><a href="#sharedcounter-prismarineblock" class="header-anchor">#</a> <code>SharedCounter&lt;PrismarineBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;PrismarineBlock&gt;
{
  PrismarineBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-prismarineblock"><a href="#sharedptr-prismarineblock" class="header-anchor">#</a> <code>SharedPtr&lt;PrismarineBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;PrismarineBlock&gt;
{
  SharedCounter&lt;PrismarineBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-sealanternblock"><a href="#sharedcounter-sealanternblock" class="header-anchor">#</a> <code>SharedCounter&lt;SeaLanternBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;SeaLanternBlock&gt;
{
  SeaLanternBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-sealanternblock"><a href="#sharedptr-sealanternblock" class="header-anchor">#</a> <code>SharedPtr&lt;SeaLanternBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;SeaLanternBlock&gt;
{
  SharedCounter&lt;SeaLanternBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-hayblockblock"><a href="#sharedcounter-hayblockblock" class="header-anchor">#</a> <code>SharedCounter&lt;HayBlockBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;HayBlockBlock&gt;
{
  HayBlockBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-hayblockblock"><a href="#sharedptr-hayblockblock" class="header-anchor">#</a> <code>SharedPtr&lt;HayBlockBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;HayBlockBlock&gt;
{
  SharedCounter&lt;HayBlockBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-woolcarpetblock"><a href="#sharedcounter-woolcarpetblock" class="header-anchor">#</a> <code>SharedCounter&lt;WoolCarpetBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;WoolCarpetBlock&gt;
{
  WoolCarpetBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-woolcarpetblock"><a href="#sharedptr-woolcarpetblock" class="header-anchor">#</a> <code>SharedPtr&lt;WoolCarpetBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;WoolCarpetBlock&gt;
{
  SharedCounter&lt;WoolCarpetBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-doubleplantblock"><a href="#sharedcounter-doubleplantblock" class="header-anchor">#</a> <code>SharedCounter&lt;DoublePlantBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;DoublePlantBlock&gt;
{
  DoublePlantBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-doubleplantblock"><a href="#sharedptr-doubleplantblock" class="header-anchor">#</a> <code>SharedPtr&lt;DoublePlantBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;DoublePlantBlock&gt;
{
  SharedCounter&lt;DoublePlantBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-bannerblock"><a href="#sharedcounter-bannerblock" class="header-anchor">#</a> <code>SharedCounter&lt;BannerBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;BannerBlock&gt;
{
  BannerBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-bannerblock"><a href="#sharedptr-bannerblock" class="header-anchor">#</a> <code>SharedPtr&lt;BannerBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;BannerBlock&gt;
{
  SharedCounter&lt;BannerBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-stoneslabblock2"><a href="#sharedcounter-stoneslabblock2" class="header-anchor">#</a> <code>SharedCounter&lt;StoneSlabBlock2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;StoneSlabBlock2&gt;
{
  StoneSlabBlock2 *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-stoneslabblock2"><a href="#sharedptr-stoneslabblock2" class="header-anchor">#</a> <code>SharedPtr&lt;StoneSlabBlock2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;StoneSlabBlock2&gt;
{
  SharedCounter&lt;StoneSlabBlock2&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-grasspathblock"><a href="#sharedcounter-grasspathblock" class="header-anchor">#</a> <code>SharedCounter&lt;GrassPathBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;GrassPathBlock&gt;
{
  GrassPathBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-grasspathblock"><a href="#sharedptr-grasspathblock" class="header-anchor">#</a> <code>SharedPtr&lt;GrassPathBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;GrassPathBlock&gt;
{
  SharedCounter&lt;GrassPathBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-itemframeblock"><a href="#sharedcounter-itemframeblock" class="header-anchor">#</a> <code>SharedCounter&lt;ItemFrameBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ItemFrameBlock&gt;
{
  ItemFrameBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-itemframeblock"><a href="#sharedptr-itemframeblock" class="header-anchor">#</a> <code>SharedPtr&lt;ItemFrameBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ItemFrameBlock&gt;
{
  SharedCounter&lt;ItemFrameBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-chorusflowerblock"><a href="#sharedcounter-chorusflowerblock" class="header-anchor">#</a> <code>SharedCounter&lt;ChorusFlowerBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ChorusFlowerBlock&gt;
{
  ChorusFlowerBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-chorusflowerblock"><a href="#sharedptr-chorusflowerblock" class="header-anchor">#</a> <code>SharedPtr&lt;ChorusFlowerBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ChorusFlowerBlock&gt;
{
  SharedCounter&lt;ChorusFlowerBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-undyedshulkerboxblock"><a href="#sharedcounter-undyedshulkerboxblock" class="header-anchor">#</a> <code>SharedCounter&lt;UndyedShulkerBoxBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;UndyedShulkerBoxBlock&gt;
{
  UndyedShulkerBoxBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-undyedshulkerboxblock"><a href="#sharedptr-undyedshulkerboxblock" class="header-anchor">#</a> <code>SharedPtr&lt;UndyedShulkerBoxBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;UndyedShulkerBoxBlock&gt;
{
  SharedCounter&lt;UndyedShulkerBoxBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-frostediceblock"><a href="#sharedcounter-frostediceblock" class="header-anchor">#</a> <code>SharedCounter&lt;FrostedIceBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;FrostedIceBlock&gt;
{
  FrostedIceBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-frostediceblock"><a href="#sharedptr-frostediceblock" class="header-anchor">#</a> <code>SharedPtr&lt;FrostedIceBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;FrostedIceBlock&gt;
{
  SharedCounter&lt;FrostedIceBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-endrodblock"><a href="#sharedcounter-endrodblock" class="header-anchor">#</a> <code>SharedCounter&lt;EndRodBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;EndRodBlock&gt;
{
  EndRodBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-endrodblock"><a href="#sharedptr-endrodblock" class="header-anchor">#</a> <code>SharedPtr&lt;EndRodBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;EndRodBlock&gt;
{
  SharedCounter&lt;EndRodBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-borderblock"><a href="#sharedcounter-borderblock" class="header-anchor">#</a> <code>SharedCounter&lt;BorderBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;BorderBlock&gt;
{
  BorderBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-borderblock"><a href="#sharedptr-borderblock" class="header-anchor">#</a> <code>SharedPtr&lt;BorderBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;BorderBlock&gt;
{
  SharedCounter&lt;BorderBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-magmablock"><a href="#sharedcounter-magmablock" class="header-anchor">#</a> <code>SharedCounter&lt;MagmaBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;MagmaBlock&gt;
{
  MagmaBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-magmablock"><a href="#sharedptr-magmablock" class="header-anchor">#</a> <code>SharedPtr&lt;MagmaBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;MagmaBlock&gt;
{
  SharedCounter&lt;MagmaBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-rotatedpillarblock"><a href="#sharedcounter-rotatedpillarblock" class="header-anchor">#</a> <code>SharedCounter&lt;RotatedPillarBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;RotatedPillarBlock&gt;
{
  RotatedPillarBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-rotatedpillarblock"><a href="#sharedptr-rotatedpillarblock" class="header-anchor">#</a> <code>SharedPtr&lt;RotatedPillarBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;RotatedPillarBlock&gt;
{
  SharedCounter&lt;RotatedPillarBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-structurevoid"><a href="#sharedcounter-structurevoid" class="header-anchor">#</a> <code>SharedCounter&lt;StructureVoid&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;StructureVoid&gt;
{
  StructureVoid *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-structurevoid"><a href="#sharedptr-structurevoid" class="header-anchor">#</a> <code>SharedPtr&lt;StructureVoid&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;StructureVoid&gt;
{
  SharedCounter&lt;StructureVoid&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-shulkerboxblock"><a href="#sharedcounter-shulkerboxblock" class="header-anchor">#</a> <code>SharedCounter&lt;ShulkerBoxBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ShulkerBoxBlock&gt;
{
  ShulkerBoxBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-shulkerboxblock"><a href="#sharedptr-shulkerboxblock" class="header-anchor">#</a> <code>SharedPtr&lt;ShulkerBoxBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ShulkerBoxBlock&gt;
{
  SharedCounter&lt;ShulkerBoxBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-glazedterracottablock"><a href="#sharedcounter-glazedterracottablock" class="header-anchor">#</a> <code>SharedCounter&lt;GlazedTerracottaBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;GlazedTerracottaBlock&gt;
{
  GlazedTerracottaBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-glazedterracottablock"><a href="#sharedptr-glazedterracottablock" class="header-anchor">#</a> <code>SharedPtr&lt;GlazedTerracottaBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;GlazedTerracottaBlock&gt;
{
  SharedCounter&lt;GlazedTerracottaBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-concreteblock"><a href="#sharedcounter-concreteblock" class="header-anchor">#</a> <code>SharedCounter&lt;ConcreteBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ConcreteBlock&gt;
{
  ConcreteBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-concreteblock"><a href="#sharedptr-concreteblock" class="header-anchor">#</a> <code>SharedPtr&lt;ConcreteBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ConcreteBlock&gt;
{
  SharedCounter&lt;ConcreteBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-concretepowderblock"><a href="#sharedcounter-concretepowderblock" class="header-anchor">#</a> <code>SharedCounter&lt;ConcretePowderBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ConcretePowderBlock&gt;
{
  ConcretePowderBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-concretepowderblock"><a href="#sharedptr-concretepowderblock" class="header-anchor">#</a> <code>SharedPtr&lt;ConcretePowderBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ConcretePowderBlock&gt;
{
  SharedCounter&lt;ConcretePowderBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-chorusplantblock"><a href="#sharedcounter-chorusplantblock" class="header-anchor">#</a> <code>SharedCounter&lt;ChorusPlantBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ChorusPlantBlock&gt;
{
  ChorusPlantBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-chorusplantblock"><a href="#sharedptr-chorusplantblock" class="header-anchor">#</a> <code>SharedPtr&lt;ChorusPlantBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ChorusPlantBlock&gt;
{
  SharedCounter&lt;ChorusPlantBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-stainedglassblock"><a href="#sharedcounter-stainedglassblock" class="header-anchor">#</a> <code>SharedCounter&lt;StainedGlassBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;StainedGlassBlock&gt;
{
  StainedGlassBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-stainedglassblock"><a href="#sharedptr-stainedglassblock" class="header-anchor">#</a> <code>SharedPtr&lt;StainedGlassBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;StainedGlassBlock&gt;
{
  SharedCounter&lt;StainedGlassBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-camerablock"><a href="#sharedcounter-camerablock" class="header-anchor">#</a> <code>SharedCounter&lt;CameraBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;CameraBlock&gt;
{
  CameraBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-camerablock"><a href="#sharedptr-camerablock" class="header-anchor">#</a> <code>SharedPtr&lt;CameraBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;CameraBlock&gt;
{
  SharedCounter&lt;CameraBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-podzolblock"><a href="#sharedcounter-podzolblock" class="header-anchor">#</a> <code>SharedCounter&lt;PodzolBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;PodzolBlock&gt;
{
  PodzolBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-podzolblock"><a href="#sharedptr-podzolblock" class="header-anchor">#</a> <code>SharedPtr&lt;PodzolBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;PodzolBlock&gt;
{
  SharedCounter&lt;PodzolBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-beetrootblock"><a href="#sharedcounter-beetrootblock" class="header-anchor">#</a> <code>SharedCounter&lt;BeetrootBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;BeetrootBlock&gt;
{
  BeetrootBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-beetrootblock"><a href="#sharedptr-beetrootblock" class="header-anchor">#</a> <code>SharedPtr&lt;BeetrootBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;BeetrootBlock&gt;
{
  SharedCounter&lt;BeetrootBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-stonecutterblock"><a href="#sharedcounter-stonecutterblock" class="header-anchor">#</a> <code>SharedCounter&lt;StonecutterBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;StonecutterBlock&gt;
{
  StonecutterBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-stonecutterblock"><a href="#sharedptr-stonecutterblock" class="header-anchor">#</a> <code>SharedPtr&lt;StonecutterBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;StonecutterBlock&gt;
{
  SharedCounter&lt;StonecutterBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-netherreactorblock"><a href="#sharedcounter-netherreactorblock" class="header-anchor">#</a> <code>SharedCounter&lt;NetherReactorBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;NetherReactorBlock&gt;
{
  NetherReactorBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-netherreactorblock"><a href="#sharedptr-netherreactorblock" class="header-anchor">#</a> <code>SharedPtr&lt;NetherReactorBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;NetherReactorBlock&gt;
{
  SharedCounter&lt;NetherReactorBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-movingblock"><a href="#sharedcounter-movingblock" class="header-anchor">#</a> <code>SharedCounter&lt;MovingBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;MovingBlock&gt;
{
  MovingBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-movingblock"><a href="#sharedptr-movingblock" class="header-anchor">#</a> <code>SharedPtr&lt;MovingBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;MovingBlock&gt;
{
  SharedCounter&lt;MovingBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-observerblock"><a href="#sharedcounter-observerblock" class="header-anchor">#</a> <code>SharedCounter&lt;ObserverBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ObserverBlock&gt;
{
  ObserverBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-observerblock"><a href="#sharedptr-observerblock" class="header-anchor">#</a> <code>SharedPtr&lt;ObserverBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ObserverBlock&gt;
{
  SharedCounter&lt;ObserverBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-structureblock"><a href="#sharedcounter-structureblock" class="header-anchor">#</a> <code>SharedCounter&lt;StructureBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;StructureBlock&gt;
{
  StructureBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-structureblock"><a href="#sharedptr-structureblock" class="header-anchor">#</a> <code>SharedPtr&lt;StructureBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;StructureBlock&gt;
{
  SharedCounter&lt;StructureBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-strippedlogblock"><a href="#sharedcounter-strippedlogblock" class="header-anchor">#</a> <code>SharedCounter&lt;StrippedLogBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;StrippedLogBlock&gt;
{
  StrippedLogBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-strippedlogblock"><a href="#sharedptr-strippedlogblock" class="header-anchor">#</a> <code>SharedPtr&lt;StrippedLogBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;StrippedLogBlock&gt;
{
  SharedCounter&lt;StrippedLogBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-blueiceblock"><a href="#sharedcounter-blueiceblock" class="header-anchor">#</a> <code>SharedCounter&lt;BlueIceBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;BlueIceBlock&gt;
{
  BlueIceBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-blueiceblock"><a href="#sharedptr-blueiceblock" class="header-anchor">#</a> <code>SharedPtr&lt;BlueIceBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;BlueIceBlock&gt;
{
  SharedCounter&lt;BlueIceBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-fireblock"><a href="#sharedcounter-fireblock" class="header-anchor">#</a> <code>SharedCounter&lt;FireBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;FireBlock&gt;
{
  FireBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-fireblock"><a href="#sharedptr-fireblock" class="header-anchor">#</a> <code>SharedPtr&lt;FireBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;FireBlock&gt;
{
  SharedCounter&lt;FireBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-chemistrytableblock"><a href="#sharedcounter-chemistrytableblock" class="header-anchor">#</a> <code>SharedCounter&lt;ChemistryTableBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ChemistryTableBlock&gt;
{
  ChemistryTableBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-chemistrytableblock"><a href="#sharedptr-chemistrytableblock" class="header-anchor">#</a> <code>SharedPtr&lt;ChemistryTableBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ChemistryTableBlock&gt;
{
  SharedCounter&lt;ChemistryTableBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-underwatertorchblock"><a href="#sharedcounter-underwatertorchblock" class="header-anchor">#</a> <code>SharedCounter&lt;UnderwaterTorchBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;UnderwaterTorchBlock&gt;
{
  UnderwaterTorchBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-underwatertorchblock"><a href="#sharedptr-underwatertorchblock" class="header-anchor">#</a> <code>SharedPtr&lt;UnderwaterTorchBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;UnderwaterTorchBlock&gt;
{
  SharedCounter&lt;UnderwaterTorchBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-chemicalheatblock"><a href="#sharedcounter-chemicalheatblock" class="header-anchor">#</a> <code>SharedCounter&lt;ChemicalHeatBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ChemicalHeatBlock&gt;
{
  ChemicalHeatBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-chemicalheatblock"><a href="#sharedptr-chemicalheatblock" class="header-anchor">#</a> <code>SharedPtr&lt;ChemicalHeatBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ChemicalHeatBlock&gt;
{
  SharedCounter&lt;ChemicalHeatBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-coloredtorchblock"><a href="#sharedcounter-coloredtorchblock" class="header-anchor">#</a> <code>SharedCounter&lt;ColoredTorchBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ColoredTorchBlock&gt;
{
  ColoredTorchBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-coloredtorchblock"><a href="#sharedptr-coloredtorchblock" class="header-anchor">#</a> <code>SharedPtr&lt;ColoredTorchBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ColoredTorchBlock&gt;
{
  SharedCounter&lt;ColoredTorchBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-modblock"><a href="#sharedcounter-modblock" class="header-anchor">#</a> <code>SharedCounter&lt;ModBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ModBlock&gt;
{
  ModBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-modblock"><a href="#sharedptr-modblock" class="header-anchor">#</a> <code>SharedPtr&lt;ModBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ModBlock&gt;
{
  SharedCounter&lt;ModBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-elementblock"><a href="#sharedcounter-elementblock" class="header-anchor">#</a> <code>SharedCounter&lt;ElementBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ElementBlock&gt;
{
  ElementBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-elementblock"><a href="#sharedptr-elementblock" class="header-anchor">#</a> <code>SharedPtr&lt;ElementBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ElementBlock&gt;
{
  SharedCounter&lt;ElementBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-coral"><a href="#sharedcounter-coral" class="header-anchor">#</a> <code>SharedCounter&lt;Coral&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;Coral&gt;
{
  Coral *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-coral"><a href="#sharedptr-coral" class="header-anchor">#</a> <code>SharedPtr&lt;Coral&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;Coral&gt;
{
  SharedCounter&lt;Coral&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-coralblock"><a href="#sharedcounter-coralblock" class="header-anchor">#</a> <code>SharedCounter&lt;CoralBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;CoralBlock&gt;
{
  CoralBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-coralblock"><a href="#sharedptr-coralblock" class="header-anchor">#</a> <code>SharedPtr&lt;CoralBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;CoralBlock&gt;
{
  SharedCounter&lt;CoralBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-coralfan"><a href="#sharedcounter-coralfan" class="header-anchor">#</a> <code>SharedCounter&lt;CoralFan&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;CoralFan&gt;
{
  CoralFan *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-coralfan"><a href="#sharedptr-coralfan" class="header-anchor">#</a> <code>SharedPtr&lt;CoralFan&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;CoralFan&gt;
{
  SharedCounter&lt;CoralFan&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-coralfanhang"><a href="#sharedcounter-coralfanhang" class="header-anchor">#</a> <code>SharedCounter&lt;CoralFanHang&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;CoralFanHang&gt;
{
  CoralFanHang *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-coralfanhang"><a href="#sharedptr-coralfanhang" class="header-anchor">#</a> <code>SharedPtr&lt;CoralFanHang&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;CoralFanHang&gt;
{
  SharedCounter&lt;CoralFanHang&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-kelpblock"><a href="#sharedcounter-kelpblock" class="header-anchor">#</a> <code>SharedCounter&lt;KelpBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;KelpBlock&gt;
{
  KelpBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-kelpblock"><a href="#sharedptr-kelpblock" class="header-anchor">#</a> <code>SharedPtr&lt;KelpBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;KelpBlock&gt;
{
  SharedCounter&lt;KelpBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-driedkelpblock"><a href="#sharedcounter-driedkelpblock" class="header-anchor">#</a> <code>SharedCounter&lt;DriedKelpBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;DriedKelpBlock&gt;
{
  DriedKelpBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-driedkelpblock"><a href="#sharedptr-driedkelpblock" class="header-anchor">#</a> <code>SharedPtr&lt;DriedKelpBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;DriedKelpBlock&gt;
{
  SharedCounter&lt;DriedKelpBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-seagrass"><a href="#sharedcounter-seagrass" class="header-anchor">#</a> <code>SharedCounter&lt;SeaGrass&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;SeaGrass&gt;
{
  SeaGrass *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-seagrass"><a href="#sharedptr-seagrass" class="header-anchor">#</a> <code>SharedPtr&lt;SeaGrass&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;SeaGrass&gt;
{
  SharedCounter&lt;SeaGrass&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-seapickle"><a href="#sharedcounter-seapickle" class="header-anchor">#</a> <code>SharedCounter&lt;SeaPickle&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;SeaPickle&gt;
{
  SeaPickle *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-seapickle"><a href="#sharedptr-seapickle" class="header-anchor">#</a> <code>SharedPtr&lt;SeaPickle&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;SeaPickle&gt;
{
  SharedCounter&lt;SeaPickle&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-conduitblock"><a href="#sharedcounter-conduitblock" class="header-anchor">#</a> <code>SharedCounter&lt;ConduitBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ConduitBlock&gt;
{
  ConduitBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-conduitblock"><a href="#sharedptr-conduitblock" class="header-anchor">#</a> <code>SharedPtr&lt;ConduitBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ConduitBlock&gt;
{
  SharedCounter&lt;ConduitBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-bubblecolumnblock"><a href="#sharedcounter-bubblecolumnblock" class="header-anchor">#</a> <code>SharedCounter&lt;BubbleColumnBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;BubbleColumnBlock&gt;
{
  BubbleColumnBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-bubblecolumnblock"><a href="#sharedptr-bubblecolumnblock" class="header-anchor">#</a> <code>SharedPtr&lt;BubbleColumnBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;BubbleColumnBlock&gt;
{
  SharedCounter&lt;BubbleColumnBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-turtleeggblock"><a href="#sharedcounter-turtleeggblock" class="header-anchor">#</a> <code>SharedCounter&lt;TurtleEggBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;TurtleEggBlock&gt;
{
  TurtleEggBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-turtleeggblock"><a href="#sharedptr-turtleeggblock" class="header-anchor">#</a> <code>SharedPtr&lt;TurtleEggBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;TurtleEggBlock&gt;
{
  SharedCounter&lt;TurtleEggBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-barrierblock"><a href="#sharedcounter-barrierblock" class="header-anchor">#</a> <code>SharedCounter&lt;BarrierBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;BarrierBlock&gt;
{
  BarrierBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-barrierblock"><a href="#sharedptr-barrierblock" class="header-anchor">#</a> <code>SharedPtr&lt;BarrierBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;BarrierBlock&gt;
{
  SharedCounter&lt;BarrierBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-scaffoldingblock"><a href="#sharedcounter-scaffoldingblock" class="header-anchor">#</a> <code>SharedCounter&lt;ScaffoldingBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ScaffoldingBlock&gt;
{
  ScaffoldingBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-scaffoldingblock"><a href="#sharedptr-scaffoldingblock" class="header-anchor">#</a> <code>SharedPtr&lt;ScaffoldingBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ScaffoldingBlock&gt;
{
  SharedCounter&lt;ScaffoldingBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-bambooblock"><a href="#sharedcounter-bambooblock" class="header-anchor">#</a> <code>SharedCounter&lt;BambooBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;BambooBlock&gt;
{
  BambooBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-bambooblock"><a href="#sharedptr-bambooblock" class="header-anchor">#</a> <code>SharedPtr&lt;BambooBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;BambooBlock&gt;
{
  SharedCounter&lt;BambooBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-bamboosapling"><a href="#sharedcounter-bamboosapling" class="header-anchor">#</a> <code>SharedCounter&lt;BambooSapling&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;BambooSapling&gt;
{
  BambooSapling *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-bamboosapling"><a href="#sharedptr-bamboosapling" class="header-anchor">#</a> <code>SharedPtr&lt;BambooSapling&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;BambooSapling&gt;
{
  SharedCounter&lt;BambooSapling&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-stoneslabblock3"><a href="#sharedcounter-stoneslabblock3" class="header-anchor">#</a> <code>SharedCounter&lt;StoneSlabBlock3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;StoneSlabBlock3&gt;
{
  StoneSlabBlock3 *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-stoneslabblock3"><a href="#sharedptr-stoneslabblock3" class="header-anchor">#</a> <code>SharedPtr&lt;StoneSlabBlock3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;StoneSlabBlock3&gt;
{
  SharedCounter&lt;StoneSlabBlock3&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-stoneslabblock4"><a href="#sharedcounter-stoneslabblock4" class="header-anchor">#</a> <code>SharedCounter&lt;StoneSlabBlock4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;StoneSlabBlock4&gt;
{
  StoneSlabBlock4 *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-stoneslabblock4"><a href="#sharedptr-stoneslabblock4" class="header-anchor">#</a> <code>SharedPtr&lt;StoneSlabBlock4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;StoneSlabBlock4&gt;
{
  SharedCounter&lt;StoneSlabBlock4&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-lecternblock"><a href="#sharedcounter-lecternblock" class="header-anchor">#</a> <code>SharedCounter&lt;LecternBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;LecternBlock&gt;
{
  LecternBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-lecternblock"><a href="#sharedptr-lecternblock" class="header-anchor">#</a> <code>SharedPtr&lt;LecternBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;LecternBlock&gt;
{
  SharedCounter&lt;LecternBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-grindstoneblock"><a href="#sharedcounter-grindstoneblock" class="header-anchor">#</a> <code>SharedCounter&lt;GrindstoneBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;GrindstoneBlock&gt;
{
  GrindstoneBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-grindstoneblock"><a href="#sharedptr-grindstoneblock" class="header-anchor">#</a> <code>SharedPtr&lt;GrindstoneBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;GrindstoneBlock&gt;
{
  SharedCounter&lt;GrindstoneBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-blastfurnaceblock"><a href="#sharedcounter-blastfurnaceblock" class="header-anchor">#</a> <code>SharedCounter&lt;BlastFurnaceBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;BlastFurnaceBlock&gt;
{
  BlastFurnaceBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-blastfurnaceblock"><a href="#sharedptr-blastfurnaceblock" class="header-anchor">#</a> <code>SharedPtr&lt;BlastFurnaceBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;BlastFurnaceBlock&gt;
{
  SharedCounter&lt;BlastFurnaceBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-smokerblock"><a href="#sharedcounter-smokerblock" class="header-anchor">#</a> <code>SharedCounter&lt;SmokerBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;SmokerBlock&gt;
{
  SmokerBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-smokerblock"><a href="#sharedptr-smokerblock" class="header-anchor">#</a> <code>SharedPtr&lt;SmokerBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;SmokerBlock&gt;
{
  SharedCounter&lt;SmokerBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-cartographytableblock"><a href="#sharedcounter-cartographytableblock" class="header-anchor">#</a> <code>SharedCounter&lt;CartographyTableBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;CartographyTableBlock&gt;
{
  CartographyTableBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-cartographytableblock"><a href="#sharedptr-cartographytableblock" class="header-anchor">#</a> <code>SharedPtr&lt;CartographyTableBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;CartographyTableBlock&gt;
{
  SharedCounter&lt;CartographyTableBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-smithingtableblock"><a href="#sharedcounter-smithingtableblock" class="header-anchor">#</a> <code>SharedCounter&lt;SmithingTableBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;SmithingTableBlock&gt;
{
  SmithingTableBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-smithingtableblock"><a href="#sharedptr-smithingtableblock" class="header-anchor">#</a> <code>SharedPtr&lt;SmithingTableBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;SmithingTableBlock&gt;
{
  SharedCounter&lt;SmithingTableBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-barrelblock"><a href="#sharedcounter-barrelblock" class="header-anchor">#</a> <code>SharedCounter&lt;BarrelBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;BarrelBlock&gt;
{
  BarrelBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-barrelblock"><a href="#sharedptr-barrelblock" class="header-anchor">#</a> <code>SharedPtr&lt;BarrelBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;BarrelBlock&gt;
{
  SharedCounter&lt;BarrelBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-loomblock"><a href="#sharedcounter-loomblock" class="header-anchor">#</a> <code>SharedCounter&lt;LoomBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;LoomBlock&gt;
{
  LoomBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-loomblock"><a href="#sharedptr-loomblock" class="header-anchor">#</a> <code>SharedPtr&lt;LoomBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;LoomBlock&gt;
{
  SharedCounter&lt;LoomBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-bellblock"><a href="#sharedcounter-bellblock" class="header-anchor">#</a> <code>SharedCounter&lt;BellBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;BellBlock&gt;
{
  BellBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-bellblock"><a href="#sharedptr-bellblock" class="header-anchor">#</a> <code>SharedPtr&lt;BellBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;BellBlock&gt;
{
  SharedCounter&lt;BellBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-sweetberrybushblock"><a href="#sharedcounter-sweetberrybushblock" class="header-anchor">#</a> <code>SharedCounter&lt;SweetBerryBushBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;SweetBerryBushBlock&gt;
{
  SweetBerryBushBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-sweetberrybushblock"><a href="#sharedptr-sweetberrybushblock" class="header-anchor">#</a> <code>SharedPtr&lt;SweetBerryBushBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;SweetBerryBushBlock&gt;
{
  SharedCounter&lt;SweetBerryBushBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-lanternblock"><a href="#sharedcounter-lanternblock" class="header-anchor">#</a> <code>SharedCounter&lt;LanternBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;LanternBlock&gt;
{
  LanternBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-lanternblock"><a href="#sharedptr-lanternblock" class="header-anchor">#</a> <code>SharedPtr&lt;LanternBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;LanternBlock&gt;
{
  SharedCounter&lt;LanternBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-campfireblock"><a href="#sharedcounter-campfireblock" class="header-anchor">#</a> <code>SharedCounter&lt;CampfireBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;CampfireBlock&gt;
{
  CampfireBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-campfireblock"><a href="#sharedptr-campfireblock" class="header-anchor">#</a> <code>SharedPtr&lt;CampfireBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;CampfireBlock&gt;
{
  SharedCounter&lt;CampfireBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-jigsawblock"><a href="#sharedcounter-jigsawblock" class="header-anchor">#</a> <code>SharedCounter&lt;JigsawBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;JigsawBlock&gt;
{
  JigsawBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-jigsawblock"><a href="#sharedptr-jigsawblock" class="header-anchor">#</a> <code>SharedPtr&lt;JigsawBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;JigsawBlock&gt;
{
  SharedCounter&lt;JigsawBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-woodblock"><a href="#sharedcounter-woodblock" class="header-anchor">#</a> <code>SharedCounter&lt;WoodBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;WoodBlock&gt;
{
  WoodBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-woodblock"><a href="#sharedptr-woodblock" class="header-anchor">#</a> <code>SharedPtr&lt;WoodBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;WoodBlock&gt;
{
  SharedCounter&lt;WoodBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-composterblock"><a href="#sharedcounter-composterblock" class="header-anchor">#</a> <code>SharedCounter&lt;ComposterBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ComposterBlock&gt;
{
  ComposterBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-composterblock"><a href="#sharedptr-composterblock" class="header-anchor">#</a> <code>SharedPtr&lt;ComposterBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ComposterBlock&gt;
{
  SharedCounter&lt;ComposterBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-lightblock"><a href="#sharedcounter-lightblock" class="header-anchor">#</a> <code>SharedCounter&lt;LightBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;LightBlock&gt;
{
  LightBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-lightblock"><a href="#sharedptr-lightblock" class="header-anchor">#</a> <code>SharedPtr&lt;LightBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;LightBlock&gt;
{
  SharedCounter&lt;LightBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-witherroseblock"><a href="#sharedcounter-witherroseblock" class="header-anchor">#</a> <code>SharedCounter&lt;WitherRoseBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;WitherRoseBlock&gt;
{
  WitherRoseBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-witherroseblock"><a href="#sharedptr-witherroseblock" class="header-anchor">#</a> <code>SharedPtr&lt;WitherRoseBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;WitherRoseBlock&gt;
{
  SharedCounter&lt;WitherRoseBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-beehiveblock"><a href="#sharedcounter-beehiveblock" class="header-anchor">#</a> <code>SharedCounter&lt;BeehiveBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;BeehiveBlock&gt;
{
  BeehiveBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-beehiveblock"><a href="#sharedptr-beehiveblock" class="header-anchor">#</a> <code>SharedPtr&lt;BeehiveBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;BeehiveBlock&gt;
{
  SharedCounter&lt;BeehiveBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-honeyblock"><a href="#sharedcounter-honeyblock" class="header-anchor">#</a> <code>SharedCounter&lt;HoneyBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;HoneyBlock&gt;
{
  HoneyBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-honeyblock"><a href="#sharedptr-honeyblock" class="header-anchor">#</a> <code>SharedPtr&lt;HoneyBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;HoneyBlock&gt;
{
  SharedCounter&lt;HoneyBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-honeycombblock"><a href="#sharedcounter-honeycombblock" class="header-anchor">#</a> <code>SharedCounter&lt;HoneycombBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;HoneycombBlock&gt;
{
  HoneycombBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-honeycombblock"><a href="#sharedptr-honeycombblock" class="header-anchor">#</a> <code>SharedPtr&lt;HoneycombBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;HoneycombBlock&gt;
{
  SharedCounter&lt;HoneycombBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-lodestoneblock"><a href="#sharedcounter-lodestoneblock" class="header-anchor">#</a> <code>SharedCounter&lt;LodestoneBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;LodestoneBlock&gt;
{
  LodestoneBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-lodestoneblock"><a href="#sharedptr-lodestoneblock" class="header-anchor">#</a> <code>SharedPtr&lt;LodestoneBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;LodestoneBlock&gt;
{
  SharedCounter&lt;LodestoneBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-fungusstem"><a href="#sharedcounter-fungusstem" class="header-anchor">#</a> <code>SharedCounter&lt;FungusStem&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;FungusStem&gt;
{
  FungusStem *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-fungusstem"><a href="#sharedptr-fungusstem" class="header-anchor">#</a> <code>SharedPtr&lt;FungusStem&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;FungusStem&gt;
{
  SharedCounter&lt;FungusStem&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-netherfungusblock"><a href="#sharedcounter-netherfungusblock" class="header-anchor">#</a> <code>SharedCounter&lt;NetherFungusBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;NetherFungusBlock&gt;
{
  NetherFungusBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-netherfungusblock"><a href="#sharedptr-netherfungusblock" class="header-anchor">#</a> <code>SharedPtr&lt;NetherFungusBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;NetherFungusBlock&gt;
{
  SharedCounter&lt;NetherFungusBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-weepingvinesblock"><a href="#sharedcounter-weepingvinesblock" class="header-anchor">#</a> <code>SharedCounter&lt;WeepingVinesBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;WeepingVinesBlock&gt;
{
  WeepingVinesBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-weepingvinesblock"><a href="#sharedptr-weepingvinesblock" class="header-anchor">#</a> <code>SharedPtr&lt;WeepingVinesBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;WeepingVinesBlock&gt;
{
  SharedCounter&lt;WeepingVinesBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-nyliumblock"><a href="#sharedcounter-nyliumblock" class="header-anchor">#</a> <code>SharedCounter&lt;NyliumBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;NyliumBlock&gt;
{
  NyliumBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-nyliumblock"><a href="#sharedptr-nyliumblock" class="header-anchor">#</a> <code>SharedPtr&lt;NyliumBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;NyliumBlock&gt;
{
  SharedCounter&lt;NyliumBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-bluefireblock"><a href="#sharedcounter-bluefireblock" class="header-anchor">#</a> <code>SharedCounter&lt;BlueFireBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;BlueFireBlock&gt;
{
  BlueFireBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-bluefireblock"><a href="#sharedptr-bluefireblock" class="header-anchor">#</a> <code>SharedPtr&lt;BlueFireBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;BlueFireBlock&gt;
{
  SharedCounter&lt;BlueFireBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-nethersprouts"><a href="#sharedcounter-nethersprouts" class="header-anchor">#</a> <code>SharedCounter&lt;NetherSprouts&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;NetherSprouts&gt;
{
  NetherSprouts *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-nethersprouts"><a href="#sharedptr-nethersprouts" class="header-anchor">#</a> <code>SharedPtr&lt;NetherSprouts&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;NetherSprouts&gt;
{
  SharedCounter&lt;NetherSprouts&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-targetblock"><a href="#sharedcounter-targetblock" class="header-anchor">#</a> <code>SharedCounter&lt;TargetBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;TargetBlock&gt;
{
  TargetBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-targetblock"><a href="#sharedptr-targetblock" class="header-anchor">#</a> <code>SharedPtr&lt;TargetBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;TargetBlock&gt;
{
  SharedCounter&lt;TargetBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-slabblock"><a href="#sharedcounter-slabblock" class="header-anchor">#</a> <code>SharedCounter&lt;SlabBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;SlabBlock&gt;
{
  SlabBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-slabblock"><a href="#sharedptr-slabblock" class="header-anchor">#</a> <code>SharedPtr&lt;SlabBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;SlabBlock&gt;
{
  SharedCounter&lt;SlabBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-soultorchblock"><a href="#sharedcounter-soultorchblock" class="header-anchor">#</a> <code>SharedCounter&lt;SoulTorchBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;SoulTorchBlock&gt;
{
  SoulTorchBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-soultorchblock"><a href="#sharedptr-soultorchblock" class="header-anchor">#</a> <code>SharedPtr&lt;SoulTorchBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;SoulTorchBlock&gt;
{
  SharedCounter&lt;SoulTorchBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-respawnanchorblock"><a href="#sharedcounter-respawnanchorblock" class="header-anchor">#</a> <code>SharedCounter&lt;RespawnAnchorBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;RespawnAnchorBlock&gt;
{
  RespawnAnchorBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedcounter-gildedblackstone"><a href="#sharedcounter-gildedblackstone" class="header-anchor">#</a> <code>SharedCounter&lt;GildedBlackstone&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;GildedBlackstone&gt;
{
  GildedBlackstone *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-gildedblackstone"><a href="#sharedptr-gildedblackstone" class="header-anchor">#</a> <code>SharedPtr&lt;GildedBlackstone&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;GildedBlackstone&gt;
{
  SharedCounter&lt;GildedBlackstone&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-chainblock"><a href="#sharedcounter-chainblock" class="header-anchor">#</a> <code>SharedCounter&lt;ChainBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;ChainBlock&gt;
{
  ChainBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-chainblock"><a href="#sharedptr-chainblock" class="header-anchor">#</a> <code>SharedPtr&lt;ChainBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;ChainBlock&gt;
{
  SharedCounter&lt;ChainBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-twistingvinesblock"><a href="#sharedcounter-twistingvinesblock" class="header-anchor">#</a> <code>SharedCounter&lt;TwistingVinesBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;TwistingVinesBlock&gt;
{
  TwistingVinesBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-twistingvinesblock"><a href="#sharedptr-twistingvinesblock" class="header-anchor">#</a> <code>SharedPtr&lt;TwistingVinesBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;TwistingVinesBlock&gt;
{
  SharedCounter&lt;TwistingVinesBlock&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-cryingobsidianblock"><a href="#sharedcounter-cryingobsidianblock" class="header-anchor">#</a> <code>SharedCounter&lt;CryingObsidianBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;CryingObsidianBlock&gt;
{
  CryingObsidianBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-cryingobsidianblock"><a href="#sharedptr-cryingobsidianblock" class="header-anchor">#</a> <code>SharedPtr&lt;CryingObsidianBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;CryingObsidianBlock&gt;
{
  SharedCounter&lt;CryingObsidianBlock&gt; *pc;
};

</code></pre></div><h3 id="skullblock-checkmobspawn-l17-lambda-b4b567f629a037a9035c572fb1fba35e"><a href="#skullblock-checkmobspawn-l17-lambda-b4b567f629a037a9035c572fb1fba35e" class="header-anchor">#</a> <code>SkullBlock::checkMobSpawn::__l17::&lt;lambda_b4b567f629a037a9035c572fb1fba35e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SkullBlock::checkMobSpawn::__l17::&lt;lambda_b4b567f629a037a9035c572fb1fba35e&gt;
{
  const BlockPos *pos;
  Mob **mob;
  BlockSource *region;
};

</code></pre></div><h3 id="skullblock-checkmobspawn-l11-lambda-67539536fae5ffef79f3a0de553d19bc"><a href="#skullblock-checkmobspawn-l11-lambda-67539536fae5ffef79f3a0de553d19bc" class="header-anchor">#</a> <code>SkullBlock::checkMobSpawn::__l11::&lt;lambda_67539536fae5ffef79f3a0de553d19bc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SkullBlock::checkMobSpawn::__l11::&lt;lambda_67539536fae5ffef79f3a0de553d19bc&gt;
{
  const BlockPos *pos;
  BlockSource *region;
};

</code></pre></div><h3 id="sapling-isnearflowerblock-l2-lambda-356b45de45567e8e6fa659ccfaec2036"><a href="#sapling-isnearflowerblock-l2-lambda-356b45de45567e8e6fa659ccfaec2036" class="header-anchor">#</a> <code>Sapling::_isNearFlowerBlock::__l2::&lt;lambda_356b45de45567e8e6fa659ccfaec2036&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Sapling::_isNearFlowerBlock::__l2::&lt;lambda_356b45de45567e8e6fa659ccfaec2036&gt;
{
};

</code></pre></div><h3 id="stringprintstream"><a href="#stringprintstream" class="header-anchor">#</a> <code>StringPrintStream</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StringPrintStream : PrintStream
{
  std::basic_stringstream&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; out;
};

</code></pre></div><h3 id="stringprintstream-vtbl"><a href="#stringprintstream-vtbl" class="header-anchor">#</a> <code>StringPrintStream_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StringPrintStream_vtbl
{
  void (__fastcall *~PrintStream)(PrintStream *this);
  void (__fastcall *print)(PrintStream *this, const std::string *);
};

</code></pre></div><h3 id="subtractivelightinfo"><a href="#subtractivelightinfo" class="header-anchor">#</a> <code>SubtractiveLightInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SubtractiveLightInfo
{
  $52A32AF023F0868BF2C19D5A22A86A92 ___u0;
};

</code></pre></div><h3 id="subchunkblockstoragepaletted-1-1"><a href="#subchunkblockstoragepaletted-1-1" class="header-anchor">#</a> <code>SubChunkBlockStoragePaletted&lt;1,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) SubChunkBlockStoragePaletted&lt;1,1&gt; : ISubChunkBlockStoragePaletted
{
  unsigned int mBlocks[128];
  AppendOnlyAtomicLookupTable&lt;Block const *,2&gt; mPalette;
  bool mModDataFlag;
};

</code></pre></div><h3 id="subchunkblockstoragepaletted-2-2"><a href="#subchunkblockstoragepaletted-2-2" class="header-anchor">#</a> <code>SubChunkBlockStoragePaletted&lt;2,2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) SubChunkBlockStoragePaletted&lt;2,2&gt; : ISubChunkBlockStoragePaletted
{
  unsigned int mBlocks[256];
  AppendOnlyAtomicLookupTable&lt;Block const *,4&gt; mPalette;
  bool mModDataFlag;
};

</code></pre></div><h3 id="subchunkblockstoragepaletted-3-3"><a href="#subchunkblockstoragepaletted-3-3" class="header-anchor">#</a> <code>SubChunkBlockStoragePaletted&lt;3,3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) SubChunkBlockStoragePaletted&lt;3,3&gt; : ISubChunkBlockStoragePaletted
{
  unsigned int mBlocks[410];
  AppendOnlyAtomicLookupTable&lt;Block const *,8&gt; mPalette;
  bool mModDataFlag;
};

</code></pre></div><h3 id="subchunkblockstoragepaletted-4-4"><a href="#subchunkblockstoragepaletted-4-4" class="header-anchor">#</a> <code>SubChunkBlockStoragePaletted&lt;4,4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) SubChunkBlockStoragePaletted&lt;4,4&gt; : ISubChunkBlockStoragePaletted
{
  unsigned int mBlocks[512];
  AppendOnlyAtomicLookupTable&lt;Block const *,16&gt; mPalette;
  bool mModDataFlag;
};

</code></pre></div><h3 id="subchunkblockstoragepaletted-5-5"><a href="#subchunkblockstoragepaletted-5-5" class="header-anchor">#</a> <code>SubChunkBlockStoragePaletted&lt;5,5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) SubChunkBlockStoragePaletted&lt;5,5&gt; : ISubChunkBlockStoragePaletted
{
  unsigned int mBlocks[683];
  AppendOnlyAtomicLookupTable&lt;Block const *,32&gt; mPalette;
  bool mModDataFlag;
};

</code></pre></div><h3 id="subchunkblockstoragepaletted-6-6"><a href="#subchunkblockstoragepaletted-6-6" class="header-anchor">#</a> <code>SubChunkBlockStoragePaletted&lt;6,6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) SubChunkBlockStoragePaletted&lt;6,6&gt; : ISubChunkBlockStoragePaletted
{
  unsigned int mBlocks[820];
  AppendOnlyAtomicLookupTable&lt;Block const *,64&gt; mPalette;
  bool mModDataFlag;
};

</code></pre></div><h3 id="subchunkblockstoragepaletted-8-8"><a href="#subchunkblockstoragepaletted-8-8" class="header-anchor">#</a> <code>SubChunkBlockStoragePaletted&lt;8,8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) SubChunkBlockStoragePaletted&lt;8,8&gt; : ISubChunkBlockStoragePaletted
{
  unsigned int mBlocks[1024];
  AppendOnlyAtomicLookupTable&lt;Block const *,256&gt; mPalette;
  bool mModDataFlag;
};

</code></pre></div><h3 id="subchunkblockstoragepaletted-16-16"><a href="#subchunkblockstoragepaletted-16-16" class="header-anchor">#</a> <code>SubChunkBlockStoragePaletted&lt;16,16&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) SubChunkBlockStoragePaletted&lt;16,16&gt; : ISubChunkBlockStoragePaletted
{
  unsigned int mBlocks[2048];
  AppendOnlyAtomicLookupTable&lt;Block const *,4096&gt; mPalette;
  bool mModDataFlag;
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-0812bcb2507b32093a0a61069d8a46e3"><a href="#scatterparams-buildschema-l2-lambda-0812bcb2507b32093a0a61069d8a46e3" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_0812bcb2507b32093a0a61069d8a46e3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_0812bcb2507b32093a0a61069d8a46e3&gt;
{
  std::function&lt;ScatterParams &amp; __cdecl(AutomaticFeatureRules::AutomaticFeatureRule *)&gt; scatterAccessor;
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-adc91ec67211fa85faa0bdd4dd420227"><a href="#scatterparams-buildschema-l2-lambda-adc91ec67211fa85faa0bdd4dd420227" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_adc91ec67211fa85faa0bdd4dd420227&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_adc91ec67211fa85faa0bdd4dd420227&gt;
{
  std::function&lt;ScatterParams &amp; __cdecl(AutomaticFeatureRules::AutomaticFeatureRule *)&gt; scatterAccessor;
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-b408264c7c65667b62fdd391893bda86"><a href="#scatterparams-buildschema-l2-lambda-b408264c7c65667b62fdd391893bda86" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_b408264c7c65667b62fdd391893bda86&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_b408264c7c65667b62fdd391893bda86&gt;
{
  std::function&lt;ScatterParams &amp; __cdecl(AutomaticFeatureRules::AutomaticFeatureRule *)&gt; scatterAccessor;
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-ef7741f99428e89231f1ac3107cd92ce"><a href="#scatterparams-buildschema-l2-lambda-ef7741f99428e89231f1ac3107cd92ce" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_ef7741f99428e89231f1ac3107cd92ce&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_ef7741f99428e89231f1ac3107cd92ce&gt;
{
  std::function&lt;ScatterParams &amp; __cdecl(AutomaticFeatureRules::AutomaticFeatureRule *)&gt; scatterAccessor;
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-aa996b390096f3a8fdec0bcbde8e973d"><a href="#scatterparams-buildschema-l2-lambda-aa996b390096f3a8fdec0bcbde8e973d" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_aa996b390096f3a8fdec0bcbde8e973d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_aa996b390096f3a8fdec0bcbde8e973d&gt;
{
  std::function&lt;ScatterParams &amp; __cdecl(AutomaticFeatureRules::AutomaticFeatureRule *)&gt; scatterAccessor;
};

</code></pre></div><h3 id="scatterparams-buildschema-l3-lambda-aeacb45e4360de140d50033a3d23444e"><a href="#scatterparams-buildschema-l3-lambda-aeacb45e4360de140d50033a3d23444e" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l3::&lt;lambda_aeacb45e4360de140d50033a3d23444e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l3::&lt;lambda_aeacb45e4360de140d50033a3d23444e&gt;
{
  std::function&lt;ScatterParams &amp; __cdecl(AutomaticFeatureRules::AutomaticFeatureRule *)&gt; scatterAccessor;
};

</code></pre></div><h3 id="scatterparams-buildschema-l3-lambda-895ea9aa2378ef8b84ab5139aa899cbe"><a href="#scatterparams-buildschema-l3-lambda-895ea9aa2378ef8b84ab5139aa899cbe" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l3::&lt;lambda_895ea9aa2378ef8b84ab5139aa899cbe&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l3::&lt;lambda_895ea9aa2378ef8b84ab5139aa899cbe&gt;
{
  std::function&lt;ScatterParams &amp; __cdecl(AutomaticFeatureRules::AutomaticFeatureRule *)&gt; scatterAccessor;
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-102185838b4f232d0d9c272cce6292a1"><a href="#scatterparams-buildschema-l2-lambda-102185838b4f232d0d9c272cce6292a1" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_102185838b4f232d0d9c272cce6292a1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_102185838b4f232d0d9c272cce6292a1&gt;
{
  std::function&lt;ScatterParams::CoordinateRange &amp; __cdecl(AutomaticFeatureRules::AutomaticFeatureRule *)&gt; coordAccessor;
  const HashedString name;
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-21cbaf2d1049bdf761022c22dee3fa11"><a href="#scatterparams-buildschema-l2-lambda-21cbaf2d1049bdf761022c22dee3fa11" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_21cbaf2d1049bdf761022c22dee3fa11&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_21cbaf2d1049bdf761022c22dee3fa11&gt;
{
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-686c7cb4abbd310594d514a7a14ae3aa"><a href="#scatterparams-buildschema-l2-lambda-686c7cb4abbd310594d514a7a14ae3aa" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_686c7cb4abbd310594d514a7a14ae3aa&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_686c7cb4abbd310594d514a7a14ae3aa&gt;
{
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-8b159dec1ab4da716db4d16a1e125a65"><a href="#scatterparams-buildschema-l2-lambda-8b159dec1ab4da716db4d16a1e125a65" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_8b159dec1ab4da716db4d16a1e125a65&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_8b159dec1ab4da716db4d16a1e125a65&gt;
{
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-fb412aee829706126aa27a66e2340659"><a href="#scatterparams-buildschema-l2-lambda-fb412aee829706126aa27a66e2340659" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_fb412aee829706126aa27a66e2340659&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_fb412aee829706126aa27a66e2340659&gt;
{
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-d1bfadf98c6ff6fe553f53858657333c"><a href="#scatterparams-buildschema-l2-lambda-d1bfadf98c6ff6fe553f53858657333c" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_d1bfadf98c6ff6fe553f53858657333c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_d1bfadf98c6ff6fe553f53858657333c&gt;
{
};

</code></pre></div><h3 id="simpletreecanopy"><a href="#simpletreecanopy" class="header-anchor">#</a> <code>SimpleTreeCanopy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SimpleTreeCanopy : ITreeCanopy
{
  int mMinOffset;
  int mMaxOffset;
  int mMinWidth;
  int mRise;
  int mRun;
  BlockDescriptor mLeafBlockDescriptor;
  TreeHelper::AttachableDecoration mDecoration;
  std::vector&lt;ChanceInformation&gt; mVariationChancePerLayer;
};

</code></pre></div><h3 id="simpletreecanopy-vtbl"><a href="#simpletreecanopy-vtbl" class="header-anchor">#</a> <code>SimpleTreeCanopy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SimpleTreeCanopy_vtbl
{
  void (__fastcall *~ITreeCanopy)(ITreeCanopy *this);
  std::optional&lt;BlockPos&gt; *(__fastcall *placeCanopy)(ITreeCanopy *this, std::optional&lt;BlockPos&gt; *result, IBlockWorldGenAPI *, const BlockPos *, Random *, RenderParams *, const TreeHelper::TreeParams *);
  bool (__fastcall *parseTreeCanopy)(ITreeCanopy *this, const rapidjson::GenericValue&lt;rapidjson::UTF8&lt;char&gt;,rapidjson::MemoryPoolAllocator&lt;rapidjson::CrtAllocator&gt; &gt; *, IWorldRegistriesProvider *);
};

</code></pre></div><h3 id="sprucetreecanopy"><a href="#sprucetreecanopy" class="header-anchor">#</a> <code>SpruceTreeCanopy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SpruceTreeCanopy : ITreeCanopy
{
  IntRange mLowerOffset;
  IntRange mUpperOffset;
  IntRange mRadius;
  BlockDescriptor mLeafBlockDescriptor;
};

</code></pre></div><h3 id="sprucetreecanopy-vtbl"><a href="#sprucetreecanopy-vtbl" class="header-anchor">#</a> <code>SpruceTreeCanopy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SpruceTreeCanopy_vtbl
{
  void (__fastcall *~ITreeCanopy)(ITreeCanopy *this);
  std::optional&lt;BlockPos&gt; *(__fastcall *placeCanopy)(ITreeCanopy *this, std::optional&lt;BlockPos&gt; *result, IBlockWorldGenAPI *, const BlockPos *, Random *, RenderParams *, const TreeHelper::TreeParams *);
  bool (__fastcall *parseTreeCanopy)(ITreeCanopy *this, const rapidjson::GenericValue&lt;rapidjson::UTF8&lt;char&gt;,rapidjson::MemoryPoolAllocator&lt;rapidjson::CrtAllocator&gt; &gt; *, IWorldRegistriesProvider *);
};

</code></pre></div><h3 id="simpletreetrunk"><a href="#simpletreetrunk" class="header-anchor">#</a> <code>SimpleTreeTrunk</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SimpleTreeTrunk : ITreeTrunk
{
  int mSubmergedDepth;
  IntRange mHeight;
  IntRange mHeightModifier;
  BlockDescriptor mTrunkBlockDescriptor;
  TreeHelper::AttachableDecoration mDecoration;
};

</code></pre></div><h3 id="simpletreetrunk-vtbl"><a href="#simpletreetrunk-vtbl" class="header-anchor">#</a> <code>SimpleTreeTrunk_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SimpleTreeTrunk_vtbl
{
  void (__fastcall *~ITreeTrunk)(ITreeTrunk *this);
  std::optional&lt;BlockPos&gt; *(__fastcall *placeTrunk)(ITreeTrunk *this, std::optional&lt;BlockPos&gt; *result, IBlockWorldGenAPI *, const BlockPos *, Random *, RenderParams *, const TreeHelper::TreeParams *, const ITreeCanopy *);
  bool (__fastcall *parse)(ITreeTrunk *this, const rapidjson::GenericValue&lt;rapidjson::UTF8&lt;char&gt;,rapidjson::MemoryPoolAllocator&lt;rapidjson::CrtAllocator&gt; &gt; *, IWorldRegistriesProvider *);
};

</code></pre></div><h3 id="scatterfeature"><a href="#scatterfeature" class="header-anchor">#</a> <code>ScatterFeature</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ScatterFeature : IFeature
{
  WeakRefT&lt;FeatureRefTraits&gt; mFeatureToScatter;
  ScatterParams mScatterParams;
  bool mProjectInputToFloor;
};

</code></pre></div><h3 id="scatterfeature-vtbl"><a href="#scatterfeature-vtbl" class="header-anchor">#</a> <code>ScatterFeature_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ScatterFeature_vtbl
{
  void (__fastcall *~IFeature)(IFeature *this);
  std::optional&lt;BlockPos&gt; *(__fastcall *place)(IFeature *this, std::optional&lt;BlockPos&gt; *result, IBlockWorldGenAPI *, const BlockPos *, Random *, RenderParams *);
  std::string *(__fastcall *getStructureName)(IFeature *this, std::string *result);
  bool (__fastcall *parse)(IFeature *this, const rapidjson::GenericValue&lt;rapidjson::UTF8&lt;char&gt;,rapidjson::MemoryPoolAllocator&lt;rapidjson::CrtAllocator&gt; &gt; *, IWorldRegistriesProvider *);
};

</code></pre></div><h3 id="searchfeature"><a href="#searchfeature" class="header-anchor">#</a> <code>SearchFeature</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) SearchFeature : IFeature
{
  WeakRefT&lt;FeatureRefTraits&gt; mFeatureRef;
  AABB mSearchVolume;
  SearchFeature::SearchAxis mSearchAxis;
  int mRequiredSuccesses;
};

</code></pre></div><h3 id="searchfeature-vtbl"><a href="#searchfeature-vtbl" class="header-anchor">#</a> <code>SearchFeature_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SearchFeature_vtbl
{
  void (__fastcall *~IFeature)(IFeature *this);
  std::optional&lt;BlockPos&gt; *(__fastcall *place)(IFeature *this, std::optional&lt;BlockPos&gt; *result, IBlockWorldGenAPI *, const BlockPos *, Random *, RenderParams *);
  std::string *(__fastcall *getStructureName)(IFeature *this, std::string *result);
  bool (__fastcall *parse)(IFeature *this, const rapidjson::GenericValue&lt;rapidjson::UTF8&lt;char&gt;,rapidjson::MemoryPoolAllocator&lt;rapidjson::CrtAllocator&gt; &gt; *, IWorldRegistriesProvider *);
};

</code></pre></div><h3 id="singleblockfeature"><a href="#singleblockfeature" class="header-anchor">#</a> <code>SingleBlockFeature</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SingleBlockFeature : IFeature
{
  BlockDescriptor mBlock;
  bool mEnforcePlacementRules;
  bool mEnforceSurvivabilityRules;
  bool mAutoRotate;
  bool mEnforceAttachmentRules;
  int mMinAttachedSides;
  std::vector&lt;BlockDescriptor&gt; mTopMayAttachTo;
  std::vector&lt;BlockDescriptor&gt; mBottomMayAttachTo;
  std::vector&lt;BlockDescriptor&gt; mNorthMayAttachTo;
  std::vector&lt;BlockDescriptor&gt; mEastMayAttachTo;
  std::vector&lt;BlockDescriptor&gt; mSouthMayAttachTo;
  std::vector&lt;BlockDescriptor&gt; mWestMayAttachTo;
  std::vector&lt;BlockDescriptor&gt; mAllMayAttachTo;
  std::vector&lt;BlockDescriptor&gt; mSidesMayAttachTo;
  std::vector&lt;BlockDescriptor&gt; mMayReplace;
  std::vector&lt;BlockDescriptor&gt; mMayPlaceOn;
};

</code></pre></div><h3 id="singleblockfeature-vtbl"><a href="#singleblockfeature-vtbl" class="header-anchor">#</a> <code>SingleBlockFeature_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SingleBlockFeature_vtbl
{
  void (__fastcall *~IFeature)(IFeature *this);
  std::optional&lt;BlockPos&gt; *(__fastcall *place)(IFeature *this, std::optional&lt;BlockPos&gt; *result, IBlockWorldGenAPI *, const BlockPos *, Random *, RenderParams *);
  std::string *(__fastcall *getStructureName)(IFeature *this, std::string *result);
  bool (__fastcall *parse)(IFeature *this, const rapidjson::GenericValue&lt;rapidjson::UTF8&lt;char&gt;,rapidjson::MemoryPoolAllocator&lt;rapidjson::CrtAllocator&gt; &gt; *, IWorldRegistriesProvider *);
};

</code></pre></div><h3 id="structuretemplatefeature"><a href="#structuretemplatefeature" class="header-anchor">#</a> <code>StructureTemplateFeature</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureTemplateFeature : IFeature
{
  StructureTemplate *mStructure;
  int mAdjustmentRadius;
  Direction::Type mFaceDirection;
  std::vector&lt;std::unique_ptr&lt;IStructureConstraint&gt;&gt; mConstraints;
};

</code></pre></div><h3 id="structuretemplatefeature-vtbl"><a href="#structuretemplatefeature-vtbl" class="header-anchor">#</a> <code>StructureTemplateFeature_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StructureTemplateFeature_vtbl
{
  void (__fastcall *~IFeature)(IFeature *this);
  std::optional&lt;BlockPos&gt; *(__fastcall *place)(IFeature *this, std::optional&lt;BlockPos&gt; *result, IBlockWorldGenAPI *, const BlockPos *, Random *, RenderParams *);
  std::string *(__fastcall *getStructureName)(IFeature *this, std::string *result);
  bool (__fastcall *parse)(IFeature *this, const rapidjson::GenericValue&lt;rapidjson::UTF8&lt;char&gt;,rapidjson::MemoryPoolAllocator&lt;rapidjson::CrtAllocator&gt; &gt; *, IWorldRegistriesProvider *);
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-6697fcc338a28a2a66475f1030b55eb2"><a href="#scatterparams-buildschema-l2-lambda-6697fcc338a28a2a66475f1030b55eb2" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_6697fcc338a28a2a66475f1030b55eb2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_6697fcc338a28a2a66475f1030b55eb2&gt;
{
  std::function&lt;ScatterParams &amp; __cdecl(FeatureLoading::ConcreteFeatureHolder&lt;ScatterFeature&gt; *)&gt; scatterAccessor;
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-369c4269327dd66eb89c3f306f673098"><a href="#scatterparams-buildschema-l2-lambda-369c4269327dd66eb89c3f306f673098" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_369c4269327dd66eb89c3f306f673098&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_369c4269327dd66eb89c3f306f673098&gt;
{
  std::function&lt;ScatterParams &amp; __cdecl(FeatureLoading::ConcreteFeatureHolder&lt;ScatterFeature&gt; *)&gt; scatterAccessor;
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-29be4b69395e49f372ab7ee3e3861ea8"><a href="#scatterparams-buildschema-l2-lambda-29be4b69395e49f372ab7ee3e3861ea8" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_29be4b69395e49f372ab7ee3e3861ea8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_29be4b69395e49f372ab7ee3e3861ea8&gt;
{
  std::function&lt;ScatterParams &amp; __cdecl(FeatureLoading::ConcreteFeatureHolder&lt;ScatterFeature&gt; *)&gt; scatterAccessor;
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-dbb9e2db8c522c4dd6b7016d0b2de0dd"><a href="#scatterparams-buildschema-l2-lambda-dbb9e2db8c522c4dd6b7016d0b2de0dd" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_dbb9e2db8c522c4dd6b7016d0b2de0dd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_dbb9e2db8c522c4dd6b7016d0b2de0dd&gt;
{
  std::function&lt;ScatterParams &amp; __cdecl(FeatureLoading::ConcreteFeatureHolder&lt;ScatterFeature&gt; *)&gt; scatterAccessor;
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-db78833ebc823bb660a1786f4a9dc20f"><a href="#scatterparams-buildschema-l2-lambda-db78833ebc823bb660a1786f4a9dc20f" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_db78833ebc823bb660a1786f4a9dc20f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_db78833ebc823bb660a1786f4a9dc20f&gt;
{
  std::function&lt;ScatterParams &amp; __cdecl(FeatureLoading::ConcreteFeatureHolder&lt;ScatterFeature&gt; *)&gt; scatterAccessor;
};

</code></pre></div><h3 id="scatterparams-buildschema-l3-lambda-0457dbd857bf74e1044a46b87cf44a13"><a href="#scatterparams-buildschema-l3-lambda-0457dbd857bf74e1044a46b87cf44a13" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l3::&lt;lambda_0457dbd857bf74e1044a46b87cf44a13&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l3::&lt;lambda_0457dbd857bf74e1044a46b87cf44a13&gt;
{
  std::function&lt;ScatterParams &amp; __cdecl(FeatureLoading::ConcreteFeatureHolder&lt;ScatterFeature&gt; *)&gt; scatterAccessor;
};

</code></pre></div><h3 id="scatterparams-buildschema-l3-lambda-6ad2e3a1f50cbd1daf19b6f4b1b7d80b"><a href="#scatterparams-buildschema-l3-lambda-6ad2e3a1f50cbd1daf19b6f4b1b7d80b" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l3::&lt;lambda_6ad2e3a1f50cbd1daf19b6f4b1b7d80b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l3::&lt;lambda_6ad2e3a1f50cbd1daf19b6f4b1b7d80b&gt;
{
  std::function&lt;ScatterParams &amp; __cdecl(FeatureLoading::ConcreteFeatureHolder&lt;ScatterFeature&gt; *)&gt; scatterAccessor;
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-74ac550b64edf02e4da438a098fcacbc"><a href="#scatterparams-buildschema-l2-lambda-74ac550b64edf02e4da438a098fcacbc" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_74ac550b64edf02e4da438a098fcacbc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_74ac550b64edf02e4da438a098fcacbc&gt;
{
  std::function&lt;ScatterParams::CoordinateRange &amp; __cdecl(FeatureLoading::ConcreteFeatureHolder&lt;ScatterFeature&gt; *)&gt; coordAccessor;
  const HashedString name;
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-aeb0075ee3c02cb1c6b4dc667e40d095"><a href="#scatterparams-buildschema-l2-lambda-aeb0075ee3c02cb1c6b4dc667e40d095" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_aeb0075ee3c02cb1c6b4dc667e40d095&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_aeb0075ee3c02cb1c6b4dc667e40d095&gt;
{
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-e369566461023c183400dc583203e8e8"><a href="#scatterparams-buildschema-l2-lambda-e369566461023c183400dc583203e8e8" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_e369566461023c183400dc583203e8e8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_e369566461023c183400dc583203e8e8&gt;
{
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-3fd1d93ba142a5f6fdb37a96cadf2ed2"><a href="#scatterparams-buildschema-l2-lambda-3fd1d93ba142a5f6fdb37a96cadf2ed2" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_3fd1d93ba142a5f6fdb37a96cadf2ed2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_3fd1d93ba142a5f6fdb37a96cadf2ed2&gt;
{
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-e8a00d27dbfc8e954d6c48d82e17a609"><a href="#scatterparams-buildschema-l2-lambda-e8a00d27dbfc8e954d6c48d82e17a609" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_e8a00d27dbfc8e954d6c48d82e17a609&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_e8a00d27dbfc8e954d6c48d82e17a609&gt;
{
};

</code></pre></div><h3 id="scatterparams-buildschema-l2-lambda-61601f14b4a1fa382565cb431a3a9c30"><a href="#scatterparams-buildschema-l2-lambda-61601f14b4a1fa382565cb431a3a9c30" class="header-anchor">#</a> <code>ScatterParams::_buildSchema::__l2::&lt;lambda_61601f14b4a1fa382565cb431a3a9c30&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::_buildSchema::__l2::&lt;lambda_61601f14b4a1fa382565cb431a3a9c30&gt;
{
};

</code></pre></div><h3 id="structurestart"><a href="#structurestart" class="header-anchor">#</a> <code>StructureStart</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureStart
{
  StructureStart_vtbl *__vftable /*VFT*/;
  BoundingBox boundingBox;
  int chunkX;
  int chunkZ;
  std::vector&lt;std::unique_ptr&lt;StructurePiece&gt;&gt; pieces;
};

</code></pre></div><h3 id="structurestart-vtbl"><a href="#structurestart-vtbl" class="header-anchor">#</a> <code>StructureStart_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StructureStart_vtbl
{
  void (__fastcall *~StructureStart)(StructureStart *this);
  bool (__fastcall *postProcess)(StructureStart *this, BlockSource *, Random *, const BoundingBox *);
  bool (__fastcall *isValid)(StructureStart *this);
  StructureFeatureType (__fastcall *getType)(StructureStart *this);
};

</code></pre></div><h3 id="structurefeature"><a href="#structurefeature" class="header-anchor">#</a> <code>StructureFeature</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) StructureFeature
{
  StructureFeature_vtbl *__vftable /*VFT*/;
  std::unordered_map&lt;ChunkPos,std::unique_ptr&lt;StructureStart&gt;&gt; cachedStructures;
  std::shared_mutex cacheMutex;
  std::unordered_set&lt;ChunkPos&gt; visitedPositions;
  SpinLock visitedPositionsMutex;
  unsigned int mRadius;
  const BiomeSource *mLastBiomeSource;
  int mLastXCenterTownChunk;
  int mLastZCenterTownChunk;
  int mRandomInt1;
  int mRandomInt2;
  int mRandomInt3;
  int mRandomInt4;
  std::mutex mCreateBlueprintsMutex;
  std::condition_variable mBlueprintWaitVar;
  std::atomic&lt;int&gt; mActiveBlueprintCreateCount;
  std::atomic&lt;bool&gt; mBlueprintsFinished;
};

</code></pre></div><h3 id="structurefeature-vtbl"><a href="#structurefeature-vtbl" class="header-anchor">#</a> <code>StructureFeature_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StructureFeature_vtbl
{
  void (__fastcall *~StructureFeature)(StructureFeature *this);
  bool (__fastcall *postProcess)(StructureFeature *this, BlockSource *, Random *, int, int);
  bool (__fastcall *getNearestGeneratedFeature)(StructureFeature *this, Dimension *, BiomeSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *isFeatureChunk)(StructureFeature *this, const BiomeSource *, Random *, const ChunkPos *, unsigned int);
  std::unique_ptr&lt;StructureStart&gt; *(__fastcall *createStructureStart)(StructureFeature *this, std::unique_ptr&lt;StructureStart&gt; *result, Dimension *, BiomeSource *, Random *, const ChunkPos *);
  StructureStart *(__fastcall *getStructureAt)(StructureFeature *this, int, int, int);
  std::vector&lt;BlockPos&gt; *(__fastcall *getGuesstimatedFeaturePositions)(StructureFeature *this, std::vector&lt;BlockPos&gt; *result);
};

</code></pre></div><h3 id="structurehelpers"><a href="#structurehelpers" class="header-anchor">#</a> <code>StructureHelpers</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureHelpers
{
};

</code></pre></div><h3 id="structuremanager-loadplacementqueue-l2-lambda-15a6796dd03535f8c563237a40a8a391"><a href="#structuremanager-loadplacementqueue-l2-lambda-15a6796dd03535f8c563237a40a8a391" class="header-anchor">#</a> <code>StructureManager::loadPlacementQueue::__l2::&lt;lambda_15a6796dd03535f8c563237a40a8a391&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureManager::loadPlacementQueue::__l2::&lt;lambda_15a6796dd03535f8c563237a40a8a391&gt;
{
  StructureManager *const __this;
  Level *level;
  Dimension *dim;
};

</code></pre></div><h3 id="structurefeature-generatehardcodedmobspawns-l2-lambda-76a5cb87f28859d827010015848cdbdd"><a href="#structurefeature-generatehardcodedmobspawns-l2-lambda-76a5cb87f28859d827010015848cdbdd" class="header-anchor">#</a> <code>StructureFeature::generateHardcodedMobSpawns::__l2::&lt;lambda_76a5cb87f28859d827010015848cdbdd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureFeature::generateHardcodedMobSpawns::__l2::&lt;lambda_76a5cb87f28859d827010015848cdbdd&gt;
{
  BoundingBox *bb;
  LevelChunk *lc;
};

</code></pre></div><h3 id="structurefeature-postprocess-l13-lambda-0c2d594d928e035ca9cca2bbda13c6d1"><a href="#structurefeature-postprocess-l13-lambda-0c2d594d928e035ca9cca2bbda13c6d1" class="header-anchor">#</a> <code>StructureFeature::postProcess::__l13::&lt;lambda_0c2d594d928e035ca9cca2bbda13c6d1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureFeature::postProcess::__l13::&lt;lambda_0c2d594d928e035ca9cca2bbda13c6d1&gt;
{
  bool *postProcessApplied;
  BlockSource *region;
  Random *random;
  BoundingBox *bb;
};

</code></pre></div><h3 id="structurecornermodeutils-findcornerblocks-l2-lambda-d421c17110b9d2c83deb2c3cc9564f05"><a href="#structurecornermodeutils-findcornerblocks-l2-lambda-d421c17110b9d2c83deb2c3cc9564f05" class="header-anchor">#</a> <code>StructureCornerModeUtils::findCornerBlocks::__l2::&lt;lambda_d421c17110b9d2c83deb2c3cc9564f05&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureCornerModeUtils::findCornerBlocks::__l2::&lt;lambda_d421c17110b9d2c83deb2c3cc9564f05&gt;
{
};

</code></pre></div><h3 id="structurepoolactorpredicatealwaystrue"><a href="#structurepoolactorpredicatealwaystrue" class="header-anchor">#</a> <code>StructurePoolActorPredicateAlwaysTrue</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructurePoolActorPredicateAlwaysTrue : IStructurePoolActorPredicate
{
};

</code></pre></div><h3 id="structurepoolactorpredicatealwaystrue-vtbl"><a href="#structurepoolactorpredicatealwaystrue-vtbl" class="header-anchor">#</a> <code>StructurePoolActorPredicateAlwaysTrue_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StructurePoolActorPredicateAlwaysTrue_vtbl
{
  void (__fastcall *~IStructurePoolActorPredicate)(IStructurePoolActorPredicate *this);
  bool (__fastcall *test)(IStructurePoolActorPredicate *this, const std::string *);
};

</code></pre></div><h3 id="structurepoolactorpredicateactormatch"><a href="#structurepoolactorpredicateactormatch" class="header-anchor">#</a> <code>StructurePoolActorPredicateActorMatch</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructurePoolActorPredicateActorMatch : IStructurePoolActorPredicate
{
  const std::string mActor;
};

</code></pre></div><h3 id="structurepoolactorpredicateactormatch-vtbl"><a href="#structurepoolactorpredicateactormatch-vtbl" class="header-anchor">#</a> <code>StructurePoolActorPredicateActorMatch_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StructurePoolActorPredicateActorMatch_vtbl
{
  void (__fastcall *~IStructurePoolActorPredicate)(IStructurePoolActorPredicate *this);
  bool (__fastcall *test)(IStructurePoolActorPredicate *this, const std::string *);
};

</code></pre></div><h3 id="structurepoolblockpredicatealwaystrue"><a href="#structurepoolblockpredicatealwaystrue" class="header-anchor">#</a> <code>StructurePoolBlockPredicateAlwaysTrue</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructurePoolBlockPredicateAlwaysTrue : IStructurePoolBlockPredicate
{
};

</code></pre></div><h3 id="structurepoolblockpredicatealwaystrue-vtbl"><a href="#structurepoolblockpredicatealwaystrue-vtbl" class="header-anchor">#</a> <code>StructurePoolBlockPredicateAlwaysTrue_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StructurePoolBlockPredicateAlwaysTrue_vtbl
{
  void (__fastcall *~IStructurePoolBlockPredicate)(IStructurePoolBlockPredicate *this);
  bool (__fastcall *test)(IStructurePoolBlockPredicate *this, const BlockPos *, const BlockPos *, Random *);
  bool (__fastcall *test)(IStructurePoolBlockPredicate *this, const Block *, Random *);
};

</code></pre></div><h3 id="structurepoolblockpredicateblockmatch"><a href="#structurepoolblockpredicateblockmatch" class="header-anchor">#</a> <code>StructurePoolBlockPredicateBlockMatch</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructurePoolBlockPredicateBlockMatch : IStructurePoolBlockPredicate
{
  const Block *mBlock;
};

</code></pre></div><h3 id="structurepoolblockpredicateblockmatch-vtbl"><a href="#structurepoolblockpredicateblockmatch-vtbl" class="header-anchor">#</a> <code>StructurePoolBlockPredicateBlockMatch_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StructurePoolBlockPredicateBlockMatch_vtbl
{
  void (__fastcall *~IStructurePoolBlockPredicate)(IStructurePoolBlockPredicate *this);
  bool (__fastcall *test)(IStructurePoolBlockPredicate *this, const BlockPos *, const BlockPos *, Random *);
  bool (__fastcall *test)(IStructurePoolBlockPredicate *this, const Block *, Random *);
};

</code></pre></div><h3 id="structurepoolblockpredicatestatematch"><a href="#structurepoolblockpredicatestatematch" class="header-anchor">#</a> <code>StructurePoolBlockPredicateStateMatch</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructurePoolBlockPredicateStateMatch : IStructurePoolBlockPredicate
{
  const Block *mBlock;
};

</code></pre></div><h3 id="structurepoolblockpredicatestatematch-vtbl"><a href="#structurepoolblockpredicatestatematch-vtbl" class="header-anchor">#</a> <code>StructurePoolBlockPredicateStateMatch_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StructurePoolBlockPredicateStateMatch_vtbl
{
  void (__fastcall *~IStructurePoolBlockPredicate)(IStructurePoolBlockPredicate *this);
  bool (__fastcall *test)(IStructurePoolBlockPredicate *this, const BlockPos *, const BlockPos *, Random *);
  bool (__fastcall *test)(IStructurePoolBlockPredicate *this, const Block *, Random *);
};

</code></pre></div><h3 id="structurepoolblockpredicateblockmatchrandom"><a href="#structurepoolblockpredicateblockmatchrandom" class="header-anchor">#</a> <code>StructurePoolBlockPredicateBlockMatchRandom</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) StructurePoolBlockPredicateBlockMatchRandom : IStructurePoolBlockPredicate
{
  const Block *mBlock;
  const float mProbability;
};

</code></pre></div><h3 id="structurepoolblockpredicateblockmatchrandom-vtbl"><a href="#structurepoolblockpredicateblockmatchrandom-vtbl" class="header-anchor">#</a> <code>StructurePoolBlockPredicateBlockMatchRandom_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StructurePoolBlockPredicateBlockMatchRandom_vtbl
{
  void (__fastcall *~IStructurePoolBlockPredicate)(IStructurePoolBlockPredicate *this);
  bool (__fastcall *test)(IStructurePoolBlockPredicate *this, const BlockPos *, const BlockPos *, Random *);
  bool (__fastcall *test)(IStructurePoolBlockPredicate *this, const Block *, Random *);
};

</code></pre></div><h3 id="structurepoolblockpredicatestatematchrandom"><a href="#structurepoolblockpredicatestatematchrandom" class="header-anchor">#</a> <code>StructurePoolBlockPredicateStateMatchRandom</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) StructurePoolBlockPredicateStateMatchRandom : IStructurePoolBlockPredicate
{
  const Block *mBlock;
  const float mProbability;
};

</code></pre></div><h3 id="structurepoolblockpredicatestatematchrandom-vtbl"><a href="#structurepoolblockpredicatestatematchrandom-vtbl" class="header-anchor">#</a> <code>StructurePoolBlockPredicateStateMatchRandom_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StructurePoolBlockPredicateStateMatchRandom_vtbl
{
  void (__fastcall *~IStructurePoolBlockPredicate)(IStructurePoolBlockPredicate *this);
  bool (__fastcall *test)(IStructurePoolBlockPredicate *this, const BlockPos *, const BlockPos *, Random *);
  bool (__fastcall *test)(IStructurePoolBlockPredicate *this, const Block *, Random *);
};

</code></pre></div><h3 id="structurepoolblockpredicatelinearposition"><a href="#structurepoolblockpredicatelinearposition" class="header-anchor">#</a> <code>StructurePoolBlockPredicateLinearPosition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructurePoolBlockPredicateLinearPosition : IStructurePoolBlockPredicate
{
  const float mMinChance;
  const float mMaxChance;
  const int mMinDist;
  const int mMaxDist;
};

</code></pre></div><h3 id="structurepoolblockpredicatelinearposition-vtbl"><a href="#structurepoolblockpredicatelinearposition-vtbl" class="header-anchor">#</a> <code>StructurePoolBlockPredicateLinearPosition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StructurePoolBlockPredicateLinearPosition_vtbl
{
  void (__fastcall *~IStructurePoolBlockPredicate)(IStructurePoolBlockPredicate *this);
  bool (__fastcall *test)(IStructurePoolBlockPredicate *this, const BlockPos *, const BlockPos *, Random *);
  bool (__fastcall *test)(IStructurePoolBlockPredicate *this, const Block *, Random *);
};

</code></pre></div><h3 id="structurepoolblockpredicateaxisalignedposition"><a href="#structurepoolblockpredicateaxisalignedposition" class="header-anchor">#</a> <code>StructurePoolBlockPredicateAxisAlignedPosition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) StructurePoolBlockPredicateAxisAlignedPosition : IStructurePoolBlockPredicate
{
  const float mMinChance;
  const float mMaxChance;
  const int mMinDist;
  const int mMaxDist;
  const unsigned __int8 mAxis;
};

</code></pre></div><h3 id="structurepoolblockpredicateaxisalignedposition-vtbl"><a href="#structurepoolblockpredicateaxisalignedposition-vtbl" class="header-anchor">#</a> <code>StructurePoolBlockPredicateAxisAlignedPosition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StructurePoolBlockPredicateAxisAlignedPosition_vtbl
{
  void (__fastcall *~IStructurePoolBlockPredicate)(IStructurePoolBlockPredicate *this);
  bool (__fastcall *test)(IStructurePoolBlockPredicate *this, const BlockPos *, const BlockPos *, Random *);
  bool (__fastcall *test)(IStructurePoolBlockPredicate *this, const Block *, Random *);
};

</code></pre></div><h3 id="structurepoolblocktagpredicatealwaystrue"><a href="#structurepoolblocktagpredicatealwaystrue" class="header-anchor">#</a> <code>StructurePoolBlockTagPredicateAlwaysTrue</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructurePoolBlockTagPredicateAlwaysTrue : IStructurePoolBlockTagPredicate
{
};

</code></pre></div><h3 id="structurepoolblocktagpredicatealwaystrue-vtbl"><a href="#structurepoolblocktagpredicatealwaystrue-vtbl" class="header-anchor">#</a> <code>StructurePoolBlockTagPredicateAlwaysTrue_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StructurePoolBlockTagPredicateAlwaysTrue_vtbl
{
  void (__fastcall *~IStructurePoolBlockTagPredicate)(IStructurePoolBlockTagPredicate *this);
  bool (__fastcall *test)(IStructurePoolBlockTagPredicate *this, const Block *, const CompoundTag *);
};

</code></pre></div><h3 id="structurepoolblocktagpredicateblocktagmatch"><a href="#structurepoolblocktagpredicateblocktagmatch" class="header-anchor">#</a> <code>StructurePoolBlockTagPredicateBlockTagMatch</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructurePoolBlockTagPredicateBlockTagMatch : IStructurePoolBlockTagPredicate
{
  const Block *mBlock;
  const CompoundTag *mTag;
};

</code></pre></div><h3 id="structurepoolblocktagpredicateblocktagmatch-vtbl"><a href="#structurepoolblocktagpredicateblocktagmatch-vtbl" class="header-anchor">#</a> <code>StructurePoolBlockTagPredicateBlockTagMatch_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StructurePoolBlockTagPredicateBlockTagMatch_vtbl
{
  void (__fastcall *~IStructurePoolBlockTagPredicate)(IStructurePoolBlockTagPredicate *this);
  bool (__fastcall *test)(IStructurePoolBlockTagPredicate *this, const Block *, const CompoundTag *);
};

</code></pre></div><h3 id="structurepoolblocktagpredicateblocktagstringmatches"><a href="#structurepoolblocktagpredicateblocktagstringmatches" class="header-anchor">#</a> <code>StructurePoolBlockTagPredicateBlockTagStringMatches</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructurePoolBlockTagPredicateBlockTagStringMatches : IStructurePoolBlockTagPredicate
{
  const Block *mBlock;
  const std::string mTagKey;
  const std::string mTagValue;
};

</code></pre></div><h3 id="structurepoolblocktagpredicateblocktagstringmatches-vtbl"><a href="#structurepoolblocktagpredicateblocktagstringmatches-vtbl" class="header-anchor">#</a> <code>StructurePoolBlockTagPredicateBlockTagStringMatches_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StructurePoolBlockTagPredicateBlockTagStringMatches_vtbl
{
  void (__fastcall *~IStructurePoolBlockTagPredicate)(IStructurePoolBlockTagPredicate *this);
  bool (__fastcall *test)(IStructurePoolBlockTagPredicate *this, const Block *, const CompoundTag *);
};

</code></pre></div><h3 id="structurepoolelement-gettemplate-l2-lambda-1a973c56dbe31fc5f9ab5e1e998eaab8"><a href="#structurepoolelement-gettemplate-l2-lambda-1a973c56dbe31fc5f9ab5e1e998eaab8" class="header-anchor">#</a> <code>StructurePoolElement::_getTemplate::__l2::&lt;lambda_1a973c56dbe31fc5f9ab5e1e998eaab8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructurePoolElement::_getTemplate::__l2::&lt;lambda_1a973c56dbe31fc5f9ab5e1e998eaab8&gt;
{
  const StructurePoolElement *const __this;
};

</code></pre></div><h3 id="structuretemplate-placenextblocksegmentinworld-l20-lambda-48c17ca5fc4f95e30535757e8d9844e6"><a href="#structuretemplate-placenextblocksegmentinworld-l20-lambda-48c17ca5fc4f95e30535757e8d9844e6" class="header-anchor">#</a> <code>StructureTemplate::_placeNextBlockSegmentInWorld::__l20::&lt;lambda_48c17ca5fc4f95e30535757e8d9844e6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureTemplate::_placeNextBlockSegmentInWorld::__l20::&lt;lambda_48c17ca5fc4f95e30535757e8d9844e6&gt;
{
  BoundingBox *bounds;
  const BlockPos *size;
  const std::vector&lt;bool&gt; *flagList;
  const std::vector&lt;int&gt; *blockIndices;
  unsigned __int64 *startPlacement;
  unsigned __int64 *endPlacement;
};

</code></pre></div><h3 id="spawner-tick-l2-lambda-09ec85d0ca7d6d046e1515d997dfdfbb"><a href="#spawner-tick-l2-lambda-09ec85d0ca7d6d046e1515d997dfdfbb" class="header-anchor">#</a> <code>Spawner::tick::__l2::&lt;lambda_09ec85d0ca7d6d046e1515d997dfdfbb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Spawner::tick::__l2::&lt;lambda_09ec85d0ca7d6d046e1515d997dfdfbb&gt;
{
  Spawner *const __this;
  BlockSource *region;
};

</code></pre></div><h3 id="spawner-tick-l2-lambda-51ff26e5b76b68a77052d006f8c71dae"><a href="#spawner-tick-l2-lambda-51ff26e5b76b68a77052d006f8c71dae" class="header-anchor">#</a> <code>Spawner::tick::__l2::&lt;lambda_51ff26e5b76b68a77052d006f8c71dae&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Spawner::tick::__l2::&lt;lambda_51ff26e5b76b68a77052d006f8c71dae&gt;
{
};

</code></pre></div><h3 id="spawner-tick-l2-lambda-b07d485834905f743033162c239520e0"><a href="#spawner-tick-l2-lambda-b07d485834905f743033162c239520e0" class="header-anchor">#</a> <code>Spawner::tick::__l2::&lt;lambda_b07d485834905f743033162c239520e0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Spawner::tick::__l2::&lt;lambda_b07d485834905f743033162c239520e0&gt;
{
  Spawner *const __this;
  BlockSource *region;
};

</code></pre></div><h3 id="spawner-spawnmobincluster-l5-lambda-0e6f8e8c785d124fa1cb4eb0b607824d"><a href="#spawner-spawnmobincluster-l5-lambda-0e6f8e8c785d124fa1cb4eb0b607824d" class="header-anchor">#</a> <code>Spawner::_spawnMobInCluster::__l5::&lt;lambda_0e6f8e8c785d124fa1cb4eb0b607824d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Spawner::_spawnMobInCluster::__l5::&lt;lambda_0e6f8e8c785d124fa1cb4eb0b607824d&gt;
{
  ActorDefinitionIdentifier *id;
  Mob **spawnedMob;
  const BlockPos *pos;
};

</code></pre></div><h3 id="spawner-spawnprojectile-l19-lambda-af0f9963b64003ead87cb9d70fb4d46f"><a href="#spawner-spawnprojectile-l19-lambda-af0f9963b64003ead87cb9d70fb4d46f" class="header-anchor">#</a> <code>Spawner::spawnProjectile::__l19::&lt;lambda_af0f9963b64003ead87cb9d70fb4d46f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Spawner::spawnProjectile::__l19::&lt;lambda_af0f9963b64003ead87cb9d70fb4d46f&gt;
{
  Actor **projectile;
  const ActorDefinitionIdentifier *id;
  Actor **spawner;
};

</code></pre></div><h3 id="seasons-tick-l2-lambda-8111e138941c168ffc51d79b3a3b084e"><a href="#seasons-tick-l2-lambda-8111e138941c168ffc51d79b3a3b084e" class="header-anchor">#</a> <code>Seasons::tick::__l2::&lt;lambda_8111e138941c168ffc51d79b3a3b084e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Seasons::tick::__l2::&lt;lambda_8111e138941c168ffc51d79b3a3b084e&gt;
{
  Weather *weather;
};

</code></pre></div><h3 id="scatterparams-initmolangparams-l2-lambda-fe7f6cbc21f6541281b9d6c12e3aa8c9"><a href="#scatterparams-initmolangparams-l2-lambda-fe7f6cbc21f6541281b9d6c12e3aa8c9" class="header-anchor">#</a> <code>ScatterParams::initMolangParams::__l2::&lt;lambda_fe7f6cbc21f6541281b9d6c12e3aa8c9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScatterParams::initMolangParams::__l2::&lt;lambda_fe7f6cbc21f6541281b9d6c12e3aa8c9&gt;
{
  Random *random;
};

</code></pre></div><h3 id="setbannerdetailsfunction"><a href="#setbannerdetailsfunction" class="header-anchor">#</a> <code>SetBannerDetailsFunction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SetBannerDetailsFunction : LootItemFunction
{
  BannerBlockType mBannerType;
  _BYTE mBaseColor[1];
  std::vector&lt;std::pair&lt;unsigned char,enum ItemColor&gt;&gt; mBannerPatterns;
};

</code></pre></div><h3 id="setbannerdetailsfunction-vtbl"><a href="#setbannerdetailsfunction-vtbl" class="header-anchor">#</a> <code>SetBannerDetailsFunction_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SetBannerDetailsFunction_vtbl
{
  void (__fastcall *~LootItemFunction)(LootItemFunction *this);
  int (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, LootTableContext *);
  int (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, LootTableContext *);
};

</code></pre></div><h3 id="setbookcontentsfunction"><a href="#setbookcontentsfunction" class="header-anchor">#</a> <code>SetBookContentsFunction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SetBookContentsFunction : LootItemFunction
{
  std::string mTitle;
  std::string mAuthor;
  std::vector&lt;std::string&gt; mPages;
};

</code></pre></div><h3 id="setbookcontentsfunction-vtbl"><a href="#setbookcontentsfunction-vtbl" class="header-anchor">#</a> <code>SetBookContentsFunction_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SetBookContentsFunction_vtbl
{
  void (__fastcall *~LootItemFunction)(LootItemFunction *this);
  int (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, LootTableContext *);
  int (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, LootTableContext *);
};

</code></pre></div><h3 id="setitemcountfunction"><a href="#setitemcountfunction" class="header-anchor">#</a> <code>SetItemCountFunction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SetItemCountFunction : LootItemFunction
{
  RandomValueBounds mValue;
};

</code></pre></div><h3 id="setitemcountfunction-vtbl"><a href="#setitemcountfunction-vtbl" class="header-anchor">#</a> <code>SetItemCountFunction_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SetItemCountFunction_vtbl
{
  void (__fastcall *~LootItemFunction)(LootItemFunction *this);
  int (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, LootTableContext *);
  int (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, LootTableContext *);
};

</code></pre></div><h3 id="setitemdatafunction"><a href="#setitemdatafunction" class="header-anchor">#</a> <code>SetItemDataFunction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SetItemDataFunction : LootItemFunction
{
  RandomValueBounds mValue;
};

</code></pre></div><h3 id="setitemdatafunction-vtbl"><a href="#setitemdatafunction-vtbl" class="header-anchor">#</a> <code>SetItemDataFunction_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SetItemDataFunction_vtbl
{
  void (__fastcall *~LootItemFunction)(LootItemFunction *this);
  int (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, LootTableContext *);
  int (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, LootTableContext *);
};

</code></pre></div><h3 id="setitemdamagefunction"><a href="#setitemdamagefunction" class="header-anchor">#</a> <code>SetItemDamageFunction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SetItemDamageFunction : LootItemFunction
{
  RandomValueBounds mDamage;
};

</code></pre></div><h3 id="setitemdamagefunction-vtbl"><a href="#setitemdamagefunction-vtbl" class="header-anchor">#</a> <code>SetItemDamageFunction_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SetItemDamageFunction_vtbl
{
  void (__fastcall *~LootItemFunction)(LootItemFunction *this);
  int (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, LootTableContext *);
  int (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, LootTableContext *);
};

</code></pre></div><h3 id="setitemlorefunction"><a href="#setitemlorefunction" class="header-anchor">#</a> <code>SetItemLoreFunction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SetItemLoreFunction : LootItemFunction
{
  std::vector&lt;std::string&gt; mLore;
};

</code></pre></div><h3 id="setitemlorefunction-vtbl"><a href="#setitemlorefunction-vtbl" class="header-anchor">#</a> <code>SetItemLoreFunction_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SetItemLoreFunction_vtbl
{
  void (__fastcall *~LootItemFunction)(LootItemFunction *this);
  int (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, LootTableContext *);
  int (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, LootTableContext *);
};

</code></pre></div><h3 id="setitemnamefunction"><a href="#setitemnamefunction" class="header-anchor">#</a> <code>SetItemNameFunction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SetItemNameFunction : LootItemFunction
{
  std::string mName;
};

</code></pre></div><h3 id="setitemnamefunction-vtbl"><a href="#setitemnamefunction-vtbl" class="header-anchor">#</a> <code>SetItemNameFunction_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SetItemNameFunction_vtbl
{
  void (__fastcall *~LootItemFunction)(LootItemFunction *this);
  int (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, LootTableContext *);
  int (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, LootTableContext *);
};

</code></pre></div><h3 id="setspawneggfunction"><a href="#setspawneggfunction" class="header-anchor">#</a> <code>SetSpawnEggFunction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SetSpawnEggFunction : LootItemFunction
{
  ActorDefinitionIdentifier mActor;
};

</code></pre></div><h3 id="setspawneggfunction-vtbl"><a href="#setspawneggfunction-vtbl" class="header-anchor">#</a> <code>SetSpawnEggFunction_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SetSpawnEggFunction_vtbl
{
  void (__fastcall *~LootItemFunction)(LootItemFunction *this);
  int (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, LootTableContext *);
  int (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, LootTableContext *);
};

</code></pre></div><h3 id="smeltitemfunction"><a href="#smeltitemfunction" class="header-anchor">#</a> <code>SmeltItemFunction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SmeltItemFunction : LootItemFunction
{
};

</code></pre></div><h3 id="smeltitemfunction-vtbl"><a href="#smeltitemfunction-vtbl" class="header-anchor">#</a> <code>SmeltItemFunction_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SmeltItemFunction_vtbl
{
  void (__fastcall *~LootItemFunction)(LootItemFunction *this);
  int (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, LootTableContext *);
  int (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, LootTableContext *);
};

</code></pre></div><h3 id="specificenchantfunction"><a href="#specificenchantfunction" class="header-anchor">#</a> <code>SpecificEnchantFunction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SpecificEnchantFunction : LootItemFunction
{
  std::vector&lt;SpecificEnchantFunction::EnchantInfo&gt; mEnchantments;
};

</code></pre></div><h3 id="specificenchantfunction-vtbl"><a href="#specificenchantfunction-vtbl" class="header-anchor">#</a> <code>SpecificEnchantFunction_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SpecificEnchantFunction_vtbl
{
  void (__fastcall *~LootItemFunction)(LootItemFunction *this);
  int (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, LootTableContext *);
  int (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, LootTableContext *);
};

</code></pre></div><h3 id="setdatafromcolorindexfunction"><a href="#setdatafromcolorindexfunction" class="header-anchor">#</a> <code>SetDataFromColorIndexFunction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SetDataFromColorIndexFunction : LootItemFunction
{
};

</code></pre></div><h3 id="setdatafromcolorindexfunction-vtbl"><a href="#setdatafromcolorindexfunction-vtbl" class="header-anchor">#</a> <code>SetDataFromColorIndexFunction_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SetDataFromColorIndexFunction_vtbl
{
  void (__fastcall *~LootItemFunction)(LootItemFunction *this);
  int (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, LootTableContext *);
  int (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, LootTableContext *);
};

</code></pre></div><h3 id="setattributesfunction"><a href="#setattributesfunction" class="header-anchor">#</a> <code>SetAttributesFunction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SetAttributesFunction : LootItemFunction
{
  std::vector&lt;AttributeModifier&gt; mModifiers;
};

</code></pre></div><h3 id="setattributesfunction-vtbl"><a href="#setattributesfunction-vtbl" class="header-anchor">#</a> <code>SetAttributesFunction_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SetAttributesFunction_vtbl
{
  void (__fastcall *~LootItemFunction)(LootItemFunction *this);
  int (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, LootTableContext *);
  int (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, LootTableContext *);
};

</code></pre></div><h3 id="snapshotwritablefile"><a href="#snapshotwritablefile" class="header-anchor">#</a> <code>SnapshotWritableFile</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SnapshotWritableFile : leveldb::WritableFile
{
  leveldb::WritableFile *mLeveldbWritableFile;
  std::shared_mutex *mCreationAndWriteLock;
};

</code></pre></div><h3 id="snapshotwritablefile-vtbl"><a href="#snapshotwritablefile-vtbl" class="header-anchor">#</a> <code>SnapshotWritableFile_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SnapshotWritableFile_vtbl
{
  void (__fastcall *~WritableFile)(leveldb::WritableFile *this);
  leveldb::Status *(__fastcall *Append)(leveldb::WritableFile *this, leveldb::Status *result, const leveldb::Slice *);
  leveldb::Status *(__fastcall *Close)(leveldb::WritableFile *this, leveldb::Status *result);
  leveldb::Status *(__fastcall *Flush)(leveldb::WritableFile *this, leveldb::Status *result);
  leveldb::Status *(__fastcall *Sync)(leveldb::WritableFile *this, leveldb::Status *result);
};

</code></pre></div><h3 id="subchunkpositerator"><a href="#subchunkpositerator" class="header-anchor">#</a> <code>SubChunkPosIterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) SubChunkPosIterator
{
  const SubChunkPos mMinCorner;
  const SubChunkPos mMaxCorner;
  SubChunkPos mCurrentPos;
  bool mDone;
};

</code></pre></div><h3 id="shouldcreatenewservertag-l2-lambda-49d12031768ec3221a197c06ce099fc7"><a href="#shouldcreatenewservertag-l2-lambda-49d12031768ec3221a197c06ce099fc7" class="header-anchor">#</a> <code>shouldCreateNewServerTag::__l2::&lt;lambda_49d12031768ec3221a197c06ce099fc7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj shouldCreateNewServerTag::__l2::&lt;lambda_49d12031768ec3221a197c06ce099fc7&gt;
{
  bool *isDataConflict;
  CompoundTag *serverTag;
};

</code></pre></div><h3 id="saveservertag-l2-lambda-54122adfe065e725be55aa7f8beaba9a"><a href="#saveservertag-l2-lambda-54122adfe065e725be55aa7f8beaba9a" class="header-anchor">#</a> <code>saveServerTag::__l2::&lt;lambda_54122adfe065e725be55aa7f8beaba9a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj saveServerTag::__l2::&lt;lambda_54122adfe065e725be55aa7f8beaba9a&gt;
{
  LevelStorage *storage;
  CompoundTag *serverTag;
};

</code></pre></div><h3 id="simpleplayercontainer-setitem-l2-lambda-a42ec50a0799ef1a7ea93fb9caa94eff"><a href="#simpleplayercontainer-setitem-l2-lambda-a42ec50a0799ef1a7ea93fb9caa94eff" class="header-anchor">#</a> <code>SimplePlayerContainer::setItem::__l2::&lt;lambda_a42ec50a0799ef1a7ea93fb9caa94eff&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) SimplePlayerContainer::setItem::__l2::&lt;lambda_a42ec50a0799ef1a7ea93fb9caa94eff&gt;
{
  SimplePlayerContainer *const __this;
  int slot;
};

</code></pre></div><h3 id="servicelocator-cg-igraphicsdeviceplatformprovider"><a href="#servicelocator-cg-igraphicsdeviceplatformprovider" class="header-anchor">#</a> <code>ServiceLocator&lt;cg::IGraphicsDevicePlatformProvider&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ServiceLocator&lt;cg::IGraphicsDevicePlatformProvider&gt;
{
};

</code></pre></div><h3 id="servicelocator-bedrock-iapplicationdatastores"><a href="#servicelocator-bedrock-iapplicationdatastores" class="header-anchor">#</a> <code>ServiceLocator&lt;Bedrock::IApplicationDataStores&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ServiceLocator&lt;Bedrock::IApplicationDataStores&gt;
{
};

</code></pre></div><h3 id="skinhelper-personainfo-resetpieceinfo"><a href="#skinhelper-personainfo-resetpieceinfo" class="header-anchor">#</a> <code>SkinHelper::PersonaInfo::ResetPieceInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SkinHelper::PersonaInfo::ResetPieceInfo
{
  _BYTE type[4];
  _BYTE side[4];
};

</code></pre></div><h3 id="skinhelper-personainfo-resettintinfo"><a href="#skinhelper-personainfo-resettintinfo" class="header-anchor">#</a> <code>SkinHelper::PersonaInfo::ResetTintInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SkinHelper::PersonaInfo::ResetTintInfo
{
  _BYTE type[4];
};

</code></pre></div><h3 id="skinhelper"><a href="#skinhelper" class="header-anchor">#</a> <code>SkinHelper</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SkinHelper
{
};

</code></pre></div><h3 id="social-lambda-e32165e8d086835752a776bf1d92da3e"><a href="#social-lambda-e32165e8d086835752a776bf1d92da3e" class="header-anchor">#</a> <code>Social::&lt;lambda_e32165e8d086835752a776bf1d92da3e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Social::&lt;lambda_e32165e8d086835752a776bf1d92da3e&gt;
{
};

</code></pre></div><h3 id="social-lambda-7dd75ea614ed2fda75aa56b254ad5bc5"><a href="#social-lambda-7dd75ea614ed2fda75aa56b254ad5bc5" class="header-anchor">#</a> <code>Social::&lt;lambda_7dd75ea614ed2fda75aa56b254ad5bc5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Social::&lt;lambda_7dd75ea614ed2fda75aa56b254ad5bc5&gt;
{
};

</code></pre></div><h3 id="scriptneteventcallback"><a href="#scriptneteventcallback" class="header-anchor">#</a> <code>ScriptNetEventCallback</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScriptNetEventCallback : NetEventCallback
{
  ScriptInstance *m_instance;
  NetworkHandler *mNetHandler;
};

</code></pre></div><h3 id="social-lambda-78f584806f387d7a546cbd44155fe1f8"><a href="#social-lambda-78f584806f387d7a546cbd44155fe1f8" class="header-anchor">#</a> <code>Social::&lt;lambda_78f584806f387d7a546cbd44155fe1f8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Social::&lt;lambda_78f584806f387d7a546cbd44155fe1f8&gt;
{
};

</code></pre></div><h3 id="social-lambda-3d03ebee43d043137d244195b801d9dd"><a href="#social-lambda-3d03ebee43d043137d244195b801d9dd" class="header-anchor">#</a> <code>Social::&lt;lambda_3d03ebee43d043137d244195b801d9dd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Social::&lt;lambda_3d03ebee43d043137d244195b801d9dd&gt;
{
};

</code></pre></div><h3 id="social-lambda-4f6367c3de6d9a9078c88399f400288e"><a href="#social-lambda-4f6367c3de6d9a9078c88399f400288e" class="header-anchor">#</a> <code>Social::&lt;lambda_4f6367c3de6d9a9078c88399f400288e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Social::&lt;lambda_4f6367c3de6d9a9078c88399f400288e&gt;
{
};

</code></pre></div><h3 id="social-lambda-a57cc4f1efe457c3fa07fc75ca994b45"><a href="#social-lambda-a57cc4f1efe457c3fa07fc75ca994b45" class="header-anchor">#</a> <code>Social::&lt;lambda_a57cc4f1efe457c3fa07fc75ca994b45&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Social::&lt;lambda_a57cc4f1efe457c3fa07fc75ca994b45&gt;
{
};

</code></pre></div><h3 id="social-lambda-f563cae144b869bbcf358649151c7ed8"><a href="#social-lambda-f563cae144b869bbcf358649151c7ed8" class="header-anchor">#</a> <code>Social::&lt;lambda_f563cae144b869bbcf358649151c7ed8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Social::&lt;lambda_f563cae144b869bbcf358649151c7ed8&gt;
{
};

</code></pre></div><h3 id="social-lambda-036d7f5b8afcff24460186c40d92f24e"><a href="#social-lambda-036d7f5b8afcff24460186c40d92f24e" class="header-anchor">#</a> <code>Social::&lt;lambda_036d7f5b8afcff24460186c40d92f24e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Social::&lt;lambda_036d7f5b8afcff24460186c40d92f24e&gt;
{
};

</code></pre></div><h3 id="scriptingscreencontroller"><a href="#scriptingscreencontroller" class="header-anchor">#</a> <code>ScriptingScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ScriptingScreenController : MinecraftScreenController
{
  ScriptInstance *m_instance;
  bool mIsOpened;
};

</code></pre></div><h3 id="scriptingscreencontroller-vtbl"><a href="#scriptingscreencontroller-vtbl" class="header-anchor">#</a> <code>ScriptingScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ScriptingScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="social-lambda-8f164ec9646e2439d4259e90c9313d4f"><a href="#social-lambda-8f164ec9646e2439d4259e90c9313d4f" class="header-anchor">#</a> <code>Social::&lt;lambda_8f164ec9646e2439d4259e90c9313d4f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Social::&lt;lambda_8f164ec9646e2439d4259e90c9313d4f&gt;
{
};

</code></pre></div><h3 id="social-lambda-9951891f522a27c552e50df636dd659d"><a href="#social-lambda-9951891f522a27c552e50df636dd659d" class="header-anchor">#</a> <code>Social::&lt;lambda_9951891f522a27c552e50df636dd659d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Social::&lt;lambda_9951891f522a27c552e50df636dd659d&gt;
{
};

</code></pre></div><h3 id="scriptsimulator"><a href="#scriptsimulator" class="header-anchor">#</a> <code>ScriptSimulator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ScriptSimulator
{
  int mState;
  int mPatchState;
  int mRetryCnt;
  int mMaxRetry;
  bool mCheckMd5;
  bool mCheckSize;
  Json::Value mPatchListInfo;
  std::vector&lt;std::string&gt; mMsgList;
};

</code></pre></div><h3 id="storeutil-requestjwts-l2-lambda-22713ab80c88642ea8a00ca2b75349fc"><a href="#storeutil-requestjwts-l2-lambda-22713ab80c88642ea8a00ca2b75349fc" class="header-anchor">#</a> <code>storeUtil::_requestJwts::__l2::&lt;lambda_22713ab80c88642ea8a00ca2b75349fc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj storeUtil::_requestJwts::__l2::&lt;lambda_22713ab80c88642ea8a00ca2b75349fc&gt;
{
  std::function&lt;void __cdecl(std::unordered_map&lt;std::string,std::string&gt; &amp;&amp;)&gt; callback;
};

</code></pre></div><h3 id="storeutil-requestjwt-l2-lambda-2932e6f7f48580995e05464c1d7c03c4"><a href="#storeutil-requestjwt-l2-lambda-2932e6f7f48580995e05464c1d7c03c4" class="header-anchor">#</a> <code>storeUtil::_requestJwt::__l2::&lt;lambda_2932e6f7f48580995e05464c1d7c03c4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj storeUtil::_requestJwt::__l2::&lt;lambda_2932e6f7f48580995e05464c1d7c03c4&gt;
{
  std::function&lt;void __cdecl(std::string &amp;&amp;)&gt; callback;
};

</code></pre></div><h3 id="storeutil-requestpublickey-l2-lambda-71553e1cefa7c0bbe6f89de57804ea29"><a href="#storeutil-requestpublickey-l2-lambda-71553e1cefa7c0bbe6f89de57804ea29" class="header-anchor">#</a> <code>storeUtil::requestPublicKey::__l2::&lt;lambda_71553e1cefa7c0bbe6f89de57804ea29&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj storeUtil::requestPublicKey::__l2::&lt;lambda_71553e1cefa7c0bbe6f89de57804ea29&gt;
{
  std::function&lt;void __cdecl(int,std::string &amp;&amp;)&gt; callback;
};

</code></pre></div><h3 id="skinhelper-generatepersonacharacter-l14-lambda-6b5d2809ea5e04a86a781b5f89ab6767"><a href="#skinhelper-generatepersonacharacter-l14-lambda-6b5d2809ea5e04a86a781b5f89ab6767" class="header-anchor">#</a> <code>SkinHelper::generatePersonaCharacter::__l14::&lt;lambda_6b5d2809ea5e04a86a781b5f89ab6767&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SkinHelper::generatePersonaCharacter::__l14::&lt;lambda_6b5d2809ea5e04a86a781b5f89ab6767&gt;
{
  bool *result;
};

</code></pre></div><h3 id="skinhelper-changepersonapiecesyncnoupdate-l2-lambda-1cd8e212a4b1bf2bb6b8a5a14b152e2d"><a href="#skinhelper-changepersonapiecesyncnoupdate-l2-lambda-1cd8e212a4b1bf2bb6b8a5a14b152e2d" class="header-anchor">#</a> <code>SkinHelper::changePersonaPieceSyncNoUpdate::__l2::&lt;lambda_1cd8e212a4b1bf2bb6b8a5a14b152e2d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SkinHelper::changePersonaPieceSyncNoUpdate::__l2::&lt;lambda_1cd8e212a4b1bf2bb6b8a5a14b152e2d&gt;
{
  const SkinHelper::PersonaInfo::PieceInfo *pieceInfo;
  bool *result;
};

</code></pre></div><h3 id="skinhelper-generatepersonacharacter-l32-lambda-68a91a6dfa295f6a02bd3c550bd20a21"><a href="#skinhelper-generatepersonacharacter-l32-lambda-68a91a6dfa295f6a02bd3c550bd20a21" class="header-anchor">#</a> <code>SkinHelper::generatePersonaCharacter::__l32::&lt;lambda_68a91a6dfa295f6a02bd3c550bd20a21&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SkinHelper::generatePersonaCharacter::__l32::&lt;lambda_68a91a6dfa295f6a02bd3c550bd20a21&gt;
{
  bool *result;
};

</code></pre></div><h3 id="skinhelper-changepersonapiecesyncnoupdate-l15-lambda-832338e720a06d9f2a3a4b010e66b3c8"><a href="#skinhelper-changepersonapiecesyncnoupdate-l15-lambda-832338e720a06d9f2a3a4b010e66b3c8" class="header-anchor">#</a> <code>SkinHelper::changePersonaPieceSyncNoUpdate::__l15::&lt;lambda_832338e720a06d9f2a3a4b010e66b3c8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SkinHelper::changePersonaPieceSyncNoUpdate::__l15::&lt;lambda_832338e720a06d9f2a3a4b010e66b3c8&gt;
{
  const SkinHelper::PersonaInfo::PieceInfo *pieceInfo;
  bool *result;
};

</code></pre></div><h3 id="statscollector-t"><a href="#statscollector-t" class="header-anchor">#</a> <code>statscollector_t</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct statscollector_t
{
  _object *list;
  _object *sublist;
  long double factor;
};

</code></pre></div><h3 id="storylinecomponent-createstoryline-l5-lambda-154776dec58b83371c4d6cd630e4c641"><a href="#storylinecomponent-createstoryline-l5-lambda-154776dec58b83371c4d6cd630e4c641" class="header-anchor">#</a> <code>StorylineComponent::createStoryline::__l5::&lt;lambda_154776dec58b83371c4d6cd630e4c641&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StorylineComponent::createStoryline::__l5::&lt;lambda_154776dec58b83371c4d6cd630e4c641&gt;
{
  StorylineComponent *const __this;
};

</code></pre></div><h3 id="storylinecomponent-tick-l5-lambda-49501ea1395abf66e5a21b15f0a03ac6"><a href="#storylinecomponent-tick-l5-lambda-49501ea1395abf66e5a21b15f0a03ac6" class="header-anchor">#</a> <code>StorylineComponent::tick::__l5::&lt;lambda_49501ea1395abf66e5a21b15f0a03ac6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StorylineComponent::tick::__l5::&lt;lambda_49501ea1395abf66e5a21b15f0a03ac6&gt;
{
  StorylineComponent *const __this;
};

</code></pre></div><h3 id="sharedcounter-customrangedweaponitem"><a href="#sharedcounter-customrangedweaponitem" class="header-anchor">#</a> <code>SharedCounter&lt;CustomRangedWeaponItem&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;CustomRangedWeaponItem&gt;
{
  CustomRangedWeaponItem *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-customrangedweaponitem"><a href="#sharedptr-customrangedweaponitem" class="header-anchor">#</a> <code>SharedPtr&lt;CustomRangedWeaponItem&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;CustomRangedWeaponItem&gt;
{
  SharedCounter&lt;CustomRangedWeaponItem&gt; *pc;
};

</code></pre></div><h3 id="sharedcounter-customprojectileitem"><a href="#sharedcounter-customprojectileitem" class="header-anchor">#</a> <code>SharedCounter&lt;CustomProjectileItem&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;CustomProjectileItem&gt;
{
  CustomProjectileItem *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sendneighborchangedeventtoscriptdescription-buildschema-l2-lambda-4e9dd81ac04276ac80769d0fb71cdc68"><a href="#sendneighborchangedeventtoscriptdescription-buildschema-l2-lambda-4e9dd81ac04276ac80769d0fb71cdc68" class="header-anchor">#</a> <code>SendNeighBorChangedEventToScriptDescription::buildSchema::__l2::&lt;lambda_4e9dd81ac04276ac80769d0fb71cdc68&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SendNeighBorChangedEventToScriptDescription::buildSchema::__l2::&lt;lambda_4e9dd81ac04276ac80769d0fb71cdc68&gt;
{
};

</code></pre></div><h3 id="sendneighborchangedeventtoscriptdescription-buildschema-l2-lambda-2c3bbfcb9ba1b81d58be4d43e3f8b51a"><a href="#sendneighborchangedeventtoscriptdescription-buildschema-l2-lambda-2c3bbfcb9ba1b81d58be4d43e3f8b51a" class="header-anchor">#</a> <code>SendNeighBorChangedEventToScriptDescription::buildSchema::__l2::&lt;lambda_2c3bbfcb9ba1b81d58be4d43e3f8b51a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SendNeighBorChangedEventToScriptDescription::buildSchema::__l2::&lt;lambda_2c3bbfcb9ba1b81d58be4d43e3f8b51a&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="sharedcounter-customcropblock"><a href="#sharedcounter-customcropblock" class="header-anchor">#</a> <code>SharedCounter&lt;CustomCropBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedCounter&lt;CustomCropBlock&gt;
{
  CustomCropBlock *ptr;
  std::atomic&lt;int&gt; share_count;
  std::atomic&lt;int&gt; weak_count;
};

</code></pre></div><h3 id="sharedptr-customcropblock"><a href="#sharedptr-customcropblock" class="header-anchor">#</a> <code>SharedPtr&lt;CustomCropBlock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SharedPtr&lt;CustomCropBlock&gt;
{
  SharedCounter&lt;CustomCropBlock&gt; *pc;
};

</code></pre></div><h3 id="sensitivewordsmanager-checkvalid-l2-lambda-dc5c5c29e1bd4050c138f9153ae4a9be"><a href="#sensitivewordsmanager-checkvalid-l2-lambda-dc5c5c29e1bd4050c138f9153ae4a9be" class="header-anchor">#</a> <code>SensitiveWordsManager::checkValid::__l2::&lt;lambda_dc5c5c29e1bd4050c138f9153ae4a9be&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SensitiveWordsManager::checkValid::__l2::&lt;lambda_dc5c5c29e1bd4050c138f9153ae4a9be&gt;
{
};

</code></pre></div><h3 id="sensitivewordsmanager-checkvalidclient-l2-lambda-3f925f660a516b7830d18fe012a8406a"><a href="#sensitivewordsmanager-checkvalidclient-l2-lambda-3f925f660a516b7830d18fe012a8406a" class="header-anchor">#</a> <code>SensitiveWordsManager::checkValidClient::__l2::&lt;lambda_3f925f660a516b7830d18fe012a8406a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SensitiveWordsManager::checkValidClient::__l2::&lt;lambda_3f925f660a516b7830d18fe012a8406a&gt;
{
  SensitiveWordsLog::ContentType *contentType;
  const std::string *content;
  bool *ret;
};

</code></pre></div><h3 id="sensitivewordsmanager-checkvalid4cmd-l2-lambda-0626c5ad482fb936463ae3157a47840e"><a href="#sensitivewordsmanager-checkvalid4cmd-l2-lambda-0626c5ad482fb936463ae3157a47840e" class="header-anchor">#</a> <code>SensitiveWordsManager::checkValid4Cmd::__l2::&lt;lambda_0626c5ad482fb936463ae3157a47840e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SensitiveWordsManager::checkValid4Cmd::__l2::&lt;lambda_0626c5ad482fb936463ae3157a47840e&gt;
{
};

</code></pre></div><h3 id="sensitivewordsmanager-checkvalidclient4cmd-l2-lambda-cd47dc911db3be61c64915e3dbc674b9"><a href="#sensitivewordsmanager-checkvalidclient4cmd-l2-lambda-cd47dc911db3be61c64915e3dbc674b9" class="header-anchor">#</a> <code>SensitiveWordsManager::checkValidClient4Cmd::__l2::&lt;lambda_cd47dc911db3be61c64915e3dbc674b9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SensitiveWordsManager::checkValidClient4Cmd::__l2::&lt;lambda_cd47dc911db3be61c64915e3dbc674b9&gt;
{
  const std::string *content;
  bool *ret;
};

</code></pre></div><h3 id="smokercontainermanagercontroller"><a href="#smokercontainermanagercontroller" class="header-anchor">#</a> <code>SmokerContainerManagerController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SmokerContainerManagerController : FurnaceContainerManagerController
{
};

</code></pre></div><h3 id="smokercontainermanagercontroller-vtbl"><a href="#smokercontainermanagercontroller-vtbl" class="header-anchor">#</a> <code>SmokerContainerManagerController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SmokerContainerManagerController_vtbl
{
  void (__fastcall *~ContainerManagerController)(ContainerManagerController *this);
  void (__fastcall *registerContainerCallbacks)(ContainerManagerController *this);
  const ItemStackBase *(__fastcall *getTakeableItemStackBase)(ContainerManagerController *this, const SlotData *);
  void (__fastcall *handleTakeAmount)(ContainerManagerController *this, const SlotData *, int, const SlotData *);
  void (__fastcall *handleTakeAll)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handlePlaceAll)(ContainerManagerController *this, const SelectedSlotInfo *, const SlotData *);
  void (__fastcall *handleTakeHalf)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handlePlaceOne)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handlePlaceAmount)(ContainerManagerController *this, const SlotData *, int, const SlotData *);
  int (__fastcall *handleAutoPlace)(ContainerManagerController *this, const SlotData *, int, const std::vector&lt;AutoPlaceItem&gt; *, std::vector&lt;AutoPlaceResult&gt; *);
  int (__fastcall *handleAutoPlaceStack)(ContainerManagerController *this, const SlotData *, ItemTakeType, const std::vector&lt;AutoPlaceItem&gt; *, std::vector&lt;AutoPlaceResult&gt; *);
  void (__fastcall *handleSplitSingle)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handleSplitMultiple)(ContainerManagerController *this, const SelectedSlotInfo *, const ItemInstance *, const SlotData *);
  void (__fastcall *handleCoalesce)(ContainerManagerController *this, const SlotData *, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *handleSwap)(ContainerManagerController *this, const SlotData *, const SlotData *);
  bool (__fastcall *handleDrop)(ContainerManagerController *this, const SlotData *, const ItemTransferAmount);
  bool (__fastcall *handleDestroy)(ContainerManagerController *this, const SlotData *, const ItemTransferAmount);
  bool (__fastcall *handleDestroy)(ContainerManagerController *this, const SelectedSlotInfo *, const ItemTransferAmount);
  bool (__fastcall *handleConsume)(ContainerManagerController *this, const SlotData *, const ItemTransferAmount);
  void (__fastcall *handleAddToStack)(ContainerManagerController *this, const SlotData *, const SlotData *, ItemTakeType);
  void (__fastcall *closeContainers)(ContainerManagerController *this);
  const std::vector&lt;ContainerSplitControl&gt; *(__fastcall *getSplitItems)(ContainerManagerController *this);
  bool (__fastcall *isOutputSlot)(ContainerManagerController *this, const std::string *);
  void (__fastcall *_onItemTransferredFrom)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
  void (__fastcall *_onItemTransferredTo)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
  void (__fastcall *_onItemAcquired)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
  void (__fastcall *_onItemPlaced)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
};

</code></pre></div><h3 id="smokercontainermanagermodel"><a href="#smokercontainermanagermodel" class="header-anchor">#</a> <code>SmokerContainerManagerModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SmokerContainerManagerModel : FurnaceContainerManagerModel
{
};

</code></pre></div><h3 id="smokercontainermanagermodel-vtbl"><a href="#smokercontainermanagermodel-vtbl" class="header-anchor">#</a> <code>SmokerContainerManagerModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SmokerContainerManagerModel_vtbl
{
  void (__fastcall *~IContainerManager)(IContainerManager *this);
  ContainerID (__fastcall *getContainerId)(IContainerManager *this);
  void (__fastcall *setContainerId)(IContainerManager *this, ContainerID);
  ContainerType (__fastcall *getContainerType)(IContainerManager *this);
  void (__fastcall *setContainerType)(IContainerManager *this, ContainerType);
  void (__fastcall *serverInitItemStackIds)(IContainerManager *this);
  std::vector&lt;ItemStack&gt; *(__fastcall *getItemCopies)(IContainerManager *this, std::vector&lt;ItemStack&gt; *result);
  void (__fastcall *setSlot)(IContainerManager *this, int, const ItemStack *, bool);
  const ItemStack *(__fastcall *getSlot)(IContainerManager *this, int);
  void (__fastcall *setData)(IContainerManager *this, int, int);
  void (__fastcall *broadcastChanges)(IContainerManager *this);
  bool (__fastcall *validateContainer)(IContainerManager *this);
  bool (__fastcall *isValid)(ContainerManagerModel *this, float);
  ContainerScreenContext *(__fastcall *_postInit)(ContainerManagerModel *this, ContainerScreenContext *result);
};

</code></pre></div><h3 id="smithingtablecontainermanagermodel"><a href="#smithingtablecontainermanagermodel" class="header-anchor">#</a> <code>SmithingTableContainerManagerModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) SmithingTableContainerManagerModel : ContainerManagerModel
{
  BlockPos mBlockPos;
};

</code></pre></div><h3 id="smithingtablecontainermanagermodel-vtbl"><a href="#smithingtablecontainermanagermodel-vtbl" class="header-anchor">#</a> <code>SmithingTableContainerManagerModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SmithingTableContainerManagerModel_vtbl
{
  void (__fastcall *~IContainerManager)(IContainerManager *this);
  ContainerID (__fastcall *getContainerId)(IContainerManager *this);
  void (__fastcall *setContainerId)(IContainerManager *this, ContainerID);
  ContainerType (__fastcall *getContainerType)(IContainerManager *this);
  void (__fastcall *setContainerType)(IContainerManager *this, ContainerType);
  void (__fastcall *serverInitItemStackIds)(IContainerManager *this);
  std::vector&lt;ItemStack&gt; *(__fastcall *getItemCopies)(IContainerManager *this, std::vector&lt;ItemStack&gt; *result);
  void (__fastcall *setSlot)(IContainerManager *this, int, const ItemStack *, bool);
  const ItemStack *(__fastcall *getSlot)(IContainerManager *this, int);
  void (__fastcall *setData)(IContainerManager *this, int, int);
  void (__fastcall *broadcastChanges)(IContainerManager *this);
  bool (__fastcall *validateContainer)(IContainerManager *this);
  bool (__fastcall *isValid)(ContainerManagerModel *this, float);
  ContainerScreenContext *(__fastcall *_postInit)(ContainerManagerModel *this, ContainerScreenContext *result);
};

</code></pre></div><h3 id="smithingtablecontainermanagercontroller"><a href="#smithingtablecontainermanagercontroller" class="header-anchor">#</a> <code>SmithingTableContainerManagerController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SmithingTableContainerManagerController : ContainerManagerController
{
  std::weak_ptr&lt;SmithingTableContainerManagerModel&gt; mSmithingTableContainerManagerModel;
  const SlotData mCreatedItemOutputSlot;
  ItemInstance mResultPreviewItem;
};

</code></pre></div><h3 id="smithingtablecontainermanagercontroller-vtbl"><a href="#smithingtablecontainermanagercontroller-vtbl" class="header-anchor">#</a> <code>SmithingTableContainerManagerController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SmithingTableContainerManagerController_vtbl
{
  void (__fastcall *~ContainerManagerController)(ContainerManagerController *this);
  void (__fastcall *registerContainerCallbacks)(ContainerManagerController *this);
  const ItemStackBase *(__fastcall *getTakeableItemStackBase)(ContainerManagerController *this, const SlotData *);
  void (__fastcall *handleTakeAmount)(ContainerManagerController *this, const SlotData *, int, const SlotData *);
  void (__fastcall *handleTakeAll)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handlePlaceAll)(ContainerManagerController *this, const SelectedSlotInfo *, const SlotData *);
  void (__fastcall *handleTakeHalf)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handlePlaceOne)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handlePlaceAmount)(ContainerManagerController *this, const SlotData *, int, const SlotData *);
  int (__fastcall *handleAutoPlace)(ContainerManagerController *this, const SlotData *, int, const std::vector&lt;AutoPlaceItem&gt; *, std::vector&lt;AutoPlaceResult&gt; *);
  int (__fastcall *handleAutoPlaceStack)(ContainerManagerController *this, const SlotData *, ItemTakeType, const std::vector&lt;AutoPlaceItem&gt; *, std::vector&lt;AutoPlaceResult&gt; *);
  void (__fastcall *handleSplitSingle)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handleSplitMultiple)(ContainerManagerController *this, const SelectedSlotInfo *, const ItemInstance *, const SlotData *);
  void (__fastcall *handleCoalesce)(ContainerManagerController *this, const SlotData *, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *handleSwap)(ContainerManagerController *this, const SlotData *, const SlotData *);
  bool (__fastcall *handleDrop)(ContainerManagerController *this, const SlotData *, const ItemTransferAmount);
  bool (__fastcall *handleDestroy)(ContainerManagerController *this, const SlotData *, const ItemTransferAmount);
  bool (__fastcall *handleDestroy)(ContainerManagerController *this, const SelectedSlotInfo *, const ItemTransferAmount);
  bool (__fastcall *handleConsume)(ContainerManagerController *this, const SlotData *, const ItemTransferAmount);
  void (__fastcall *handleAddToStack)(ContainerManagerController *this, const SlotData *, const SlotData *, ItemTakeType);
  void (__fastcall *closeContainers)(ContainerManagerController *this);
  const std::vector&lt;ContainerSplitControl&gt; *(__fastcall *getSplitItems)(ContainerManagerController *this);
  bool (__fastcall *isOutputSlot)(ContainerManagerController *this, const std::string *);
  void (__fastcall *_onItemTransferredFrom)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
  void (__fastcall *_onItemTransferredTo)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
  void (__fastcall *_onItemAcquired)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
  void (__fastcall *_onItemPlaced)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
};

</code></pre></div><h3 id="smithingtablescreencontroller"><a href="#smithingtablescreencontroller" class="header-anchor">#</a> <code>SmithingTableScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) SmithingTableScreenController : ContainerScreenController
{
  std::shared_ptr&lt;SmithingTableContainerManagerController&gt; mSmithingTableContainerManagerController;
  SmithingTableScreenController::SlotIndex mHoveredSlot;
};

</code></pre></div><h3 id="smithingtablescreencontroller-vtbl"><a href="#smithingtablescreencontroller-vtbl" class="header-anchor">#</a> <code>SmithingTableScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ SmithingTableScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
  void (__fastcall *_handlePlaceAll)(ContainerScreenController *this, const std::string *, int);
  void (__fastcall *_handlePlaceOne)(ContainerScreenController *this, const std::string *, int);
  void (__fastcall *_handleSelectSlot)(ContainerScreenController *this, const std::string *, int);
  const SelectedSlotInfo *(__fastcall *_getSelectedSlotInfo)(ContainerScreenController *this, const SelectedSlotInfo *result);
  const ItemStack *(__fastcall *_getItemStack)(ContainerScreenController *this, const std::string *, int);
  const ItemStackBase *(__fastcall *_getVisualItemStack)(ContainerScreenController *this, const std::string *, int);
  const ItemStackBase *(__fastcall *_getTakeableItemStackBase)(ContainerScreenController *this, const std::string *, int);
  ui::ViewRequest (__fastcall *_onContainerSlotHovered)(ContainerScreenController *this, const std::string *, int);
  ui::ViewRequest (__fastcall *_onContainerSlotSelected)(ContainerScreenController *this, const std::string *, int);
  ui::ViewRequest (__fastcall *_onContainerSlotPressed)(ContainerScreenController *this, const std::string *, int);
  bool (__fastcall *_shouldSwap)(ContainerScreenController *this, const std::string *, int, const std::string *, int);
  std::string *(__fastcall *_getCollectionName)(ContainerScreenController *this, std::string *result, UIPropertyBag *);
  bool (__fastcall *_canSplit)(ContainerScreenController *this, const std::string *, int);
  void (__fastcall *_sendFlyingItem)(ContainerScreenController *this, const ItemStackBase *, const std::string *, int, const std::string *, int);
  void (__fastcall *_registerCoalesceOrder)(ContainerScreenController *this);
  void (__fastcall *_registerAutoPlaceOrder)(ContainerScreenController *this);
};

</code></pre></div><h3 id="smithingtablescreencontroller-registerstatemachine-l2-lambda-ba402959662717d23678cc853bd3b9fc"><a href="#smithingtablescreencontroller-registerstatemachine-l2-lambda-ba402959662717d23678cc853bd3b9fc" class="header-anchor">#</a> <code>SmithingTableScreenController::_registerStateMachine::__l2::&lt;lambda_ba402959662717d23678cc853bd3b9fc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SmithingTableScreenController::_registerStateMachine::__l2::&lt;lambda_ba402959662717d23678cc853bd3b9fc&gt;
{
  const unsigned int smithingTableTakeAllPlaceAllButtonId;
  const unsigned int smithingTableCoalesceButtonId;
};

</code></pre></div><h3 id="smithingtablescreencontroller-registerstatemachine-l2-lambda-999a0f07d9f034bae5bfc88381c18da3"><a href="#smithingtablescreencontroller-registerstatemachine-l2-lambda-999a0f07d9f034bae5bfc88381c18da3" class="header-anchor">#</a> <code>SmithingTableScreenController::_registerStateMachine::__l2::&lt;lambda_999a0f07d9f034bae5bfc88381c18da3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SmithingTableScreenController::_registerStateMachine::__l2::&lt;lambda_999a0f07d9f034bae5bfc88381c18da3&gt;
{
  const unsigned int smithingTableTakeAllPlaceAllButtonId;
  const unsigned int smithingTableCoalesceButtonId;
};

</code></pre></div><h3 id="smithingtablescreencontroller-registerstatemachine-l2-lambda-9b1dfbd2491d12131652dd2ba3dbe453"><a href="#smithingtablescreencontroller-registerstatemachine-l2-lambda-9b1dfbd2491d12131652dd2ba3dbe453" class="header-anchor">#</a> <code>SmithingTableScreenController::_registerStateMachine::__l2::&lt;lambda_9b1dfbd2491d12131652dd2ba3dbe453&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SmithingTableScreenController::_registerStateMachine::__l2::&lt;lambda_9b1dfbd2491d12131652dd2ba3dbe453&gt;
{
  SmithingTableScreenController *const __this;
  const unsigned int smithingTableTakeAllPlaceAllButtonId;
  const unsigned int smithingTableCoalesceButtonId;
};

</code></pre></div><h3 id="smithingtablescreencontroller-registerstatemachine-l2-lambda-2c5c31c0227b80caf2bd9c445f5d3d56"><a href="#smithingtablescreencontroller-registerstatemachine-l2-lambda-2c5c31c0227b80caf2bd9c445f5d3d56" class="header-anchor">#</a> <code>SmithingTableScreenController::_registerStateMachine::__l2::&lt;lambda_2c5c31c0227b80caf2bd9c445f5d3d56&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SmithingTableScreenController::_registerStateMachine::__l2::&lt;lambda_2c5c31c0227b80caf2bd9c445f5d3d56&gt;
{
  SmithingTableScreenController *const __this;
  const unsigned int smithingTableTakeAllPlaceAllButtonId;
  const unsigned int smithingTableCoalesceButtonId;
};

</code></pre></div><h3 id="smithingtablescreencontroller-registerbindings-l2-lambda-81b3799dd862b8a5ed457441fb3f3d13"><a href="#smithingtablescreencontroller-registerbindings-l2-lambda-81b3799dd862b8a5ed457441fb3f3d13" class="header-anchor">#</a> <code>SmithingTableScreenController::_registerBindings::__l2::&lt;lambda_81b3799dd862b8a5ed457441fb3f3d13&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SmithingTableScreenController::_registerBindings::__l2::&lt;lambda_81b3799dd862b8a5ed457441fb3f3d13&gt;
{
  SmithingTableScreenController *const __this;
};

</code></pre></div><h3 id="stonecuttercontainermanagermodel"><a href="#stonecuttercontainermanagermodel" class="header-anchor">#</a> <code>StonecutterContainerManagerModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) StonecutterContainerManagerModel : ContainerManagerModel
{
  BlockPos mBlockPos;
};

</code></pre></div><h3 id="stonecuttercontainermanagermodel-vtbl"><a href="#stonecuttercontainermanagermodel-vtbl" class="header-anchor">#</a> <code>StonecutterContainerManagerModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StonecutterContainerManagerModel_vtbl
{
  void (__fastcall *~IContainerManager)(IContainerManager *this);
  ContainerID (__fastcall *getContainerId)(IContainerManager *this);
  void (__fastcall *setContainerId)(IContainerManager *this, ContainerID);
  ContainerType (__fastcall *getContainerType)(IContainerManager *this);
  void (__fastcall *setContainerType)(IContainerManager *this, ContainerType);
  void (__fastcall *serverInitItemStackIds)(IContainerManager *this);
  std::vector&lt;ItemStack&gt; *(__fastcall *getItemCopies)(IContainerManager *this, std::vector&lt;ItemStack&gt; *result);
  void (__fastcall *setSlot)(IContainerManager *this, int, const ItemStack *, bool);
  const ItemStack *(__fastcall *getSlot)(IContainerManager *this, int);
  void (__fastcall *setData)(IContainerManager *this, int, int);
  void (__fastcall *broadcastChanges)(IContainerManager *this);
  bool (__fastcall *validateContainer)(IContainerManager *this);
  bool (__fastcall *isValid)(ContainerManagerModel *this, float);
  ContainerScreenContext *(__fastcall *_postInit)(ContainerManagerModel *this, ContainerScreenContext *result);
};

</code></pre></div><h3 id="stonecuttercontainermanagercontroller"><a href="#stonecuttercontainermanagercontroller" class="header-anchor">#</a> <code>StonecutterContainerManagerController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StonecutterContainerManagerController : ContainerManagerController
{
  int mSelectedStoneIndex;
  std::weak_ptr&lt;StonecutterContainerManagerModel&gt; mStonecutterContainerManagerModel;
  const SlotData mCreatedItemOutputSlot;
  ItemInstance mResultItemPreview;
};

</code></pre></div><h3 id="stonecuttercontainermanagercontroller-vtbl"><a href="#stonecuttercontainermanagercontroller-vtbl" class="header-anchor">#</a> <code>StonecutterContainerManagerController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StonecutterContainerManagerController_vtbl
{
  void (__fastcall *~ContainerManagerController)(ContainerManagerController *this);
  void (__fastcall *registerContainerCallbacks)(ContainerManagerController *this);
  const ItemStackBase *(__fastcall *getTakeableItemStackBase)(ContainerManagerController *this, const SlotData *);
  void (__fastcall *handleTakeAmount)(ContainerManagerController *this, const SlotData *, int, const SlotData *);
  void (__fastcall *handleTakeAll)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handlePlaceAll)(ContainerManagerController *this, const SelectedSlotInfo *, const SlotData *);
  void (__fastcall *handleTakeHalf)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handlePlaceOne)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handlePlaceAmount)(ContainerManagerController *this, const SlotData *, int, const SlotData *);
  int (__fastcall *handleAutoPlace)(ContainerManagerController *this, const SlotData *, int, const std::vector&lt;AutoPlaceItem&gt; *, std::vector&lt;AutoPlaceResult&gt; *);
  int (__fastcall *handleAutoPlaceStack)(ContainerManagerController *this, const SlotData *, ItemTakeType, const std::vector&lt;AutoPlaceItem&gt; *, std::vector&lt;AutoPlaceResult&gt; *);
  void (__fastcall *handleSplitSingle)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handleSplitMultiple)(ContainerManagerController *this, const SelectedSlotInfo *, const ItemInstance *, const SlotData *);
  void (__fastcall *handleCoalesce)(ContainerManagerController *this, const SlotData *, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *handleSwap)(ContainerManagerController *this, const SlotData *, const SlotData *);
  bool (__fastcall *handleDrop)(ContainerManagerController *this, const SlotData *, const ItemTransferAmount);
  bool (__fastcall *handleDestroy)(ContainerManagerController *this, const SlotData *, const ItemTransferAmount);
  bool (__fastcall *handleDestroy)(ContainerManagerController *this, const SelectedSlotInfo *, const ItemTransferAmount);
  bool (__fastcall *handleConsume)(ContainerManagerController *this, const SlotData *, const ItemTransferAmount);
  void (__fastcall *handleAddToStack)(ContainerManagerController *this, const SlotData *, const SlotData *, ItemTakeType);
  void (__fastcall *closeContainers)(ContainerManagerController *this);
  const std::vector&lt;ContainerSplitControl&gt; *(__fastcall *getSplitItems)(ContainerManagerController *this);
  bool (__fastcall *isOutputSlot)(ContainerManagerController *this, const std::string *);
  void (__fastcall *_onItemTransferredFrom)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
  void (__fastcall *_onItemTransferredTo)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
  void (__fastcall *_onItemAcquired)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
  void (__fastcall *_onItemPlaced)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
};

</code></pre></div><h3 id="stonecutterscreencontroller"><a href="#stonecutterscreencontroller" class="header-anchor">#</a> <code>StonecutterScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StonecutterScreenController : ContainerScreenController
{
  StonecutterScreenController::LeftTabIndex mSelectedTabIndex;
  std::shared_ptr&lt;StonecutterContainerManagerController&gt; mStonecutterContainerManagerController;
};

</code></pre></div><h3 id="stonecutterscreencontroller-vtbl"><a href="#stonecutterscreencontroller-vtbl" class="header-anchor">#</a> <code>StonecutterScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StonecutterScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
  void (__fastcall *_handlePlaceAll)(ContainerScreenController *this, const std::string *, int);
  void (__fastcall *_handlePlaceOne)(ContainerScreenController *this, const std::string *, int);
  void (__fastcall *_handleSelectSlot)(ContainerScreenController *this, const std::string *, int);
  const SelectedSlotInfo *(__fastcall *_getSelectedSlotInfo)(ContainerScreenController *this, const SelectedSlotInfo *result);
  const ItemStack *(__fastcall *_getItemStack)(ContainerScreenController *this, const std::string *, int);
  const ItemStackBase *(__fastcall *_getVisualItemStack)(ContainerScreenController *this, const std::string *, int);
  const ItemStackBase *(__fastcall *_getTakeableItemStackBase)(ContainerScreenController *this, const std::string *, int);
  ui::ViewRequest (__fastcall *_onContainerSlotHovered)(ContainerScreenController *this, const std::string *, int);
  ui::ViewRequest (__fastcall *_onContainerSlotSelected)(ContainerScreenController *this, const std::string *, int);
  ui::ViewRequest (__fastcall *_onContainerSlotPressed)(ContainerScreenController *this, const std::string *, int);
  bool (__fastcall *_shouldSwap)(ContainerScreenController *this, const std::string *, int, const std::string *, int);
  std::string *(__fastcall *_getCollectionName)(ContainerScreenController *this, std::string *result, UIPropertyBag *);
  bool (__fastcall *_canSplit)(ContainerScreenController *this, const std::string *, int);
  void (__fastcall *_sendFlyingItem)(ContainerScreenController *this, const ItemStackBase *, const std::string *, int, const std::string *, int);
  void (__fastcall *_registerCoalesceOrder)(ContainerScreenController *this);
  void (__fastcall *_registerAutoPlaceOrder)(ContainerScreenController *this);
};

</code></pre></div><h3 id="stonecutterscreencontroller-registerstatemachine-l2-lambda-52cbcac621fc8dbfb95e023ed7161412"><a href="#stonecutterscreencontroller-registerstatemachine-l2-lambda-52cbcac621fc8dbfb95e023ed7161412" class="header-anchor">#</a> <code>StonecutterScreenController::_registerStateMachine::__l2::&lt;lambda_52cbcac621fc8dbfb95e023ed7161412&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StonecutterScreenController::_registerStateMachine::__l2::&lt;lambda_52cbcac621fc8dbfb95e023ed7161412&gt;
{
  const unsigned int stonecutterResultTakeAllPlaceAllButtonId;
};

</code></pre></div><h3 id="stonecutterscreencontroller-registerstatemachine-l2-lambda-7f699dc2007b1f7df2f85fede7c25aac"><a href="#stonecutterscreencontroller-registerstatemachine-l2-lambda-7f699dc2007b1f7df2f85fede7c25aac" class="header-anchor">#</a> <code>StonecutterScreenController::_registerStateMachine::__l2::&lt;lambda_7f699dc2007b1f7df2f85fede7c25aac&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StonecutterScreenController::_registerStateMachine::__l2::&lt;lambda_7f699dc2007b1f7df2f85fede7c25aac&gt;
{
  const unsigned int stonecutterResultTakeAllPlaceAllButtonId;
};

</code></pre></div><h3 id="stonecutterscreencontroller-registerstatemachine-l2-lambda-1d57109cab209478ed0e8fadae76fb8d"><a href="#stonecutterscreencontroller-registerstatemachine-l2-lambda-1d57109cab209478ed0e8fadae76fb8d" class="header-anchor">#</a> <code>StonecutterScreenController::_registerStateMachine::__l2::&lt;lambda_1d57109cab209478ed0e8fadae76fb8d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) StonecutterScreenController::_registerStateMachine::__l2::&lt;lambda_1d57109cab209478ed0e8fadae76fb8d&gt;
{
  StonecutterScreenController *const __this;
  const unsigned int stonecutterResultTakeAllPlaceAllButtonId;
};

</code></pre></div><h3 id="stonecutterscreencontroller-registerstatemachine-l2-lambda-cbd8e926ac4111025a7cf9837f332499"><a href="#stonecutterscreencontroller-registerstatemachine-l2-lambda-cbd8e926ac4111025a7cf9837f332499" class="header-anchor">#</a> <code>StonecutterScreenController::_registerStateMachine::__l2::&lt;lambda_cbd8e926ac4111025a7cf9837f332499&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) StonecutterScreenController::_registerStateMachine::__l2::&lt;lambda_cbd8e926ac4111025a7cf9837f332499&gt;
{
  StonecutterScreenController *const __this;
  const unsigned int stonecutterResultTakeAllPlaceAllButtonId;
};

</code></pre></div><h3 id="stonecutterscreencontroller-registerbindings-l2-lambda-38e625c7cda1953129346ebf1b5d4519"><a href="#stonecutterscreencontroller-registerbindings-l2-lambda-38e625c7cda1953129346ebf1b5d4519" class="header-anchor">#</a> <code>StonecutterScreenController::_registerBindings::__l2::&lt;lambda_38e625c7cda1953129346ebf1b5d4519&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StonecutterScreenController::_registerBindings::__l2::&lt;lambda_38e625c7cda1953129346ebf1b5d4519&gt;
{
  StonecutterScreenController *const __this;
};

</code></pre></div><h3 id="stonecutterscreencontroller-registerbindings-l2-lambda-0c4de8d8d81eb3182fbc84272dbf63ca"><a href="#stonecutterscreencontroller-registerbindings-l2-lambda-0c4de8d8d81eb3182fbc84272dbf63ca" class="header-anchor">#</a> <code>StonecutterScreenController::_registerBindings::__l2::&lt;lambda_0c4de8d8d81eb3182fbc84272dbf63ca&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StonecutterScreenController::_registerBindings::__l2::&lt;lambda_0c4de8d8d81eb3182fbc84272dbf63ca&gt;
{
};

</code></pre></div><h3 id="stonecutterscreencontroller-registerbindings-l2-lambda-0038879b7a8de0c086b195bcc2e1ee8e"><a href="#stonecutterscreencontroller-registerbindings-l2-lambda-0038879b7a8de0c086b195bcc2e1ee8e" class="header-anchor">#</a> <code>StonecutterScreenController::_registerBindings::__l2::&lt;lambda_0038879b7a8de0c086b195bcc2e1ee8e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StonecutterScreenController::_registerBindings::__l2::&lt;lambda_0038879b7a8de0c086b195bcc2e1ee8e&gt;
{
  StonecutterScreenController *const __this;
};

</code></pre></div><h3 id="stonecutterscreencontroller-registerbindings-l2-lambda-1a90ada11a821ed0678752ef4476e7a5"><a href="#stonecutterscreencontroller-registerbindings-l2-lambda-1a90ada11a821ed0678752ef4476e7a5" class="header-anchor">#</a> <code>StonecutterScreenController::_registerBindings::__l2::&lt;lambda_1a90ada11a821ed0678752ef4476e7a5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StonecutterScreenController::_registerBindings::__l2::&lt;lambda_1a90ada11a821ed0678752ef4476e7a5&gt;
{
  StonecutterScreenController *const __this;
};

</code></pre></div><h3 id="stonecutterscreencontroller-registerbindings-l2-lambda-0f977d8a20dce43eaf6552c2d6ecff51"><a href="#stonecutterscreencontroller-registerbindings-l2-lambda-0f977d8a20dce43eaf6552c2d6ecff51" class="header-anchor">#</a> <code>StonecutterScreenController::_registerBindings::__l2::&lt;lambda_0f977d8a20dce43eaf6552c2d6ecff51&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StonecutterScreenController::_registerBindings::__l2::&lt;lambda_0f977d8a20dce43eaf6552c2d6ecff51&gt;
{
  StonecutterScreenController *const __this;
};

</code></pre></div><h3 id="stonecutterscreencontroller-registerbindings-l2-lambda-695907618a811ce0a51ea50717a06557"><a href="#stonecutterscreencontroller-registerbindings-l2-lambda-695907618a811ce0a51ea50717a06557" class="header-anchor">#</a> <code>StonecutterScreenController::_registerBindings::__l2::&lt;lambda_695907618a811ce0a51ea50717a06557&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StonecutterScreenController::_registerBindings::__l2::&lt;lambda_695907618a811ce0a51ea50717a06557&gt;
{
  StonecutterScreenController *const __this;
};

</code></pre></div><h3 id="stonecutterscreencontroller-registerbindings-l2-lambda-c0a3e91d4ac4e878dd07cf1628250c99"><a href="#stonecutterscreencontroller-registerbindings-l2-lambda-c0a3e91d4ac4e878dd07cf1628250c99" class="header-anchor">#</a> <code>StonecutterScreenController::_registerBindings::__l2::&lt;lambda_c0a3e91d4ac4e878dd07cf1628250c99&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StonecutterScreenController::_registerBindings::__l2::&lt;lambda_c0a3e91d4ac4e878dd07cf1628250c99&gt;
{
  StonecutterScreenController *const __this;
};

</code></pre></div><h3 id="stonecutterscreencontroller-registerbindings-l2-lambda-ae45fc556ee1e25bb18356f840e9d835"><a href="#stonecutterscreencontroller-registerbindings-l2-lambda-ae45fc556ee1e25bb18356f840e9d835" class="header-anchor">#</a> <code>StonecutterScreenController::_registerBindings::__l2::&lt;lambda_ae45fc556ee1e25bb18356f840e9d835&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StonecutterScreenController::_registerBindings::__l2::&lt;lambda_ae45fc556ee1e25bb18356f840e9d835&gt;
{
  StonecutterScreenController *const __this;
};

</code></pre></div><h3 id="stonecutterscreencontroller-registereventhandlers-l2-lambda-32c3578c484002a1d327c2d9b5a4b3e5"><a href="#stonecutterscreencontroller-registereventhandlers-l2-lambda-32c3578c484002a1d327c2d9b5a4b3e5" class="header-anchor">#</a> <code>StonecutterScreenController::_registerEventHandlers::__l2::&lt;lambda_32c3578c484002a1d327c2d9b5a4b3e5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StonecutterScreenController::_registerEventHandlers::__l2::&lt;lambda_32c3578c484002a1d327c2d9b5a4b3e5&gt;
{
  StonecutterScreenController *const __this;
};

</code></pre></div><h3 id="stonecutterscreencontroller-registereventhandlers-l2-lambda-6749e690d9fcc44f4b14db74c2abfd59"><a href="#stonecutterscreencontroller-registereventhandlers-l2-lambda-6749e690d9fcc44f4b14db74c2abfd59" class="header-anchor">#</a> <code>StonecutterScreenController::_registerEventHandlers::__l2::&lt;lambda_6749e690d9fcc44f4b14db74c2abfd59&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StonecutterScreenController::_registerEventHandlers::__l2::&lt;lambda_6749e690d9fcc44f4b14db74c2abfd59&gt;
{
  StonecutterScreenController *const __this;
};

</code></pre></div><h3 id="stonecutterscreencontroller-registereventhandlers-l2-lambda-e8da87a54aca72f5cc14f8affdede447"><a href="#stonecutterscreencontroller-registereventhandlers-l2-lambda-e8da87a54aca72f5cc14f8affdede447" class="header-anchor">#</a> <code>StonecutterScreenController::_registerEventHandlers::__l2::&lt;lambda_e8da87a54aca72f5cc14f8affdede447&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StonecutterScreenController::_registerEventHandlers::__l2::&lt;lambda_e8da87a54aca72f5cc14f8affdede447&gt;
{
  StonecutterScreenController *const __this;
};

</code></pre></div><h3 id="stonecutterscreencontroller-registereventhandlers-l2-lambda-88c06bbe2c12fdb6ddf446d21c2a9a06"><a href="#stonecutterscreencontroller-registereventhandlers-l2-lambda-88c06bbe2c12fdb6ddf446d21c2a9a06" class="header-anchor">#</a> <code>StonecutterScreenController::_registerEventHandlers::__l2::&lt;lambda_88c06bbe2c12fdb6ddf446d21c2a9a06&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StonecutterScreenController::_registerEventHandlers::__l2::&lt;lambda_88c06bbe2c12fdb6ddf446d21c2a9a06&gt;
{
  StonecutterScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller"><a href="#structureeditorscreencontroller" class="header-anchor">#</a> <code>StructureEditorScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController : BlockScreenController
{
  const BlockPos mBlockPos;
  bool mRedstoneDropdownActive;
  bool mModeDropDownActive;
  bool mTextBoxEditing;
  bool mExportCompleted;
  bool mExportSucceeded;
  bool mRenderedStructure;
  bool mIsExporting;
  bool mNeedsBindsUpdate;
  bool mMirrorX;
  bool mMirrorZ;
  bool mStructureExists;
  bool mHasOpened;
  bool mTrigger3dExport;
  const bool m3DExportSupport;
  std::shared_ptr&lt;MinecraftglTFExporter&gt; mglTFExporter;
  StructureEditorData mStructureEditorData;
  StructureTelemetryClientData mTelemetryClientData;
  std::string mSeedString;
};

</code></pre></div><h3 id="structureeditorscreencontroller-vtbl"><a href="#structureeditorscreencontroller-vtbl" class="header-anchor">#</a> <code>StructureEditorScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ StructureEditorScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="structureeditorscreencontroller-initiatefilegeneration-l5-lambda-1477a61444aa550355d70c3d32caa3d8"><a href="#structureeditorscreencontroller-initiatefilegeneration-l5-lambda-1477a61444aa550355d70c3d32caa3d8" class="header-anchor">#</a> <code>StructureEditorScreenController::_initiateFileGeneration::__l5::&lt;lambda_1477a61444aa550355d70c3d32caa3d8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_initiateFileGeneration::__l5::&lt;lambda_1477a61444aa550355d70c3d32caa3d8&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registermodedropdown-l6-lambda-c651ae665ac61ec2de19316a60e5fa6e"><a href="#structureeditorscreencontroller-registermodedropdown-l6-lambda-c651ae665ac61ec2de19316a60e5fa6e" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerModeDropdown::__l6::&lt;lambda_c651ae665ac61ec2de19316a60e5fa6e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerModeDropdown::__l6::&lt;lambda_c651ae665ac61ec2de19316a60e5fa6e&gt;
{
  StructureEditorScreenController *const __this;
  std::pair&lt;std::string const ,enum StructureBlockType&gt; modePair;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registermodedropdown-l6-lambda-cd8581ad6b5371cca84b11bd5ba460b1"><a href="#structureeditorscreencontroller-registermodedropdown-l6-lambda-cd8581ad6b5371cca84b11bd5ba460b1" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerModeDropdown::__l6::&lt;lambda_cd8581ad6b5371cca84b11bd5ba460b1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerModeDropdown::__l6::&lt;lambda_cd8581ad6b5371cca84b11bd5ba460b1&gt;
{
  StructureEditorScreenController *const __this;
  std::pair&lt;std::string const ,enum StructureBlockType&gt; modePair;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registermodedropdown-l2-lambda-4d60dc4f1e1d4ec3df724772c6a2b80a"><a href="#structureeditorscreencontroller-registermodedropdown-l2-lambda-4d60dc4f1e1d4ec3df724772c6a2b80a" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerModeDropdown::__l2::&lt;lambda_4d60dc4f1e1d4ec3df724772c6a2b80a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerModeDropdown::__l2::&lt;lambda_4d60dc4f1e1d4ec3df724772c6a2b80a&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registermodedropdown-l2-lambda-4773ff81c781f339c0e7e3cf85989e33"><a href="#structureeditorscreencontroller-registermodedropdown-l2-lambda-4773ff81c781f339c0e7e3cf85989e33" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerModeDropdown::__l2::&lt;lambda_4773ff81c781f339c0e7e3cf85989e33&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerModeDropdown::__l2::&lt;lambda_4773ff81c781f339c0e7e3cf85989e33&gt;
{
  StructureEditorScreenController *const __this;
  std::unordered_map&lt;enum StructureBlockType,std::string&gt; modeLabels;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registermodedropdown-l2-lambda-1f006060f6e1ff05fe6dee258edb99e1"><a href="#structureeditorscreencontroller-registermodedropdown-l2-lambda-1f006060f6e1ff05fe6dee258edb99e1" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerModeDropdown::__l2::&lt;lambda_1f006060f6e1ff05fe6dee258edb99e1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerModeDropdown::__l2::&lt;lambda_1f006060f6e1ff05fe6dee258edb99e1&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registermodedropdown-l2-lambda-4825f84003fb7158c9d726b73020647a"><a href="#structureeditorscreencontroller-registermodedropdown-l2-lambda-4825f84003fb7158c9d726b73020647a" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerModeDropdown::__l2::&lt;lambda_4825f84003fb7158c9d726b73020647a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerModeDropdown::__l2::&lt;lambda_4825f84003fb7158c9d726b73020647a&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registermodedropdown-l2-lambda-ceb3161255ba98e62ef50497a1519e63"><a href="#structureeditorscreencontroller-registermodedropdown-l2-lambda-ceb3161255ba98e62ef50497a1519e63" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerModeDropdown::__l2::&lt;lambda_ceb3161255ba98e62ef50497a1519e63&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerModeDropdown::__l2::&lt;lambda_ceb3161255ba98e62ef50497a1519e63&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registermodedropdown-l2-lambda-093d5fb18a8558bb2b3bf4a25a2e3dcc"><a href="#structureeditorscreencontroller-registermodedropdown-l2-lambda-093d5fb18a8558bb2b3bf4a25a2e3dcc" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerModeDropdown::__l2::&lt;lambda_093d5fb18a8558bb2b3bf4a25a2e3dcc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerModeDropdown::__l2::&lt;lambda_093d5fb18a8558bb2b3bf4a25a2e3dcc&gt;
{
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerredstonedropdown-l6-lambda-cf2174049ace314232ff088b22187753"><a href="#structureeditorscreencontroller-registerredstonedropdown-l6-lambda-cf2174049ace314232ff088b22187753" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerRedstoneDropdown::__l6::&lt;lambda_cf2174049ace314232ff088b22187753&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerRedstoneDropdown::__l6::&lt;lambda_cf2174049ace314232ff088b22187753&gt;
{
  StructureEditorScreenController *const __this;
  std::pair&lt;std::string const ,enum StructureRedstoneSaveMode&gt; modePair;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerredstonedropdown-l6-lambda-652232be9ffee578487d94f99a1fc412"><a href="#structureeditorscreencontroller-registerredstonedropdown-l6-lambda-652232be9ffee578487d94f99a1fc412" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerRedstoneDropdown::__l6::&lt;lambda_652232be9ffee578487d94f99a1fc412&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerRedstoneDropdown::__l6::&lt;lambda_652232be9ffee578487d94f99a1fc412&gt;
{
  StructureEditorScreenController *const __this;
  std::pair&lt;std::string const ,enum StructureRedstoneSaveMode&gt; modePair;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerredstonedropdown-l2-lambda-6f1030c9b09e03b9fa9d54769245d653"><a href="#structureeditorscreencontroller-registerredstonedropdown-l2-lambda-6f1030c9b09e03b9fa9d54769245d653" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerRedstoneDropdown::__l2::&lt;lambda_6f1030c9b09e03b9fa9d54769245d653&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerRedstoneDropdown::__l2::&lt;lambda_6f1030c9b09e03b9fa9d54769245d653&gt;
{
  StructureEditorScreenController *const __this;
  std::unordered_map&lt;enum StructureRedstoneSaveMode,std::string&gt; modeLabels;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerredstonedropdown-l2-lambda-0ef651b559d673e4c68f88356ebe80f6"><a href="#structureeditorscreencontroller-registerredstonedropdown-l2-lambda-0ef651b559d673e4c68f88356ebe80f6" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerRedstoneDropdown::__l2::&lt;lambda_0ef651b559d673e4c68f88356ebe80f6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerRedstoneDropdown::__l2::&lt;lambda_0ef651b559d673e4c68f88356ebe80f6&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerredstonedropdown-l2-lambda-28759f155dc56fe57dcbe3ff6ccb3c12"><a href="#structureeditorscreencontroller-registerredstonedropdown-l2-lambda-28759f155dc56fe57dcbe3ff6ccb3c12" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerRedstoneDropdown::__l2::&lt;lambda_28759f155dc56fe57dcbe3ff6ccb3c12&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerRedstoneDropdown::__l2::&lt;lambda_28759f155dc56fe57dcbe3ff6ccb3c12&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerredstonedropdown-l2-lambda-a9810a69733acbf12c054263a1448ac5"><a href="#structureeditorscreencontroller-registerredstonedropdown-l2-lambda-a9810a69733acbf12c054263a1448ac5" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerRedstoneDropdown::__l2::&lt;lambda_a9810a69733acbf12c054263a1448ac5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerRedstoneDropdown::__l2::&lt;lambda_a9810a69733acbf12c054263a1448ac5&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerredstonedropdown-l2-lambda-29a7a178e18ef0f466cabcdcabd0e862"><a href="#structureeditorscreencontroller-registerredstonedropdown-l2-lambda-29a7a178e18ef0f466cabcdcabd0e862" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerRedstoneDropdown::__l2::&lt;lambda_29a7a178e18ef0f466cabcdcabd0e862&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerRedstoneDropdown::__l2::&lt;lambda_29a7a178e18ef0f466cabcdcabd0e862&gt;
{
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-6540386cb875116df17d88520853e8de"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-6540386cb875116df17d88520853e8de" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_6540386cb875116df17d88520853e8de&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_6540386cb875116df17d88520853e8de&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-c8d2f005ae6cf5fd316a00d511b8de10"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-c8d2f005ae6cf5fd316a00d511b8de10" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_c8d2f005ae6cf5fd316a00d511b8de10&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_c8d2f005ae6cf5fd316a00d511b8de10&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-6026a8b53bee8e215142b71f31056593"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-6026a8b53bee8e215142b71f31056593" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_6026a8b53bee8e215142b71f31056593&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_6026a8b53bee8e215142b71f31056593&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-ebd942b06ee4b1d599636c784736a7d3"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-ebd942b06ee4b1d599636c784736a7d3" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_ebd942b06ee4b1d599636c784736a7d3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_ebd942b06ee4b1d599636c784736a7d3&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-9ed9e8c065c6bab88900e312c01e355a"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-9ed9e8c065c6bab88900e312c01e355a" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_9ed9e8c065c6bab88900e312c01e355a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_9ed9e8c065c6bab88900e312c01e355a&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-6a1a2c704678af811cf540b7acdf317d"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-6a1a2c704678af811cf540b7acdf317d" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_6a1a2c704678af811cf540b7acdf317d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_6a1a2c704678af811cf540b7acdf317d&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-ca08fc3c2afd1cfabebf8b2109765fb1"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-ca08fc3c2afd1cfabebf8b2109765fb1" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_ca08fc3c2afd1cfabebf8b2109765fb1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_ca08fc3c2afd1cfabebf8b2109765fb1&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-0615fb80fbd23d2f112c0b48ea17f129"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-0615fb80fbd23d2f112c0b48ea17f129" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_0615fb80fbd23d2f112c0b48ea17f129&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_0615fb80fbd23d2f112c0b48ea17f129&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-e5f19455ee7723394e1af88ccf3549e6"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-e5f19455ee7723394e1af88ccf3549e6" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_e5f19455ee7723394e1af88ccf3549e6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_e5f19455ee7723394e1af88ccf3549e6&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-31ab7942926185a2a9346b63c60bd5f5"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-31ab7942926185a2a9346b63c60bd5f5" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_31ab7942926185a2a9346b63c60bd5f5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_31ab7942926185a2a9346b63c60bd5f5&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-0ed2ab97794f382a20b8b4724f382e9f"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-0ed2ab97794f382a20b8b4724f382e9f" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_0ed2ab97794f382a20b8b4724f382e9f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_0ed2ab97794f382a20b8b4724f382e9f&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-d1c3a320ccf1c1502427ade8ee1efaba"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-d1c3a320ccf1c1502427ade8ee1efaba" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_d1c3a320ccf1c1502427ade8ee1efaba&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_d1c3a320ccf1c1502427ade8ee1efaba&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-299e5561592e5861fe7a67450951a925"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-299e5561592e5861fe7a67450951a925" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_299e5561592e5861fe7a67450951a925&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_299e5561592e5861fe7a67450951a925&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-fd7ec7ffc5b6129e9ba4166ebeef77a6"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-fd7ec7ffc5b6129e9ba4166ebeef77a6" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_fd7ec7ffc5b6129e9ba4166ebeef77a6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_fd7ec7ffc5b6129e9ba4166ebeef77a6&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-30544fe449eaa373a413acf173a97cdb"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-30544fe449eaa373a413acf173a97cdb" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_30544fe449eaa373a413acf173a97cdb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_30544fe449eaa373a413acf173a97cdb&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-163865a931b2d1ff9d755634bb918870"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-163865a931b2d1ff9d755634bb918870" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_163865a931b2d1ff9d755634bb918870&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_163865a931b2d1ff9d755634bb918870&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-ade6a026cae66cd5fa9bfcf5e9dc7df4"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-ade6a026cae66cd5fa9bfcf5e9dc7df4" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_ade6a026cae66cd5fa9bfcf5e9dc7df4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_ade6a026cae66cd5fa9bfcf5e9dc7df4&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-dd3788d89fdec8f518237ed667691687"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-dd3788d89fdec8f518237ed667691687" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_dd3788d89fdec8f518237ed667691687&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_dd3788d89fdec8f518237ed667691687&gt;
{
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-e04bf21d4b1166c16df1d0b1e8df7ee4"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-e04bf21d4b1166c16df1d0b1e8df7ee4" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_e04bf21d4b1166c16df1d0b1e8df7ee4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_e04bf21d4b1166c16df1d0b1e8df7ee4&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-4284ad8984f86a205dfb7dccb12d0ed1"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-4284ad8984f86a205dfb7dccb12d0ed1" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_4284ad8984f86a205dfb7dccb12d0ed1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_4284ad8984f86a205dfb7dccb12d0ed1&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-bc82c85b3e2a3f6d8264b42383e8f61e"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-bc82c85b3e2a3f6d8264b42383e8f61e" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_bc82c85b3e2a3f6d8264b42383e8f61e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_bc82c85b3e2a3f6d8264b42383e8f61e&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-f7bebd9abd297b906c57977cc21a58e9"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-f7bebd9abd297b906c57977cc21a58e9" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_f7bebd9abd297b906c57977cc21a58e9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_f7bebd9abd297b906c57977cc21a58e9&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-6aaa1869cc6bf9512fd22a832dc122e3"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-6aaa1869cc6bf9512fd22a832dc122e3" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_6aaa1869cc6bf9512fd22a832dc122e3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_6aaa1869cc6bf9512fd22a832dc122e3&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-bedd27238cd188564d1ce1a64ff3c6ca"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-bedd27238cd188564d1ce1a64ff3c6ca" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_bedd27238cd188564d1ce1a64ff3c6ca&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_bedd27238cd188564d1ce1a64ff3c6ca&gt;
{
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-bf486e361ea46dd34d65edbe1e9f5787"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-bf486e361ea46dd34d65edbe1e9f5787" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_bf486e361ea46dd34d65edbe1e9f5787&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_bf486e361ea46dd34d65edbe1e9f5787&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-f6f5896022a75b453df01faf3ee28ae4"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-f6f5896022a75b453df01faf3ee28ae4" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_f6f5896022a75b453df01faf3ee28ae4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_f6f5896022a75b453df01faf3ee28ae4&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-a559822a43c3e433e8251dffe1e47e9d"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-a559822a43c3e433e8251dffe1e47e9d" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_a559822a43c3e433e8251dffe1e47e9d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_a559822a43c3e433e8251dffe1e47e9d&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-18e7bb396375b075376ffaf1e43f498c"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-18e7bb396375b075376ffaf1e43f498c" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_18e7bb396375b075376ffaf1e43f498c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_18e7bb396375b075376ffaf1e43f498c&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-899f871a85c396dc53103d33e96ab00e"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-899f871a85c396dc53103d33e96ab00e" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_899f871a85c396dc53103d33e96ab00e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_899f871a85c396dc53103d33e96ab00e&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-9626094940c021e7f42269040f7cf9c6"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-9626094940c021e7f42269040f7cf9c6" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_9626094940c021e7f42269040f7cf9c6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_9626094940c021e7f42269040f7cf9c6&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-b69a585c589181fa721201d8afa4d3c9"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-b69a585c589181fa721201d8afa4d3c9" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_b69a585c589181fa721201d8afa4d3c9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_b69a585c589181fa721201d8afa4d3c9&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-5263de1a285aee9febfb86126eb2e861"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-5263de1a285aee9febfb86126eb2e861" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_5263de1a285aee9febfb86126eb2e861&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_5263de1a285aee9febfb86126eb2e861&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-033b5b9026db266e180c490abf69c8bc"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-033b5b9026db266e180c490abf69c8bc" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_033b5b9026db266e180c490abf69c8bc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_033b5b9026db266e180c490abf69c8bc&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-8f719c42d4ab40bcd79d6c156337763e"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-8f719c42d4ab40bcd79d6c156337763e" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_8f719c42d4ab40bcd79d6c156337763e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_8f719c42d4ab40bcd79d6c156337763e&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-c72440e11cc7c2c7fb2f5bfc86f5e853"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-c72440e11cc7c2c7fb2f5bfc86f5e853" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_c72440e11cc7c2c7fb2f5bfc86f5e853&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_c72440e11cc7c2c7fb2f5bfc86f5e853&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-da75c2aabce2897f0dfaa6e39dbc43e9"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-da75c2aabce2897f0dfaa6e39dbc43e9" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_da75c2aabce2897f0dfaa6e39dbc43e9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_da75c2aabce2897f0dfaa6e39dbc43e9&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-8fef16974e5dbf1c92fb4615aa7eea6b"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-8fef16974e5dbf1c92fb4615aa7eea6b" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_8fef16974e5dbf1c92fb4615aa7eea6b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_8fef16974e5dbf1c92fb4615aa7eea6b&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-b062a6c2d91e7336e495529e4b003f15"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-b062a6c2d91e7336e495529e4b003f15" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_b062a6c2d91e7336e495529e4b003f15&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_b062a6c2d91e7336e495529e4b003f15&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-1aefb63d1af58fbf1ee991962ed89233"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-1aefb63d1af58fbf1ee991962ed89233" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_1aefb63d1af58fbf1ee991962ed89233&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_1aefb63d1af58fbf1ee991962ed89233&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-eacff6756df493bed0ddae23261c7b72"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-eacff6756df493bed0ddae23261c7b72" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_eacff6756df493bed0ddae23261c7b72&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_eacff6756df493bed0ddae23261c7b72&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-5fc6df8969f93fe9f87b83e6ee311297"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-5fc6df8969f93fe9f87b83e6ee311297" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_5fc6df8969f93fe9f87b83e6ee311297&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_5fc6df8969f93fe9f87b83e6ee311297&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-3f2cde9436d4394632c27861e43c23b2"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-3f2cde9436d4394632c27861e43c23b2" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_3f2cde9436d4394632c27861e43c23b2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_3f2cde9436d4394632c27861e43c23b2&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-87a932225fa72e6b8549db26047b8eee"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-87a932225fa72e6b8549db26047b8eee" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_87a932225fa72e6b8549db26047b8eee&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_87a932225fa72e6b8549db26047b8eee&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-040745b848fa3e8c5d163253df3e8f48"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-040745b848fa3e8c5d163253df3e8f48" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_040745b848fa3e8c5d163253df3e8f48&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_040745b848fa3e8c5d163253df3e8f48&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-6aafc1ba122b87ead1ef055b3b770067"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-6aafc1ba122b87ead1ef055b3b770067" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_6aafc1ba122b87ead1ef055b3b770067&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_6aafc1ba122b87ead1ef055b3b770067&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-e60f5bb4cc7b3d32aa7be83c83b6561b"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-e60f5bb4cc7b3d32aa7be83c83b6561b" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_e60f5bb4cc7b3d32aa7be83c83b6561b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_e60f5bb4cc7b3d32aa7be83c83b6561b&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-3e2e2099ba379e1d5a8ff95baba06c81"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-3e2e2099ba379e1d5a8ff95baba06c81" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_3e2e2099ba379e1d5a8ff95baba06c81&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_3e2e2099ba379e1d5a8ff95baba06c81&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-26a56776cf3bb7c5f51362099e5de97a"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-26a56776cf3bb7c5f51362099e5de97a" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_26a56776cf3bb7c5f51362099e5de97a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_26a56776cf3bb7c5f51362099e5de97a&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-6dbbf2e0b7754be26983c366acec377e"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-6dbbf2e0b7754be26983c366acec377e" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_6dbbf2e0b7754be26983c366acec377e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_6dbbf2e0b7754be26983c366acec377e&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-6d0a94a97c7035c0b45ea400c4fffb26"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-6d0a94a97c7035c0b45ea400c4fffb26" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_6d0a94a97c7035c0b45ea400c4fffb26&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_6d0a94a97c7035c0b45ea400c4fffb26&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-f98190cd3aaca6acc42dcdd9981c1dcf"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-f98190cd3aaca6acc42dcdd9981c1dcf" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_f98190cd3aaca6acc42dcdd9981c1dcf&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_f98190cd3aaca6acc42dcdd9981c1dcf&gt;
{
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-1618d2b0e0f401fd966612175c9bc573"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-1618d2b0e0f401fd966612175c9bc573" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_1618d2b0e0f401fd966612175c9bc573&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_1618d2b0e0f401fd966612175c9bc573&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-290c0c655bef69129d1208bd0b59f5f5"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-290c0c655bef69129d1208bd0b59f5f5" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_290c0c655bef69129d1208bd0b59f5f5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_290c0c655bef69129d1208bd0b59f5f5&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-c4fd6892bd8ffd35418c6cb2b4808da0"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-c4fd6892bd8ffd35418c6cb2b4808da0" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_c4fd6892bd8ffd35418c6cb2b4808da0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_c4fd6892bd8ffd35418c6cb2b4808da0&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-03240cc8e792a37b04e87f70b2c618db"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-03240cc8e792a37b04e87f70b2c618db" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_03240cc8e792a37b04e87f70b2c618db&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_03240cc8e792a37b04e87f70b2c618db&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-2b1d0f3645a4ededfe1c0855ebb90f7e"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-2b1d0f3645a4ededfe1c0855ebb90f7e" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_2b1d0f3645a4ededfe1c0855ebb90f7e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_2b1d0f3645a4ededfe1c0855ebb90f7e&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-8ede4cda0aaa46acb78b4fd147411cfa"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-8ede4cda0aaa46acb78b4fd147411cfa" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_8ede4cda0aaa46acb78b4fd147411cfa&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_8ede4cda0aaa46acb78b4fd147411cfa&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-42e5177abcbeeb0981136e788bad7e32"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-42e5177abcbeeb0981136e788bad7e32" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_42e5177abcbeeb0981136e788bad7e32&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_42e5177abcbeeb0981136e788bad7e32&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-8bb63d2c4790da88183e41860bc23490"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-8bb63d2c4790da88183e41860bc23490" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_8bb63d2c4790da88183e41860bc23490&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_8bb63d2c4790da88183e41860bc23490&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-9c3aef89b8e43b8e3126e6d83731d134"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-9c3aef89b8e43b8e3126e6d83731d134" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_9c3aef89b8e43b8e3126e6d83731d134&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_9c3aef89b8e43b8e3126e6d83731d134&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-92288559d9e34010eb70d83250180f6e"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-92288559d9e34010eb70d83250180f6e" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_92288559d9e34010eb70d83250180f6e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_92288559d9e34010eb70d83250180f6e&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-c5aa3b12fbff70f23f9729b1ca8a7c80"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-c5aa3b12fbff70f23f9729b1ca8a7c80" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_c5aa3b12fbff70f23f9729b1ca8a7c80&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_c5aa3b12fbff70f23f9729b1ca8a7c80&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-645f377827cb9a4f939eb9e4e4fa6080"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-645f377827cb9a4f939eb9e4e4fa6080" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_645f377827cb9a4f939eb9e4e4fa6080&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_645f377827cb9a4f939eb9e4e4fa6080&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-85d46fe9cb504577f4ad575f87678f39"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-85d46fe9cb504577f4ad575f87678f39" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_85d46fe9cb504577f4ad575f87678f39&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_85d46fe9cb504577f4ad575f87678f39&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registerbindings-l2-lambda-d178fde3ac7efc4d2f1528ab6d7b1d3f"><a href="#structureeditorscreencontroller-registerbindings-l2-lambda-d178fde3ac7efc4d2f1528ab6d7b1d3f" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_d178fde3ac7efc4d2f1528ab6d7b1d3f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerBindings::__l2::&lt;lambda_d178fde3ac7efc4d2f1528ab6d7b1d3f&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-dfa635092b10483cfc7dd6bc75dd17ae"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-dfa635092b10483cfc7dd6bc75dd17ae" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_dfa635092b10483cfc7dd6bc75dd17ae&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_dfa635092b10483cfc7dd6bc75dd17ae&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-958b7dc635e2f18eab730cae249c994f"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-958b7dc635e2f18eab730cae249c994f" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_958b7dc635e2f18eab730cae249c994f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_958b7dc635e2f18eab730cae249c994f&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-86312da72210731d01a9ceff375b34ee"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-86312da72210731d01a9ceff375b34ee" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_86312da72210731d01a9ceff375b34ee&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_86312da72210731d01a9ceff375b34ee&gt;
{
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-3f0cd4ac7726f88d92e93a8f646f4d98"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-3f0cd4ac7726f88d92e93a8f646f4d98" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_3f0cd4ac7726f88d92e93a8f646f4d98&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_3f0cd4ac7726f88d92e93a8f646f4d98&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-dc049d57de45b1f35abee2e5056eaa77"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-dc049d57de45b1f35abee2e5056eaa77" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_dc049d57de45b1f35abee2e5056eaa77&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_dc049d57de45b1f35abee2e5056eaa77&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-74ef516e56dac0edee49b79d5d7079b5"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-74ef516e56dac0edee49b79d5d7079b5" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_74ef516e56dac0edee49b79d5d7079b5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_74ef516e56dac0edee49b79d5d7079b5&gt;
{
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-08d957a9ad6acc2a617c78b2c7006a27"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-08d957a9ad6acc2a617c78b2c7006a27" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_08d957a9ad6acc2a617c78b2c7006a27&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_08d957a9ad6acc2a617c78b2c7006a27&gt;
{
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-f573a41b9e98cd4ee069e4973e98b68f"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-f573a41b9e98cd4ee069e4973e98b68f" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_f573a41b9e98cd4ee069e4973e98b68f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_f573a41b9e98cd4ee069e4973e98b68f&gt;
{
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-d6b6139d70fba103d9d2b339bc9a873d"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-d6b6139d70fba103d9d2b339bc9a873d" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_d6b6139d70fba103d9d2b339bc9a873d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_d6b6139d70fba103d9d2b339bc9a873d&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-31cc49485365e4cecf19f8c37745a88c"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-31cc49485365e4cecf19f8c37745a88c" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_31cc49485365e4cecf19f8c37745a88c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_31cc49485365e4cecf19f8c37745a88c&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-2717da237319f56673aefabc43f5988f"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-2717da237319f56673aefabc43f5988f" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_2717da237319f56673aefabc43f5988f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_2717da237319f56673aefabc43f5988f&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-a9ea8696386cc38422bcf7ab14da9f61"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-a9ea8696386cc38422bcf7ab14da9f61" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_a9ea8696386cc38422bcf7ab14da9f61&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_a9ea8696386cc38422bcf7ab14da9f61&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-0c070f5882fccf42a617af8c6cc6824f"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-0c070f5882fccf42a617af8c6cc6824f" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_0c070f5882fccf42a617af8c6cc6824f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_0c070f5882fccf42a617af8c6cc6824f&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-c87477bbaede8a4ef55647bf35f15454"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-c87477bbaede8a4ef55647bf35f15454" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_c87477bbaede8a4ef55647bf35f15454&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_c87477bbaede8a4ef55647bf35f15454&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-154b61a8f083037a562b2655f5c2ff49"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-154b61a8f083037a562b2655f5c2ff49" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_154b61a8f083037a562b2655f5c2ff49&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_154b61a8f083037a562b2655f5c2ff49&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-35366de2a5c80746f384d8d3bcd22eb3"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-35366de2a5c80746f384d8d3bcd22eb3" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_35366de2a5c80746f384d8d3bcd22eb3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_35366de2a5c80746f384d8d3bcd22eb3&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-17ad5a79aa343f5dce2b65f11f20b09e"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-17ad5a79aa343f5dce2b65f11f20b09e" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_17ad5a79aa343f5dce2b65f11f20b09e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_17ad5a79aa343f5dce2b65f11f20b09e&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-1561890049b9c19bce48e342bb64d848"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-1561890049b9c19bce48e342bb64d848" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_1561890049b9c19bce48e342bb64d848&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_1561890049b9c19bce48e342bb64d848&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-84839fa596fdc0a020032dadd2dfccdc"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-84839fa596fdc0a020032dadd2dfccdc" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_84839fa596fdc0a020032dadd2dfccdc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_84839fa596fdc0a020032dadd2dfccdc&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-ed9c1f11b18958b9124ff8f646b644bf"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-ed9c1f11b18958b9124ff8f646b644bf" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_ed9c1f11b18958b9124ff8f646b644bf&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_ed9c1f11b18958b9124ff8f646b644bf&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-74917e8ca45a859c11ea6baf308534e1"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-74917e8ca45a859c11ea6baf308534e1" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_74917e8ca45a859c11ea6baf308534e1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_74917e8ca45a859c11ea6baf308534e1&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-110ba341efe7a36bf690d008e154cd42"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-110ba341efe7a36bf690d008e154cd42" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_110ba341efe7a36bf690d008e154cd42&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_110ba341efe7a36bf690d008e154cd42&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-a54df26685fd3d92bcf8cf5d336bfce0"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-a54df26685fd3d92bcf8cf5d336bfce0" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_a54df26685fd3d92bcf8cf5d336bfce0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_a54df26685fd3d92bcf8cf5d336bfce0&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-4361ee77f97cf2f3819f2344137b6d72"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-4361ee77f97cf2f3819f2344137b6d72" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_4361ee77f97cf2f3819f2344137b6d72&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_4361ee77f97cf2f3819f2344137b6d72&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-663ca88f039158acd12a83b67fcfa190"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-663ca88f039158acd12a83b67fcfa190" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_663ca88f039158acd12a83b67fcfa190&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_663ca88f039158acd12a83b67fcfa190&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-7dc9daea7a69aed8fe448ea2e1c1c846"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-7dc9daea7a69aed8fe448ea2e1c1c846" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_7dc9daea7a69aed8fe448ea2e1c1c846&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_7dc9daea7a69aed8fe448ea2e1c1c846&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-82294aac5ff483bfdadd8812d9ac7a44"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-82294aac5ff483bfdadd8812d9ac7a44" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_82294aac5ff483bfdadd8812d9ac7a44&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_82294aac5ff483bfdadd8812d9ac7a44&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-831d0183d5475c36268ccfd320b15f7d"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-831d0183d5475c36268ccfd320b15f7d" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_831d0183d5475c36268ccfd320b15f7d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_831d0183d5475c36268ccfd320b15f7d&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-831d0183d5475c36268ccfd320b15f7d-l5-lambda-29fcba485d3c7186b0a5a769cf9477fb"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-831d0183d5475c36268ccfd320b15f7d-l5-lambda-29fcba485d3c7186b0a5a769cf9477fb" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_831d0183d5475c36268ccfd320b15f7d&gt;::()::__l5::&lt;lambda_29fcba485d3c7186b0a5a769cf9477fb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_831d0183d5475c36268ccfd320b15f7d&gt;::()::__l5::&lt;lambda_29fcba485d3c7186b0a5a769cf9477fb&gt;
{
  std::string *newName;
};

</code></pre></div><h3 id="structureeditorscreencontroller-registereventhandlers-l2-lambda-62cd34819bb144d4a718458e1ec8cfc2"><a href="#structureeditorscreencontroller-registereventhandlers-l2-lambda-62cd34819bb144d4a718458e1ec8cfc2" class="header-anchor">#</a> <code>StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_62cd34819bb144d4a718458e1ec8cfc2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_registerEventHandlers::__l2::&lt;lambda_62cd34819bb144d4a718458e1ec8cfc2&gt;
{
};

</code></pre></div><h3 id="structureeditorscreencontroller-tick-l14-lambda-71f3c6f4f3703f5826dd865b72addcde"><a href="#structureeditorscreencontroller-tick-l14-lambda-71f3c6f4f3703f5826dd865b72addcde" class="header-anchor">#</a> <code>StructureEditorScreenController::tick::__l14::&lt;lambda_71f3c6f4f3703f5826dd865b72addcde&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::tick::__l14::&lt;lambda_71f3c6f4f3703f5826dd865b72addcde&gt;
{
  std::weak_ptr&lt;StructureEditorScreenController&gt; weakThis;
};

</code></pre></div><h3 id="structureeditorscreencontroller-initiateexport-l12-lambda-44cf8e96a5035585dedb484d2d92f642"><a href="#structureeditorscreencontroller-initiateexport-l12-lambda-44cf8e96a5035585dedb484d2d92f642" class="header-anchor">#</a> <code>StructureEditorScreenController::_initiateExport::__l12::&lt;lambda_44cf8e96a5035585dedb484d2d92f642&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_initiateExport::__l12::&lt;lambda_44cf8e96a5035585dedb484d2d92f642&gt;
{
  std::weak_ptr&lt;StructureEditorScreenController&gt; weakThis;
};

</code></pre></div><h3 id="structureeditorscreencontroller-initiateexport-l12-lambda-92d4ec9a1a9afd13498a146cc0a80f05"><a href="#structureeditorscreencontroller-initiateexport-l12-lambda-92d4ec9a1a9afd13498a146cc0a80f05" class="header-anchor">#</a> <code>StructureEditorScreenController::_initiateExport::__l12::&lt;lambda_92d4ec9a1a9afd13498a146cc0a80f05&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_initiateExport::__l12::&lt;lambda_92d4ec9a1a9afd13498a146cc0a80f05&gt;
{
  std::weak_ptr&lt;StructureEditorScreenController&gt; weakThis;
};

</code></pre></div><h3 id="structureeditorscreencontroller-initiateexport-l12-lambda-1e8c3d51b9a59a1d6cf180d991a96183"><a href="#structureeditorscreencontroller-initiateexport-l12-lambda-1e8c3d51b9a59a1d6cf180d991a96183" class="header-anchor">#</a> <code>StructureEditorScreenController::_initiateExport::__l12::&lt;lambda_1e8c3d51b9a59a1d6cf180d991a96183&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) StructureEditorScreenController::_initiateExport::__l12::&lt;lambda_1e8c3d51b9a59a1d6cf180d991a96183&gt;
{
  std::weak_ptr&lt;StructureEditorScreenController&gt; weakThis;
  StructureTemplateRequestOperation exportOperation;
};

</code></pre></div><h3 id="structureeditorscreencontroller-filepickerforexport-l2-lambda-d0f4e1b97c2b6a4e9a8533aae17f00fe"><a href="#structureeditorscreencontroller-filepickerforexport-l2-lambda-d0f4e1b97c2b6a4e9a8533aae17f00fe" class="header-anchor">#</a> <code>StructureEditorScreenController::_filePickerForExport::__l2::&lt;lambda_d0f4e1b97c2b6a4e9a8533aae17f00fe&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_filePickerForExport::__l2::&lt;lambda_d0f4e1b97c2b6a4e9a8533aae17f00fe&gt;
{
  StructureEditorScreenController *const __this;
};

</code></pre></div><h3 id="structureeditorscreencontroller-filepickerforexport-l2-lambda-3822bb2053a55165f069b4f692424baa"><a href="#structureeditorscreencontroller-filepickerforexport-l2-lambda-3822bb2053a55165f069b4f692424baa" class="header-anchor">#</a> <code>StructureEditorScreenController::_filePickerForExport::__l2::&lt;lambda_3822bb2053a55165f069b4f692424baa&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj StructureEditorScreenController::_filePickerForExport::__l2::&lt;lambda_3822bb2053a55165f069b4f692424baa&gt;
{
  StructureEditorScreenController *const __this;
  std::shared_ptr&lt;FilePickerSettings&gt; pickerSettings;
  const std::string *structureName;
};

</code></pre></div><h3 id="scenecreationutils-bindingamescreencreator-l2-lambda-e2b51608baa087dc2b80d24071bb6844"><a href="#scenecreationutils-bindingamescreencreator-l2-lambda-e2b51608baa087dc2b80d24071bb6844" class="header-anchor">#</a> <code>SceneCreationUtils::bindInGameScreenCreator::__l2::&lt;lambda_e2b51608baa087dc2b80d24071bb6844&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SceneCreationUtils::bindInGameScreenCreator::__l2::&lt;lambda_e2b51608baa087dc2b80d24071bb6844&gt;
{
  bool &lt;args_0&gt;;
  bool &lt;args_1&gt;;
  CraftingType &lt;args_2&gt;;
};

</code></pre></div><h3 id="scenecreationutils-bindingamescreencreator-l2-lambda-60392c5ae36866dfcce58558d05abe86"><a href="#scenecreationutils-bindingamescreencreator-l2-lambda-60392c5ae36866dfcce58558d05abe86" class="header-anchor">#</a> <code>SceneCreationUtils::bindInGameScreenCreator::__l2::&lt;lambda_60392c5ae36866dfcce58558d05abe86&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SceneCreationUtils::bindInGameScreenCreator::__l2::&lt;lambda_60392c5ae36866dfcce58558d05abe86&gt;
{
  BlockActorType &lt;args_0&gt;;
};

</code></pre></div><h3 id="scenecreationutils-bindingamescreencreator-l2-lambda-28407d547321730e910a933db892eab3"><a href="#scenecreationutils-bindingamescreencreator-l2-lambda-28407d547321730e910a933db892eab3" class="header-anchor">#</a> <code>SceneCreationUtils::bindInGameScreenCreator::__l2::&lt;lambda_28407d547321730e910a933db892eab3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SceneCreationUtils::bindInGameScreenCreator::__l2::&lt;lambda_28407d547321730e910a933db892eab3&gt;
{
};

</code></pre></div><h3 id="scenecreationutils-bindingamescreencreator-l2-lambda-2c4014e86efd85151d693d483b1c8ae0"><a href="#scenecreationutils-bindingamescreencreator-l2-lambda-2c4014e86efd85151d693d483b1c8ae0" class="header-anchor">#</a> <code>SceneCreationUtils::bindInGameScreenCreator::__l2::&lt;lambda_2c4014e86efd85151d693d483b1c8ae0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SceneCreationUtils::bindInGameScreenCreator::__l2::&lt;lambda_2c4014e86efd85151d693d483b1c8ae0&gt;
{
};

</code></pre></div><h3 id="scenecreationutils-bindingamescreencreator-l2-lambda-eaf6a1a7616fd7652cdcba455066ac17"><a href="#scenecreationutils-bindingamescreencreator-l2-lambda-eaf6a1a7616fd7652cdcba455066ac17" class="header-anchor">#</a> <code>SceneCreationUtils::bindInGameScreenCreator::__l2::&lt;lambda_eaf6a1a7616fd7652cdcba455066ac17&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SceneCreationUtils::bindInGameScreenCreator::__l2::&lt;lambda_eaf6a1a7616fd7652cdcba455066ac17&gt;
{
};

</code></pre></div><h3 id="scenecreationutils-bindingamescreencreator-l2-lambda-d1df447776e9d6c8d664da3462859960"><a href="#scenecreationutils-bindingamescreencreator-l2-lambda-d1df447776e9d6c8d664da3462859960" class="header-anchor">#</a> <code>SceneCreationUtils::bindInGameScreenCreator::__l2::&lt;lambda_d1df447776e9d6c8d664da3462859960&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SceneCreationUtils::bindInGameScreenCreator::__l2::&lt;lambda_d1df447776e9d6c8d664da3462859960&gt;
{
};

</code></pre></div><h3 id="scenecreationutils-bindingamescreencreator-l2-lambda-880e2e0794a164a9c4be0a8cba10e48a"><a href="#scenecreationutils-bindingamescreencreator-l2-lambda-880e2e0794a164a9c4be0a8cba10e48a" class="header-anchor">#</a> <code>SceneCreationUtils::bindInGameScreenCreator::__l2::&lt;lambda_880e2e0794a164a9c4be0a8cba10e48a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SceneCreationUtils::bindInGameScreenCreator::__l2::&lt;lambda_880e2e0794a164a9c4be0a8cba10e48a&gt;
{
};

</code></pre></div><h3 id="scenecreationutils-bindingamescreencreator-l2-lambda-e4706ef1a8ad552e10b7fe744a56b9e3"><a href="#scenecreationutils-bindingamescreencreator-l2-lambda-e4706ef1a8ad552e10b7fe744a56b9e3" class="header-anchor">#</a> <code>SceneCreationUtils::bindInGameScreenCreator::__l2::&lt;lambda_e4706ef1a8ad552e10b7fe744a56b9e3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj SceneCreationUtils::bindInGameScreenCreator::__l2::&lt;lambda_e4706ef1a8ad552e10b7fe744a56b9e3&gt;
{
};

</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      
      <a href="/mcstructure/1.16.201/structure/S~2.html" class="prev">
        S~2
      </a></span> <span class="next"><a href="/mcstructure/1.16.201/structure/S~4.html">
        S~4
      </a>
      
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/mcstructure/assets/js/app.56b0ab36.js" defer></script><script src="/mcstructure/assets/js/2.56e23786.js" defer></script><script src="/mcstructure/assets/js/139.5e9afeaa.js" defer></script>
  </body>
</html>
