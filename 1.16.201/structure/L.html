<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>L | MC TIL</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Some structure and enum information for minecraft bedrock edition.">
    
    <link rel="preload" href="/mcstructure/assets/css/0.styles.5de0a167.css" as="style"><link rel="preload" href="/mcstructure/assets/js/app.56b0ab36.js" as="script"><link rel="preload" href="/mcstructure/assets/js/2.56e23786.js" as="script"><link rel="preload" href="/mcstructure/assets/js/119.0b88b1c0.js" as="script"><link rel="prefetch" href="/mcstructure/assets/js/10.dda8da32.js"><link rel="prefetch" href="/mcstructure/assets/js/100.d193fca3.js"><link rel="prefetch" href="/mcstructure/assets/js/101.324df8d1.js"><link rel="prefetch" href="/mcstructure/assets/js/102.81d32953.js"><link rel="prefetch" href="/mcstructure/assets/js/103.bafffe55.js"><link rel="prefetch" href="/mcstructure/assets/js/104.4a4116d4.js"><link rel="prefetch" href="/mcstructure/assets/js/105.ee5ab7c3.js"><link rel="prefetch" href="/mcstructure/assets/js/106.16520c01.js"><link rel="prefetch" href="/mcstructure/assets/js/107.e4e2fef9.js"><link rel="prefetch" href="/mcstructure/assets/js/108.9771cecd.js"><link rel="prefetch" href="/mcstructure/assets/js/109.07a059f8.js"><link rel="prefetch" href="/mcstructure/assets/js/11.84aff5f4.js"><link rel="prefetch" href="/mcstructure/assets/js/110.79e73184.js"><link rel="prefetch" href="/mcstructure/assets/js/111.735fe11b.js"><link rel="prefetch" href="/mcstructure/assets/js/112.5b8c9633.js"><link rel="prefetch" href="/mcstructure/assets/js/113.a961fd7d.js"><link rel="prefetch" href="/mcstructure/assets/js/114.f46e6ac6.js"><link rel="prefetch" href="/mcstructure/assets/js/115.29d129b9.js"><link rel="prefetch" href="/mcstructure/assets/js/116.0761604d.js"><link rel="prefetch" href="/mcstructure/assets/js/117.8fa51bbe.js"><link rel="prefetch" href="/mcstructure/assets/js/118.65b68c09.js"><link rel="prefetch" href="/mcstructure/assets/js/12.fb0b2343.js"><link rel="prefetch" href="/mcstructure/assets/js/120.6514cc60.js"><link rel="prefetch" href="/mcstructure/assets/js/121.30792057.js"><link rel="prefetch" href="/mcstructure/assets/js/122.ac6c9052.js"><link rel="prefetch" href="/mcstructure/assets/js/123.9dde14ff.js"><link rel="prefetch" href="/mcstructure/assets/js/124.1b8cd48f.js"><link rel="prefetch" href="/mcstructure/assets/js/125.ba14f223.js"><link rel="prefetch" href="/mcstructure/assets/js/126.5dd69ba6.js"><link rel="prefetch" href="/mcstructure/assets/js/127.32df8d72.js"><link rel="prefetch" href="/mcstructure/assets/js/128.aa9a14cc.js"><link rel="prefetch" href="/mcstructure/assets/js/129.d7a703a5.js"><link rel="prefetch" href="/mcstructure/assets/js/13.b8437649.js"><link rel="prefetch" href="/mcstructure/assets/js/130.d8f7ecf5.js"><link rel="prefetch" href="/mcstructure/assets/js/131.0c1d33fe.js"><link rel="prefetch" href="/mcstructure/assets/js/132.8b6e6ff3.js"><link rel="prefetch" href="/mcstructure/assets/js/133.f999118d.js"><link rel="prefetch" href="/mcstructure/assets/js/134.bc4a2893.js"><link rel="prefetch" href="/mcstructure/assets/js/135.e6e793b3.js"><link rel="prefetch" href="/mcstructure/assets/js/136.c50dcaff.js"><link rel="prefetch" href="/mcstructure/assets/js/137.209d5c8a.js"><link rel="prefetch" href="/mcstructure/assets/js/138.3eed47db.js"><link rel="prefetch" href="/mcstructure/assets/js/139.5e9afeaa.js"><link rel="prefetch" href="/mcstructure/assets/js/14.c94aa248.js"><link rel="prefetch" href="/mcstructure/assets/js/140.ac85c96f.js"><link rel="prefetch" href="/mcstructure/assets/js/141.82f0f06f.js"><link rel="prefetch" href="/mcstructure/assets/js/142.08052153.js"><link rel="prefetch" href="/mcstructure/assets/js/143.97d16176.js"><link rel="prefetch" href="/mcstructure/assets/js/144.66c74f2b.js"><link rel="prefetch" href="/mcstructure/assets/js/145.58e96ed1.js"><link rel="prefetch" href="/mcstructure/assets/js/146.4c73b3b4.js"><link rel="prefetch" href="/mcstructure/assets/js/147.0e0e09a7.js"><link rel="prefetch" href="/mcstructure/assets/js/148.a8c2c253.js"><link rel="prefetch" href="/mcstructure/assets/js/149.99f1b4f1.js"><link rel="prefetch" href="/mcstructure/assets/js/15.fd6df6e3.js"><link rel="prefetch" href="/mcstructure/assets/js/16.855c8adf.js"><link rel="prefetch" href="/mcstructure/assets/js/17.860009b0.js"><link rel="prefetch" href="/mcstructure/assets/js/18.63105a6b.js"><link rel="prefetch" href="/mcstructure/assets/js/19.fbddb16b.js"><link rel="prefetch" href="/mcstructure/assets/js/20.605578ab.js"><link rel="prefetch" href="/mcstructure/assets/js/21.1e5adf90.js"><link rel="prefetch" href="/mcstructure/assets/js/22.29bfa69a.js"><link rel="prefetch" href="/mcstructure/assets/js/23.566201a2.js"><link rel="prefetch" href="/mcstructure/assets/js/24.d912e845.js"><link rel="prefetch" href="/mcstructure/assets/js/25.8885d257.js"><link rel="prefetch" href="/mcstructure/assets/js/26.8409713f.js"><link rel="prefetch" href="/mcstructure/assets/js/27.49cb5267.js"><link rel="prefetch" href="/mcstructure/assets/js/28.2a890355.js"><link rel="prefetch" href="/mcstructure/assets/js/29.6ea7598b.js"><link rel="prefetch" href="/mcstructure/assets/js/3.50967458.js"><link rel="prefetch" href="/mcstructure/assets/js/30.1a3c3902.js"><link rel="prefetch" href="/mcstructure/assets/js/31.24ec9e8b.js"><link rel="prefetch" href="/mcstructure/assets/js/32.40831503.js"><link rel="prefetch" href="/mcstructure/assets/js/33.6602f7d9.js"><link rel="prefetch" href="/mcstructure/assets/js/34.75d333d9.js"><link rel="prefetch" href="/mcstructure/assets/js/35.84bf3e5a.js"><link rel="prefetch" href="/mcstructure/assets/js/36.fe4e7307.js"><link rel="prefetch" href="/mcstructure/assets/js/37.b2ee95ad.js"><link rel="prefetch" href="/mcstructure/assets/js/38.c03d5dee.js"><link rel="prefetch" href="/mcstructure/assets/js/39.a60df6e0.js"><link rel="prefetch" href="/mcstructure/assets/js/4.f5835878.js"><link rel="prefetch" href="/mcstructure/assets/js/40.6322a006.js"><link rel="prefetch" href="/mcstructure/assets/js/41.420acfde.js"><link rel="prefetch" href="/mcstructure/assets/js/42.a4ef9cfe.js"><link rel="prefetch" href="/mcstructure/assets/js/43.660cc3cf.js"><link rel="prefetch" href="/mcstructure/assets/js/44.683fc1e0.js"><link rel="prefetch" href="/mcstructure/assets/js/45.f27a9ad0.js"><link rel="prefetch" href="/mcstructure/assets/js/46.9f9edd2c.js"><link rel="prefetch" href="/mcstructure/assets/js/47.fd3ae547.js"><link rel="prefetch" href="/mcstructure/assets/js/48.375f8f97.js"><link rel="prefetch" href="/mcstructure/assets/js/49.e0d0f024.js"><link rel="prefetch" href="/mcstructure/assets/js/5.e0bd9261.js"><link rel="prefetch" href="/mcstructure/assets/js/50.aa126f14.js"><link rel="prefetch" href="/mcstructure/assets/js/51.e939b03e.js"><link rel="prefetch" href="/mcstructure/assets/js/52.a2d46eef.js"><link rel="prefetch" href="/mcstructure/assets/js/53.72de48c3.js"><link rel="prefetch" href="/mcstructure/assets/js/54.54675155.js"><link rel="prefetch" href="/mcstructure/assets/js/55.8b419ad8.js"><link rel="prefetch" href="/mcstructure/assets/js/56.07af8dcf.js"><link rel="prefetch" href="/mcstructure/assets/js/57.0bedaec9.js"><link rel="prefetch" href="/mcstructure/assets/js/58.37c94f2a.js"><link rel="prefetch" href="/mcstructure/assets/js/59.b0866a6a.js"><link rel="prefetch" href="/mcstructure/assets/js/6.04e2a2d2.js"><link rel="prefetch" href="/mcstructure/assets/js/60.5c5afc8c.js"><link rel="prefetch" href="/mcstructure/assets/js/61.ea56e4d6.js"><link rel="prefetch" href="/mcstructure/assets/js/62.3cb13464.js"><link rel="prefetch" href="/mcstructure/assets/js/63.83c0082d.js"><link rel="prefetch" href="/mcstructure/assets/js/64.2cd02c8b.js"><link rel="prefetch" href="/mcstructure/assets/js/65.c16cc8f2.js"><link rel="prefetch" href="/mcstructure/assets/js/66.ad2d4521.js"><link rel="prefetch" href="/mcstructure/assets/js/67.83e59ab1.js"><link rel="prefetch" href="/mcstructure/assets/js/68.beec9ddd.js"><link rel="prefetch" href="/mcstructure/assets/js/69.b4bc257c.js"><link rel="prefetch" href="/mcstructure/assets/js/7.fd995bdf.js"><link rel="prefetch" href="/mcstructure/assets/js/70.1ea3abef.js"><link rel="prefetch" href="/mcstructure/assets/js/71.3cf65839.js"><link rel="prefetch" href="/mcstructure/assets/js/72.6f64c4ab.js"><link rel="prefetch" href="/mcstructure/assets/js/73.452d7013.js"><link rel="prefetch" href="/mcstructure/assets/js/74.0660e6d9.js"><link rel="prefetch" href="/mcstructure/assets/js/75.b7b5e783.js"><link rel="prefetch" href="/mcstructure/assets/js/76.5fddaea1.js"><link rel="prefetch" href="/mcstructure/assets/js/77.be26bbc6.js"><link rel="prefetch" href="/mcstructure/assets/js/78.0e00fef4.js"><link rel="prefetch" href="/mcstructure/assets/js/79.731c37fb.js"><link rel="prefetch" href="/mcstructure/assets/js/8.1cbf1ff3.js"><link rel="prefetch" href="/mcstructure/assets/js/80.2282d655.js"><link rel="prefetch" href="/mcstructure/assets/js/81.33a53399.js"><link rel="prefetch" href="/mcstructure/assets/js/82.196f3fc3.js"><link rel="prefetch" href="/mcstructure/assets/js/83.e9cb3f05.js"><link rel="prefetch" href="/mcstructure/assets/js/84.35c05041.js"><link rel="prefetch" href="/mcstructure/assets/js/85.16e996b6.js"><link rel="prefetch" href="/mcstructure/assets/js/86.97412bd5.js"><link rel="prefetch" href="/mcstructure/assets/js/87.2244cc28.js"><link rel="prefetch" href="/mcstructure/assets/js/88.f00d5fcc.js"><link rel="prefetch" href="/mcstructure/assets/js/89.13359307.js"><link rel="prefetch" href="/mcstructure/assets/js/9.86a5a003.js"><link rel="prefetch" href="/mcstructure/assets/js/90.3b4668a2.js"><link rel="prefetch" href="/mcstructure/assets/js/91.85f8c578.js"><link rel="prefetch" href="/mcstructure/assets/js/92.c7bfeb53.js"><link rel="prefetch" href="/mcstructure/assets/js/93.87278538.js"><link rel="prefetch" href="/mcstructure/assets/js/94.9636adb8.js"><link rel="prefetch" href="/mcstructure/assets/js/95.49a2df5b.js"><link rel="prefetch" href="/mcstructure/assets/js/96.f84087c6.js"><link rel="prefetch" href="/mcstructure/assets/js/97.777e52ef.js"><link rel="prefetch" href="/mcstructure/assets/js/98.95f637bf.js"><link rel="prefetch" href="/mcstructure/assets/js/99.535a1eab.js">
    <link rel="stylesheet" href="/mcstructure/assets/css/0.styles.5de0a167.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/mcstructure/" class="home-link router-link-active"><!----> <span class="site-name">MC TIL</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/mcstructure/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/Redbeanw44602/mcstructure" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/mcstructure/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/Redbeanw44602/mcstructure" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Struct</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/mcstructure/1.16.201/structure/A.html" class="sidebar-link">A</a></li><li><a href="/mcstructure/1.16.201/structure/A~1.html" class="sidebar-link">A~1</a></li><li><a href="/mcstructure/1.16.201/structure/B.html" class="sidebar-link">B</a></li><li><a href="/mcstructure/1.16.201/structure/B~1.html" class="sidebar-link">B~1</a></li><li><a href="/mcstructure/1.16.201/structure/B~2.html" class="sidebar-link">B~2</a></li><li><a href="/mcstructure/1.16.201/structure/C.html" class="sidebar-link">C</a></li><li><a href="/mcstructure/1.16.201/structure/C~1.html" class="sidebar-link">C~1</a></li><li><a href="/mcstructure/1.16.201/structure/C~2.html" class="sidebar-link">C~2</a></li><li><a href="/mcstructure/1.16.201/structure/C~3.html" class="sidebar-link">C~3</a></li><li><a href="/mcstructure/1.16.201/structure/D.html" class="sidebar-link">D</a></li><li><a href="/mcstructure/1.16.201/structure/D~1.html" class="sidebar-link">D~1</a></li><li><a href="/mcstructure/1.16.201/structure/D~2.html" class="sidebar-link">D~2</a></li><li><a href="/mcstructure/1.16.201/structure/D~3.html" class="sidebar-link">D~3</a></li><li><a href="/mcstructure/1.16.201/structure/D~4.html" class="sidebar-link">D~4</a></li><li><a href="/mcstructure/1.16.201/structure/D~5.html" class="sidebar-link">D~5</a></li><li><a href="/mcstructure/1.16.201/structure/D~6.html" class="sidebar-link">D~6</a></li><li><a href="/mcstructure/1.16.201/structure/D~7.html" class="sidebar-link">D~7</a></li><li><a href="/mcstructure/1.16.201/structure/D~8.html" class="sidebar-link">D~8</a></li><li><a href="/mcstructure/1.16.201/structure/D~9.html" class="sidebar-link">D~9</a></li><li><a href="/mcstructure/1.16.201/structure/D~10.html" class="sidebar-link">D~10</a></li><li><a href="/mcstructure/1.16.201/structure/E.html" class="sidebar-link">E</a></li><li><a href="/mcstructure/1.16.201/structure/E~1.html" class="sidebar-link">E~1</a></li><li><a href="/mcstructure/1.16.201/structure/F.html" class="sidebar-link">F</a></li><li><a href="/mcstructure/1.16.201/structure/F~1.html" class="sidebar-link">F~1</a></li><li><a href="/mcstructure/1.16.201/structure/G.html" class="sidebar-link">G</a></li><li><a href="/mcstructure/1.16.201/structure/H.html" class="sidebar-link">H</a></li><li><a href="/mcstructure/1.16.201/structure/I.html" class="sidebar-link">I</a></li><li><a href="/mcstructure/1.16.201/structure/I~1.html" class="sidebar-link">I~1</a></li><li><a href="/mcstructure/1.16.201/structure/I~2.html" class="sidebar-link">I~2</a></li><li><a href="/mcstructure/1.16.201/structure/J.html" class="sidebar-link">J</a></li><li><a href="/mcstructure/1.16.201/structure/K.html" class="sidebar-link">K</a></li><li><a href="/mcstructure/1.16.201/structure/L.html" aria-current="page" class="active sidebar-link">L</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/mcstructure/1.16.201/structure/L~1.html" class="sidebar-link">L~1</a></li><li><a href="/mcstructure/1.16.201/structure/M.html" class="sidebar-link">M</a></li><li><a href="/mcstructure/1.16.201/structure/M~1.html" class="sidebar-link">M~1</a></li><li><a href="/mcstructure/1.16.201/structure/M~2.html" class="sidebar-link">M~2</a></li><li><a href="/mcstructure/1.16.201/structure/M~3.html" class="sidebar-link">M~3</a></li><li><a href="/mcstructure/1.16.201/structure/N.html" class="sidebar-link">N</a></li><li><a href="/mcstructure/1.16.201/structure/O.html" class="sidebar-link">O</a></li><li><a href="/mcstructure/1.16.201/structure/P.html" class="sidebar-link">P</a></li><li><a href="/mcstructure/1.16.201/structure/P~1.html" class="sidebar-link">P~1</a></li><li><a href="/mcstructure/1.16.201/structure/P~2.html" class="sidebar-link">P~2</a></li><li><a href="/mcstructure/1.16.201/structure/P~3.html" class="sidebar-link">P~3</a></li><li><a href="/mcstructure/1.16.201/structure/Q.html" class="sidebar-link">Q</a></li><li><a href="/mcstructure/1.16.201/structure/R.html" class="sidebar-link">R</a></li><li><a href="/mcstructure/1.16.201/structure/R~1.html" class="sidebar-link">R~1</a></li><li><a href="/mcstructure/1.16.201/structure/R~2.html" class="sidebar-link">R~2</a></li><li><a href="/mcstructure/1.16.201/structure/R~3.html" class="sidebar-link">R~3</a></li><li><a href="/mcstructure/1.16.201/structure/S.html" class="sidebar-link">S</a></li><li><a href="/mcstructure/1.16.201/structure/S~1.html" class="sidebar-link">S~1</a></li><li><a href="/mcstructure/1.16.201/structure/S~2.html" class="sidebar-link">S~2</a></li><li><a href="/mcstructure/1.16.201/structure/S~3.html" class="sidebar-link">S~3</a></li><li><a href="/mcstructure/1.16.201/structure/S~4.html" class="sidebar-link">S~4</a></li><li><a href="/mcstructure/1.16.201/structure/T.html" class="sidebar-link">T</a></li><li><a href="/mcstructure/1.16.201/structure/T~1.html" class="sidebar-link">T~1</a></li><li><a href="/mcstructure/1.16.201/structure/U.html" class="sidebar-link">U</a></li><li><a href="/mcstructure/1.16.201/structure/V.html" class="sidebar-link">V</a></li><li><a href="/mcstructure/1.16.201/structure/W.html" class="sidebar-link">W</a></li><li><a href="/mcstructure/1.16.201/structure/W~1.html" class="sidebar-link">W~1</a></li><li><a href="/mcstructure/1.16.201/structure/X.html" class="sidebar-link">X</a></li><li><a href="/mcstructure/1.16.201/structure/Z.html" class="sidebar-link">Z</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Enums</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="l"><a href="#l" class="header-anchor">#</a> L</h1> <h3 id="legacyworldinfo"><a href="#legacyworldinfo" class="header-anchor">#</a> <code>LegacyWorldInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(568) <code>LocalWorldInfo</code></td> <td>baseclass_0</td></tr> <tr><td>568</td> <td>(32) <code>std::string</code></td> <td>mIdentifier</td></tr> <tr><td>600</td> <td>(1) <code>bool</code></td> <td>mIsBetaRetailSave</td></tr></tbody></table> <h3 id="localworldinfo"><a href="#localworldinfo" class="header-anchor">#</a> <code>LocalWorldInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>WorldInfo</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(32) <code>std::string</code></td> <td>mScreenshotTexture</td></tr> <tr><td>40</td> <td>(8) <code>unsigned __int64</code></td> <td>mFileSize</td></tr> <tr><td>48</td> <td>(32) <code>std::string</code></td> <td>mFilesizeAsString</td></tr> <tr><td>80</td> <td>(32) <code>std::string</code></td> <td>mWorldName</td></tr> <tr><td>112</td> <td>(32) <code>std::string</code></td> <td>mDate</td></tr> <tr><td>144</td> <td>(32) <code>std::string</code></td> <td>mGameType</td></tr> <tr><td>176</td> <td>(1) <code>bool</code></td> <td>mLocalStorage</td></tr> <tr><td>177</td> <td>(1) <code>bool</code></td> <td>mCloudStorage</td></tr> <tr><td>178</td> <td>(1) <code>bool</code></td> <td>mIsDirty</td></tr> <tr><td>179</td> <td>(1) <code>bool</code></td> <td>mIsBetaRetailSave</td></tr> <tr><td>184</td> <td>(384) <code>LevelSummary</code></td> <td>mLevelSummary</td></tr></tbody></table> <h3 id="levelsummary"><a href="#levelsummary" class="header-anchor">#</a> <code>LevelSummary</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>mId</td></tr> <tr><td>32</td> <td>(32) <code>std::string</code></td> <td>mName</td></tr> <tr><td>64</td> <td>(8) <code>__int64</code></td> <td>mLastPlayed</td></tr> <tr><td>72</td> <td>(4) <code>GameType</code></td> <td>mGameType</td></tr> <tr><td>76</td> <td>(4) <code>Difficulty</code></td> <td>mGameDifficulty</td></tr> <tr><td>80</td> <td>(4) <code>int</code></td> <td>mSeed</td></tr> <tr><td>84</td> <td>(4) <code>int</code></td> <td>mNetworkProtocolVersion</td></tr> <tr><td>88</td> <td>(8) <code>unsigned __int64</code></td> <td>mSizeOnDisk</td></tr> <tr><td>96</td> <td>(1) <code>bool</code></td> <td>mConfirmedPlatformLockedContent</td></tr> <tr><td>97</td> <td>(1) <code>bool</code></td> <td>mLANBroadcastIntent</td></tr> <tr><td>100</td> <td>(4) <code>Social::GamePublishSetting</code></td> <td>mXBLBroadcastIntent</td></tr> <tr><td>104</td> <td>(1) <code>bool</code></td> <td>mCommandsEnabled</td></tr> <tr><td>108</td> <td>(4) <code>EducationEditionOfferValue</code></td> <td>mEducationEditionOffer</td></tr> <tr><td>112</td> <td>(56) <code>GameVersion</code></td> <td>mLastLoadedGameVersion</td></tr> <tr><td>168</td> <td>(56) <code>GameVersion</code></td> <td>mMinCompatibleClientVersion</td></tr> <tr><td>224</td> <td>(4) <code>_BYTE[4]</code></td> <td>mStorageVersion</td></tr> <tr><td>232</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>mWorldIconPath</td></tr> <tr><td>264</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>mWorldIconTargetPath</td></tr> <tr><td>296</td> <td>(24) <code>ContentIdentity</code></td> <td>mPremiumTemplateContentIdentity</td></tr> <tr><td>320</td> <td>(32) <code>std::string</code></td> <td>mEducationOid</td></tr> <tr><td>352</td> <td>(1) <code>bool</code></td> <td>mIsSingleUseWorld</td></tr> <tr><td>353</td> <td>(1) <code>bool</code></td> <td>mIsBetaRetailLevel</td></tr> <tr><td>360</td> <td>(24) <code>ContentIdentity</code></td> <td>?</td></tr></tbody></table> <h3 id="layoutrule-addstackpanelvisibilityterm-l2-lambda-41e73def6e306693a2d0395c1cfcc6a2"><a href="#layoutrule-addstackpanelvisibilityterm-l2-lambda-41e73def6e306693a2d0395c1cfcc6a2" class="header-anchor">#</a> <code>LayoutRule::addStackPanelVisibilityTerm::__l2::&lt;lambda_41e73def6e306693a2d0395c1cfcc6a2&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="layoutmanager-update-l2-lambda-582f447c20f51f382c4eb7054a5dd98a"><a href="#layoutmanager-update-l2-lambda-582f447c20f51f382c4eb7054a5dd98a" class="header-anchor">#</a> <code>LayoutManager::_update::__l2::&lt;lambda_582f447c20f51f382c4eb7054a5dd98a&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="levelbuilder-preparerenderchunkrenderlist-l2-lambda-68215dddadd9af939d720f1d070375e1"><a href="#levelbuilder-preparerenderchunkrenderlist-l2-lambda-68215dddadd9af939d720f1d070375e1" class="header-anchor">#</a> <code>LevelBuilder::_prepareRenderChunkRenderList::__l2::&lt;lambda_68215dddadd9af939d720f1d070375e1&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="levelbuilder-buildrenderchunks-l2-lambda-a08ac9d83425319e6a6e10392713a815-l2-lambda-e21558297a2641a2000dbf4a718e58a4"><a href="#levelbuilder-buildrenderchunks-l2-lambda-a08ac9d83425319e6a6e10392713a815-l2-lambda-e21558297a2641a2000dbf4a718e58a4" class="header-anchor">#</a> <code>LevelBuilder::_buildRenderChunks::__l2::&lt;lambda_a08ac9d83425319e6a6e10392713a815&gt;::()::__l2::&lt;lambda_e21558297a2641a2000dbf4a718e58a4&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="lockless-weakatomic-spscqueue-gamecontrollerhandler-windows-inputstate-windows-512-block"><a href="#lockless-weakatomic-spscqueue-gamecontrollerhandler-windows-inputstate-windows-512-block" class="header-anchor">#</a> <code>Lockless::WeakAtomic&lt;SPSCQueue&lt;GameControllerHandler_Windows::InputState_Windows,512&gt;::Block *&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::atomic&lt;SPSCQueue&lt;GameControllerHandler_Windows::InputState_Windows,512&gt;::Block *&gt;</code></td> <td>mValue</td></tr></tbody></table> <h3 id="listtag"><a href="#listtag" class="header-anchor">#</a> <code>ListTag</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Tag</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(24) <code>std::vector&lt;std::unique_ptr&lt;Tag&gt;&gt;</code></td> <td>mList</td></tr> <tr><td>32</td> <td>(1) <code>_BYTE[1]</code></td> <td>mType</td></tr></tbody></table> <h3 id="levelchunk-fixupcorruptedblockactors-l2-lambda-484ffdbe9c80c92eec14bddff882ab4a"><a href="#levelchunk-fixupcorruptedblockactors-l2-lambda-484ffdbe9c80c92eec14bddff882ab4a" class="header-anchor">#</a> <code>LevelChunk::_fixupCorruptedBlockActors::__l2::&lt;lambda_484ffdbe9c80c92eec14bddff882ab4a&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="level-comparelevelchunkqueuedsavingelement"><a href="#level-comparelevelchunkqueuedsavingelement" class="header-anchor">#</a> <code>Level::CompareLevelChunkQueuedSavingElement</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="layerfilters-backcompatsorter"><a href="#layerfilters-backcompatsorter" class="header-anchor">#</a> <code>LayerFilters::BackCompatSorter</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="layerresult-enum-biometemperaturecategory"><a href="#layerresult-enum-biometemperaturecategory" class="header-anchor">#</a> <code>LayerResult&lt;enum BiomeTemperatureCategory&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::unique_ptr&lt;char [0]&gt;</code></td> <td>mResult</td></tr></tbody></table> <h3 id="loginstatemachine"><a href="#loginstatemachine" class="header-anchor">#</a> <code>LoginStateMachine</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>LoginStateMachine_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(16) <code>std::shared_ptr&lt;BaseStage&gt;</code></td> <td>mCurrent</td></tr> <tr><td>24</td> <td>(64) <code>std::function&lt;void __cdecl(void)&gt;</code></td> <td>mSuccCallback</td></tr> <tr><td>88</td> <td>(64) <code>std::function&lt;void __cdecl(enum eLoginStage,int,std::string,std::string)&gt;</code></td> <td>mFailCallback</td></tr> <tr><td>152</td> <td>(4) <code>eLoginStage</code></td> <td>mLoginStage</td></tr> <tr><td>160</td> <td>(24) <code>std::vector&lt;std::string&gt;</code></td> <td>mDnsIpArray</td></tr> <tr><td>184</td> <td>(4) <code>int</code></td> <td>mDnsTxtTTL</td></tr> <tr><td>188</td> <td>(4) <code>unsigned int</code></td> <td>mDnsValidTime</td></tr> <tr><td>192</td> <td>(16) <code>std::map&lt;std::string,std::pair&lt;std::vector&lt;std::string&gt;,unsigned int&gt;&gt;</code></td> <td>mDomainCacheMap</td></tr> <tr><td>208</td> <td>(80) <code>std::mutex</code></td> <td>mResMutex</td></tr> <tr><td>288</td> <td>(1) <code>bool</code></td> <td>mDirtyDNS</td></tr> <tr><td>289</td> <td>(1) <code>bool</code></td> <td>misLoginEnable</td></tr> <tr><td>290</td> <td>(1) <code>bool</code></td> <td>misLoginSuccess</td></tr> <tr><td>296</td> <td>(32) <code>std::string</code></td> <td>mNickName</td></tr> <tr><td>328</td> <td>(1) <code>bool</code></td> <td>mIsOfflineStart</td></tr> <tr><td>329</td> <td>(1) <code>bool</code></td> <td>misOfflineStartEnable</td></tr> <tr><td>336</td> <td>(16) <code>Json::Value</code></td> <td>mUpdatePatchInfo</td></tr> <tr><td>352</td> <td>(1) <code>bool</code></td> <td>?</td></tr> <tr><td>353</td> <td>(1) <code>bool</code></td> <td>mRnInstalled</td></tr> <tr><td>354</td> <td>(1) <code>bool</code></td> <td>mLogoHided</td></tr> <tr><td>355</td> <td>(1) <code>bool</code></td> <td>mIsRnInited</td></tr> <tr><td>356</td> <td>(1) <code>bool</code></td> <td>mIsCheckedPatch</td></tr> <tr><td>357</td> <td>(1) <code>bool</code></td> <td>mNeedCheckUpdate</td></tr> <tr><td>358</td> <td>(1) <code>bool</code></td> <td>mCheckUpdateFromOffline</td></tr> <tr><td>360</td> <td>(32) <code>std::string</code></td> <td>mWebServerUrl</td></tr> <tr><td>392</td> <td>(32) <code>std::string</code></td> <td>mCoreServerUrl</td></tr> <tr><td>424</td> <td>(32) <code>std::string</code></td> <td>mWebServerGrayUrl</td></tr> <tr><td>456</td> <td>(32) <code>std::string</code></td> <td>mTransServerUrl</td></tr> <tr><td>488</td> <td>(32) <code>std::string</code></td> <td>mCdnServerUrl</td></tr> <tr><td>520</td> <td>(32) <code>std::string</code></td> <td>mChatServerUrl</td></tr> <tr><td>552</td> <td>(32) <code>std::string</code></td> <td>mAuthServerUrl</td></tr> <tr><td>584</td> <td>(32) <code>std::string</code></td> <td>mApiGatewayUrl</td></tr> <tr><td>616</td> <td>(32) <code>std::string</code></td> <td>mH5ResVersionUrl</td></tr> <tr><td>648</td> <td>(32) <code>std::string</code></td> <td>mH5ResServerUrl</td></tr> <tr><td>680</td> <td>(32) <code>std::string</code></td> <td>mTranSrvInfoJson</td></tr> <tr><td>712</td> <td>(32) <code>std::string</code></td> <td>mChatServerJson</td></tr> <tr><td>744</td> <td>(32) <code>std::string</code></td> <td>mSensitiveWordJson</td></tr> <tr><td>776</td> <td>(32) <code>std::string</code></td> <td>mDebugUserName</td></tr> <tr><td>808</td> <td>(32) <code>std::string</code></td> <td>mDebugPassword</td></tr> <tr><td>840</td> <td>(32) <code>std::string</code></td> <td>mMomentUrl</td></tr> <tr><td>872</td> <td>(32) <code>std::string</code></td> <td>mFirstLogin</td></tr> <tr><td>904</td> <td>(4) <code>int</code></td> <td>mSelectServerIndex</td></tr> <tr><td>912</td> <td>(32) <code>std::string</code></td> <td>mServerListUrl</td></tr> <tr><td>944</td> <td>(32) <code>std::string</code></td> <td>mTestUpdateFlag</td></tr> <tr><td>976</td> <td>(24) <code>std::vector&lt;std::string&gt;</code></td> <td>mServerListArray</td></tr> <tr><td>1000</td> <td>(32) <code>std::string</code></td> <td>mServerListName</td></tr> <tr><td>1032</td> <td>(32) <code>std::string</code></td> <td>mJf_gas_url</td></tr> <tr><td>1064</td> <td>(32) <code>std::string</code></td> <td>mAuthenSeed</td></tr> <tr><td>1096</td> <td>(32) <code>std::string</code></td> <td>mAuthenKey</td></tr> <tr><td>1128</td> <td>(32) <code>std::string</code></td> <td>mAuthenValue1</td></tr> <tr><td>1160</td> <td>(32) <code>std::string</code></td> <td>mAuthenValue2</td></tr> <tr><td>1192</td> <td>(32) <code>std::string</code></td> <td>mAuthenValue3</td></tr> <tr><td>1224</td> <td>(32) <code>std::string</code></td> <td>mAuthenSign</td></tr> <tr><td>1256</td> <td>(32) <code>std::string</code></td> <td>mAuthenTimeStamp</td></tr> <tr><td>1288</td> <td>(1) <code>bool</code></td> <td>mServerStop</td></tr> <tr><td>1289</td> <td>(1) <code>bool</code></td> <td>mUpdateStop</td></tr> <tr><td>1290</td> <td>(1) <code>bool</code></td> <td>mUseHttpDNS</td></tr> <tr><td>1291</td> <td>(1) <code>bool</code></td> <td>?</td></tr> <tr><td>1292</td> <td>(1) <code>bool</code></td> <td>mIsPatchUpdated</td></tr> <tr><td>1296</td> <td>(4) <code>int</code></td> <td>mPatchUpdateStatus</td></tr> <tr><td>1304</td> <td>(8) <code>__int64</code></td> <td>mPatchStartTimeStamp</td></tr> <tr><td>1312</td> <td>(8) <code>__int64</code></td> <td>mPatchSuccTimeStamp</td></tr> <tr><td>1320</td> <td>(8) <code>__int64</code></td> <td>mPatchFailTimeStamp</td></tr></tbody></table> <h3 id="lockless-weakatomic-spscqueue-unsigned-int-512-block"><a href="#lockless-weakatomic-spscqueue-unsigned-int-512-block" class="header-anchor">#</a> <code>Lockless::WeakAtomic&lt;SPSCQueue&lt;unsigned int,512&gt;::Block *&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::atomic&lt;SPSCQueue&lt;unsigned int,512&gt;::Block *&gt;</code></td> <td>mValue</td></tr></tbody></table> <h3 id="layerresult-float"><a href="#layerresult-float" class="header-anchor">#</a> <code>LayerResult&lt;float&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::unique_ptr&lt;char [0]&gt;</code></td> <td>mResult</td></tr></tbody></table> <h3 id="layervalues-prebiome"><a href="#layervalues-prebiome" class="header-anchor">#</a> <code>LayerValues::PreBiome</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>LayerValues::Terrain</code></td> <td>mTerrain</td></tr> <tr><td>1</td> <td>(1) <code>_BYTE[1]</code></td> <td>mTemperature</td></tr></tbody></table> <h3 id="layerresult-bool"><a href="#layerresult-bool" class="header-anchor">#</a> <code>LayerResult&lt;bool&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::unique_ptr&lt;char [0]&gt;</code></td> <td>mResult</td></tr></tbody></table> <h3 id="loopingsoundstate"><a href="#loopingsoundstate" class="header-anchor">#</a> <code>LoopingSoundState</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>glm::tvec3&lt;float,0&gt;</code></td> <td>position</td></tr> <tr><td>12</td> <td>(4) <code>float</code></td> <td>pitch</td></tr> <tr><td>16</td> <td>(4) <code>float</code></td> <td>volume</td></tr></tbody></table> <h3 id="label"><a href="#label" class="header-anchor">#</a> <code>label</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>lb_type</td></tr> <tr><td>8</td> <td>(8) <code>char *</code></td> <td>lb_str</td></tr></tbody></table> <h3 id="legacyskinserialization"><a href="#legacyskinserialization" class="header-anchor">#</a> <code>LegacySkinSerialization</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(112) <code>SkinHandle</code></td> <td>mSkinHandle</td></tr> <tr><td>112</td> <td>(4) <code>persona::ProfileType</code></td> <td>mLastUsedSlot</td></tr> <tr><td>116</td> <td>(1) <code>bool</code></td> <td>mBeingDeleted</td></tr></tbody></table> <h3 id="labellist"><a href="#labellist" class="header-anchor">#</a> <code>labellist</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>ll_nlabels</td></tr> <tr><td>8</td> <td>(8) <code>label *</code></td> <td>ll_label</td></tr></tbody></table> <h3 id="lexicon-struct"><a href="#lexicon-struct" class="header-anchor">#</a> <code>lexicon_struct</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>char *</code></td> <td>name</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>num_entries</td></tr> <tr><td>16</td> <td>(8) <code>unsigned __int8 *</code></td> <td>data</td></tr> <tr><td>24</td> <td>(4) <code>int</code></td> <td>num_bytes</td></tr> <tr><td>32</td> <td>(8) <code>char **</code></td> <td>phone_table</td></tr> <tr><td>40</td> <td>(8) <code>cst_lts_rules_struct *</code></td> <td>lts_rule_set</td></tr> <tr><td>48</td> <td>(8) <code>int (__fastcall *)(const cst_item_struct *, const cst_val_struct *)</code></td> <td>syl_boundary</td></tr> <tr><td>56</td> <td>(8) <code>cst_val_struct *(__fastcall *)(const lexicon_struct *, const char *, const char *, const cst_features_struct *)</code></td> <td>lts_function</td></tr> <tr><td>64</td> <td>(8) <code>char ***</code></td> <td>addenda</td></tr> <tr><td>72</td> <td>(8) <code>const char *const *</code></td> <td>phone_hufftable</td></tr> <tr><td>80</td> <td>(8) <code>const char *const *</code></td> <td>entry_hufftable</td></tr> <tr><td>88</td> <td>(8) <code>cst_utterance_struct *(__fastcall *)(cst_utterance_struct *)</code></td> <td>postlex</td></tr> <tr><td>96</td> <td>(8) <code>cst_val_struct *</code></td> <td>lex_addenda</td></tr></tbody></table> <h3 id="leveldb-logger"><a href="#leveldb-logger" class="header-anchor">#</a> <code>leveldb::Logger</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>leveldb::Logger_vtbl *</code></td> <td>__vftable</td></tr></tbody></table> <h3 id="localconnectivitysystem"><a href="#localconnectivitysystem" class="header-anchor">#</a> <code>LocalConnectivitySystem</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>LocalConnector *</code></td> <td>mHostConnector</td></tr></tbody></table> <h3 id="localization"><a href="#localization" class="header-anchor">#</a> <code>Localization</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>mCommaSeperator</td></tr> <tr><td>8</td> <td>(32) <code>const std::string</code></td> <td>mCode</td></tr> <tr><td>40</td> <td>(16) <code>std::map&lt;std::string,std::string&gt;</code></td> <td>mStrings</td></tr> <tr><td>56</td> <td>(16) <code>std::shared_ptr&lt;std::mutex&gt;</code></td> <td>m_lock</td></tr></tbody></table> <h3 id="legacyoptionsconverterinternal-conversionrule"><a href="#legacyoptionsconverterinternal-conversionrule" class="header-anchor">#</a> <code>LegacyOptionsConverterInternal::ConversionRule</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>LegacyOption</code></td> <td>mSourceOption</td></tr> <tr><td>4</td> <td>(4) <code>OptionID</code></td> <td>mTargetOption</td></tr> <tr><td>8</td> <td>(64) <code>std::function&lt;bool __cdecl(enum LegacyOption,enum OptionID,LegacyOptionsParser const &amp;,Options &amp;)&gt;</code></td> <td>mConversionRecipe</td></tr></tbody></table> <h3 id="lodestonecompasscomponent"><a href="#lodestonecompasscomponent" class="header-anchor">#</a> <code>LodestoneCompassComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>PositionTrackingId</code></td> <td>mTrackingHandle</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::variant&lt;ActorUniqueID,std::pair&lt;BlockPos,AutomaticID&lt;Dimension,int&gt; &gt; &gt;,std::unique_ptr&lt;LodestoneCompassComponentCalculator&gt;,std::hash&lt;std::variant&lt;ActorUniqueID,std::pair&lt;BlockPos,AutomaticID&lt;Dimension,int&gt; &gt; &gt; &gt;,std::equal_to&lt;std::variant&lt;ActorUniqueID,std::pair&lt;BlockPos,AutomaticID&lt;Dimension,int&gt; &gt; &gt; &gt;,std::allocator&lt;std::pair&lt;std::variant&lt;ActorUniqueID,std::pair&lt;BlockPos,AutomaticID&lt;Dimension,int&gt; &gt; &gt; const ,std::unique_ptr&lt;LodestoneCompassComponentCalculator&gt; &gt; &gt; &gt;</code></td> <td>mCalculators</td></tr></tbody></table> <h3 id="levelsoundeventpacket"><a href="#levelsoundeventpacket" class="header-anchor">#</a> <code>LevelSoundEventPacket</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(40) <code>Packet</code></td> <td>baseclass_0</td></tr> <tr><td>40</td> <td>(4) <code>LevelSoundEvent</code></td> <td>mEventId</td></tr> <tr><td>44</td> <td>(12) <code>Vec3</code></td> <td>mPos</td></tr> <tr><td>56</td> <td>(4) <code>int</code></td> <td>mData</td></tr> <tr><td>64</td> <td>(32) <code>std::string</code></td> <td>mEntityIdentifier</td></tr> <tr><td>96</td> <td>(1) <code>bool</code></td> <td>mIsBabyMob</td></tr> <tr><td>97</td> <td>(1) <code>bool</code></td> <td>mIsGlobal</td></tr></tbody></table> <h3 id="levelloader-importlevel-l2-lambda-ef1a8fc506d0b5dfc78e5f6835e03656"><a href="#levelloader-importlevel-l2-lambda-ef1a8fc506d0b5dfc78e5f6835e03656" class="header-anchor">#</a> <code>LevelLoader::_importLevel::__l2::&lt;lambda_ef1a8fc506d0b5dfc78e5f6835e03656&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>LevelLoader *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(40) <code>const ImportLevelData</code></td> <td>levelData</td></tr></tbody></table> <h3 id="levelsettings"><a href="#levelsettings" class="header-anchor">#</a> <code>LevelSettings</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>mSeed</td></tr> <tr><td>4</td> <td>(4) <code>GameType</code></td> <td>mGameType</td></tr> <tr><td>8</td> <td>(4) <code>Difficulty</code></td> <td>mGameDifficulty</td></tr> <tr><td>12</td> <td>(1) <code>bool</code></td> <td>mForceGameType</td></tr> <tr><td>16</td> <td>(4) <code>GeneratorType</code></td> <td>mGenerator</td></tr> <tr><td>20</td> <td>(1) <code>_BYTE[1]</code></td> <td>mNetherType</td></tr> <tr><td>24</td> <td>(48) <code>SpawnSettings</code></td> <td>mSpawnSettings</td></tr> <tr><td>72</td> <td>(1) <code>bool</code></td> <td>mAchievementsDisabled</td></tr> <tr><td>76</td> <td>(4) <code>int</code></td> <td>mTime</td></tr> <tr><td>80</td> <td>(4) <code>EducationEditionOfferValue</code></td> <td>mEducationEditionOffer</td></tr> <tr><td>84</td> <td>(1) <code>bool</code></td> <td>mEducationFeaturesEnabled</td></tr> <tr><td>85</td> <td>(1) <code>bool</code></td> <td>mImmutableWorld</td></tr> <tr><td>88</td> <td>(4) <code>float</code></td> <td>mRainLevel</td></tr> <tr><td>92</td> <td>(4) <code>float</code></td> <td>mLightningLevel</td></tr> <tr><td>96</td> <td>(1) <code>bool</code></td> <td>mConfirmedPlatformLockedContent</td></tr> <tr><td>97</td> <td>(1) <code>bool</code></td> <td>mMultiplayerGameIntent</td></tr> <tr><td>98</td> <td>(1) <code>bool</code></td> <td>mLANBroadcastIntent</td></tr> <tr><td>100</td> <td>(4) <code>Social::GamePublishSetting</code></td> <td>mXBLBroadcastIntent</td></tr> <tr><td>104</td> <td>(4) <code>Social::GamePublishSetting</code></td> <td>mPlatformBroadcastIntent</td></tr> <tr><td>108</td> <td>(1) <code>bool</code></td> <td>mCommandsEnabled</td></tr> <tr><td>109</td> <td>(1) <code>bool</code></td> <td>mTexturePacksRequired</td></tr> <tr><td>110</td> <td>(1) <code>bool</code></td> <td>mHasLockedBehaviorPack</td></tr> <tr><td>111</td> <td>(1) <code>bool</code></td> <td>mHasLockedResourcePack</td></tr> <tr><td>112</td> <td>(1) <code>bool</code></td> <td>mIsFromLockedTemplate</td></tr> <tr><td>113</td> <td>(1) <code>bool</code></td> <td>mUseMsaGamertagsOnly</td></tr> <tr><td>114</td> <td>(1) <code>bool</code></td> <td>mOverrideSettings</td></tr> <tr><td>115</td> <td>(1) <code>bool</code></td> <td>mBonusChestEnabled</td></tr> <tr><td>116</td> <td>(1) <code>bool</code></td> <td>mStartWithMapEnabled</td></tr> <tr><td>120</td> <td>(4) <code>int</code></td> <td>mServerChunkTickRange</td></tr> <tr><td>124</td> <td>(1) <code>bool</code></td> <td>mIsFromWorldTemplate</td></tr> <tr><td>125</td> <td>(1) <code>bool</code></td> <td>mIsWorldTemplateOptionLocked</td></tr> <tr><td>126</td> <td>(1) <code>bool</code></td> <td>mSpawnV1Villagers</td></tr> <tr><td>128</td> <td>(4) <code>int</code></td> <td>mLimitedWorldWidth</td></tr> <tr><td>132</td> <td>(4) <code>int</code></td> <td>mLimitedWorldDepth</td></tr> <tr><td>136</td> <td>(4) <code>int</code></td> <td>mTempPlayerDimensionIdToCreate</td></tr> <tr><td>144</td> <td>(2712) <code>Abilities</code></td> <td>mDefaultAbilities</td></tr> <tr><td>2856</td> <td>(12) <code>BlockPos</code></td> <td>mDefaultSpawn</td></tr> <tr><td>2872</td> <td>(24) <code>std::vector&lt;PackInstanceId&gt;</code></td> <td>mNewWorldBehaviorPackIdentities</td></tr> <tr><td>2896</td> <td>(24) <code>std::vector&lt;PackInstanceId&gt;</code></td> <td>mNewWorldResourcePackIdentities</td></tr> <tr><td>2920</td> <td>(24) <code>GameRules</code></td> <td>mGameRules</td></tr> <tr><td>2944</td> <td>(40) <code>ExperimentStorage</code></td> <td>mExperiments</td></tr> <tr><td>2984</td> <td>(112) <code>BaseGameVersion</code></td> <td>mBaseGameVersion</td></tr> <tr><td>3096</td> <td>(32) <code>std::string</code></td> <td>mEducationProductID</td></tr> <tr><td>3128</td> <td>(32) <code>std::string</code></td> <td>mBiomeOverride</td></tr> <tr><td>3160</td> <td>(192) <code>std::optional&lt;EducationLevelSettings&gt;</code></td> <td>mEducationLevelSettings</td></tr> <tr><td>3352</td> <td>(2) <code>std::optional&lt;bool&gt;</code></td> <td>mOverrideForceExperimentalGameplayFlag</td></tr></tbody></table> <h3 id="lessoninfo"><a href="#lessoninfo" class="header-anchor">#</a> <code>LessonInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>courseId</td></tr> <tr><td>32</td> <td>(32) <code>std::string</code></td> <td>lessonId</td></tr></tbody></table> <h3 id="leveldata"><a href="#leveldata" class="header-anchor">#</a> <code>LevelData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(5) <code>AdventureSettings</code></td> <td>mAdventureSettings</td></tr> <tr><td>8</td> <td>(280) <code>WorldTemplateLevelData</code></td> <td>mWorldTemplateLevelData</td></tr> <tr><td>288</td> <td>(24) <code>GameRules</code></td> <td>mGameRules</td></tr> <tr><td>312</td> <td>(40) <code>ExperimentStorage</code></td> <td>mExperiments</td></tr> <tr><td>352</td> <td>(2712) <code>Abilities</code></td> <td>mDefaultAbilities</td></tr> <tr><td>3064</td> <td>(32) <code>std::string</code></td> <td>mLevelName</td></tr> <tr><td>3096</td> <td>(4) <code>_BYTE[4]</code></td> <td>mStorageVersion</td></tr> <tr><td>3104</td> <td>(56) <code>GameVersion</code></td> <td>mMinCompatibleClientVersion</td></tr> <tr><td>3160</td> <td>(4) <code>int</code></td> <td>mNetworkVersion</td></tr> <tr><td>3168</td> <td>(112) <code>SemVersion</code></td> <td>mInventoryVersion</td></tr> <tr><td>3280</td> <td>(8) <code>Tick</code></td> <td>mCurrentTick</td></tr> <tr><td>3288</td> <td>(1) <code>bool</code></td> <td>mHasSpawnPos</td></tr> <tr><td>3292</td> <td>(12) <code>BlockPos</code></td> <td>mLimitedWorldOrigin</td></tr> <tr><td>3304</td> <td>(4) <code>int</code></td> <td>mTime</td></tr> <tr><td>3312</td> <td>(8) <code>__int64</code></td> <td>mLastPlayed</td></tr> <tr><td>3320</td> <td>(4) <code>unsigned int</code></td> <td>mServerTickRange</td></tr> <tr><td>3324</td> <td>(4) <code>float</code></td> <td>mRainLevel</td></tr> <tr><td>3328</td> <td>(4) <code>int</code></td> <td>mRainTime</td></tr> <tr><td>3332</td> <td>(4) <code>float</code></td> <td>mLightningLevel</td></tr> <tr><td>3336</td> <td>(4) <code>int</code></td> <td>mLightningTime</td></tr> <tr><td>3340</td> <td>(4) <code>int</code></td> <td>mNetherScale</td></tr> <tr><td>3344</td> <td>(56) <code>GameVersion</code></td> <td>mLastOpenedWithVersion</td></tr> <tr><td>3400</td> <td>(4) <code>Difficulty</code></td> <td>mGameDifficulty</td></tr> <tr><td>3404</td> <td>(1) <code>bool</code></td> <td>mForceGameType</td></tr> <tr><td>3405</td> <td>(1) <code>bool</code></td> <td>mSpawnMobs</td></tr> <tr><td>3408</td> <td>(16) <code>Json::Value</code></td> <td>mFlatworldGeneratorOptions</td></tr> <tr><td>3424</td> <td>(4) <code>unsigned int</code></td> <td>mWorldStartCount</td></tr> <tr><td>3428</td> <td>(1) <code>bool</code></td> <td>mAchievementsDisabled</td></tr> <tr><td>3432</td> <td>(4) <code>EducationEditionOfferValue</code></td> <td>mEducationEditionOffer</td></tr> <tr><td>3436</td> <td>(1) <code>bool</code></td> <td>mEducationFeaturesEnabled</td></tr> <tr><td>3437</td> <td>(1) <code>bool</code></td> <td>mIsSingleUseWorld</td></tr> <tr><td>3438</td> <td>(1) <code>bool</code></td> <td>mConfirmedPlatformLockedContent</td></tr> <tr><td>3439</td> <td>(1) <code>bool</code></td> <td>mMultiplayerGameIntent</td></tr> <tr><td>3440</td> <td>(1) <code>bool</code></td> <td>mMultiplayerGame</td></tr> <tr><td>3441</td> <td>(1) <code>bool</code></td> <td>mLANBroadcastIntent</td></tr> <tr><td>3442</td> <td>(1) <code>bool</code></td> <td>mLANBroadcast</td></tr> <tr><td>3444</td> <td>(4) <code>Social::GamePublishSetting</code></td> <td>mXBLBroadcastIntent</td></tr> <tr><td>3448</td> <td>(4) <code>Social::GamePublishSetting</code></td> <td>mXBLBroadcastMode</td></tr> <tr><td>3452</td> <td>(4) <code>Social::GamePublishSetting</code></td> <td>mPlatformBroadcastIntent</td></tr> <tr><td>3456</td> <td>(4) <code>Social::GamePublishSetting</code></td> <td>mPlatformBroadcastMode</td></tr> <tr><td>3460</td> <td>(1) <code>bool</code></td> <td>mCommandsEnabled</td></tr> <tr><td>3461</td> <td>(1) <code>bool</code></td> <td>mTexturePacksRequired</td></tr> <tr><td>3462</td> <td>(1) <code>bool</code></td> <td>mHasLockedBehaviorPack</td></tr> <tr><td>3463</td> <td>(1) <code>bool</code></td> <td>mHasLockedResourcePack</td></tr> <tr><td>3464</td> <td>(1) <code>bool</code></td> <td>mIsFromLockedTemplate</td></tr> <tr><td>3472</td> <td>(32) <code>std::string</code></td> <td>mEducationProductId</td></tr> <tr><td>3504</td> <td>(1) <code>bool</code></td> <td>mUseMsaGamertagsOnly</td></tr> <tr><td>3505</td> <td>(1) <code>bool</code></td> <td>mBonusChestEnabled</td></tr> <tr><td>3506</td> <td>(1) <code>bool</code></td> <td>mBonusChestSpawned</td></tr> <tr><td>3507</td> <td>(1) <code>bool</code></td> <td>mStartWithMapEnabled</td></tr> <tr><td>3508</td> <td>(1) <code>bool</code></td> <td>mUselimitArea</td></tr> <tr><td>3512</td> <td>(12) <code>Vec3</code></td> <td>mLimitAreaCenter</td></tr> <tr><td>3524</td> <td>(4) <code>int</code></td> <td>mLimitAreaOffsetX</td></tr> <tr><td>3528</td> <td>(4) <code>int</code></td> <td>mLimitAreaOffsetZ</td></tr> <tr><td>3532</td> <td>(1) <code>bool</code></td> <td>mLockDifficulty</td></tr> <tr><td>3533</td> <td>(1) <code>bool</code></td> <td>mDisableItemUse</td></tr> <tr><td>3534</td> <td>(1) <code>bool</code></td> <td>mDisableItemUseOnBlock</td></tr> <tr><td>3536</td> <td>(64) <code>std::unordered_map&lt;int,int&gt;</code></td> <td>mMapDimensionToVersion</td></tr> <tr><td>3600</td> <td>(1) <code>bool</code></td> <td>mMapsCenteredToOrigin</td></tr> <tr><td>3601</td> <td>(1) <code>bool</code></td> <td>mRequiresCopiedPackRemovalCheck</td></tr> <tr><td>3602</td> <td>(1) <code>bool</code></td> <td>mSpawnV1Villagers</td></tr> <tr><td>3603</td> <td>(1) <code>_BYTE[1]</code></td> <td>mNetherType</td></tr> <tr><td>3608</td> <td>(48) <code>SpawnSettings</code></td> <td>mSpawnSettings</td></tr> <tr><td>3656</td> <td>(64) <code>std::unordered_map&lt;HashedString,LevelDataValue&gt;</code></td> <td>mValues</td></tr> <tr><td>3720</td> <td>(64) <code>std::unordered_map&lt;HashedString,LevelDataValue&gt;</code></td> <td>mOverrides</td></tr> <tr><td>3784</td> <td>(32) <code>std::string</code></td> <td>mBiomeOverride</td></tr> <tr><td>3816</td> <td>(24) <code>ContentIdentity</code></td> <td>?</td></tr></tbody></table> <h3 id="large-integer"><a href="#large-integer" class="header-anchor">#</a> <code>LARGE_INTEGER</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>$FAF74743FBE1C8632047CFB668F7028A</code></td> <td>__s0</td></tr> <tr><td>1</td> <td>(8) <code>struct {unsigned int LowPart;int HighPart;}</code></td> <td>u</td></tr> <tr><td>2</td> <td>(8) <code>__int64</code></td> <td>QuadPart</td></tr></tbody></table> <h3 id="lockedstateeventdata"><a href="#lockedstateeventdata" class="header-anchor">#</a> <code>LockedStateEventData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>locked</td></tr></tbody></table> <h3 id="latejoinpregamescreencontroller-checkpremiumaccessandshowupsell-l2-lambda-2760d6c2b2b29a79ae8f23ce45c3a731"><a href="#latejoinpregamescreencontroller-checkpremiumaccessandshowupsell-l2-lambda-2760d6c2b2b29a79ae8f23ce45c3a731" class="header-anchor">#</a> <code>LateJoinPreGameScreenController::_checkPremiumAccessAndShowUpsell::__l2::&lt;lambda_2760d6c2b2b29a79ae8f23ce45c3a731&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::weak_ptr&lt;LateJoinPreGameScreenController&gt;</code></td> <td>weakThis</td></tr> <tr><td>16</td> <td>(64) <code>std::function&lt;void __cdecl(bool)&gt;</code></td> <td>callback</td></tr></tbody></table> <h3 id="leveldb-internalkey"><a href="#leveldb-internalkey" class="header-anchor">#</a> <code>leveldb::InternalKey</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>rep_</td></tr></tbody></table> <h3 id="levelrenderprerenderupdateparameters"><a href="#levelrenderprerenderupdateparameters" class="header-anchor">#</a> <code>LevelRenderPreRenderUpdateParameters</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>FrustumCuller *</code></td> <td>leftCuller</td></tr> <tr><td>8</td> <td>(8) <code>FrustumCuller *</code></td> <td>rightCuller</td></tr> <tr><td>16</td> <td>(12) <code>glm::tvec3&lt;float,0&gt;</code></td> <td>cameraWorldPosition</td></tr> <tr><td>28</td> <td>(12) <code>glm::tvec3&lt;float,0&gt;</code></td> <td>cameraTargetWorldPosition</td></tr> <tr><td>40</td> <td>(12) <code>glm::tvec3&lt;float,0&gt;</code></td> <td>cameraForward</td></tr> <tr><td>52</td> <td>(4) <code>const unsigned int</code></td> <td>viewBlockRadius</td></tr> <tr><td>56</td> <td>(4) <code>const float</code></td> <td>currentTime</td></tr> <tr><td>64</td> <td>(8) <code>BlockSource *</code></td> <td>region</td></tr> <tr><td>72</td> <td>(8) <code>const glm::tvec3&lt;float,0&gt; *</code></td> <td>tickWorldPosition</td></tr> <tr><td>80</td> <td>(1) <code>bool</code></td> <td>stereoRendering</td></tr> <tr><td>84</td> <td>(4) <code>FakeHDRSetting</code></td> <td>enableFakeHDR</td></tr> <tr><td>88</td> <td>(4) <code>float</code></td> <td>skyIntensityOverride</td></tr> <tr><td>92</td> <td>(4) <code>float</code></td> <td>renderDistanceScalar</td></tr> <tr><td>96</td> <td>(1) <code>LevelCullerType</code></td> <td>levelCullerType</td></tr> <tr><td>97</td> <td>(1) <code>FrustumCullerType</code></td> <td>frustumCullerType</td></tr> <tr><td>104</td> <td>(64) <code>std::function&lt;void __cdecl(LevelRenderPreRenderUpdateParameters &amp;)&gt;</code></td> <td>preLevelBuildCallback</td></tr></tbody></table> <h3 id="layoutrule-adddynamicgriditemgridpositionterm-l2-lambda-f55cbd476301545fb1f583c0e70c270e"><a href="#layoutrule-adddynamicgriditemgridpositionterm-l2-lambda-f55cbd476301545fb1f583c0e70c270e" class="header-anchor">#</a> <code>LayoutRule::addDynamicGridItemGridPositionTerm::__l2::&lt;lambda_f55cbd476301545fb1f583c0e70c270e&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::weak_ptr&lt;UIControl&gt;</code></td> <td>weakParent</td></tr> <tr><td>16</td> <td>(4) <code>ui::OrientationType</code></td> <td>rescalingType</td></tr> <tr><td>20</td> <td>(1) <code>LayoutVariableType</code></td> <td>type</td></tr> <tr><td>24</td> <td>(4) <code>int</code></td> <td>collectionIndex</td></tr></tbody></table> <h3 id="layoutrule-addstackpanelitempositionterms-l2-lambda-7d7bffcfcabf3e69cd7e400ef5cc8ea5"><a href="#layoutrule-addstackpanelitempositionterms-l2-lambda-7d7bffcfcabf3e69cd7e400ef5cc8ea5" class="header-anchor">#</a> <code>LayoutRule::addStackPanelItemPositionTerms::__l2::&lt;lambda_7d7bffcfcabf3e69cd7e400ef5cc8ea5&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>UIControl *</code></td> <td>priorSibling</td></tr></tbody></table> <h3 id="layoutrule-addstackpanelvisibilityterm-l2-lambda-65b4f493b8e36199de434873facedc43"><a href="#layoutrule-addstackpanelvisibilityterm-l2-lambda-65b4f493b8e36199de434873facedc43" class="header-anchor">#</a> <code>LayoutRule::addStackPanelVisibilityTerm::__l2::&lt;lambda_65b4f493b8e36199de434873facedc43&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>UIControl *</code></td> <td>control</td></tr> <tr><td>8</td> <td>(1) <code>const LayoutVariableType</code></td> <td>sizeType</td></tr></tbody></table> <h3 id="layoutrule-addstackpanelitemremaindersizeterms-l2-lambda-db9e97e64f0225748868637354f669ba"><a href="#layoutrule-addstackpanelitemremaindersizeterms-l2-lambda-db9e97e64f0225748868637354f669ba" class="header-anchor">#</a> <code>LayoutRule::addStackPanelItemRemainderSizeTerms::__l2::&lt;lambda_db9e97e64f0225748868637354f669ba&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;float __cdecl(void)&gt;</code></td> <td>calcFactorFunction</td></tr></tbody></table> <h3 id="lecternupdatepacket"><a href="#lecternupdatepacket" class="header-anchor">#</a> <code>LecternUpdatePacket</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(40) <code>Packet</code></td> <td>baseclass_0</td></tr> <tr><td>40</td> <td>(4) <code>int</code></td> <td>mPage</td></tr> <tr><td>44</td> <td>(4) <code>int</code></td> <td>mTotalPages</td></tr> <tr><td>48</td> <td>(1) <code>bool</code></td> <td>mShouldDropBook</td></tr> <tr><td>52</td> <td>(12) <code>NetworkBlockPosition</code></td> <td>mPos</td></tr></tbody></table> <h3 id="leveldatavalue"><a href="#leveldatavalue" class="header-anchor">#</a> <code>LevelDataValue</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(40) <code>std::variant&lt;int,bool,float,std::string,enum GeneratorType,enum GameType,BlockPos,unsigned int,LevelDataValue::Tag&gt;</code></td> <td>mValue</td></tr></tbody></table> <h3 id="leveldatavalue-tag"><a href="#leveldatavalue-tag" class="header-anchor">#</a> <code>LevelDataValue::Tag</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::unique_ptr&lt;CompoundTag&gt;</code></td> <td>mTag</td></tr></tbody></table> <h3 id="levellistcache-createbackupcopyofworld-l5-lambda-01ffea937a76700a6f61e699c9c52645"><a href="#levellistcache-createbackupcopyofworld-l5-lambda-01ffea937a76700a6f61e699c9c52645" class="header-anchor">#</a> <code>LevelListCache::createBackupCopyOfWorld::__l5::&lt;lambda_01ffea937a76700a6f61e699c9c52645&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>LevelListCache *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(32) <code>const std::string</code></td> <td>newLevelId</td></tr></tbody></table> <h3 id="libraryitem"><a href="#libraryitem" class="header-anchor">#</a> <code>LibraryItem</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(296) <code>LessonItem</code></td> <td>baseclass_0</td></tr> <tr><td>296</td> <td>(32) <code>std::string</code></td> <td>mSubtitle</td></tr> <tr><td>328</td> <td>(32) <code>std::string</code></td> <td>mDifficulty</td></tr> <tr><td>360</td> <td>(24) <code>std::vector&lt;std::string&gt;</code></td> <td>mSearchKeywords</td></tr> <tr><td>384</td> <td>(4) <code>_BYTE[4]</code></td> <td>mBadgeCategory</td></tr> <tr><td>388</td> <td>(4) <code>_BYTE[4]</code></td> <td>mType</td></tr> <tr><td>392</td> <td>(8) <code>std::optional&lt;int&gt;</code></td> <td>mDuration</td></tr> <tr><td>400</td> <td>(8) <code>std::optional&lt;int&gt;</code></td> <td>mMinAge</td></tr> <tr><td>408</td> <td>(8) <code>std::optional&lt;int&gt;</code></td> <td>mMaxAge</td></tr> <tr><td>416</td> <td>(8) <code>std::optional&lt;float&gt;</code></td> <td>mFileSizeMB</td></tr> <tr><td>424</td> <td>(64) <code>std::unordered_map&lt;enum Library::OptionalProductInfo,std::string&gt;</code></td> <td>mOptionalProductInfo</td></tr> <tr><td>488</td> <td>(64) <code>std::unordered_map&lt;enum Library::OptionalProductLink,std::string&gt;</code></td> <td>mOptionalProductLinks</td></tr> <tr><td>552</td> <td>(64) <code>std::function&lt;void __cdecl(LibraryItem const &amp;)&gt;</code></td> <td>mDestructorCallback</td></tr></tbody></table> <h3 id="lessonitem"><a href="#lessonitem" class="header-anchor">#</a> <code>LessonItem</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>LessonItem_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(16) <code>std::enable_shared_from_this&lt;LessonItem&gt;</code></td> <td>baseclass_8</td></tr> <tr><td>24</td> <td>(32) <code>std::string</code></td> <td>mImageUri</td></tr> <tr><td>56</td> <td>(8) <code>std::unique_ptr&lt;LessonItem::ImageInfo&gt;</code></td> <td>mImageInfo</td></tr> <tr><td>64</td> <td>(32) <code>std::string</code></td> <td>mWorldDownloadUri</td></tr> <tr><td>96</td> <td>(1) <code>bool</code></td> <td>mShouldRefresh</td></tr> <tr><td>104</td> <td>(32) <code>std::string</code></td> <td>mProductId</td></tr> <tr><td>136</td> <td>(32) <code>std::string</code></td> <td>mTitle</td></tr> <tr><td>168</td> <td>(32) <code>std::string</code></td> <td>mDescription</td></tr> <tr><td>200</td> <td>(32) <code>std::string</code></td> <td>mCreator</td></tr> <tr><td>232</td> <td>(40) <code>std::optional&lt;std::string &gt;</code></td> <td>mWorldId</td></tr> <tr><td>272</td> <td>(4) <code>_BYTE[4]</code></td> <td>mImportState</td></tr> <tr><td>276</td> <td>(1) <code>bool</code></td> <td>mHasQuiz</td></tr> <tr><td>280</td> <td>(16) <code>std::weak_ptr&lt;InstructionalContentCollection&gt;</code></td> <td>mCollection</td></tr></tbody></table> <h3 id="lessonitemcache-createitem-l2-lambda-45b6fea0b32e146eac7eb8d3175611d0"><a href="#lessonitemcache-createitem-l2-lambda-45b6fea0b32e146eac7eb8d3175611d0" class="header-anchor">#</a> <code>LessonItemCache::createItem::__l2::&lt;lambda_45b6fea0b32e146eac7eb8d3175611d0&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::weak_ptr&lt;LessonItemCache&gt;</code></td> <td>weakThis</td></tr></tbody></table> <h3 id="librarycollection-refresh-l12-lambda-660a8991daf205c274a409143d346b65"><a href="#librarycollection-refresh-l12-lambda-660a8991daf205c274a409143d346b65" class="header-anchor">#</a> <code>LibraryCollection::refresh::__l12::&lt;lambda_660a8991daf205c274a409143d346b65&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>LibraryCollection *const</code></td> <td>__this</td></tr></tbody></table> <h3 id="legacy-worldimporter-importworld-l2-lambda-ae938f074dd3a375f0777a73fbeb379e"><a href="#legacy-worldimporter-importworld-l2-lambda-ae938f074dd3a375f0777a73fbeb379e" class="header-anchor">#</a> <code>Legacy::WorldImporter::importWorld::__l2::&lt;lambda_ae938f074dd3a375f0777a73fbeb379e&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Legacy::WorldImporter *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(16) <code>std::shared_ptr&lt;Social::User&gt;</code></td> <td>user</td></tr> <tr><td>24</td> <td>(16) <code>std::shared_ptr&lt;Legacy::WorldProcessRequest&gt;</code></td> <td>processRequest</td></tr> <tr><td>40</td> <td>(16) <code>Legacy::WorldImporter::importWorld::__l2::&lt;lambda_366519f82ad483b9658c695262c21046&gt;</code></td> <td>progressCallback</td></tr></tbody></table> <h3 id="legacy-worldimporter-importworld-l2-lambda-366519f82ad483b9658c695262c21046"><a href="#legacy-worldimporter-importworld-l2-lambda-366519f82ad483b9658c695262c21046" class="header-anchor">#</a> <code>Legacy::WorldImporter::importWorld::__l2::&lt;lambda_366519f82ad483b9658c695262c21046&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;CallbackTokenContext&lt;std::function&lt;void __cdecl(enum Legacy::ImportStatus,float,std::shared_ptr&lt;ImportResult&gt;)&gt; &gt; &gt;</code></td> <td>context</td></tr></tbody></table> <h3 id="legacyoptionsconverterinternal-makegenericrecipe-l2-lambda-9f36d3efb04074791ed7f3702039126e"><a href="#legacyoptionsconverterinternal-makegenericrecipe-l2-lambda-9f36d3efb04074791ed7f3702039126e" class="header-anchor">#</a> <code>LegacyOptionsConverterInternal::_makeGenericRecipe::__l2::&lt;lambda_9f36d3efb04074791ed7f3702039126e&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;void __cdecl(Option *,bool)&gt;</code></td> <td>setOption</td></tr></tbody></table> <h3 id="legacyoptionsconverterinternal-makegenericrecipe-l2-lambda-3250100f958fa1f0f26c0275bd843c8d"><a href="#legacyoptionsconverterinternal-makegenericrecipe-l2-lambda-3250100f958fa1f0f26c0275bd843c8d" class="header-anchor">#</a> <code>LegacyOptionsConverterInternal::_makeGenericRecipe::__l2::&lt;lambda_3250100f958fa1f0f26c0275bd843c8d&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;void __cdecl(Option *,unsigned char)&gt;</code></td> <td>setOption</td></tr></tbody></table> <h3 id="legacy-worldimporter-retrieveworldlist-l2-lambda-c472bd97cd77568961a14503f1a05380"><a href="#legacy-worldimporter-retrieveworldlist-l2-lambda-c472bd97cd77568961a14503f1a05380" class="header-anchor">#</a> <code>Legacy::WorldImporter::retrieveWorldList::__l2::&lt;lambda_c472bd97cd77568961a14503f1a05380&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Legacy::WorldImporter *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::function&lt;void __cdecl(enum Legacy::RetrieveStatus)&gt;</code></td> <td>fetchCompleteCB</td></tr></tbody></table> <h3 id="legacy-worldimporter-importworld-l2-lambda-b2029e45b00b21c59d0f455bcac15a46"><a href="#legacy-worldimporter-importworld-l2-lambda-b2029e45b00b21c59d0f455bcac15a46" class="header-anchor">#</a> <code>Legacy::WorldImporter::importWorld::__l2::&lt;lambda_b2029e45b00b21c59d0f455bcac15a46&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Legacy::WorldImporter *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::function&lt;void __cdecl(enum Legacy::ImportStatus,float,std::shared_ptr&lt;ImportResult&gt;)&gt;</code></td> <td>statusCallback</td></tr></tbody></table> <h3 id="legacy-worldconversionreport"><a href="#legacy-worldconversionreport" class="header-anchor">#</a> <code>Legacy::WorldConversionReport</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>Legacy::WorldConverter::ConversionResult</code></td> <td>mResult</td></tr> <tr><td>8</td> <td>(32) <code>std::string</code></td> <td>mWorldName</td></tr> <tr><td>40</td> <td>(8) <code>std::chrono::duration&lt;double,std::ratio&lt;1,1&gt; &gt;</code></td> <td>mConversionDurationSeconds</td></tr> <tr><td>48</td> <td>(8) <code>unsigned __int64</code></td> <td>mChunksConverted</td></tr> <tr><td>56</td> <td>(8) <code>unsigned __int64</code></td> <td>mTotalEstimatedChunks</td></tr> <tr><td>64</td> <td>(4) <code>Legacy::WorldConverter::Type</code></td> <td>mOriginatingPlatform</td></tr> <tr><td>72</td> <td>(32) <code>std::string</code></td> <td>mConverterVersion</td></tr></tbody></table> <h3 id="librarydeeplinklistener-navigatetolink-l2-lambda-d498d340354ce2f453ed38567f54fbc2"><a href="#librarydeeplinklistener-navigatetolink-l2-lambda-d498d340354ce2f453ed38567f54fbc2" class="header-anchor">#</a> <code>LibraryDeeplinkListener::_navigateToLink::__l2::&lt;lambda_d498d340354ce2f453ed38567f54fbc2&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::weak_ptr&lt;bool&gt;</code></td> <td>existenceTracker</td></tr> <tr><td>16</td> <td>(16) <code>std::shared_ptr&lt;AsyncTracker&gt;</code></td> <td>timeoutTracker</td></tr> <tr><td>32</td> <td>(8) <code>const LibraryDeeplinkListener *const</code></td> <td>__this</td></tr> <tr><td>40</td> <td>(16) <code>std::shared_ptr&lt;SearchResult&gt;</code></td> <td>searchResult</td></tr> <tr><td>56</td> <td>(24) <code>std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt;</code></td> <td>eventProperties</td></tr></tbody></table> <h3 id="labtablepacket"><a href="#labtablepacket" class="header-anchor">#</a> <code>LabTablePacket</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(40) <code>Packet</code></td> <td>baseclass_0</td></tr> <tr><td>40</td> <td>(1) <code>LabTablePacket::Type</code></td> <td>mType</td></tr> <tr><td>44</td> <td>(12) <code>BlockPos</code></td> <td>mPos</td></tr> <tr><td>56</td> <td>(1) <code>LabTableReactionType</code></td> <td>mReaction</td></tr></tbody></table> <h3 id="legacyclientnetworkhandler-handle-l2-lambda-fa967f588a1ce712e27d64a182893b8b"><a href="#legacyclientnetworkhandler-handle-l2-lambda-fa967f588a1ce712e27d64a182893b8b" class="header-anchor">#</a> <code>LegacyClientNetworkHandler::handle::__l2::&lt;lambda_fa967f588a1ce712e27d64a182893b8b&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>const BlockEventPacket</code></td> <td>packet</td></tr></tbody></table> <h3 id="legacyclientnetworkhandler-handle-l2-lambda-93d079b43c62f7e1248b34064f45323f"><a href="#legacyclientnetworkhandler-handle-l2-lambda-93d079b43c62f7e1248b34064f45323f" class="header-anchor">#</a> <code>LegacyClientNetworkHandler::handle::__l2::&lt;lambda_93d079b43c62f7e1248b34064f45323f&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>const ContainerOpenPacket</code></td> <td>packet</td></tr> <tr><td>64</td> <td>(8) <code>LocalPlayer *</code></td> <td>player</td></tr> <tr><td>72</td> <td>(8) <code>MultiPlayerLevel *</code></td> <td>level</td></tr></tbody></table> <h3 id="legacyclientnetworkhandler-handle-l5-lambda-89563cba18849588825a7327afbb76f5"><a href="#legacyclientnetworkhandler-handle-l5-lambda-89563cba18849588825a7327afbb76f5" class="header-anchor">#</a> <code>LegacyClientNetworkHandler::handle::__l5::&lt;lambda_89563cba18849588825a7327afbb76f5&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>LegacyClientNetworkHandler *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(16) <code>std::shared_ptr&lt;LevelChunkPacketHandler&gt;</code></td> <td>handler</td></tr> <tr><td>24</td> <td>(152) <code>const NetworkIdentifier</code></td> <td>source</td></tr></tbody></table> <h3 id="legacyclientnetworkhandler-applyplayerskin-l7-lambda-42405ada392c75a6c6b62314c754af1d"><a href="#legacyclientnetworkhandler-applyplayerskin-l7-lambda-42405ada392c75a6c6b62314c754af1d" class="header-anchor">#</a> <code>LegacyClientNetworkHandler::_applyPlayerSkin::__l7::&lt;lambda_42405ada392c75a6c6b62314c754af1d&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::weak_ptr&lt;IClientInstance&gt;</code></td> <td>weakClient</td></tr> <tr><td>16</td> <td>(16) <code>mce::UUID</code></td> <td>uuid</td></tr> <tr><td>32</td> <td>(640) <code>const SerializedSkin</code></td> <td>serializableSkin</td></tr> <tr><td>672</td> <td>(8) <code>LegacyClientNetworkHandler *const</code></td> <td>__this</td></tr> <tr><td>680</td> <td>(16) <code>std::weak_ptr&lt;bool&gt;</code></td> <td>weakExistance</td></tr> <tr><td>696</td> <td>(4) <code>unsigned int</code></td> <td>version</td></tr></tbody></table> <h3 id="levelchunkpackethandler-addreusefromcachestep-l2-lambda-00c643ea340363bdff366ebe864def6e"><a href="#levelchunkpackethandler-addreusefromcachestep-l2-lambda-00c643ea340363bdff366ebe864def6e" class="header-anchor">#</a> <code>LevelChunkPacketHandler::_addReuseFromCacheStep::__l2::&lt;lambda_00c643ea340363bdff366ebe864def6e&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>LevelChunkPacketHandler *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(8) <code>unsigned __int64</code></td> <td>i</td></tr> <tr><td>16</td> <td>(4) <code>float</code></td> <td>abortRequestTime</td></tr> <tr><td>24</td> <td>(64) <code>std::function&lt;void __cdecl(VarIntDataInput &amp;)&gt;</code></td> <td>deserializer</td></tr></tbody></table> <h3 id="linearallocator-viewrenderobject"><a href="#linearallocator-viewrenderobject" class="header-anchor">#</a> <code>LinearAllocator&lt;ViewRenderObject&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;AllocatorData&gt;</code></td> <td>mData</td></tr></tbody></table> <h3 id="levelbuilder-schedulechunkbuild-l19-lambda-72252b7199841403e2a415b3bd023c08"><a href="#levelbuilder-schedulechunkbuild-l19-lambda-72252b7199841403e2a415b3bd023c08" class="header-anchor">#</a> <code>LevelBuilder::scheduleChunkBuild::__l19::&lt;lambda_72252b7199841403e2a415b3bd023c08&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>immediate</td></tr> <tr><td>8</td> <td>(16) <code>std::shared_ptr&lt;RenderChunkInstanced&gt;</code></td> <td>renderChunkInstancedShared</td></tr> <tr><td>24</td> <td>(16) <code>const std::shared_ptr&lt;RenderChunkShared&gt;</code></td> <td>renderChunkShared</td></tr> <tr><td>40</td> <td>(1) <code>bool</code></td> <td>doSort</td></tr> <tr><td>48</td> <td>(8) <code>LevelBuilder *const</code></td> <td>__this</td></tr> <tr><td>56</td> <td>(16) <code>std::shared_ptr&lt;SortTaskContext&gt;</code></td> <td>sortTaskContext</td></tr> <tr><td>72</td> <td>(16) <code>std::shared_ptr&lt;BuildTaskContext&gt;</code></td> <td>buildTaskContext</td></tr> <tr><td>88</td> <td>(16) <code>const std::shared_ptr&lt;RenderChunkGeometry&gt;</code></td> <td>buildingRenderChunkGeometry</td></tr> <tr><td>104</td> <td>(16) <code>const std::shared_ptr&lt;RenderChunkGeometry&gt;</code></td> <td>currentRenderChunkGeometry</td></tr></tbody></table> <h3 id="levelbuilder-schedulechunkbuild-l19-lambda-06fe4843def8ec0a40648f31185946ab"><a href="#levelbuilder-schedulechunkbuild-l19-lambda-06fe4843def8ec0a40648f31185946ab" class="header-anchor">#</a> <code>LevelBuilder::scheduleChunkBuild::__l19::&lt;lambda_06fe4843def8ec0a40648f31185946ab&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;RenderChunkInstanced&gt;</code></td> <td>renderChunkInstancedShared</td></tr> <tr><td>16</td> <td>(16) <code>const std::shared_ptr&lt;RenderChunkShared&gt;</code></td> <td>renderChunkShared</td></tr> <tr><td>32</td> <td>(1) <code>const bool</code></td> <td>transparentLeaves</td></tr> <tr><td>36</td> <td>(4) <code>_BYTE[4]</code></td> <td>lightingType</td></tr> <tr><td>40</td> <td>(1) <code>const bool</code></td> <td>usePBRFormats</td></tr> <tr><td>41</td> <td>(1) <code>const bool</code></td> <td>emitPointLights</td></tr> <tr><td>42</td> <td>(1) <code>bool</code></td> <td>doSort</td></tr> <tr><td>44</td> <td>(12) <code>Vec3</code></td> <td>currentCameraForward</td></tr> <tr><td>56</td> <td>(1) <code>const bool</code></td> <td>cullerIsOrthographic</td></tr> <tr><td>64</td> <td>(16) <code>std::shared_ptr&lt;SortTaskContext&gt;</code></td> <td>sortTaskContext</td></tr> <tr><td>80</td> <td>(16) <code>std::shared_ptr&lt;BuildTaskContext&gt;</code></td> <td>buildTaskContext</td></tr></tbody></table> <h3 id="linearallocator-actorshadowrenderobject"><a href="#linearallocator-actorshadowrenderobject" class="header-anchor">#</a> <code>LinearAllocator&lt;ActorShadowRenderObject&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;AllocatorData&gt;</code></td> <td>mData</td></tr></tbody></table> <h3 id="linearallocator-particletyperenderobject"><a href="#linearallocator-particletyperenderobject" class="header-anchor">#</a> <code>LinearAllocator&lt;ParticleTypeRenderObject&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;AllocatorData&gt;</code></td> <td>mData</td></tr></tbody></table> <h3 id="linearallocator-mce-textureptr"><a href="#linearallocator-mce-textureptr" class="header-anchor">#</a> <code>LinearAllocator&lt;mce::TexturePtr&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;AllocatorData&gt;</code></td> <td>mData</td></tr></tbody></table> <h3 id="linearallocator-crackrenderobject"><a href="#linearallocator-crackrenderobject" class="header-anchor">#</a> <code>LinearAllocator&lt;CrackRenderObject&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;AllocatorData&gt;</code></td> <td>mData</td></tr></tbody></table> <h3 id="linearallocator-nametagrenderobject"><a href="#linearallocator-nametagrenderobject" class="header-anchor">#</a> <code>LinearAllocator&lt;NameTagRenderObject&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;AllocatorData&gt;</code></td> <td>mData</td></tr></tbody></table> <h3 id="levelcullercachedbase-updatechunkdata"><a href="#levelcullercachedbase-updatechunkdata" class="header-anchor">#</a> <code>LevelCullerCachedBase::UpdateChunkData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>SubChunkPos</code></td> <td>mRenderChunkPosition</td></tr> <tr><td>12</td> <td>(1) <code>bool</code></td> <td>mIsSkyLit</td></tr> <tr><td>13</td> <td>(6) <code>VisibilityNode</code></td> <td>mVisibilityNode</td></tr> <tr><td>19</td> <td>(1) <code>bool</code></td> <td>mChunkIsEmpty</td></tr> <tr><td>20</td> <td>(1) <code>bool</code></td> <td>mForceRequery</td></tr></tbody></table> <h3 id="levelrenderercamera-updateperchunkfacesortstate-l10-lambda-d6963569be67244178665fa6230fe26b"><a href="#levelrenderercamera-updateperchunkfacesortstate-l10-lambda-d6963569be67244178665fa6230fe26b" class="header-anchor">#</a> <code>LevelRendererCamera::updatePerChunkFaceSortState::__l10::&lt;lambda_d6963569be67244178665fa6230fe26b&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>LevelRendererCamera *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(12) <code>const Vec3</code></td> <td>viewPos</td></tr> <tr><td>20</td> <td>(12) <code>BlockPos</code></td> <td>blockSortPos</td></tr> <tr><td>32</td> <td>(12) <code>const Vec3</code></td> <td>viewDir</td></tr> <tr><td>44</td> <td>(12) <code>BlockPos</code></td> <td>lastFaceSortPos</td></tr> <tr><td>56</td> <td>(12) <code>Vec3</code></td> <td>lastFaceSortDir</td></tr> <tr><td>68</td> <td>(1) <code>bool</code></td> <td>isOrthoCamera</td></tr> <tr><td>72</td> <td>(16) <code>std::shared_ptr&lt;GridArea&lt;std::shared_ptr&lt;RenderChunkInstanced&gt; &gt; &gt;</code></td> <td>bufferedViewArea</td></tr></tbody></table> <h3 id="levelrenderercamera-renderchunkposbounds"><a href="#levelrenderercamera-renderchunkposbounds" class="header-anchor">#</a> <code>LevelRendererCamera::RenderChunkPosBounds</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>SubChunkPos</code></td> <td>min</td></tr> <tr><td>12</td> <td>(12) <code>SubChunkPos</code></td> <td>max</td></tr></tbody></table> <h3 id="layer-biome"><a href="#layer-biome" class="header-anchor">#</a> <code>Layer&lt;Biome *&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>LayerDetails::LayerBase</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="layerdetails-layerbase"><a href="#layerdetails-layerbase" class="header-anchor">#</a> <code>LayerDetails::LayerBase</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>LayerDetails::LayerBase_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(8) <code>__int64</code></td> <td>mSeed</td></tr> <tr><td>16</td> <td>(8) <code>__int64</code></td> <td>mSeedMixup</td></tr></tbody></table> <h3 id="legacytradeablecomponent"><a href="#legacytradeablecomponent" class="header-anchor">#</a> <code>LegacyTradeableComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>mAddRecipeOnUpdate</td></tr> <tr><td>1</td> <td>(1) <code>bool</code></td> <td>mResetLockedOnFirstTrade</td></tr> <tr><td>2</td> <td>(1) <code>bool</code></td> <td>mWillingToBreed</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>mRiches</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>mTradeTier</td></tr> <tr><td>12</td> <td>(4) <code>int</code></td> <td>mUpdateMerchantTimer</td></tr> <tr><td>16</td> <td>(8) <code>Player *</code></td> <td>mLastPlayerTradeName</td></tr> <tr><td>24</td> <td>(8) <code>std::unique_ptr&lt;MerchantRecipeList&gt;</code></td> <td>mOffers</td></tr> <tr><td>32</td> <td>(32) <code>std::string</code></td> <td>mDisplayName</td></tr> <tr><td>64</td> <td>(24) <code>std::vector&lt;int&gt;</code></td> <td>mTradeRecipeFirstTime</td></tr></tbody></table> <h3 id="listtagfloatadder"><a href="#listtagfloatadder" class="header-anchor">#</a> <code>ListTagFloatAdder</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::unique_ptr&lt;ListTag&gt;</code></td> <td>mTag</td></tr></tbody></table> <h3 id="loottablecontext"><a href="#loottablecontext" class="header-anchor">#</a> <code>LootTableContext</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>float</code></td> <td>mLuck</td></tr> <tr><td>8</td> <td>(8) <code>Level *</code></td> <td>mLevel</td></tr> <tr><td>16</td> <td>(8) <code>BlockSource *</code></td> <td>mRegion</td></tr> <tr><td>24</td> <td>(8) <code>Actor *</code></td> <td>mThisEntity</td></tr> <tr><td>32</td> <td>(8) <code>Player *</code></td> <td>mKillerPlayer</td></tr> <tr><td>40</td> <td>(8) <code>const ActorDamageSource *</code></td> <td>mDeathSource</td></tr> <tr><td>48</td> <td>(64) <code>std::unordered_set&lt;LootTable const *&gt;</code></td> <td>mVisitedTables</td></tr> <tr><td>112</td> <td>(4) <code>float</code></td> <td>mExplosionRadius</td></tr> <tr><td>120</td> <td>(32) <code>std::string</code></td> <td>mOriginalItemName</td></tr></tbody></table> <h3 id="listtagintadder"><a href="#listtagintadder" class="header-anchor">#</a> <code>ListTagIntAdder</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::unique_ptr&lt;ListTag&gt;</code></td> <td>mTag</td></tr></tbody></table> <h3 id="localconnector-localconnection"><a href="#localconnector-localconnection" class="header-anchor">#</a> <code>LocalConnector::LocalConnection</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>LocalConnector *</code></td> <td>mConnector</td></tr> <tr><td>8</td> <td>(152) <code>NetworkIdentifier</code></td> <td>mId</td></tr></tbody></table> <h3 id="lookcontrolcomponent"><a href="#lookcontrolcomponent" class="header-anchor">#</a> <code>LookControlComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>mHasWantedPosition</td></tr> <tr><td>1</td> <td>(1) <code>bool</code></td> <td>mHasWantedRotation</td></tr> <tr><td>4</td> <td>(4) <code>float</code></td> <td>mYMax</td></tr> <tr><td>8</td> <td>(4) <code>float</code></td> <td>mXMax</td></tr> <tr><td>12</td> <td>(12) <code>Vec3</code></td> <td>mWantedPosition</td></tr> <tr><td>24</td> <td>(12) <code>Vec3</code></td> <td>mWantedRotation</td></tr> <tr><td>40</td> <td>(8) <code>std::unique_ptr&lt;LookControl&gt;</code></td> <td>mLookControl</td></tr></tbody></table> <h3 id="leveldb-status"><a href="#leveldb-status" class="header-anchor">#</a> <code>leveldb::Status</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>state_</td></tr></tbody></table> <h3 id="leveldb-compressor"><a href="#leveldb-compressor" class="header-anchor">#</a> <code>leveldb::Compressor</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>leveldb::Compressor_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(8) <code>unsigned __int64</code></td> <td>inputBytes</td></tr> <tr><td>16</td> <td>(8) <code>unsigned __int64</code></td> <td>compressedBytes</td></tr> <tr><td>24</td> <td>(1) <code>const char</code></td> <td>uniqueCompressionID</td></tr></tbody></table> <h3 id="leveldb-zlibcompressorbase"><a href="#leveldb-zlibcompressorbase" class="header-anchor">#</a> <code>leveldb::ZlibCompressorBase</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>leveldb::Compressor</code></td> <td>baseclass_0</td></tr> <tr><td>32</td> <td>(4) <code>const int</code></td> <td>compressionLevel</td></tr> <tr><td>36</td> <td>(1) <code>const bool</code></td> <td>raw</td></tr></tbody></table> <h3 id="localconnector-connect-l5-lambda-53fd3492de6269a51add08adad05dd5f"><a href="#localconnector-connect-l5-lambda-53fd3492de6269a51add08adad05dd5f" class="header-anchor">#</a> <code>LocalConnector::connect::__l5::&lt;lambda_53fd3492de6269a51add08adad05dd5f&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>LocalConnector *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(152) <code>NetworkIdentifier</code></td> <td>hostId</td></tr> <tr><td>160</td> <td>(16) <code>std::shared_ptr&lt;LocalNetworkPeer&gt;</code></td> <td>newPeer</td></tr></tbody></table> <h3 id="localconnector-createpeer-l2-lambda-ddc662792dc88affbd03064fa30cfc5e"><a href="#localconnector-createpeer-l2-lambda-ddc662792dc88affbd03064fa30cfc5e" class="header-anchor">#</a> <code>LocalConnector::createPeer::__l2::&lt;lambda_ddc662792dc88affbd03064fa30cfc5e&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>LocalConnector *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(152) <code>NetworkIdentifier</code></td> <td>clientId</td></tr> <tr><td>160</td> <td>(16) <code>std::shared_ptr&lt;LocalNetworkPeer&gt;</code></td> <td>newPeer</td></tr></tbody></table> <h3 id="listdcommand-execute-l2-lambda-b3cf132935515dc31340e61291b1a510"><a href="#listdcommand-execute-l2-lambda-b3cf132935515dc31340e61291b1a510" class="header-anchor">#</a> <code>ListDCommand::execute::__l2::&lt;lambda_b3cf132935515dc31340e61291b1a510&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Json::Value *</code></td> <td>playerList</td></tr> <tr><td>8</td> <td>(8) <code>std::basic_stringstream&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; *</code></td> <td>stream</td></tr> <tr><td>16</td> <td>(8) <code>int *</code></td> <td>count</td></tr> <tr><td>24</td> <td>(8) <code>std::basic_stringstream&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; *</code></td> <td>hexFormatter</td></tr> <tr><td>32</td> <td>(8) <code>bool *</code></td> <td>stats</td></tr> <tr><td>40</td> <td>(8) <code>bool *</code></td> <td>listUUIDs</td></tr> <tr><td>48</td> <td>(8) <code>bool *</code></td> <td>listIds</td></tr> <tr><td>56</td> <td>(8) <code>std::string *</code></td> <td>globalMultiplayerCorrelationId</td></tr></tbody></table> <h3 id="lookatdefinition"><a href="#lookatdefinition" class="header-anchor">#</a> <code>LookAtDefinition</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>mSetTarget</td></tr> <tr><td>4</td> <td>(4) <code>float</code></td> <td>mSearchRadius</td></tr> <tr><td>8</td> <td>(1) <code>bool</code></td> <td>mAllowInvulnerable</td></tr> <tr><td>12</td> <td>(8) <code>FloatRange</code></td> <td>mLookCooldown</td></tr> <tr><td>24</td> <td>(64) <code>ActorFilterGroup</code></td> <td>mFilter</td></tr> <tr><td>88</td> <td>(320) <code>DefinitionTrigger</code></td> <td>mOnLookAt</td></tr></tbody></table> <h3 id="leveleventcoordinator-sendlevelweatherchanged-l2-lambda-33b11a197678339fe6beb420e10f4191"><a href="#leveleventcoordinator-sendlevelweatherchanged-l2-lambda-33b11a197678339fe6beb420e10f4191" class="header-anchor">#</a> <code>LevelEventCoordinator::sendLevelWeatherChanged::__l2::&lt;lambda_33b11a197678339fe6beb420e10f4191&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>const std::string</code></td> <td>dimension</td></tr> <tr><td>32</td> <td>(1) <code>bool</code></td> <td>raining</td></tr> <tr><td>33</td> <td>(1) <code>bool</code></td> <td>lightning</td></tr></tbody></table> <h3 id="layerresult-biome"><a href="#layerresult-biome" class="header-anchor">#</a> <code>LayerResult&lt;Biome *&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::unique_ptr&lt;char [0]&gt;</code></td> <td>mResult</td></tr></tbody></table> <h3 id="levelchunk-hardcodedspawningarea"><a href="#levelchunk-hardcodedspawningarea" class="header-anchor">#</a> <code>LevelChunk::HardcodedSpawningArea</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>BoundingBox</code></td> <td>aabb</td></tr> <tr><td>24</td> <td>(1) <code>HardcodedSpawnAreaType</code></td> <td>type</td></tr></tbody></table> <h3 id="levelchunkhashmapkey"><a href="#levelchunkhashmapkey" class="header-anchor">#</a> <code>LevelChunkHashMapKey</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>LevelChunkTag</code></td> <td>mTag</td></tr> <tr><td>8</td> <td>(8) <code>unsigned __int64</code></td> <td>mIndex</td></tr></tbody></table> <h3 id="level-levelchunkqueuedsavingelement"><a href="#level-levelchunkqueuedsavingelement" class="header-anchor">#</a> <code>Level::LevelChunkQueuedSavingElement</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>mDist</td></tr> <tr><td>8</td> <td>(8) <code>ChunkPos</code></td> <td>mPosition</td></tr> <tr><td>16</td> <td>(4) <code>AutomaticID&lt;Dimension,int&gt;</code></td> <td>mDimensionId</td></tr></tbody></table> <h3 id="level-explode-l5-lambda-81dee22cf752cbc31af5429df6d1a2ac"><a href="#level-explode-l5-lambda-81dee22cf752cbc31af5429df6d1a2ac" class="header-anchor">#</a> <code>Level::explode::__l5::&lt;lambda_81dee22cf752cbc31af5429df6d1a2ac&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::string *</code></td> <td>sID</td></tr> <tr><td>8</td> <td>(8) <code>long double *</code></td> <td>x</td></tr> <tr><td>16</td> <td>(8) <code>long double *</code></td> <td>y</td></tr> <tr><td>24</td> <td>(8) <code>long double *</code></td> <td>z</td></tr> <tr><td>32</td> <td>(8) <code>float *</code></td> <td>explosionRadius</td></tr> <tr><td>40</td> <td>(8) <code>bool *</code></td> <td>fire</td></tr> <tr><td>48</td> <td>(8) <code>bool *</code></td> <td>breaksBlocks</td></tr></tbody></table> <h3 id="legacyblockplacementprocessor"><a href="#legacyblockplacementprocessor" class="header-anchor">#</a> <code>LegacyBlockPlacementProcessor</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>float</code></td> <td>mChance</td></tr> <tr><td>4</td> <td>(2516) <code>Random</code></td> <td>mRandom</td></tr> <tr><td>2520</td> <td>(1) <code>bool</code></td> <td>mHasGravity</td></tr> <tr><td>2528</td> <td>(8) <code>const std::vector&lt;std::unique_ptr&lt;StructurePoolBlockRule&gt;&gt; *</code></td> <td>mBlockRules</td></tr> <tr><td>2536</td> <td>(8) <code>const std::vector&lt;std::unique_ptr&lt;StructurePoolBlockTagRule&gt;&gt; *</code></td> <td>mBlockTagRules</td></tr></tbody></table> <h3 id="legacyjigsawplacement"><a href="#legacyjigsawplacement" class="header-anchor">#</a> <code>LegacyJigsawPlacement</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>const int</code></td> <td>mMaxDepth</td></tr> <tr><td>8</td> <td>(64) <code>std::function&lt;std::unique_ptr&lt;PoolElementStructurePiece&gt; __cdecl(StructurePoolElement const &amp;,BlockPos const &amp;,enum Rotation const &amp;,int,JigsawJunction &amp;,BoundingBox const &amp;,BlockPos const &amp;)&gt;</code></td> <td>mFactory</td></tr> <tr><td>72</td> <td>(64) <code>std::unordered_map&lt;ChunkPos,std::unique_ptr&lt;std::vector&lt;short&gt;&gt;&gt;</code></td> <td>mChunkHeightCache</td></tr></tbody></table> <h3 id="levelchunk"><a href="#levelchunk" class="header-anchor">#</a> <code>LevelChunk</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(80) <code>std::mutex</code></td> <td>mBlockEntityAccessLock</td></tr> <tr><td>80</td> <td>(8) <code>Level *</code></td> <td>mLevel</td></tr> <tr><td>88</td> <td>(8) <code>Dimension *</code></td> <td>mDimension</td></tr> <tr><td>96</td> <td>(12) <code>BlockPos</code></td> <td>mMin</td></tr> <tr><td>108</td> <td>(12) <code>BlockPos</code></td> <td>mMax</td></tr> <tr><td>120</td> <td>(8) <code>ChunkPos</code></td> <td>mPosition</td></tr> <tr><td>128</td> <td>(1) <code>bool</code></td> <td>mLightingFixupDone</td></tr> <tr><td>129</td> <td>(1) <code>std::atomic&lt;bool&gt;</code></td> <td>mLightingTaskActive</td></tr> <tr><td>130</td> <td>(1) <code>bool</code></td> <td>mReadOnly</td></tr> <tr><td>136</td> <td>(8) <code>ChunkSource *</code></td> <td>mGenerator</td></tr> <tr><td>144</td> <td>(2) <code>std::optional&lt;enum LevelChunkFormat&gt;</code></td> <td>mLoadedFormat</td></tr> <tr><td>152</td> <td>(32) <code>std::string</code></td> <td>mSerializedEntitiesBuffer</td></tr> <tr><td>184</td> <td>(1) <code>std::atomic&lt;enum ChunkState&gt;</code></td> <td>mLoadState</td></tr> <tr><td>185</td> <td>(1) <code>ChunkTerrainDataState</code></td> <td>mTerrainDataState</td></tr> <tr><td>186</td> <td>(1) <code>ChunkDebugDisplaySavedState</code></td> <td>mDebugDisplaySavedState</td></tr> <tr><td>187</td> <td>(1) <code>ChunkCachedDataState</code></td> <td>mCachedDataState</td></tr> <tr><td>192</td> <td>(32) <code>SpinLock</code></td> <td>mCachedDataStateSpinLock</td></tr> <tr><td>224</td> <td>(8) <code>Tick</code></td> <td>mLastTick</td></tr> <tr><td>232</td> <td>(8) <code>std::unique_ptr&lt;BlockTickingQueue&gt;</code></td> <td>mTickQueue</td></tr> <tr><td>240</td> <td>(8) <code>std::unique_ptr&lt;BlockTickingQueue&gt;</code></td> <td>mRandomTickQueue</td></tr> <tr><td>248</td> <td>(1832) <code>AppendOnlyAtomicLookupTable&lt;SubChunk,32&gt;</code></td> <td>mSubChunks</td></tr> <tr><td>2080</td> <td>(1024) <code>std::array&lt;SpinLock,32&gt;</code></td> <td>mSubChunkSpinLocks</td></tr> <tr><td>3104</td> <td>(256) <code>std::array&lt;BiomeChunkData,256&gt;</code></td> <td>mBiomes</td></tr> <tr><td>3360</td> <td>(2048) <code>std::array&lt;ColumnCachedData,256&gt;</code></td> <td>mCachedData</td></tr> <tr><td>5408</td> <td>(512) <code>std::array&lt;ChunkLocalHeight,256&gt;</code></td> <td>mHeightmap</td></tr> <tr><td>5920</td> <td>(8) <code>std::unique_ptr&lt;std::vector&lt;short&gt;&gt;</code></td> <td>mPreWorldGenHeightmap</td></tr> <tr><td>5928</td> <td>(64) <code>std::unordered_map&lt;unsigned char,BiomeChunkState&gt;</code></td> <td>mBiomeStates</td></tr> <tr><td>5992</td> <td>(1) <code>bool</code></td> <td>mHasCachedTemperatureNoise</td></tr> <tr><td>5993</td> <td>(256) <code>std::array&lt;unsigned char,256&gt;</code></td> <td>mBorderBlockMap</td></tr> <tr><td>6252</td> <td>(4) <code>LevelChunk::Finalization</code></td> <td>mFinalized</td></tr> <tr><td>6256</td> <td>(1) <code>bool</code></td> <td>mIsRedstoneLoaded</td></tr> <tr><td>6257</td> <td>(1) <code>bool</code></td> <td>mOwnedByTickingThread</td></tr> <tr><td>6260</td> <td>(56) <code>DirtyTicksCounter[7]</code></td> <td>mFullChunkDirtyTicksCounters</td></tr> <tr><td>6316</td> <td>(512) <code>std::array&lt;ChunkLocalHeight,256&gt;</code></td> <td>mRainHeights</td></tr> <tr><td>6832</td> <td>(24) <code>SmallSet&lt;std::unique_ptr&lt;Actor&gt; &gt;</code></td> <td>mEntities</td></tr> <tr><td>6856</td> <td>(64) <code>std::unordered_map&lt;ChunkBlockPos,std::shared_ptr&lt;BlockActor&gt;&gt;</code></td> <td>mBlockEntities</td></tr> <tr><td>6920</td> <td>(24) <code>std::vector&lt;std::shared_ptr&lt;BlockActor&gt;&gt;</code></td> <td>mDeletedBlockEntities</td></tr> <tr><td>6944</td> <td>(2) <code>BrightnessPair</code></td> <td>mDefaultBrightness</td></tr> <tr><td>6952</td> <td>(24) <code>std::vector&lt;LevelChunk::HardcodedSpawningArea&gt;</code></td> <td>mHardcodedSpawningAreas</td></tr> <tr><td>6976</td> <td>(4) <code>unsigned __int8[2][2]</code></td> <td>mbChunkInterpolants</td></tr> <tr><td>6980</td> <td>(1) <code>bool</code></td> <td>mbChunkHasConverterTag</td></tr> <tr><td>6981</td> <td>(1) <code>bool</code></td> <td>mDBChunkSurroundedByNeighbors</td></tr> <tr><td>6984</td> <td>(64) <code>std::unordered_map&lt;LevelChunkHashMapKey,unsigned __int64&gt;</code></td> <td>mLevelChunkChecksums</td></tr> <tr><td>7048</td> <td>(1) <code>bool</code></td> <td>mOnChunkLoadedCalled</td></tr> <tr><td>7056</td> <td>(80) <code>std::mutex</code></td> <td>mMicroBlockModelStorageLock</td></tr> <tr><td>7136</td> <td>(80) <code>std::mutex</code></td> <td>mMicroBlockModelTableLock</td></tr> <tr><td>7216</td> <td>(80) <code>std::mutex</code></td> <td>mStaticMicroBlockModelTableLock</td></tr> <tr><td>7296</td> <td>(80) <code>std::mutex</code></td> <td>mMicroBlockUsingMapLock</td></tr> <tr><td>7376</td> <td>(64) <code>?</code></td> <td>mMicroBlockModelStorage</td></tr> <tr><td>7440</td> <td>(64) <code>std::unordered_map&lt;BlockPos,std::string&gt;</code></td> <td>mMicroBlockModelTable</td></tr> <tr><td>7504</td> <td>(64) <code>std::unordered_map&lt;BlockPos,std::string&gt;</code></td> <td>mStaticMicroBlockModelTable</td></tr> <tr><td>7568</td> <td>(64) <code>std::unordered_map&lt;std::string,int&gt;</code></td> <td>mMicroBlockUsingMap</td></tr></tbody></table> <h3 id="levelstoragewritebatch"><a href="#levelstoragewritebatch" class="header-anchor">#</a> <code>LevelStorageWriteBatch</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>LevelStorageWriteBatch_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(24) <code>std::vector&lt;std::function&lt;void __cdecl(void)&gt;&gt;</code></td> <td>mFlushCallbacks</td></tr> <tr><td>32</td> <td>(16) <code>std::map&lt;std::string,LevelStorageWriteBatch::BatchEntry&gt;</code></td> <td>mBatch</td></tr> <tr><td>48</td> <td>(80) <code>std::mutex</code></td> <td>mFlushCallbacksMutex</td></tr></tbody></table> <h3 id="levelloosefilestorage-lambda-243d65738535c465e89fa7d414db982c"><a href="#levelloosefilestorage-lambda-243d65738535c465e89fa7d414db982c" class="header-anchor">#</a> <code>LevelLooseFileStorage::&lt;lambda_243d65738535c465e89fa7d414db982c&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>root</td></tr> <tr><td>32</td> <td>(24) <code>const ContentIdentity</code></td> <td>contentIdentity</td></tr> <tr><td>56</td> <td>(8) <code>const IContentKeyProvider *</code></td> <td>keyProvider</td></tr></tbody></table> <h3 id="leveldb-slice"><a href="#leveldb-slice" class="header-anchor">#</a> <code>leveldb::Slice</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>data_</td></tr> <tr><td>8</td> <td>(8) <code>unsigned __int64</code></td> <td>size_</td></tr></tbody></table> <h3 id="levelcache"><a href="#levelcache" class="header-anchor">#</a> <code>LevelCache</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(384) <code>LevelSummary</code></td> <td>summary</td></tr> <tr><td>384</td> <td>(8) <code>std::unique_ptr&lt;LevelData&gt;</code></td> <td>data</td></tr> <tr><td>392</td> <td>(1) <code>bool</code></td> <td>dirtySummary</td></tr> <tr><td>393</td> <td>(1) <code>bool</code></td> <td>isPartiallyCopied</td></tr></tbody></table> <h3 id="loomscreencontrollerproxycallbacks"><a href="#loomscreencontrollerproxycallbacks" class="header-anchor">#</a> <code>LoomScreenControllerProxyCallbacks</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;void __cdecl(int)&gt;</code></td> <td>mAddItem</td></tr> <tr><td>64</td> <td>(64) <code>std::function&lt;void __cdecl(int)&gt;</code></td> <td>mAddDye</td></tr> <tr><td>128</td> <td>(64) <code>std::function&lt;int __cdecl(BannerPattern const *)&gt;</code></td> <td>mGetPatternIndex</td></tr> <tr><td>192</td> <td>(64) <code>std::function&lt;void __cdecl(int)&gt;</code></td> <td>mSetSelectedPattern</td></tr> <tr><td>256</td> <td>(64) <code>std::function&lt;ItemStackBase const &amp; __cdecl(void)&gt;</code></td> <td>mGetResultItem</td></tr></tbody></table> <h3 id="layerbiomesource"><a href="#layerbiomesource" class="header-anchor">#</a> <code>LayerBiomeSource</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BiomeSource</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(16) <code>std::shared_ptr&lt;Layer&lt;Biome *&gt; const &gt;</code></td> <td>mBlockResolutionLayer</td></tr></tbody></table> <h3 id="layerdetails-randomprovidert-lambda-771016eb0f7e2748065ada6628a00507"><a href="#layerdetails-randomprovidert-lambda-771016eb0f7e2748065ada6628a00507" class="header-anchor">#</a> <code>LayerDetails::RandomProviderT&lt;&lt;lambda_771016eb0f7e2748065ada6628a00507&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>LayerDetails::LayerBase::initRandom::__l2::&lt;lambda_771016eb0f7e2748065ada6628a00507&gt;</code></td> <td>mNextRandom</td></tr> <tr><td>8</td> <td>(8) <code>__int64</code></td> <td>mRval</td></tr></tbody></table> <h3 id="layerdetails-layerbase-initrandom-l2-lambda-771016eb0f7e2748065ada6628a00507"><a href="#layerdetails-layerbase-initrandom-l2-lambda-771016eb0f7e2748065ada6628a00507" class="header-anchor">#</a> <code>LayerDetails::LayerBase::initRandom::__l2::&lt;lambda_771016eb0f7e2748065ada6628a00507&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>__int64</code></td> <td>seed</td></tr></tbody></table> <h3 id="lakefeature"><a href="#lakefeature" class="header-anchor">#</a> <code>LakeFeature</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>Feature</code></td> <td>baseclass_0</td></tr> <tr><td>24</td> <td>(8) <code>const Block *</code></td> <td>mBlock</td></tr> <tr><td>32</td> <td>(8) <code>const Block *</code></td> <td>mEmptyBlock</td></tr></tbody></table> <h3 id="layerfilters-addbiomeisland-ctor-l2-lambda-d22b2d79a9b449dd8757e60c4491a3ad"><a href="#layerfilters-addbiomeisland-ctor-l2-lambda-d22b2d79a9b449dd8757e60c4491a3ad" class="header-anchor">#</a> <code>LayerFilters::AddBiomeIsland::{ctor}::__l2::&lt;lambda_d22b2d79a9b449dd8757e60c4491a3ad&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>LayerFilters::AddBiomeIsland *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(224) <code>TagRegistry&lt;IDType&lt;BiomeTagIDType&gt;,IDType&lt;BiomeTagSetIDType&gt; &gt;</code></td> <td>tagRegistry</td></tr> <tr><td>232</td> <td>(1008) <code>WellKnownBiomeTags</code></td> <td>wellKnownBiomeTags</td></tr></tbody></table> <h3 id="layerfilters-riverinit-ctor-l2-lambda-b3b651c19a7ac355c635e67204b20baa"><a href="#layerfilters-riverinit-ctor-l2-lambda-b3b651c19a7ac355c635e67204b20baa" class="header-anchor">#</a> <code>LayerFilters::RiverInit::{ctor}::__l2::&lt;lambda_b3b651c19a7ac355c635e67204b20baa&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>LayerFilters::RiverInit *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(224) <code>TagRegistry&lt;IDType&lt;BiomeTagIDType&gt;,IDType&lt;BiomeTagSetIDType&gt; &gt;</code></td> <td>tagRegistry</td></tr> <tr><td>232</td> <td>(1008) <code>WellKnownBiomeTags</code></td> <td>wellKnownBiomeTags</td></tr></tbody></table> <h3 id="leveldb-mutexlock"><a href="#leveldb-mutexlock" class="header-anchor">#</a> <code>leveldb::MutexLock</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>leveldb::port::Mutex *const</code></td> <td>mu_</td></tr></tbody></table> <h3 id="leveldb-parsedinternalkey"><a href="#leveldb-parsedinternalkey" class="header-anchor">#</a> <code>leveldb::ParsedInternalKey</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>leveldb::Slice</code></td> <td>user_key</td></tr> <tr><td>16</td> <td>(8) <code>unsigned __int64</code></td> <td>sequence</td></tr> <tr><td>24</td> <td>(4) <code>leveldb::ValueType</code></td> <td>type</td></tr></tbody></table> <h3 id="leveldb-filemetadata"><a href="#leveldb-filemetadata" class="header-anchor">#</a> <code>leveldb::FileMetaData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>refs</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>allowed_seeks</td></tr> <tr><td>8</td> <td>(8) <code>unsigned __int64</code></td> <td>number</td></tr> <tr><td>16</td> <td>(8) <code>unsigned __int64</code></td> <td>file_size</td></tr> <tr><td>24</td> <td>(32) <code>leveldb::InternalKey</code></td> <td>smallest</td></tr> <tr><td>56</td> <td>(32) <code>leveldb::InternalKey</code></td> <td>largest</td></tr></tbody></table> <h3 id="leveldb-versionset-builder-bysmallestkey"><a href="#leveldb-versionset-builder-bysmallestkey" class="header-anchor">#</a> <code>leveldb::VersionSet::Builder::BySmallestKey</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const leveldb::InternalKeyComparator *</code></td> <td>internal_comparator</td></tr></tbody></table> <h3 id="leveldb-versionedit"><a href="#leveldb-versionedit" class="header-anchor">#</a> <code>leveldb::VersionEdit</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>comparator_</td></tr> <tr><td>32</td> <td>(8) <code>unsigned __int64</code></td> <td>log_number_</td></tr> <tr><td>40</td> <td>(8) <code>unsigned __int64</code></td> <td>prev_log_number_</td></tr> <tr><td>48</td> <td>(8) <code>unsigned __int64</code></td> <td>next_file_number_</td></tr> <tr><td>56</td> <td>(8) <code>unsigned __int64</code></td> <td>last_sequence_</td></tr> <tr><td>64</td> <td>(1) <code>bool</code></td> <td>has_comparator_</td></tr> <tr><td>65</td> <td>(1) <code>bool</code></td> <td>has_log_number_</td></tr> <tr><td>66</td> <td>(1) <code>bool</code></td> <td>has_prev_log_number_</td></tr> <tr><td>67</td> <td>(1) <code>bool</code></td> <td>has_next_file_number_</td></tr> <tr><td>68</td> <td>(1) <code>bool</code></td> <td>has_last_sequence_</td></tr> <tr><td>72</td> <td>(24) <code>std::vector&lt;std::pair&lt;int,leveldb::InternalKey&gt;&gt;</code></td> <td>compact_pointers_</td></tr> <tr><td>96</td> <td>(16) <code>std::set&lt;std::pair&lt;int,unsigned __int64&gt;&gt;</code></td> <td>deleted_files_</td></tr> <tr><td>112</td> <td>(24) <code>std::vector&lt;std::pair&lt;int,leveldb::FileMetaData&gt;&gt;</code></td> <td>new_files_</td></tr></tbody></table> <h3 id="leveldb-log-writer"><a href="#leveldb-log-writer" class="header-anchor">#</a> <code>leveldb::log::Writer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>leveldb::WritableFile *</code></td> <td>dest_</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>block_offset_</td></tr> <tr><td>12</td> <td>(20) <code>unsigned int[5]</code></td> <td>type_crc_</td></tr></tbody></table> <h3 id="leveldb-log-reader"><a href="#leveldb-log-reader" class="header-anchor">#</a> <code>leveldb::log::Reader</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>leveldb::SequentialFile *const</code></td> <td>file_</td></tr> <tr><td>8</td> <td>(8) <code>leveldb::log::Reader::Reporter *const</code></td> <td>reporter_</td></tr> <tr><td>16</td> <td>(1) <code>const bool</code></td> <td>checksum_</td></tr> <tr><td>24</td> <td>(8) <code>char *const</code></td> <td>backing_store_</td></tr> <tr><td>32</td> <td>(16) <code>leveldb::Slice</code></td> <td>buffer_</td></tr> <tr><td>48</td> <td>(1) <code>bool</code></td> <td>eof_</td></tr> <tr><td>56</td> <td>(8) <code>unsigned __int64</code></td> <td>last_record_offset_</td></tr> <tr><td>64</td> <td>(8) <code>unsigned __int64</code></td> <td>end_of_buffer_offset_</td></tr> <tr><td>72</td> <td>(8) <code>const unsigned __int64</code></td> <td>initial_offset_</td></tr> <tr><td>80</td> <td>(1) <code>bool</code></td> <td>resyncing_</td></tr></tbody></table> <h3 id="leveldb-dbimpl-compactionstate-output"><a href="#leveldb-dbimpl-compactionstate-output" class="header-anchor">#</a> <code>leveldb::DBImpl::CompactionState::Output</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int64</code></td> <td>number</td></tr> <tr><td>8</td> <td>(8) <code>unsigned __int64</code></td> <td>file_size</td></tr> <tr><td>16</td> <td>(32) <code>leveldb::InternalKey</code></td> <td>smallest</td></tr> <tr><td>48</td> <td>(32) <code>leveldb::InternalKey</code></td> <td>largest</td></tr></tbody></table> <h3 id="leveldb-readoptions"><a href="#leveldb-readoptions" class="header-anchor">#</a> <code>leveldb::ReadOptions</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>verify_checksums</td></tr> <tr><td>1</td> <td>(1) <code>bool</code></td> <td>fill_cache</td></tr> <tr><td>8</td> <td>(8) <code>const leveldb::Snapshot *</code></td> <td>snapshot</td></tr> <tr><td>16</td> <td>(8) <code>leveldb::DecompressAllocator *</code></td> <td>decompress_allocator</td></tr></tbody></table> <h3 id="leveldb-lookupkey"><a href="#leveldb-lookupkey" class="header-anchor">#</a> <code>leveldb::LookupKey</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>start_</td></tr> <tr><td>8</td> <td>(8) <code>const char *</code></td> <td>kstart_</td></tr> <tr><td>16</td> <td>(8) <code>const char *</code></td> <td>end_</td></tr> <tr><td>24</td> <td>(200) <code>char[200]</code></td> <td>space_</td></tr></tbody></table> <h3 id="leveldb-version-getstats"><a href="#leveldb-version-getstats" class="header-anchor">#</a> <code>leveldb::Version::GetStats</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>leveldb::FileMetaData *</code></td> <td>seek_file</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>seek_file_level</td></tr></tbody></table> <h3 id="leveldb-writebatch-handler"><a href="#leveldb-writebatch-handler" class="header-anchor">#</a> <code>leveldb::WriteBatch::Handler</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>leveldb::WriteBatch::Handler_vtbl *</code></td> <td>__vftable</td></tr></tbody></table> <h3 id="leveldb-options"><a href="#leveldb-options" class="header-anchor">#</a> <code>leveldb::Options</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const leveldb::Comparator *</code></td> <td>comparator</td></tr> <tr><td>8</td> <td>(1) <code>bool</code></td> <td>create_if_missing</td></tr> <tr><td>9</td> <td>(1) <code>bool</code></td> <td>error_if_exists</td></tr> <tr><td>10</td> <td>(1) <code>bool</code></td> <td>paranoid_checks</td></tr> <tr><td>16</td> <td>(8) <code>leveldb::Env *</code></td> <td>env</td></tr> <tr><td>24</td> <td>(8) <code>leveldb::Logger *</code></td> <td>info_log</td></tr> <tr><td>32</td> <td>(8) <code>unsigned __int64</code></td> <td>write_buffer_size</td></tr> <tr><td>40</td> <td>(4) <code>int</code></td> <td>max_open_files</td></tr> <tr><td>48</td> <td>(8) <code>leveldb::Cache *</code></td> <td>block_cache</td></tr> <tr><td>56</td> <td>(8) <code>unsigned __int64</code></td> <td>block_size</td></tr> <tr><td>64</td> <td>(4) <code>int</code></td> <td>block_restart_interval</td></tr> <tr><td>72</td> <td>(8) <code>unsigned __int64</code></td> <td>max_file_size</td></tr> <tr><td>80</td> <td>(2048) <code>leveldb::Compressor *[256]</code></td> <td>compressors</td></tr> <tr><td>2128</td> <td>(1) <code>bool</code></td> <td>reuse_logs</td></tr> <tr><td>2136</td> <td>(8) <code>const leveldb::FilterPolicy *</code></td> <td>filter_policy</td></tr></tbody></table> <h3 id="leveldb-internalkeycomparator"><a href="#leveldb-internalkeycomparator" class="header-anchor">#</a> <code>leveldb::InternalKeyComparator</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>leveldb::Comparator</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(8) <code>const leveldb::Comparator *</code></td> <td>user_comparator_</td></tr></tbody></table> <h3 id="leveldb-comparator"><a href="#leveldb-comparator" class="header-anchor">#</a> <code>leveldb::Comparator</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>leveldb::Comparator_vtbl *</code></td> <td>__vftable</td></tr></tbody></table> <h3 id="leveldb-internalfilterpolicy"><a href="#leveldb-internalfilterpolicy" class="header-anchor">#</a> <code>leveldb::InternalFilterPolicy</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>leveldb::FilterPolicy</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(8) <code>const leveldb::FilterPolicy *const</code></td> <td>user_policy_</td></tr></tbody></table> <h3 id="leveldb-filterpolicy"><a href="#leveldb-filterpolicy" class="header-anchor">#</a> <code>leveldb::FilterPolicy</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>leveldb::FilterPolicy_vtbl *</code></td> <td>__vftable</td></tr></tbody></table> <h3 id="leveldb-versionset-builder"><a href="#leveldb-versionset-builder" class="header-anchor">#</a> <code>leveldb::VersionSet::Builder</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>leveldb::VersionSet *</code></td> <td>vset_</td></tr> <tr><td>8</td> <td>(8) <code>leveldb::Version *</code></td> <td>base_</td></tr> <tr><td>16</td> <td>(168) <code>leveldb::VersionSet::Builder::LevelState[7]</code></td> <td>levels_</td></tr></tbody></table> <h3 id="leveldb-versionset-builder-levelstate"><a href="#leveldb-versionset-builder-levelstate" class="header-anchor">#</a> <code>leveldb::VersionSet::Builder::LevelState</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::set&lt;unsigned __int64&gt;</code></td> <td>deleted_files</td></tr> <tr><td>16</td> <td>(8) <code>std::set&lt;leveldb::FileMetaData *,leveldb::VersionSet::Builder::BySmallestKey,std::allocator&lt;leveldb::FileMetaData *&gt; &gt; *</code></td> <td>added_files</td></tr></tbody></table> <h3 id="leveldb-footer"><a href="#leveldb-footer" class="header-anchor">#</a> <code>leveldb::Footer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>leveldb::BlockHandle</code></td> <td>metaindex_handle_</td></tr> <tr><td>16</td> <td>(16) <code>leveldb::BlockHandle</code></td> <td>index_handle_</td></tr></tbody></table> <h3 id="leveldb-blockhandle"><a href="#leveldb-blockhandle" class="header-anchor">#</a> <code>leveldb::BlockHandle</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int64</code></td> <td>offset_</td></tr> <tr><td>8</td> <td>(8) <code>unsigned __int64</code></td> <td>size_</td></tr></tbody></table> <h3 id="leveldb-blockcontents"><a href="#leveldb-blockcontents" class="header-anchor">#</a> <code>leveldb::BlockContents</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>leveldb::Slice</code></td> <td>data</td></tr> <tr><td>16</td> <td>(1) <code>bool</code></td> <td>cachable</td></tr> <tr><td>17</td> <td>(1) <code>bool</code></td> <td>heap_allocated</td></tr></tbody></table> <h3 id="leveldb-blockbuilder"><a href="#leveldb-blockbuilder" class="header-anchor">#</a> <code>leveldb::BlockBuilder</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const leveldb::Options *</code></td> <td>options_</td></tr> <tr><td>8</td> <td>(32) <code>std::string</code></td> <td>buffer_</td></tr> <tr><td>40</td> <td>(24) <code>std::vector&lt;unsigned int&gt;</code></td> <td>restarts_</td></tr> <tr><td>64</td> <td>(4) <code>int</code></td> <td>counter_</td></tr> <tr><td>68</td> <td>(1) <code>bool</code></td> <td>finished_</td></tr> <tr><td>72</td> <td>(32) <code>std::string</code></td> <td>last_key_</td></tr></tbody></table> <h3 id="leveldb-port-atomicpointer"><a href="#leveldb-port-atomicpointer" class="header-anchor">#</a> <code>leveldb::port::AtomicPointer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>void *</code></td> <td>rep_</td></tr></tbody></table> <h3 id="localeinfo"><a href="#localeinfo" class="header-anchor">#</a> <code>LocaleInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>char *</code></td> <td>decimal_point</td></tr> <tr><td>8</td> <td>(8) <code>char *</code></td> <td>thousands_sep</td></tr> <tr><td>16</td> <td>(8) <code>char *</code></td> <td>grouping</td></tr></tbody></table> <h3 id="listtag-vtbl"><a href="#listtag-vtbl" class="header-anchor">#</a> <code>ListTag_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ListTag_vtbl
{
  void (__fastcall *~Tag)(Tag *this);
  void (__fastcall *deleteChildren)(Tag *this);
  void (__fastcall *write)(Tag *this, IDataOutput *);
  void (__fastcall *load)(Tag *this, IDataInput *);
  void (__fastcall *writeScriptData)(Tag *this, IDataOutput *);
  void (__fastcall *loadScriptData)(Tag *this, IDataInput *);
  std::string *(__fastcall *toString)(Tag *this, std::string *result);
  Tag::Type (__fastcall *getId)(Tag *this);
  bool (__fastcall *equals)(Tag *this, const Tag *);
  void (__fastcall *print)(Tag *this, const std::string *, PrintStream *);
  void (__fastcall *print)(Tag *this, PrintStream *);
  std::unique_ptr&lt;Tag&gt; *(__fastcall *copy)(Tag *this, std::unique_ptr&lt;Tag&gt; *result);
  unsigned __int64 (__fastcall *hash)(Tag *this);
};

</code></pre></div><h3 id="localconnector-connectioncallbacks"><a href="#localconnector-connectioncallbacks" class="header-anchor">#</a> <code>LocalConnector::ConnectionCallbacks</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LocalConnector::ConnectionCallbacks
{
  LocalConnector::ConnectionCallbacks_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="localconnector-connectioncallbacks-vtbl"><a href="#localconnector-connectioncallbacks-vtbl" class="header-anchor">#</a> <code>LocalConnector::ConnectionCallbacks_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LocalConnector::ConnectionCallbacks_vtbl
{
  void (__fastcall *~ConnectionCallbacks)(LocalConnector::ConnectionCallbacks *this);
  void (__fastcall *onNewIncomingLocalConnection)(LocalConnector::ConnectionCallbacks *this, const NetworkIdentifier *, std::shared_ptr&lt;NetworkPeer&gt;);
  void (__fastcall *onNewOutgoingLocalConnection)(LocalConnector::ConnectionCallbacks *this, const NetworkIdentifier *, std::shared_ptr&lt;NetworkPeer&gt;);
  void (__fastcall *onConnectionClosed)(LocalConnector::ConnectionCallbacks *this, const NetworkIdentifier *, const std::string *, bool);
  void (__fastcall *onOutgoingConnectionFailed)(LocalConnector::ConnectionCallbacks *this);
};

</code></pre></div><h3 id="localconnector"><a href="#localconnector" class="header-anchor">#</a> <code>LocalConnector</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LocalConnector : Connector
{
  LocalConnector::ConnectionCallbacks *mCallbacks;
  NetworkIdentifier mLocalId;
  std::vector&lt;LocalConnector::LocalConnection&gt; mConnections;
  std::vector&lt;std::function&lt;void __cdecl(void)&gt;&gt; mCallbackQueue;
};

</code></pre></div><h3 id="localconnector-vtbl"><a href="#localconnector-vtbl" class="header-anchor">#</a> <code>LocalConnector_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LocalConnector_vtbl
{
  void (__fastcall *~Connector)(Connector *this);
  std::vector&lt;std::string&gt; *(__fastcall *getLocalIps)(Connector *this, std::vector&lt;std::string&gt; *result);
  std::string *(__fastcall *getLocalIp)(Connector *this, std::string *result);
  unsigned __int16 (__fastcall *getPort)(Connector *this);
  std::vector&lt;RakNet::SystemAddress&gt; *(__fastcall *getRefinedLocalIps)(Connector *this, std::vector&lt;RakNet::SystemAddress&gt; *result);
  const Social::GameConnectionInfo *(__fastcall *getConnectedGameInfo)(Connector *this);
  void (__fastcall *setupNatPunch)(Connector *this, bool);
  Connector::NatPunchInfo *(__fastcall *getNatPunchInfo)(Connector *this, Connector::NatPunchInfo *result);
  void (__fastcall *startNatPunchingClient)(Connector *this, Social::GameConnectionInfo);
  void (__fastcall *addConnectionStateListener)(Connector *this, Connector::ConnectionStateListener *);
  void (__fastcall *removeConnectionStateListener)(Connector *this, Connector::ConnectionStateListener *);
  bool (__fastcall *isIPv4Supported)(Connector *this);
  bool (__fastcall *isIPv6Supported)(Connector *this);
  unsigned __int16 (__fastcall *getIPv4Port)(Connector *this);
  unsigned __int16 (__fastcall *getIPv6Port)(Connector *this);
  RakNet::RakNetGUID *(__fastcall *getGUID)(Connector *this, RakNet::RakNetGUID *result);
};

</code></pre></div><h3 id="lockless-weakatomic-spscqueue-batchednetworkpeer-datacallback-512-block"><a href="#lockless-weakatomic-spscqueue-batchednetworkpeer-datacallback-512-block" class="header-anchor">#</a> <code>Lockless::WeakAtomic&lt;SPSCQueue&lt;BatchedNetworkPeer::DataCallback,512&gt;::Block *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Lockless::WeakAtomic&lt;SPSCQueue&lt;BatchedNetworkPeer::DataCallback,512&gt;::Block *&gt;
{
  std::atomic&lt;SPSCQueue&lt;BatchedNetworkPeer::DataCallback,512&gt;::Block *&gt; mValue;
};

</code></pre></div><h3 id="labtablepacket-vtbl"><a href="#labtablepacket-vtbl" class="header-anchor">#</a> <code>LabTablePacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LabTablePacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="lecternupdatepacket-vtbl"><a href="#lecternupdatepacket-vtbl" class="header-anchor">#</a> <code>LecternUpdatePacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LecternUpdatePacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="levelchunkpacket-subchunkmetadata"><a href="#levelchunkpacket-subchunkmetadata" class="header-anchor">#</a> <code>LevelChunkPacket::SubChunkMetadata</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelChunkPacket::SubChunkMetadata
{
  unsigned __int64 blobId;
};

</code></pre></div><h3 id="levelchunkpacket"><a href="#levelchunkpacket" class="header-anchor">#</a> <code>LevelChunkPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelChunkPacket : Packet
{
  bool mCacheEnabled;
  ChunkPos mPos;
  std::string mSerializedChunk;
  unsigned __int64 mSubChunksCount;
  std::vector&lt;LevelChunkPacket::SubChunkMetadata&gt; mCacheMetadata;
};

</code></pre></div><h3 id="levelchunkpacket-vtbl"><a href="#levelchunkpacket-vtbl" class="header-anchor">#</a> <code>LevelChunkPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelChunkPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="leveleventgenericpacket"><a href="#leveleventgenericpacket" class="header-anchor">#</a> <code>LevelEventGenericPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj LevelEventGenericPacket : Packet
{
  int mEventId;
  std::unique_ptr&lt;CompoundTag&gt; mData;
};

</code></pre></div><h3 id="leveleventgenericpacket-vtbl"><a href="#leveleventgenericpacket-vtbl" class="header-anchor">#</a> <code>LevelEventGenericPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelEventGenericPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="leveleventpacket"><a href="#leveleventpacket" class="header-anchor">#</a> <code>LevelEventPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(8)) LevelEventPacket : Packet
{
  int mEventId;
  Vec3 mPos;
  int mData;
};

</code></pre></div><h3 id="leveleventpacket-vtbl"><a href="#leveleventpacket-vtbl" class="header-anchor">#</a> <code>LevelEventPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelEventPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="levelsoundeventpacketv2"><a href="#levelsoundeventpacketv2" class="header-anchor">#</a> <code>LevelSoundEventPacketV2</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(8)) LevelSoundEventPacketV2 : Packet
{
  LevelSoundEvent mEventId;
  Vec3 mPos;
  int mData;
  std::string mEntityIdentifier;
  bool mIsBabyMob;
  bool mIsGlobal;
};

</code></pre></div><h3 id="levelsoundeventpacketv2-vtbl"><a href="#levelsoundeventpacketv2-vtbl" class="header-anchor">#</a> <code>LevelSoundEventPacketV2_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelSoundEventPacketV2_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="levelsoundeventpacketv1"><a href="#levelsoundeventpacketv1" class="header-anchor">#</a> <code>LevelSoundEventPacketV1</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(8)) LevelSoundEventPacketV1 : Packet
{
  LevelSoundEvent mEventId;
  Vec3 mPos;
  int mData;
  ActorType mEntityType;
  bool mIsBabyMob;
  bool mIsGlobal;
};

</code></pre></div><h3 id="levelsoundeventpacketv1-vtbl"><a href="#levelsoundeventpacketv1-vtbl" class="header-anchor">#</a> <code>LevelSoundEventPacketV1_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelSoundEventPacketV1_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="levelsoundeventpacket-vtbl"><a href="#levelsoundeventpacket-vtbl" class="header-anchor">#</a> <code>LevelSoundEventPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelSoundEventPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="loginpacket"><a href="#loginpacket" class="header-anchor">#</a> <code>LoginPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj LoginPacket : Packet
{
  int mClientNetworkVersion;
  std::unique_ptr&lt;ConnectionRequest&gt; mConnectionRequest;
};

</code></pre></div><h3 id="loginpacket-vtbl"><a href="#loginpacket-vtbl" class="header-anchor">#</a> <code>LoginPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LoginPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="lockless-weakatomic-spscqueue-std-shared-ptr-backgroundtaskbase-512-block"><a href="#lockless-weakatomic-spscqueue-std-shared-ptr-backgroundtaskbase-512-block" class="header-anchor">#</a> <code>Lockless::WeakAtomic&lt;SPSCQueue&lt;std::shared_ptr&lt;BackgroundTaskBase&gt;,512&gt;::Block *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Lockless::WeakAtomic&lt;SPSCQueue&lt;std::shared_ptr&lt;BackgroundTaskBase&gt;,512&gt;::Block *&gt;
{
  std::atomic&lt;SPSCQueue&lt;std::shared_ptr&lt;BackgroundTaskBase&gt;,512&gt;::Block *&gt; mValue;
};

</code></pre></div><h3 id="legacypackidversion"><a href="#legacypackidversion" class="header-anchor">#</a> <code>LegacyPackIdVersion</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyPackIdVersion
{
  std::string mId;
  std::string mVersion;
};

</code></pre></div><h3 id="loadedresourcedata"><a href="#loadedresourcedata" class="header-anchor">#</a> <code>LoadedResourceData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LoadedResourceData
{
  int mIndex;
  std::string mContent;
};

</code></pre></div><h3 id="levellistener"><a href="#levellistener" class="header-anchor">#</a> <code>LevelListener</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelListener : BlockSourceListener
{
};

</code></pre></div><h3 id="lighttexture"><a href="#lighttexture" class="header-anchor">#</a> <code>LightTexture</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LightTexture
{
  std::shared_ptr&lt;mce::Image&gt; mBrightnessImage;
  _BYTE mBrightnessTextureId[1];
  std::shared_ptr&lt;mce::ClientTexture&gt; mBrightnessTexture;
  bool mIsTextureDirty;
  BaseLightData mLightData;
};

</code></pre></div><h3 id="legacystructureblockpalette"><a href="#legacystructureblockpalette" class="header-anchor">#</a> <code>LegacyStructureBlockPalette</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyStructureBlockPalette
{
  std::unordered_map&lt;int,Block const *&gt; mMapper;
};

</code></pre></div><h3 id="legacystructureblockinfo"><a href="#legacystructureblockinfo" class="header-anchor">#</a> <code>LegacyStructureBlockInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyStructureBlockInfo
{
  BlockPos mPos;
  const Block *mBlock;
  const Block *mExtraBlock;
  std::unique_ptr&lt;CompoundTag&gt; mTag;
};

</code></pre></div><h3 id="legacystructureactorinfo"><a href="#legacystructureactorinfo" class="header-anchor">#</a> <code>LegacyStructureActorInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyStructureActorInfo
{
  Vec3 mPos;
  BlockPos mBlockPos;
  CompoundTag mTag;
};

</code></pre></div><h3 id="legacystructuretemplate"><a href="#legacystructuretemplate" class="header-anchor">#</a> <code>LegacyStructureTemplate</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyStructureTemplate
{
  std::string mAuthor;
  BlockPos mSize;
  LegacyStructureBlockPalette mPalette;
  LegacyStructureBlockPalette mExtraBlockPalette;
  std::vector&lt;LegacyStructureBlockInfo&gt; mBlockInfo;
  std::vector&lt;LegacyStructureActorInfo&gt; mEntityInfo;
};

</code></pre></div><h3 id="levelchunkfinaldeleter"><a href="#levelchunkfinaldeleter" class="header-anchor">#</a> <code>LevelChunkFinalDeleter</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelChunkFinalDeleter
{
};

</code></pre></div><h3 id="levelchunkgridareaelement-std-weak-ptr-levelchunk"><a href="#levelchunkgridareaelement-std-weak-ptr-levelchunk" class="header-anchor">#</a> <code>LevelChunkGridAreaElement&lt;std::weak_ptr&lt;LevelChunk&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelChunkGridAreaElement&lt;std::weak_ptr&lt;LevelChunk&gt; &gt;
{
  std::unordered_map&lt;ChunkPos,std::weak_ptr&lt;LevelChunk&gt;&gt; mChunkElemMap;
  SpinLock mSpinLock;
};

</code></pre></div><h3 id="levelchunkbuilderdata-chunkreadyforprocessingelement"><a href="#levelchunkbuilderdata-chunkreadyforprocessingelement" class="header-anchor">#</a> <code>LevelChunkBuilderData::ChunkReadyForProcessingElement</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LevelChunkBuilderData::ChunkReadyForProcessingElement
{
  std::pair&lt;ChunkPos,enum ChunkState&gt; mChunkPosAndExpectedState;
  int mPriority;
};

</code></pre></div><h3 id="levelchunkbuilderdata"><a href="#levelchunkbuilderdata" class="header-anchor">#</a> <code>LevelChunkBuilderData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelChunkBuilderData
{
  SpinLock mChunkGenerationGridMapSpinLock;
  std::unordered_map&lt;ChunkPos,std::shared_ptr&lt;LevelChunkGridAreaElement&lt;std::weak_ptr&lt;LevelChunk&gt; &gt; &gt;&gt; mChunkGenerationGridMap;
  SpinLock mChunksToAddToProcessingSpinLock;
  std::vector&lt;std::pair&lt;ChunkPos,enum ChunkState&gt;&gt; mChunksToAddToProcessing;
  SpinLock mChunksReadyForProcessingSpinLock;
  std::unordered_set&lt;std::pair&lt;ChunkPos,enum ChunkState&gt;&gt; mChunksReadyForProcessing;
  std::vector&lt;LevelChunkBuilderData::ChunkReadyForProcessingElement&gt; mChunkSortVector;
  std::atomic&lt;int&gt; mChunkGenerationTasksInFlight;
  SpinLock mSpawnTasksLock;
};

</code></pre></div><h3 id="loopbackpacketsender"><a href="#loopbackpacketsender" class="header-anchor">#</a> <code>LoopbackPacketSender</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LoopbackPacketSender : PacketSender
{
  NetworkHandler *mNetwork;
  std::vector&lt;NetEventCallback *&gt; mLoopbackCallbacks;
  const std::vector&lt;std::unique_ptr&lt;Player&gt;&gt; *mUserList;
  std::vector&lt;NetworkIdentifierWithSubId&gt; mTempUserIds;
};

</code></pre></div><h3 id="loopbackpacketsender-vtbl"><a href="#loopbackpacketsender-vtbl" class="header-anchor">#</a> <code>LoopbackPacketSender_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LoopbackPacketSender_vtbl
{
  void (__fastcall *~PacketSender)(PacketSender *this);
  void (__fastcall *send)(PacketSender *this, Packet *);
  void (__fastcall *sendToServer)(PacketSender *this, Packet *);
  void (__fastcall *sendToClient)(PacketSender *this, const NetworkIdentifier *, const Packet *, unsigned __int8);
  void (__fastcall *sendToClients)(PacketSender *this, const std::vector&lt;NetworkIdentifierWithSubId&gt; *, const Packet *);
  void (__fastcall *sendBroadcast)(PacketSender *this, const NetworkIdentifier *, unsigned __int8, const Packet *);
  void (__fastcall *sendBroadcast)(PacketSender *this, const Packet *);
  void (__fastcall *flush)(PacketSender *this, const NetworkIdentifier *, std::function&lt;void __cdecl(void)&gt; *);
};

</code></pre></div><h3 id="levelstorage"><a href="#levelstorage" class="header-anchor">#</a> <code>LevelStorage</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelStorage
{
  LevelStorage_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="levelstorageobserver"><a href="#levelstorageobserver" class="header-anchor">#</a> <code>LevelStorageObserver</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelStorageObserver
{
  std::function&lt;void __cdecl(std::string const &amp;)&gt; mOnSaveCallback;
};

</code></pre></div><h3 id="levelstoragewritebatch-vtbl"><a href="#levelstoragewritebatch-vtbl" class="header-anchor">#</a> <code>LevelStorageWriteBatch_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelStorageWriteBatch_vtbl
{
  void (__fastcall *~LevelStorageWriteBatch)(LevelStorageWriteBatch *this);
  void (__fastcall *putKey)(LevelStorageWriteBatch *this, const std::string *, std::shared_ptr&lt;std::string &gt;);
  void (__fastcall *putKey)(LevelStorageWriteBatch *this, const std::string *, std::string *);
  void (__fastcall *putKey)(LevelStorageWriteBatch *this, const std::string *, const std::string *);
  void (__fastcall *putKey)(LevelStorageWriteBatch *this, const std::string *, gsl::basic_string_span&lt;char const ,-1&gt;);
  void (__fastcall *deleteKey)(LevelStorageWriteBatch *this, const std::string *);
  void (__fastcall *flush)(LevelStorageWriteBatch *this, LevelStorage *);
};

</code></pre></div><h3 id="levelstoragewritebatch-batchentry"><a href="#levelstoragewritebatch-batchentry" class="header-anchor">#</a> <code>LevelStorageWriteBatch::BatchEntry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LevelStorageWriteBatch::BatchEntry
{
  std::shared_ptr&lt;std::string &gt; mLatestValue;
  bool mDeleted;
};

</code></pre></div><h3 id="levelstorage-vtbl"><a href="#levelstorage-vtbl" class="header-anchor">#</a> <code>LevelStorage_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelStorage_vtbl
{
  void (__fastcall *~LevelStorage)(LevelStorage *this);
  void (__fastcall *addStorageObserver)(LevelStorage *this, std::unique_ptr&lt;LevelStorageObserver&gt;);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *getCompoundTag)(LevelStorage *this, std::unique_ptr&lt;CompoundTag&gt; *result, const std::string *);
  bool (__fastcall *hasKey)(LevelStorage *this, gsl::basic_string_span&lt;char const ,-1&gt;);
  void (__fastcall *forEachKeyWithPrefix)(LevelStorage *this, gsl::basic_string_span&lt;char const ,-1&gt;, const std::function&lt;void __cdecl(gsl::basic_string_span&lt;char const ,-1&gt;,gsl::basic_string_span&lt;char const ,-1&gt;)&gt; *);
  bool (__fastcall *loadLevelData)(LevelStorage *this, LevelData *);
  std::unique_ptr&lt;ChunkSource&gt; *(__fastcall *createChunkStorage)(LevelStorage *this, std::unique_ptr&lt;ChunkSource&gt; *result, std::unique_ptr&lt;ChunkSource&gt;, StorageVersion);
  void (__fastcall *saveLevelData)(LevelStorage *this, const LevelData *);
  const Core::PathBuffer&lt;std::string &gt; *(__fastcall *getFullPath)(LevelStorage *this);
  std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; *(__fastcall *saveData)(LevelStorage *this, std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; *result, const LevelStorageWriteBatch *);
  std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; *(__fastcall *saveData)(LevelStorage *this, std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; *result, const std::string *, std::string *);
  std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; *(__fastcall *deleteData)(LevelStorage *this, std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; *result, const std::string *);
  void (__fastcall *syncIO)(LevelStorage *this);
  void (__fastcall *getStatistics)(LevelStorage *this, std::string *);
  bool (__fastcall *clonePlayerData)(LevelStorage *this, gsl::basic_string_span&lt;char const ,-1&gt;, gsl::basic_string_span&lt;char const ,-1&gt;);
  Core::LevelStorageResult *(__fastcall *getLevelStorageState)(LevelStorage *this, Core::LevelStorageResult *result);
  void (__fastcall *startShutdown)(LevelStorage *this);
  bool (__fastcall *isShuttingDown)(LevelStorage *this);
  bool (__fastcall *checkShutdownDone)(LevelStorage *this);
  bool (__fastcall *loadData)(LevelStorage *this, gsl::basic_string_span&lt;char const ,-1&gt;, std::string *);
  Core::LevelStorageResult *(__fastcall *getState)(LevelStorage *this, Core::LevelStorageResult *result);
  std::vector&lt;SnapshotFilenameAndLength&gt; *(__fastcall *createSnapshot)(LevelStorage *this, std::vector&lt;SnapshotFilenameAndLength&gt; *result, const std::string *);
  void (__fastcall *releaseSnapshot)(LevelStorage *this);
  void (__fastcall *compactStorage)(LevelStorage *this);
  void (__fastcall *syncAndSuspendStorage)(LevelStorage *this);
  void (__fastcall *resumeStorage)(LevelStorage *this);
  void (__fastcall *setFlushAllowed)(LevelStorage *this, bool);
  void (__fastcall *flushToPermanentStorage)(LevelStorage *this);
  void (__fastcall *freeCaches)(LevelStorage *this);
  void (__fastcall *setCompactionCallback)(LevelStorage *this, std::function&lt;void __cdecl(enum CompactionStatus)&gt;);
  void (__fastcall *setCriticalSyncSaveCallback)(LevelStorage *this, std::function&lt;void __cdecl(void)&gt;);
  void (__fastcall *corruptLevel)(LevelStorage *this);
};

</code></pre></div><h3 id="lockless-weakatomic-spscqueue-std-function-void-cdecl-void-512-block"><a href="#lockless-weakatomic-spscqueue-std-function-void-cdecl-void-512-block" class="header-anchor">#</a> <code>Lockless::WeakAtomic&lt;SPSCQueue&lt;std::function&lt;void __cdecl(void)&gt;,512&gt;::Block *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Lockless::WeakAtomic&lt;SPSCQueue&lt;std::function&lt;void __cdecl(void)&gt;,512&gt;::Block *&gt;
{
  std::atomic&lt;SPSCQueue&lt;std::function&lt;void __cdecl(void)&gt;,512&gt;::Block *&gt; mValue;
};

</code></pre></div><h3 id="leveleventlistener"><a href="#leveleventlistener" class="header-anchor">#</a> <code>LevelEventListener</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelEventListener
{
  LevelEventListener_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="leveleventlistener-vtbl"><a href="#leveleventlistener-vtbl" class="header-anchor">#</a> <code>LevelEventListener_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelEventListener_vtbl
{
  void (__fastcall *~LevelEventListener)(LevelEventListener *this);
  EventResult (__fastcall *onLevelInitialized)(LevelEventListener *this, Level *);
  EventResult (__fastcall *onLevelSaveData)(LevelEventListener *this, Level *, CompoundTag *);
  EventResult (__fastcall *onLevelAddedPlayer)(LevelEventListener *this, Level *, Player *);
  EventResult (__fastcall *onLevelRemovedPlayer)(LevelEventListener *this, Level *, Player *);
  EventResult (__fastcall *onLevelRemovedActor)(LevelEventListener *this, Level *, Actor *);
  EventResult (__fastcall *onLevelAddedActor)(LevelEventListener *this, Level *, Actor *);
  EventResult (__fastcall *onLevelTick)(LevelEventListener *this);
  EventResult (__fastcall *onLevelWeatherChange)(LevelEventListener *this, const std::string *, bool, bool);
  EventResult (__fastcall *onLevelBiomesRegistered)(LevelEventListener *this, BiomeRegistry *);
};

</code></pre></div><h3 id="localplayer-emoteplayedtelemetrydata"><a href="#localplayer-emoteplayedtelemetrydata" class="header-anchor">#</a> <code>LocalPlayer::EmotePlayedTelemetryData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LocalPlayer::EmotePlayedTelemetryData
{
  std::string mEmoteProductId;
  bool mEmoteEndedEarly;
  bool mEmotePlayed;
  int mEmoteSlotNumber;
};

</code></pre></div><h3 id="localplayer-regionlistener"><a href="#localplayer-regionlistener" class="header-anchor">#</a> <code>LocalPlayer::RegionListener</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LocalPlayer::RegionListener
{
  LocalPlayer::RegionListener_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="localplayer-regionlistener-vtbl"><a href="#localplayer-regionlistener-vtbl" class="header-anchor">#</a> <code>LocalPlayer::RegionListener_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LocalPlayer::RegionListener_vtbl
{
  void (__fastcall *~RegionListener)(LocalPlayer::RegionListener *this);
  void (__fastcall *onRegionDestroyed)(LocalPlayer::RegionListener *this);
};

</code></pre></div><h3 id="localplayer"><a href="#localplayer" class="header-anchor">#</a> <code>LocalPlayer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(8)) LocalPlayer : Player
{
  InventoryMenu mInventoryMenu;
  float mPortalEffectTime;
  float mOPortalEffectTime;
  LocalPlayer::EmotePlayedTelemetryData mEmotePlayedTelemetryData;
  IClientInstance *mClient;
  _BYTE mLoadingState[4];
  int mCanCloseScreenOnHurtAfterTime;
  bool mIsRotatingViaScript;
  bool mIsDenyInput;
  bool mCheatTesting;
  float mFlyX;
  float mFlyY;
  float mFlyZ;
  Vec3 mlastFrameDelta;
  Vec2 mLastHmdRot;
  Vec2 mHmdAngleDelta;
  float mActionOrStopGazeLock;
  bool mHmdRotRecorded;
  bool mActionOrStopThisFrame;
  bool mEnablePortalEffect;
  SmoothFloat mSmoothFlyX;
  SmoothFloat mSmoothFlyY;
  SmoothFloat mSmoothFlyZ;
  bool mWasAutoJumping;
  bool mAutoJumpEnabled;
  float mJumpRidingScale;
  ItemStack mSentOffhandItem;
  ItemStack mSentInventoryItem;
  int mSentSelectedSlot;
  float mPreloadingProgress;
  unsigned __int64 mSessionTickCount;
  Vec3 mStartRidingPosition;
  std::vector&lt;LocalPlayer::RegionListener *&gt; mRegionListeners;
  Vec2 mLookBob;
  Vec2 mOLookBob;
  float mCurrentXa;
  float mCurrentZa;
  bool mDamagedByMobThisFrame;
  bool mLeavingLevel;
  bool mIsTeacher;
  bool mHasBeenInitialized;
  bool mPrevTransitionBlocking;
  InventoryOptions mInventoryOptions;
  ItemInstance mCachedArmor[4];
  std::unordered_set&lt;mce::UUID&gt; mAllSentEmotePieceIds;
  StructureFeatureType mCurrentStructureFeature;
  ItemStack mItemActivationItem;
  int mItemActivationTicks;
  float mItemActivationOffsetX;
  float mItemActivationOffsetY;
  std::unique_ptr&lt;PlayerAutomationObserver&gt; mAutomationObserver;
  Vec2 mTurnDelta;
  Vec3 mLastDelta;
  Vec3 mLastPos;
  NetworkChunkSubscriber mChunkSubscriberView;
  Vec3 mInitPos;
  float mMoveDis;
  float mMaxDisX;
  float mMaxDisY;
  float mMaxDisZ;
  bool mCanButtonJump;
  bool mCanButtonMove;
  bool mCanButtonToggleWalkMode;
  bool mCanButtonTogglePerspective;
  bool mCanButtonPause;
  bool mCanButtonChat;
  bool mCanButtonScreenShot;
  bool mCanButtonOpenInv;
  bool mCanScreenDrag;
  bool mCanButtonInAir;
  bool mSpeedFovClosed;
  bool mIsAutoTransform;
  int mAutoTransformFlag;
  Vec3 CheckGM;
  bool mChangeRenderByScripts;
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mLoadIntoDimensionTimeOut;
  std::vector&lt;ChunkPos&gt; mChunksNeededForLoadOffsets;
  PlayerRespawnState mClientRespawnState;
  Vec3 mClientRespawnPotentialPosition;
  int mResetHMDAfterSleepTickDelay;
};

</code></pre></div><h3 id="levelstoragesource"><a href="#levelstoragesource" class="header-anchor">#</a> <code>LevelStorageSource</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelStorageSource : Bedrock::EnableNonOwnerReferences
{
  LevelStorageSource_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="levelloosefilestorage"><a href="#levelloosefilestorage" class="header-anchor">#</a> <code>LevelLooseFileStorage</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelLooseFileStorage
{
  std::function&lt;std::unique_ptr&lt;PackAccessStrategy&gt; __cdecl(void)&gt; mConstructor;
};

</code></pre></div><h3 id="levelstoragesource-vtbl"><a href="#levelstoragesource-vtbl" class="header-anchor">#</a> <code>LevelStorageSource_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelStorageSource_vtbl
{
  void (__fastcall *~LevelStorageSource)(LevelStorageSource *this);
  const std::string *(__fastcall *getName)(LevelStorageSource *this);
  Core::Result *(__fastcall *getLevelData)(LevelStorageSource *this, Core::Result *result, const std::string *, LevelData *);
  LevelData *(__fastcall *getLevelData)(LevelStorageSource *this, LevelData *result, const std::string *);
  void (__fastcall *saveLevelData)(LevelStorageSource *this, const std::string *, const LevelData *);
  void (__fastcall *getLevelList)(LevelStorageSource *this, std::vector&lt;Core::PathBuffer&lt;std::string &gt;&gt; *);
  std::unique_ptr&lt;LevelStorage&gt; *(__fastcall *createLevelStorage)(LevelStorageSource *this, std::unique_ptr&lt;LevelStorage&gt; *result, Scheduler *, const std::string *, const ContentIdentity *, const IContentKeyProvider *, const std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; *);
  std::unique_ptr&lt;LevelLooseFileStorage&gt; *(__fastcall *createLevelLooseStorage)(LevelStorageSource *this, std::unique_ptr&lt;LevelLooseFileStorage&gt; *result, const std::string *, const ContentIdentity *, const IContentKeyProvider *);
  bool (__fastcall *isNewLevelIdAcceptable)(LevelStorageSource *this, const std::string *);
  void (__fastcall *deleteLevel)(LevelStorageSource *this, const std::string *);
  void (__fastcall *renameLevel)(LevelStorageSource *this, LevelData *, const Core::Path *, const std::string *);
  bool (__fastcall *renameLevel)(LevelStorageSource *this, const std::string *, const std::string *);
  bool (__fastcall *createBackupCopyOfWorld)(LevelStorageSource *this, const std::string *, const std::string *, const std::string *);
  bool (__fastcall *isConvertible)(LevelStorageSource *this, const std::string *);
  bool (__fastcall *requiresConversion)(LevelStorageSource *this, const std::string *);
  bool (__fastcall *convertLevel)(LevelStorageSource *this, const std::string *, struct ProgressListener *);
  bool (__fastcall *isLevelMarkedForSync)(LevelStorageSource *this, const Core::Path *);
  bool (__fastcall *isLevelPartiallyCopied)(LevelStorageSource *this, const Core::Path *);
  Core::PathBuffer&lt;std::string &gt; *(__fastcall *getLevelDatFoundPath)(LevelStorageSource *this, Core::PathBuffer&lt;std::string &gt; *result, const Core::Path *);
  const Core::PathBuffer&lt;std::string &gt; *(__fastcall *getBasePath)(LevelStorageSource *this, const Core::PathBuffer&lt;std::string &gt; *result);
  const Core::PathBuffer&lt;std::string &gt; *(__fastcall *getPathToLevel)(LevelStorageSource *this, const Core::PathBuffer&lt;std::string &gt; *result, const std::string *);
  const Core::PathBuffer&lt;std::string &gt; *(__fastcall *getPathToLevelInfo)(LevelStorageSource *this, const Core::PathBuffer&lt;std::string &gt; *result, const std::string *, bool);
  bool (__fastcall *isBetaRetailLevel)(LevelStorageSource *this, const std::string *);
};

</code></pre></div><h3 id="levellocationobserver"><a href="#levellocationobserver" class="header-anchor">#</a> <code>LevelLocationObserver</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelLocationObserver : Core::Observer&lt;LevelLocationObserver,Core::SingleThreadedLock&gt;
{
};

</code></pre></div><h3 id="levellocationobserver-vtbl"><a href="#levellocationobserver-vtbl" class="header-anchor">#</a> <code>LevelLocationObserver_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelLocationObserver_vtbl
{
  void (__fastcall *~Observer&lt;LevelLocationObserver,Core::SingleThreadedLock&gt;)(Core::Observer&lt;LevelLocationObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *_onSubjectDestroyed)(Core::Observer&lt;LevelLocationObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *onLevelAdded)(LevelLocationObserver *this, const std::string *);
  void (__fastcall *onLevelUpdated)(LevelLocationObserver *this, const std::string *);
  void (__fastcall *onLevelDeleted)(LevelLocationObserver *this, const std::string *);
  void (__fastcall *onStorageChanged)(LevelLocationObserver *this);
};

</code></pre></div><h3 id="levellistcache"><a href="#levellistcache" class="header-anchor">#</a> <code>LevelListCache</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelListCache : Bedrock::Threading::EnableQueueForMainThread
{
  LevelStorageSource *mLevelStorageSource;
  std::unordered_map&lt;std::string,LevelCache&gt; mCachedLevelData;
  std::unordered_map&lt;std::string,LevelSummary&gt; mCachedUnSyncedLevelData;
  bool mDiscoverLevels;
  Core::Subject&lt;LevelLocationObserver,Core::SingleThreadedLock&gt; mSubject;
  std::recursive_mutex mCacheLock;
  std::function&lt;bool __cdecl(void)&gt; mCheckIsSafeToFlushCache;
};

</code></pre></div><h3 id="levellistcache-vtbl"><a href="#levellistcache-vtbl" class="header-anchor">#</a> <code>LevelListCache_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelListCache_vtbl
{
  void (__fastcall *~EnableQueueForMainThread)(Bedrock::Threading::EnableQueueForMainThread *this);
};

</code></pre></div><h3 id="libraryservice"><a href="#libraryservice" class="header-anchor">#</a> <code>LibraryService</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LibraryService : ServiceClient
{
  gsl::not_null&lt;Bedrock::NonOwnerPointer&lt;DateManager const &gt; &gt; mDateManager;
  std::string mAcceptLanguage;
  const Core::PathBuffer&lt;std::string &gt; mDefaultCacheLocation;
  std::unordered_map&lt;enum LibraryRequestType,Core::PathBuffer&lt;std::string &gt;&gt; mCacheLocationPerType;
  const std::string mHostUrl;
  std::string mPlatformOverride;
  unsigned int mCacheDurationHours;
};

</code></pre></div><h3 id="libraryservice-vtbl"><a href="#libraryservice-vtbl" class="header-anchor">#</a> <code>LibraryService_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LibraryService_vtbl
{
  void (__fastcall *~ServiceClient)(ServiceClient *this);
  void (__fastcall *update)(ServiceClient *this);
  void (__fastcall *_submitRequest)(ServiceClient *this, std::shared_ptr&lt;RequestHandler&gt;);
};

</code></pre></div><h3 id="lessonitem-vtbl"><a href="#lessonitem-vtbl" class="header-anchor">#</a> <code>LessonItem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LessonItem_vtbl
{
  void (__fastcall *~LessonItem)(LessonItem *this);
  bool (__fastcall *isValid)(LessonItem *this);
  void (__fastcall *_createImageInfo)(LessonItem *this);
  const ResourceLocation *(__fastcall *_getImageResourceLocation)(LessonItem *this);
};

</code></pre></div><h3 id="lessonitem-imageinfo"><a href="#lessonitem-imageinfo" class="header-anchor">#</a> <code>LessonItem::ImageInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LessonItem::ImageInfo
{
  std::string mUrl;
  glm::tvec2&lt;int,0&gt; mDimensions;
  std::shared_ptr&lt;ResourceLocation&gt; mResourceLocation;
  bool mFetching;
};

</code></pre></div><h3 id="lessonitemcache"><a href="#lessonitemcache" class="header-anchor">#</a> <code>LessonItemCache</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LessonItemCache : std::enable_shared_from_this&lt;LessonItemCache&gt;
{
  std::mutex mMutex;
  std::unordered_map&lt;std::string,std::weak_ptr&lt;LessonItem&gt;&gt; mActiveItems;
};

</code></pre></div><h3 id="layoutcomponent"><a href="#layoutcomponent" class="header-anchor">#</a> <code>LayoutComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LayoutComponent : UIComponent
{
  std::weak_ptr&lt;LayoutVariables&gt; mAllVariables;
  std::array&lt;std::unique_ptr&lt;LayoutVariable&gt;,11&gt; mControlVariables;
  _BYTE mAnchorFrom[1];
  _BYTE mAnchorTo[1];
  ui::LayoutOffset mOffset;
  ui::LayoutOffset mSize;
  ui::LayoutOffset mMinSize;
  ui::LayoutOffset mMaxSize;
  glm::tvec2&lt;float,0&gt; mOffsetDelta;
  glm::tvec2&lt;float,0&gt; mGridDimensions;
  glm::tvec2&lt;float,0&gt; mDragPosition;
  _BYTE mDraggable[1];
  int mPriority;
  __int8 mIsBeingDragged : 1;
  __int8 mContained : 1;
  __int8 mFollowsCursor : 1;
  __int8 mActive : 1;
  __int8 mInheritMaxSiblingWidth : 1;
  __int8 mInheritMaxSiblingHeight : 1;
  __int8 mIsDelayingLayout : 1;
  __int8 mIsInitialized : 1;
};

</code></pre></div><h3 id="layoutruleterm"><a href="#layoutruleterm" class="header-anchor">#</a> <code>LayoutRuleTerm</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayoutRuleTerm
{
  LayoutRuleTermType mType;
  std::vector&lt;VariableRef&gt; mDependentVariables;
  std::function&lt;float __cdecl(std::vector&lt;VariableRef&gt; const &amp;)&gt; mFunction;
  std::function&lt;float __cdecl(void)&gt; mFactorFunction;
  float mFactor;
  float mConstant;
};

</code></pre></div><h3 id="layoutrule"><a href="#layoutrule" class="header-anchor">#</a> <code>LayoutRule</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayoutRule
{
  std::vector&lt;LayoutRuleTerm&gt; mTerms;
};

</code></pre></div><h3 id="layoutvariable-rulevalue"><a href="#layoutvariable-rulevalue" class="header-anchor">#</a> <code>LayoutVariable::RuleValue</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayoutVariable::RuleValue
{
  float mValue;
  LayoutRule mRule;
};

</code></pre></div><h3 id="layoutvariable-minmaxrulevalue"><a href="#layoutvariable-minmaxrulevalue" class="header-anchor">#</a> <code>LayoutVariable::MinMaxRuleValue</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayoutVariable::MinMaxRuleValue
{
  LayoutVariable::RuleValue mMinValue;
  LayoutVariable::RuleValue mMaxValue;
};

</code></pre></div><h3 id="layoutvariable"><a href="#layoutvariable" class="header-anchor">#</a> <code>LayoutVariable</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LayoutVariable
{
  UIControl *mControl;
  std::vector&lt;VariableRef&gt; mDependsOnMe;
  LayoutVariable::RuleValue mRuleValue;
  std::unique_ptr&lt;LayoutVariable::MinMaxRuleValue&gt; mMinMaxValue;
  LayoutVariableType mType;
  __int8 mIsSatisfied : 1;
  __int8 mIsOverriden : 1;
};

</code></pre></div><h3 id="layoutcomponent-vtbl"><a href="#layoutcomponent-vtbl" class="header-anchor">#</a> <code>LayoutComponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LayoutComponent_vtbl
{
  void (__fastcall *~UIComponent)(UIComponent *this);
  void (__fastcall *OnScreenPop)(UIComponent *this);
  std::unique_ptr&lt;UIComponent&gt; *(__fastcall *clone)(UIComponent *this, std::unique_ptr&lt;UIComponent&gt; *result, UIControl *);
  ComponentReceiveActionType (__fastcall *receive)(UIComponent *this, const ScreenEvent *);
  ComponentReceiveActionType (__fastcall *receive)(UIComponent *this, VisualTree *, ScreenInputContext *, UIAnimationController *, const ScreenEvent *);
  void (__fastcall *onNotifyChildAdded)(UIComponent *this);
  void (__fastcall *onNotifyChildRemoved)(UIComponent *this);
  void (__fastcall *onRemoved)(UIComponent *this);
  void (__fastcall *onAdded)(UIComponent *this);
  void (__fastcall *onVisibilityChanged)(UIComponent *this, bool);
  void (__fastcall *onEnabledChanged)(UIComponent *this, bool);
  bool (__fastcall *isRenderableComponent)(UIComponent *this);
  bool (__fastcall *onLayoutChange)(UIComponent *this);
  void (__fastcall *reset)(UIComponent *this);
  void (__fastcall *reload)(UIComponent *this, const UIComponent *);
  const std::string *(__fastcall *getTextToSpeechComponentValue)(UIComponent *this);
};

</code></pre></div><h3 id="layoutvariables-unsatisfiedvar"><a href="#layoutvariables-unsatisfiedvar" class="header-anchor">#</a> <code>LayoutVariables::UnsatisfiedVar</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LayoutVariables::UnsatisfiedVar
{
  VariableRef mVar;
  bool mIsSatisfied;
};

</code></pre></div><h3 id="layoutvariables"><a href="#layoutvariables" class="header-anchor">#</a> <code>LayoutVariables</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayoutVariables
{
  std::vector&lt;PostOperation&gt; mPostOperations;
  std::vector&lt;LayoutVariables::UnsatisfiedVar&gt; mUnsatisfiedVariables;
};

</code></pre></div><h3 id="layoutmanager"><a href="#layoutmanager" class="header-anchor">#</a> <code>LayoutManager</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayoutManager
{
  std::shared_ptr&lt;LayoutVariables&gt; mVariables;
  glm::tvec2&lt;float,0&gt; mSize;
  std::vector&lt;std::weak_ptr&lt;UIControl&gt;&gt; mDelayedLayout;
};

</code></pre></div><h3 id="localauthentication"><a href="#localauthentication" class="header-anchor">#</a> <code>LocalAuthentication</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LocalAuthentication
{
  PrivateKeyManager mLocalKeys;
  std::unique_ptr&lt;Certificate&gt; mSelfSignedCertificate;
  std::string mSelfSignedId;
};

</code></pre></div><h3 id="libraryrepository"><a href="#libraryrepository" class="header-anchor">#</a> <code>LibraryRepository</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryRepository : ResourcePackListener
{
  std::shared_ptr&lt;EducationContentServices&gt; mServices;
  std::function&lt;ResourcePackManager &amp; __cdecl(void)&gt; mGetResourcePackManager;
  std::unordered_map&lt;std::string,EDULibraryCategory&gt; mLibraryCategories;
};

</code></pre></div><h3 id="libraryrepository-vtbl"><a href="#libraryrepository-vtbl" class="header-anchor">#</a> <code>LibraryRepository_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LibraryRepository_vtbl
{
  void (__fastcall *~ResourcePackListener)(ResourcePackListener *this);
  void (__fastcall *onActiveResourcePacksChanged)(ResourcePackListener *this, ResourcePackManager *);
  void (__fastcall *onFullPackStackInvalid)(ResourcePackListener *this);
  void (__fastcall *onBaseGamePackDownloadComplete)(ResourcePackListener *this);
  void (__fastcall *onLanguageSubpacksChanged)(ResourcePackListener *this);
  void (__fastcall *onResourceManagerDestroyed)(ResourcePackListener *this, ResourcePackManager *);
};

</code></pre></div><h3 id="linearallocator-framerenderobject"><a href="#linearallocator-framerenderobject" class="header-anchor">#</a> <code>LinearAllocator&lt;FrameRenderObject&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LinearAllocator&lt;FrameRenderObject&gt;
{
  std::shared_ptr&lt;AllocatorData&gt; mData;
};

</code></pre></div><h3 id="levelrenderercamera"><a href="#levelrenderercamera" class="header-anchor">#</a> <code>LevelRendererCamera</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera : PlayerListener, LevelListener
{
  unsigned __int64 mChunkQueueSize;
  unsigned __int64 mTerrainChunkQueueSize[3][18];
  std::unordered_multimap&lt;HashedString,Actor *&gt; mEntityRenderQueue;
  SortedMeshDrawList mSortedMeshDrawList;
  std::vector&lt;gsl::not_null&lt;BlockActor *&gt;&gt; mBlockEntityRenderQueue;
  std::vector&lt;gsl::not_null&lt;BlockActor *&gt;&gt; mBlockEntityRenderAlphaQueue;
  std::vector&lt;gsl::not_null&lt;BlockActor *&gt;&gt; mBlockEntityShadowQueue;
  std::vector&lt;gsl::not_null&lt;BlockActor *&gt;&gt; mBlockEntityProcessBarRenderQueue;
  mce::MaterialPtr shadowVolumeBack;
  mce::MaterialPtr shadowVolumeFront;
  mce::MaterialPtr shadowOverlayMat;
  mce::MaterialPtr starsMaterial;
  mce::MaterialPtr skyPlaneMaterial;
  mce::MaterialPtr sunMoonMaterial;
  mce::MaterialPtr endSkyMaterial;
  mce::MaterialPtr cloudMaterial;
  mce::MaterialPtr wireframeMaterial;
  mce::MaterialPtr mCubemapMaterial;
  std::vector&lt;mce::TexturePtr&gt; mCubemapTextures;
  mce::ClientTexture mCubemapTexture;
  OverlayTextureMap mOverlayTextureMap;
  _BYTE mActiveOverlayTextureId[4];
  TerrainMaterialVariationManager mTerrainMaterialVariationManager;
  float mDeltaTime;
  float mLastTime;
  float mWaterLevel;
  glm::tvec2&lt;float,0&gt; mFogControl;
  float mFogBrOriginal;
  float mFogBr;
  float mBaseFogEnd;
  float mBaseFogStart;
  FogDistanceSetting mCurrentDistanceFog;
  FogDistanceSetting mLastTargetDistanceFog;
  FogVolumetricDensitySetting mCurrentFogDensity;
  FogVolumetricCoefficientSetting mAirFogCoefficient;
  FogVolumetricCoefficientSetting mWaterFogCoefficient;
  FogVolumetricCoefficientSetting mCloudFogCoefficient;
  bool mFogWasUnderwaterLastCheck;
  bool mFogWasUnderLavaLastCheck;
  bool mFogWasUnderPowderSnowLastCheck;
  bool mBlendFogThisFrame;
  float mBlindnessLevel;
  const float mRenderDistanceCloudFadeOutMultiplier;
  float mRainPosX;
  float mRainPosY;
  float mRainPosZ;
  int mRainPosSamples;
  int mRainSoundTime;
  int mRainCount;
  float mFakeHDR;
  float mAverageBrightness;
  unsigned int mFrameID;
  int mViewAreaDistance;
  float mFarChunksDistance;
  float mRenderDistance;
  float mCullEndDistance;
  const int mMaxInflightChunks;
  std::shared_ptr&lt;GridArea&lt;std::shared_ptr&lt;RenderChunkInstanced&gt; &gt; &gt; mViewArea;
  BlockPos mLastFaceSortPos;
  Vec3 mLastFaceSortDir;
  Vec3 mLastDirtySortPos;
  BlockPos mLastNearbyFaceSortPos;
  LevelRendererCamera::RenderChunkPosBounds mLastFaceSortBounds;
  Vec3 mLastChunkResortPos;
  Vec3 mCameraPos;
  Vec3 mCameraTargetPos;
  std::shared_ptr&lt;mce::Mesh&gt; mCloudsMesh;
  mce::Camera mWorldSpaceCamera;
  Matrix mSunMatrix;
  Matrix mMoonMatrix;
  glm::tvec3&lt;float,0&gt; mSunDirection;
  glm::tvec3&lt;float,0&gt; mMoonDirection;
  std::unique_ptr&lt;Tessellator&gt; mCloudTessellator;
  std::unique_ptr&lt;TextureTessellator&gt; mCloudTextureTessellator;
  Vec3 mLastCloudUpdatePosition;
  unsigned __int8 mLastCloudSide;
  bool mUpdatingClouds;
  std::vector&lt;Actor *&gt; mWaterHoleEntityQueue;
  std::unique_ptr&lt;WeatherRenderer&gt; mWeatherRenderer;
  std::unique_ptr&lt;ChunkRenderObjectCollection&gt; mChunkRenderObjects;
  std::unique_ptr&lt;Bedrock::Threading::AsyncDeferredResultT&lt;void&gt;&gt; mFrameBuilderChunkRenderObjectsReadyEvent;
  bool mCameraUnderWater;
  bool mCameraUnderLiquid;
  bool mCameraUnderPowderSnow;
  bool mCameraUnderLava;
  bool mCameraInRain;
  bool mShowSky;
  Level *mLevel;
  std::unique_ptr&lt;BlockSource&gt; mViewRegion;
  Dimension *mDimension;
  __int16 mCloudHeight;
  LevelRenderer *mLevelRenderer;
  LevelBuilder mLevelBuilder;
  ResourcePackManager *mResourcePackManager;
  mce::TextureGroup *mTextures;
  std::vector&lt;BlockActor *&gt; mTempBlockEntityList;
  std::weak_ptr&lt;cg::ImageBuffer&gt; mCloudsImage;
  std::unique_ptr&lt;LevelRendererCameraProxy&gt; mProxy;
  ParticleRenderData mParticleRenderData;
  long double mLastFrameTimeStart;
  HistoricalFrameTimes mHistoricalFrameTimes;
  bool mRenderOpacityActor;
  mce::Color mUserDefineEmptyColor;
  std::vector&lt;mce::Color&gt; mUserDefineColors;
};

</code></pre></div><h3 id="levelrenderercommandlistinit"><a href="#levelrenderercommandlistinit" class="header-anchor">#</a> <code>LevelRendererCommandListInit</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LevelRendererCommandListInit
{
  mce::ViewportInfo vp;
  glm::tvec4&lt;int,0&gt; scissor;
  mce::Texture *shadowFrameBuffer;
  mce::FrameBufferObject *frameBuffer;
  mce::RenderTargetState renderTargetState;
};

</code></pre></div><h3 id="levelrenderer"><a href="#levelrenderer" class="header-anchor">#</a> <code>LevelRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRenderer : LevelListener, AppPlatformListener
{
  std::unordered_map&lt;AutomaticID&lt;Dimension,int&gt;,std::unique_ptr&lt;RenderChunkCoordinator&gt;,std::hash&lt;AutomaticID&lt;Dimension,int&gt; &gt;,std::equal_to&lt;AutomaticID&lt;Dimension,int&gt; &gt;,std::allocator&lt;std::pair&lt;AutomaticID&lt;Dimension,int&gt; const ,std::unique_ptr&lt;RenderChunkCoordinator&gt; &gt; &gt; &gt; mRenderChunkCoordinators;
  mce::TextureGroup *mTextures;
  std::shared_ptr&lt;mce::Mesh&gt; mShadowCylinder;
  std::shared_ptr&lt;mce::Mesh&gt; mShadowOverlayCube;
  std::shared_ptr&lt;mce::Mesh&gt; mSkyMesh;
  std::shared_ptr&lt;mce::Mesh&gt; mStarsMesh;
  std::shared_ptr&lt;mce::Mesh&gt; mEndSkyMesh;
  std::shared_ptr&lt;mce::Mesh&gt; mSunMesh;
  std::shared_ptr&lt;mce::Mesh&gt; mMoonMesh[8];
  std::shared_ptr&lt;mce::Mesh&gt; mMilkyWayMesh;
  std::shared_ptr&lt;mce::Mesh&gt; mMeteorMesh[8];
  mce::TexturePtr mAtlasTexture;
  mce::TexturePtr mBrightnessTex;
  mce::TexturePtr mSunTex;
  mce::TexturePtr mMilkyWayTex;
  mce::TexturePtr mMeteorTex;
  mce::TexturePtr mMoonTex;
  mce::TexturePtr mEndSkyTex;
  std::vector&lt;mce::TexturePtr&gt; mCrackFrames;
  DebugRenderer mDebugRenderer;
  Tick mTicks;
  BlockActorRenderDispatcher *mBlockEntityRenderDispatcher;
  std::unique_ptr&lt;BlockTessellator&gt; mLocalRenderer;
  std::unique_ptr&lt;ParticleEngine&gt; mParticleEngine;
  std::unique_ptr&lt;ParticleSystemEngine&gt; mParticleSystemEngine;
  std::unique_ptr&lt;TaskGroup&gt; mTaskGroup;
  std::unique_ptr&lt;TaskGroup&gt; mSyncTaskGroup;
  GameRenderer *mGameRenderer;
  MinecraftGraphics *mMinecraftGraphics;
  Level *mLevel;
  std::shared_ptr&lt;Options&gt; mOptions;
  IClientInstance *mClientInstance;
  LocalPlayer *mLocalPlayer;
  HolographicPlatform *mHolographicPlatform;
  LevelRendererPlayer mLevelRendererPlayer;
  std::unique_ptr&lt;LevelRendererProxy&gt; mProxy;
  mce::Color mClearBufferColor;
  std::weak_ptr&lt;PlayerRenderView&gt; mPlayerView;
};

</code></pre></div><h3 id="levelrendererplayer"><a href="#levelrendererplayer" class="header-anchor">#</a> <code>LevelRendererPlayer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererPlayer : LevelRendererCamera
{
  const float WATER_VISION_QUICK_TIME;
  const float WATER_VISION_MAX_TIME;
  const float WATER_VISION_QUICK_PERCENT;
  Vec3 mComfortRenderAdjustment;
  std::unordered_map&lt;BlockPos,unsigned __int64&gt; mRecordSoundMap;
  std::unordered_map&lt;BlockPos,BlockDestructInfo&gt; mDestroyingBlockList;
  long double mLastDestroyRenderTime;
  std::unordered_map&lt;BlockPos,BlockActorDelayedDeletionInfo&gt; mBlockEntityDelayedDeletionList;
  std::vector&lt;BlockPos&gt; mRemoveBlockEntityTempList;
  float fov;
  float oFov;
  float fovOffset;
  float fovOffsetO;
  PlayerRenderingParameters mRenderingParameters;
  float thirdDistance;
  float thirdDistanceO;
  float thirdRotation;
  float thirdRotationO;
  float thirdTilt;
  float thirdTiltO;
  float cameraRoll;
  float cameraRollO;
  float currentCameraDist;
  float prevHeightOffset;
  float mHeightOffsetAdjustment;
  float mUnderwaterVisionTime;
  float mUnderwaterVisionTimePrevious;
  float mUnderwaterVisionClarity;
  float mUnderwaterVisionScale;
  mce::MaterialPtr selectionBlockEntityOverlayMaterial;
  mce::MaterialPtr selectionBlockEntityOverlayColorMaterial;
  mce::MaterialPtr selectionOverlayMaterial;
  mce::MaterialPtr selectionOpaqueMaterial;
  mce::MaterialPtr selectionTwoSidedMaterial;
  mce::MaterialPtr cracksOverlayMaterial;
  mce::MaterialPtr cracksOverlayAlphaTestMaterial;
  mce::MaterialPtr cracksOverlayBlockEntityMaterial;
  mce::MaterialPtr mOutlineSelectionMaterial;
  const SoundMapping *mSounds;
  std::vector&lt;DeferredSound&gt; mDeferredSounds;
  TextureAtlasItem uvBreakBlockItem;
  IClientInstance *mClientInstance;
  LocalPlayer *mLocalPlayer;
  LevelRenderer *mLevelRenderer;
  Bedrock::NonOwnerPointer&lt;SoundPlayerInterface&gt; mSoundPlayer;
  Level *mLevel;
  HolographicPlatform *mHolographicPlatform;
  std::unique_ptr&lt;AmbientSoundController&gt; mAmbientSoundController;
  std::function&lt;float __cdecl(float,float,float)&gt; mEase;
};

</code></pre></div><h3 id="levelrendererproxycallbacks"><a href="#levelrendererproxycallbacks" class="header-anchor">#</a> <code>LevelRendererProxyCallbacks</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererProxyCallbacks
{
  std::function&lt;RenderChunkCoordinatorProxy * __cdecl(AutomaticID&lt;Dimension,int&gt;)&gt; mGetRenderChunkCoordinator;
  std::function&lt;bool __cdecl(void)&gt; isBuildingRenderChunks;
  std::function&lt;std::shared_ptr&lt;ClientBlockPipeline::SchematicsRepository&gt; __cdecl(void)&gt; getSchematicsRepository;
};

</code></pre></div><h3 id="levelrendererproxy"><a href="#levelrendererproxy" class="header-anchor">#</a> <code>LevelRendererProxy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererProxy
{
  LevelRendererProxyCallbacks mCallbacks;
};

</code></pre></div><h3 id="levelcullerbase"><a href="#levelcullerbase" class="header-anchor">#</a> <code>LevelCullerBase</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelCullerBase
{
  LevelCullerBase_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="levelcullerbase-vtbl"><a href="#levelcullerbase-vtbl" class="header-anchor">#</a> <code>LevelCullerBase_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelCullerBase_vtbl
{
  void (__fastcall *~LevelCullerBase)(LevelCullerBase *this);
  void (__fastcall *handleCullingDutiesThisUpdate)(LevelCullerBase *this, const Vec3 *, const Vec3 *, LevelRendererCamera *);
  void (__fastcall *triggerCull)(LevelCullerBase *this, bool);
  void (__fastcall *getVisibleSubchunks)(LevelCullerBase *this, std::vector&lt;SubChunkPos&gt; *);
  void (__fastcall *resetCullingWorldDimensions)(LevelCullerBase *this, int, const DimensionHeightRange *, int);
  void (__fastcall *changeValidArea)(LevelCullerBase *this, const Bounds *);
  void (__fastcall *updateChunkData)(LevelCullerBase *this, const RenderChunkShared *);
  bool (__fastcall *isBlockPositionVisible)(LevelCullerBase *this, const BlockPos *);
  void (__fastcall *invalidateChunk)(LevelCullerBase *this, const SubChunkPos *);
  void (__fastcall *setEmpty)(LevelCullerBase *this, const SubChunkPos *, bool);
  bool (__fastcall *isBusy)(LevelCullerBase *this);
  bool (__fastcall *shouldRecullAfterChunkChange)(LevelCullerBase *this, const RenderChunkShared *);
  unsigned int (__fastcall *getCullIteration)(LevelCullerBase *this);
};

</code></pre></div><h3 id="levelbuilder-positionandpriority"><a href="#levelbuilder-positionandpriority" class="header-anchor">#</a> <code>LevelBuilder::PositionAndPriority</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelBuilder::PositionAndPriority
{
  SubChunkPos mPosition;
  int mPriority;
};

</code></pre></div><h3 id="levelbuilder"><a href="#levelbuilder" class="header-anchor">#</a> <code>LevelBuilder</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelBuilder
{
  int maxCullingSteps;
  int numDirtyChunks;
  int numDirtyChunksPrevFrame;
  const int mMaxInflightChunks;
  bool bCheckRightCuller;
  bool mEnforceInterlocks;
  FrustumCuller mLeftFrustumCuller;
  FrustumCuller mRightFrustumCuller;
  std::unique_ptr&lt;ChunkVisibilityCache&gt; mChunkVisibilityCache;
  std::shared_ptr&lt;LevelCullerBase&gt; mLevelCuller;
  FrustumCullerType mFrustumCullerType;
  Vec3 mLastCameraPos;
  Vec3 mLastCameraDir;
  Vec3 mLastAreaCenter;
  float mLastFogEnd;
  float mLastSunAngle;
  int mViewAreaSide;
  __int16 mViewAreaHeight;
  PolygonOperatorPool&lt;RenderChunkBuilder&gt; mBuilders;
  PolygonOperatorPool&lt;RenderChunkSorter&gt; mSorters;
  LevelRenderer *mLevelRenderer;
  LevelRendererCamera *mLevelRendererCamera;
  MPMCQueue&lt;SubChunkPos&gt; mRenderChunksToBuild;
  std::vector&lt;SubChunkPos&gt; mRenderChunksToBuildEraseList;
  std::queue&lt;std::shared_ptr&lt;RenderChunkShared&gt;&gt; mRenderChunksToUpload;
  SpinLock mRenderChunksFinishedBuildingSpinLock;
  std::atomic&lt;int&gt; mImmediateChunkInFlightCount;
  std::vector&lt;SubChunkPos&gt; mRenderChunksToQueryForCuller;
  SpinLock mRenderChunksToQueryForCullerLock;
  std::vector&lt;RenderChunkInstanced *&gt; mSortedRenderChunkInstancedList;
  std::vector&lt;LevelBuilder::PositionAndPriority&gt; mSortedList;
  std::vector&lt;SubChunkPos&gt; mRenderChunksVisibleFromCullingPoint;
  std::unordered_set&lt;SubChunkPos&gt; mInterlockedRenderChunksToCheck;
  std::unordered_set&lt;SubChunkPos&gt; mInterlockGraphWalkSet;
  std::vector&lt;SubChunkPos&gt; mInterlockGraphWalkToCheckList;
  std::unordered_set&lt;SubChunkPos&gt; mExtraChunksToDrawUntilNextCull;
  std::vector&lt;SubChunkPos&gt; mExtraChunksToDrawUntilNextCullEraseList;
  unsigned int mLastCullIteration;
  unsigned __int64 mLastNumRenderChunksVisibleFromCullingPoint;
  bool mForceCulling;
  bool mRecullWhenNotBusy;
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mLastTimeRenderChunksBeingBuilt;
  std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; mBuilderTask;
  LevelCullerType mLastCullerType;
  std::shared_ptr&lt;RenderChunkSorterSharedInfo&gt; mSharedSortInfo;
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mCurrentTime;
};

</code></pre></div><h3 id="levelrenderercameraproxycallbacks"><a href="#levelrenderercameraproxycallbacks" class="header-anchor">#</a> <code>LevelRendererCameraProxyCallbacks</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCameraProxyCallbacks
{
  std::function&lt;RenderChunkCoordinatorProxy * __cdecl(AutomaticID&lt;Dimension,int&gt;)&gt; mGetRenderChunkCoordinator;
};

</code></pre></div><h3 id="levelrenderercameraproxy"><a href="#levelrenderercameraproxy" class="header-anchor">#</a> <code>LevelRendererCameraProxy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCameraProxy
{
  LevelRendererCameraProxyCallbacks mCallbacks;
};

</code></pre></div><h3 id="levelrenderercamera-vtbl"><a href="#levelrenderercamera-vtbl" class="header-anchor">#</a> <code>LevelRendererCamera_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelRendererCamera_vtbl
{
  void (__fastcall *~PlayerListener)(PlayerListener *this);
  void (__fastcall *onWillChangeDimension)(PlayerListener *this, Player *);
  void (__fastcall *onDimensionChanged)(PlayerListener *this, Player *);
  void (__fastcall *onPlayerDestruction)(PlayerListener *this, Player *);
  void (__fastcall *addCameraListenerToRenderChunkCoordinator)(LevelRendererCamera *this);
  void (__fastcall *onAppSuspended)(LevelRendererCamera *this);
  void (__fastcall *onAppResumed)(LevelRendererCamera *this);
  void (__fastcall *onDeviceLost)(LevelRendererCamera *this);
  void (__fastcall *onLowMemory)(LevelRendererCamera *this);
  void (__fastcall *tickLevelRendererCamera)(LevelRendererCamera *this);
  void (__fastcall *tickRain)(LevelRendererCamera *this);
  void (__fastcall *callRenderNameTags)(LevelRendererCamera *this, ScreenContext *, const ViewRenderObject *, Font *);
  NameTagRenderObjectCollection *(__fastcall *extractNameTags)(LevelRendererCamera *this, NameTagRenderObjectCollection *result, ScreenContext *);
  void (__fastcall *callRenderCracks)(LevelRendererCamera *this, BaseActorRenderContext *, const ViewRenderObject *);
  CrackRenderObjectCollection *(__fastcall *extractCracks)(LevelRendererCamera *this, CrackRenderObjectCollection *result, ScreenContext *);
  void (__fastcall *renderEntityEffects)(LevelRendererCamera *this, BaseActorRenderContext *);
  void (__fastcall *renderBlockEntities)(LevelRendererCamera *this, BaseActorRenderContext *, bool);
  void (__fastcall *renderBindEffects)(LevelRendererCamera *this, BaseActorRenderContext *);
  void (__fastcall *renderFonts)(LevelRendererCamera *this, BaseActorRenderContext *);
  void (__fastcall *renderHealth)(LevelRendererCamera *this, BaseActorRenderContext *, const ViewRenderData *);
  void (__fastcall *renderProcessBar)(LevelRendererCamera *this, BaseActorRenderContext *, const ViewRenderData *);
  void (__fastcall *renderHolographicCursor)(LevelRendererCamera *this, ScreenContext *);
  void (__fastcall *renderVRHitFlash)(LevelRendererCamera *this, ScreenContext *);
  bool (__fastcall *getForceFog)(LevelRendererCamera *this, const Actor *);
  void (__fastcall *setupFog)(LevelRendererCamera *this, ScreenContext *, const float);
  float (__fastcall *getAmbientBrightness)(LevelRendererCamera *this);
  void (__fastcall *preRenderUpdate)(LevelRendererCamera *this, ScreenContext *, LevelRenderPreRenderUpdateParameters *);
  void (__fastcall *render)(LevelRendererCamera *this, BaseActorRenderContext *, const ViewRenderObject *, IClientInstance *, LevelRendererCommandListInit *);
  void (__fastcall *postRenderUpdate)(LevelRendererCamera *this);
  bool (__fastcall *isPositionTooCloseToCamera)(LevelRendererCamera *this, const Vec3 *);
  void (__fastcall *blockEntityAboutToBeRemoved)(LevelRendererCamera *this, BlockSource *, std::shared_ptr&lt;BlockActor&gt;);
  void (__fastcall *notifyGeoChangedForAffectedEntities)(LevelRendererCamera *this, RenderChunkShared *, unsigned __int8);
  void (__fastcall *queueRenderEntities)(LevelRendererCamera *this, const LevelRenderPreRenderUpdateParameters *);
  const Block *(__fastcall *_getBlockForBlockEnity)(LevelRendererCamera *this, const BlockActor *);
  void (__fastcall *_fetchAdditionalBlockEntities)(LevelRendererCamera *this, std::vector&lt;BlockActor *&gt; *);
  FogDefinition::DistanceSettingType (__fastcall *_getFogDistanceSettingType)(LevelRendererCamera *this);
  FogDefinition::DensitySettingType (__fastcall *_getFogDensitySettingType)(LevelRendererCamera *this);
};

</code></pre></div><h3 id="levelrendererplayer-vtbl"><a href="#levelrendererplayer-vtbl" class="header-anchor">#</a> <code>LevelRendererPlayer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelRendererPlayer_vtbl
{
  void (__fastcall *~PlayerListener)(PlayerListener *this);
  void (__fastcall *onWillChangeDimension)(PlayerListener *this, Player *);
  void (__fastcall *onDimensionChanged)(PlayerListener *this, Player *);
  void (__fastcall *onPlayerDestruction)(PlayerListener *this, Player *);
  void (__fastcall *addCameraListenerToRenderChunkCoordinator)(LevelRendererCamera *this);
  void (__fastcall *onAppSuspended)(LevelRendererCamera *this);
  void (__fastcall *onAppResumed)(LevelRendererCamera *this);
  void (__fastcall *onDeviceLost)(LevelRendererCamera *this);
  void (__fastcall *onLowMemory)(LevelRendererCamera *this);
  void (__fastcall *tickLevelRendererCamera)(LevelRendererCamera *this);
  void (__fastcall *tickRain)(LevelRendererCamera *this);
  void (__fastcall *callRenderNameTags)(LevelRendererCamera *this, ScreenContext *, const ViewRenderObject *, Font *);
  NameTagRenderObjectCollection *(__fastcall *extractNameTags)(LevelRendererCamera *this, NameTagRenderObjectCollection *result, ScreenContext *);
  void (__fastcall *callRenderCracks)(LevelRendererCamera *this, BaseActorRenderContext *, const ViewRenderObject *);
  CrackRenderObjectCollection *(__fastcall *extractCracks)(LevelRendererCamera *this, CrackRenderObjectCollection *result, ScreenContext *);
  void (__fastcall *renderEntityEffects)(LevelRendererCamera *this, BaseActorRenderContext *);
  void (__fastcall *renderBlockEntities)(LevelRendererCamera *this, BaseActorRenderContext *, bool);
  void (__fastcall *renderBindEffects)(LevelRendererCamera *this, BaseActorRenderContext *);
  void (__fastcall *renderFonts)(LevelRendererCamera *this, BaseActorRenderContext *);
  void (__fastcall *renderHealth)(LevelRendererCamera *this, BaseActorRenderContext *, const ViewRenderData *);
  void (__fastcall *renderProcessBar)(LevelRendererCamera *this, BaseActorRenderContext *, const ViewRenderData *);
  void (__fastcall *renderHolographicCursor)(LevelRendererCamera *this, ScreenContext *);
  void (__fastcall *renderVRHitFlash)(LevelRendererCamera *this, ScreenContext *);
  bool (__fastcall *getForceFog)(LevelRendererCamera *this, const Actor *);
  void (__fastcall *setupFog)(LevelRendererCamera *this, ScreenContext *, const float);
  float (__fastcall *getAmbientBrightness)(LevelRendererCamera *this);
  void (__fastcall *preRenderUpdate)(LevelRendererCamera *this, ScreenContext *, LevelRenderPreRenderUpdateParameters *);
  void (__fastcall *render)(LevelRendererCamera *this, BaseActorRenderContext *, const ViewRenderObject *, IClientInstance *, LevelRendererCommandListInit *);
  void (__fastcall *postRenderUpdate)(LevelRendererCamera *this);
  bool (__fastcall *isPositionTooCloseToCamera)(LevelRendererCamera *this, const Vec3 *);
  void (__fastcall *blockEntityAboutToBeRemoved)(LevelRendererCamera *this, BlockSource *, std::shared_ptr&lt;BlockActor&gt;);
  void (__fastcall *notifyGeoChangedForAffectedEntities)(LevelRendererCamera *this, RenderChunkShared *, unsigned __int8);
  void (__fastcall *queueRenderEntities)(LevelRendererCamera *this, const LevelRenderPreRenderUpdateParameters *);
  const Block *(__fastcall *_getBlockForBlockEnity)(LevelRendererCamera *this, const BlockActor *);
  void (__fastcall *_fetchAdditionalBlockEntities)(LevelRendererCamera *this, std::vector&lt;BlockActor *&gt; *);
  FogDefinition::DistanceSettingType (__fastcall *_getFogDistanceSettingType)(LevelRendererCamera *this);
  FogDefinition::DensitySettingType (__fastcall *_getFogDensitySettingType)(LevelRendererCamera *this);
  float (__fastcall *getUnderwaterVisionClarity)(LevelRendererPlayer *this);
};

</code></pre></div><h3 id="lessonactiondata"><a href="#lessonactiondata" class="header-anchor">#</a> <code>LessonActionData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj LessonActionData
{
  _BYTE lessonAction[1];
  std::string source;
};

</code></pre></div><h3 id="lessonprogressionservice"><a href="#lessonprogressionservice" class="header-anchor">#</a> <code>LessonProgressionService</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LessonProgressionService : ServiceClient, ILessonProgressionService
{
  const std::string mHostUrl;
  LessonInfo mLessonInfo;
  std::string mUserToken;
};

</code></pre></div><h3 id="lessonprogressionservice-vtbl"><a href="#lessonprogressionservice-vtbl" class="header-anchor">#</a> <code>LessonProgressionService_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LessonProgressionService_vtbl
{
  void (__fastcall *~ServiceClient)(ServiceClient *this);
  void (__fastcall *update)(ServiceClient *this);
  void (__fastcall *_submitRequest)(ServiceClient *this, std::shared_ptr&lt;RequestHandler&gt;);
};

</code></pre></div><h3 id="libraryitemscreencapabilities"><a href="#libraryitemscreencapabilities" class="header-anchor">#</a> <code>LibraryItemScreenCapabilities</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LibraryItemScreenCapabilities : TypedScreenCapabilities&lt;LibraryItemScreenCapabilities&gt;
{
  bool mShareLinkIgnored;
};

</code></pre></div><h3 id="libraryitemscreencapabilities-vtbl"><a href="#libraryitemscreencapabilities-vtbl" class="header-anchor">#</a> <code>LibraryItemScreenCapabilities_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LibraryItemScreenCapabilities_vtbl
{
  void (__fastcall *~IScreenCapabilities)(IScreenCapabilities *this);
  bool (__fastcall *isOfType)(IScreenCapabilities *this, typeid_t&lt;IScreenCapabilities&gt;);
};

</code></pre></div><h3 id="levelloader"><a href="#levelloader" class="header-anchor">#</a> <code>LevelLoader</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LevelLoader : Bedrock::EnableNonOwnerReferences
{
  IMinecraftGame *mMinecraft;
  std::shared_ptr&lt;ImportLevelData&gt; mQueuedImportLoad;
  std::vector&lt;ImportLevelData&gt; mLevelImportQueue;
  std::unique_ptr&lt;LevelSummary&gt; mLevelToLoad;
  std::atomic&lt;bool&gt; mPendingLoadRequest;
  std::string mRealmToLoad;
  std::atomic&lt;bool&gt; mLoadingRealmLink;
};

</code></pre></div><h3 id="latencygraphdisplay-measurement"><a href="#latencygraphdisplay-measurement" class="header-anchor">#</a> <code>LatencyGraphDisplay::Measurement</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LatencyGraphDisplay::Measurement
{
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mTimePoint;
  std::chrono::duration&lt;__int64,std::ratio&lt;1,1000&gt; &gt; mLatency;
};

</code></pre></div><h3 id="latencygraphdisplay"><a href="#latencygraphdisplay" class="header-anchor">#</a> <code>LatencyGraphDisplay</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LatencyGraphDisplay
{
  NetworkHandler *mNetworkHandler;
  RectangleArea mArea;
  bool mIsInGame;
  std::vector&lt;LatencyGraphDisplay::Measurement&gt; mLatencyMeasurements;
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mLastLatencyUpdate;
};

</code></pre></div><h3 id="loadingscreen"><a href="#loadingscreen" class="header-anchor">#</a> <code>LoadingScreen</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LoadingScreen
{
  cg::ImageDescription mLoadingScreenImageDescription;
  float mWaveSeconds;
  long double mLastTimeStamp;
};

</code></pre></div><h3 id="leveldb-env"><a href="#leveldb-env" class="header-anchor">#</a> <code>leveldb::Env</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj leveldb::Env
{
  leveldb::Env_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="leveldb-sequentialfile"><a href="#leveldb-sequentialfile" class="header-anchor">#</a> <code>leveldb::SequentialFile</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj leveldb::SequentialFile
{
  leveldb::SequentialFile_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="leveldb-sequentialfile-vtbl"><a href="#leveldb-sequentialfile-vtbl" class="header-anchor">#</a> <code>leveldb::SequentialFile_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ leveldb::SequentialFile_vtbl
{
  void (__fastcall *~SequentialFile)(leveldb::SequentialFile *this);
  leveldb::Status *(__fastcall *Read)(leveldb::SequentialFile *this, leveldb::Status *result, unsigned __int64, leveldb::Slice *, char *);
  leveldb::Status *(__fastcall *Skip)(leveldb::SequentialFile *this, leveldb::Status *result, unsigned __int64);
};

</code></pre></div><h3 id="leveldb-randomaccessfile"><a href="#leveldb-randomaccessfile" class="header-anchor">#</a> <code>leveldb::RandomAccessFile</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj leveldb::RandomAccessFile
{
  leveldb::RandomAccessFile_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="leveldb-randomaccessfile-vtbl"><a href="#leveldb-randomaccessfile-vtbl" class="header-anchor">#</a> <code>leveldb::RandomAccessFile_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ leveldb::RandomAccessFile_vtbl
{
  void (__fastcall *~RandomAccessFile)(leveldb::RandomAccessFile *this);
  leveldb::Status *(__fastcall *Read)(leveldb::RandomAccessFile *this, leveldb::Status *result, unsigned __int64, unsigned __int64, leveldb::Slice *, char *);
};

</code></pre></div><h3 id="leveldb-writablefile"><a href="#leveldb-writablefile" class="header-anchor">#</a> <code>leveldb::WritableFile</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj leveldb::WritableFile
{
  leveldb::WritableFile_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="leveldb-writablefile-vtbl"><a href="#leveldb-writablefile-vtbl" class="header-anchor">#</a> <code>leveldb::WritableFile_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ leveldb::WritableFile_vtbl
{
  void (__fastcall *~WritableFile)(leveldb::WritableFile *this);
  leveldb::Status *(__fastcall *Append)(leveldb::WritableFile *this, leveldb::Status *result, const leveldb::Slice *);
  leveldb::Status *(__fastcall *Close)(leveldb::WritableFile *this, leveldb::Status *result);
  leveldb::Status *(__fastcall *Flush)(leveldb::WritableFile *this, leveldb::Status *result);
  leveldb::Status *(__fastcall *Sync)(leveldb::WritableFile *this, leveldb::Status *result);
};

</code></pre></div><h3 id="leveldb-filelock"><a href="#leveldb-filelock" class="header-anchor">#</a> <code>leveldb::FileLock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj leveldb::FileLock
{
  leveldb::FileLock_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="leveldb-filelock-vtbl"><a href="#leveldb-filelock-vtbl" class="header-anchor">#</a> <code>leveldb::FileLock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ leveldb::FileLock_vtbl
{
  void (__fastcall *~FileLock)(leveldb::FileLock *this);
};

</code></pre></div><h3 id="leveldb-logger-vtbl"><a href="#leveldb-logger-vtbl" class="header-anchor">#</a> <code>leveldb::Logger_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ leveldb::Logger_vtbl
{
  void (__fastcall *~Logger)(leveldb::Logger *this);
  void (__fastcall *Logv)(leveldb::Logger *this, const char *, char *);
};

</code></pre></div><h3 id="leveldb-env-vtbl"><a href="#leveldb-env-vtbl" class="header-anchor">#</a> <code>leveldb::Env_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ leveldb::Env_vtbl
{
  void (__fastcall *~Env)(leveldb::Env *this);
  leveldb::Status *(__fastcall *NewSequentialFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::SequentialFile **);
  leveldb::Status *(__fastcall *NewRandomAccessFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::RandomAccessFile **);
  leveldb::Status *(__fastcall *NewWritableFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::WritableFile **);
  leveldb::Status *(__fastcall *NewAppendableFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::WritableFile **);
  bool (__fastcall *FileExists)(leveldb::Env *this, const std::string *);
  leveldb::Status *(__fastcall *GetChildren)(leveldb::Env *this, leveldb::Status *result, const std::string *, std::vector&lt;std::string&gt; *);
  leveldb::Status *(__fastcall *DeleteFileA)(leveldb::Env *this, leveldb::Status *result, const std::string *);
  leveldb::Status *(__fastcall *CreateDir)(leveldb::Env *this, leveldb::Status *result, const std::string *);
  leveldb::Status *(__fastcall *DeleteDir)(leveldb::Env *this, leveldb::Status *result, const std::string *);
  leveldb::Status *(__fastcall *GetFileSize)(leveldb::Env *this, leveldb::Status *result, const std::string *, unsigned __int64 *);
  leveldb::Status *(__fastcall *RenameFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, const std::string *);
  leveldb::Status *(__fastcall *LockFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::FileLock **);
  leveldb::Status *(__fastcall *UnlockFile)(leveldb::Env *this, leveldb::Status *result, leveldb::FileLock *);
  void (__fastcall *Schedule)(leveldb::Env *this, void (__fastcall *)(void *), void *);
  void (__fastcall *StartThread)(leveldb::Env *this, void (__fastcall *)(void *), void *);
  leveldb::Status *(__fastcall *GetTestDirectory)(leveldb::Env *this, leveldb::Status *result, std::string *);
  leveldb::Status *(__fastcall *NewLogger)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::Logger **);
  unsigned __int64 (__fastcall *NowMicros)(leveldb::Env *this);
  void (__fastcall *SleepForMicroseconds)(leveldb::Env *this, int);
};

</code></pre></div><h3 id="leveldb-envwrapper"><a href="#leveldb-envwrapper" class="header-anchor">#</a> <code>leveldb::EnvWrapper</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj leveldb::EnvWrapper : leveldb::Env
{
  leveldb::Env *target_;
};

</code></pre></div><h3 id="leveldb-envwrapper-vtbl"><a href="#leveldb-envwrapper-vtbl" class="header-anchor">#</a> <code>leveldb::EnvWrapper_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ leveldb::EnvWrapper_vtbl
{
  void (__fastcall *~Env)(leveldb::Env *this);
  leveldb::Status *(__fastcall *NewSequentialFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::SequentialFile **);
  leveldb::Status *(__fastcall *NewRandomAccessFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::RandomAccessFile **);
  leveldb::Status *(__fastcall *NewWritableFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::WritableFile **);
  leveldb::Status *(__fastcall *NewAppendableFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::WritableFile **);
  bool (__fastcall *FileExists)(leveldb::Env *this, const std::string *);
  leveldb::Status *(__fastcall *GetChildren)(leveldb::Env *this, leveldb::Status *result, const std::string *, std::vector&lt;std::string&gt; *);
  leveldb::Status *(__fastcall *DeleteFileA)(leveldb::Env *this, leveldb::Status *result, const std::string *);
  leveldb::Status *(__fastcall *CreateDir)(leveldb::Env *this, leveldb::Status *result, const std::string *);
  leveldb::Status *(__fastcall *DeleteDir)(leveldb::Env *this, leveldb::Status *result, const std::string *);
  leveldb::Status *(__fastcall *GetFileSize)(leveldb::Env *this, leveldb::Status *result, const std::string *, unsigned __int64 *);
  leveldb::Status *(__fastcall *RenameFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, const std::string *);
  leveldb::Status *(__fastcall *LockFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::FileLock **);
  leveldb::Status *(__fastcall *UnlockFile)(leveldb::Env *this, leveldb::Status *result, leveldb::FileLock *);
  void (__fastcall *Schedule)(leveldb::Env *this, void (__fastcall *)(void *), void *);
  void (__fastcall *StartThread)(leveldb::Env *this, void (__fastcall *)(void *), void *);
  leveldb::Status *(__fastcall *GetTestDirectory)(leveldb::Env *this, leveldb::Status *result, std::string *);
  leveldb::Status *(__fastcall *NewLogger)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::Logger **);
  unsigned __int64 (__fastcall *NowMicros)(leveldb::Env *this);
  void (__fastcall *SleepForMicroseconds)(leveldb::Env *this, int);
};

</code></pre></div><h3 id="leveldb-cache"><a href="#leveldb-cache" class="header-anchor">#</a> <code>leveldb::Cache</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj leveldb::Cache
{
  leveldb::Cache_vtbl *__vftable /*VFT*/;
  struct leveldb::Cache::Rep *rep_;
};

</code></pre></div><h3 id="leveldb-cache-handle"><a href="#leveldb-cache-handle" class="header-anchor">#</a> <code>leveldb::Cache::Handle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj leveldb::Cache::Handle
{
};

</code></pre></div><h3 id="leveldb-cache-vtbl"><a href="#leveldb-cache-vtbl" class="header-anchor">#</a> <code>leveldb::Cache_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ leveldb::Cache_vtbl
{
  void (__fastcall *~Cache)(leveldb::Cache *this);
  leveldb::Cache::Handle *(__fastcall *Insert)(leveldb::Cache *this, const leveldb::Slice *, void *, unsigned __int64, void (__fastcall *)(const leveldb::Slice *, void *));
  leveldb::Cache::Handle *(__fastcall *Lookup)(leveldb::Cache *this, const leveldb::Slice *);
  void (__fastcall *Release)(leveldb::Cache *this, leveldb::Cache::Handle *);
  void *(__fastcall *Value)(leveldb::Cache *this, leveldb::Cache::Handle *);
  void (__fastcall *Erase)(leveldb::Cache *this, const leveldb::Slice *);
  unsigned __int64 (__fastcall *NewId)(leveldb::Cache *this);
  void (__fastcall *Prune)(leveldb::Cache *this);
  unsigned __int64 (__fastcall *TotalCharge)(leveldb::Cache *this);
};

</code></pre></div><h3 id="leveldb-filterpolicy-vtbl"><a href="#leveldb-filterpolicy-vtbl" class="header-anchor">#</a> <code>leveldb::FilterPolicy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ leveldb::FilterPolicy_vtbl
{
  void (__fastcall *~FilterPolicy)(leveldb::FilterPolicy *this);
  const char *(__fastcall *Name)(leveldb::FilterPolicy *this);
  void (__fastcall *CreateFilter)(leveldb::FilterPolicy *this, const leveldb::Slice *, int, std::string *);
  bool (__fastcall *KeyMayMatch)(leveldb::FilterPolicy *this, const leveldb::Slice *, const leveldb::Slice *);
};

</code></pre></div><h3 id="leveldb-compressor-vtbl"><a href="#leveldb-compressor-vtbl" class="header-anchor">#</a> <code>leveldb::Compressor_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ leveldb::Compressor_vtbl
{
  void (__fastcall *~Compressor)(leveldb::Compressor *this);
  void (__fastcall *compressImpl)(leveldb::Compressor *this, const char *, unsigned __int64, std::string *);
  bool (__fastcall *decompress)(leveldb::Compressor *this, const char *, unsigned __int64, std::string *);
};

</code></pre></div><h3 id="leveldb-comparator-vtbl"><a href="#leveldb-comparator-vtbl" class="header-anchor">#</a> <code>leveldb::Comparator_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ leveldb::Comparator_vtbl
{
  void (__fastcall *~Comparator)(leveldb::Comparator *this);
  int (__fastcall *Compare)(leveldb::Comparator *this, const leveldb::Slice *, const leveldb::Slice *);
  const char *(__fastcall *Name)(leveldb::Comparator *this);
  void (__fastcall *FindShortestSeparator)(leveldb::Comparator *this, std::string *, const leveldb::Slice *);
  void (__fastcall *FindShortSuccessor)(leveldb::Comparator *this, std::string *);
};

</code></pre></div><h3 id="leveldb-snapshot"><a href="#leveldb-snapshot" class="header-anchor">#</a> <code>leveldb::Snapshot</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj leveldb::Snapshot
{
  leveldb::Snapshot_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="leveldb-snapshot-vtbl"><a href="#leveldb-snapshot-vtbl" class="header-anchor">#</a> <code>leveldb::Snapshot_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ leveldb::Snapshot_vtbl
{
  void (__fastcall *~Snapshot)(leveldb::Snapshot *this);
};

</code></pre></div><h3 id="leveldb-decompressallocator"><a href="#leveldb-decompressallocator" class="header-anchor">#</a> <code>leveldb::DecompressAllocator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj leveldb::DecompressAllocator
{
  leveldb::DecompressAllocator_vtbl *__vftable /*VFT*/;
  std::mutex mutex;
  std::vector&lt;std::string&gt; stack;
};

</code></pre></div><h3 id="leveldb-decompressallocator-vtbl"><a href="#leveldb-decompressallocator-vtbl" class="header-anchor">#</a> <code>leveldb::DecompressAllocator_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ leveldb::DecompressAllocator_vtbl
{
  void (__fastcall *~DecompressAllocator)(leveldb::DecompressAllocator *this);
  std::string *(__fastcall *get)(leveldb::DecompressAllocator *this, std::string *result);
  void (__fastcall *release)(leveldb::DecompressAllocator *this, std::string *);
  void (__fastcall *prune)(leveldb::DecompressAllocator *this);
};

</code></pre></div><h3 id="leveldb-writeoptions"><a href="#leveldb-writeoptions" class="header-anchor">#</a> <code>leveldb::WriteOptions</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj leveldb::WriteOptions
{
  bool sync;
};

</code></pre></div><h3 id="leveldb-db"><a href="#leveldb-db" class="header-anchor">#</a> <code>leveldb::DB</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj leveldb::DB
{
  leveldb::DB_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="leveldb-writebatch"><a href="#leveldb-writebatch" class="header-anchor">#</a> <code>leveldb::WriteBatch</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj leveldb::WriteBatch
{
  std::string rep_;
};

</code></pre></div><h3 id="leveldb-iterator"><a href="#leveldb-iterator" class="header-anchor">#</a> <code>leveldb::Iterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj leveldb::Iterator
{
  leveldb::Iterator_vtbl *__vftable /*VFT*/;
  leveldb::Iterator::Cleanup cleanup_;
};

</code></pre></div><h3 id="leveldb-iterator-vtbl"><a href="#leveldb-iterator-vtbl" class="header-anchor">#</a> <code>leveldb::Iterator_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ leveldb::Iterator_vtbl
{
  void (__fastcall *~Iterator)(leveldb::Iterator *this);
  bool (__fastcall *Valid)(leveldb::Iterator *this);
  void (__fastcall *SeekToFirst)(leveldb::Iterator *this);
  void (__fastcall *SeekToLast)(leveldb::Iterator *this);
  void (__fastcall *Seek)(leveldb::Iterator *this, const leveldb::Slice *);
  void (__fastcall *Next)(leveldb::Iterator *this);
  void (__fastcall *Prev)(leveldb::Iterator *this);
  leveldb::Slice *(__fastcall *key)(leveldb::Iterator *this, leveldb::Slice *result);
  leveldb::Slice *(__fastcall *value)(leveldb::Iterator *this, leveldb::Slice *result);
  leveldb::Status *(__fastcall *status)(leveldb::Iterator *this, leveldb::Status *result);
};

</code></pre></div><h3 id="leveldb-iterator-cleanup"><a href="#leveldb-iterator-cleanup" class="header-anchor">#</a> <code>leveldb::Iterator::Cleanup</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct leveldb::Iterator::Cleanup
{
  void (__fastcall *function)(void *, void *);
  void *arg1;
  void *arg2;
  leveldb::Iterator::Cleanup *next;
};

</code></pre></div><h3 id="leveldb-range"><a href="#leveldb-range" class="header-anchor">#</a> <code>leveldb::Range</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj leveldb::Range
{
  leveldb::Slice start;
  leveldb::Slice limit;
};

</code></pre></div><h3 id="leveldb-db-vtbl"><a href="#leveldb-db-vtbl" class="header-anchor">#</a> <code>leveldb::DB_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ leveldb::DB_vtbl
{
  void (__fastcall *~DB)(leveldb::DB *this);
  leveldb::Status *(__fastcall *Put)(leveldb::DB *this, leveldb::Status *result, const leveldb::WriteOptions *, const leveldb::Slice *, const leveldb::Slice *);
  leveldb::Status *(__fastcall *Delete)(leveldb::DB *this, leveldb::Status *result, const leveldb::WriteOptions *, const leveldb::Slice *);
  leveldb::Status *(__fastcall *Write)(leveldb::DB *this, leveldb::Status *result, const leveldb::WriteOptions *, leveldb::WriteBatch *);
  leveldb::Status *(__fastcall *Get)(leveldb::DB *this, leveldb::Status *result, const leveldb::ReadOptions *, const leveldb::Slice *, std::string *);
  leveldb::Iterator *(__fastcall *NewIterator)(leveldb::DB *this, const leveldb::ReadOptions *);
  const leveldb::Snapshot *(__fastcall *GetSnapshot)(leveldb::DB *this);
  void (__fastcall *ReleaseSnapshot)(leveldb::DB *this, const leveldb::Snapshot *);
  bool (__fastcall *GetProperty)(leveldb::DB *this, const leveldb::Slice *, std::string *);
  void (__fastcall *GetApproximateSizes)(leveldb::DB *this, const leveldb::Range *, int, unsigned __int64 *);
  void (__fastcall *CompactRange)(leveldb::DB *this, const leveldb::Slice *, const leveldb::Slice *);
  void (__fastcall *SuspendCompaction)(leveldb::DB *this);
  void (__fastcall *ResumeCompaction)(leveldb::DB *this);
};

</code></pre></div><h3 id="listenerinfo"><a href="#listenerinfo" class="header-anchor">#</a> <code>ListenerInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ListenerInfo
{
  std::function&lt;void __cdecl(BlockPos const &amp;,unsigned int,Block const &amp;)&gt; mCallback;
  Vec3 mPosition;
  float mRadiusSqr;
};

</code></pre></div><h3 id="levelchunkgarbagecollector"><a href="#levelchunkgarbagecollector" class="header-anchor">#</a> <code>LevelChunkGarbageCollector</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelChunkGarbageCollector
{
  Dimension *mDimension;
  MPMCQueue&lt;std::unique_ptr&lt;LevelChunk,LevelChunkFinalDeleter&gt; &gt; mLevelChunksToDiscard;
  std::atomic&lt;unsigned __int64&gt; mPendingDeletes;
};

</code></pre></div><h3 id="lootitemfunction"><a href="#lootitemfunction" class="header-anchor">#</a> <code>LootItemFunction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LootItemFunction
{
  LootItemFunction_vtbl *__vftable /*VFT*/;
  std::vector&lt;std::unique_ptr&lt;LootItemCondition&gt;&gt; mPredicates;
};

</code></pre></div><h3 id="lootpoolentry"><a href="#lootpoolentry" class="header-anchor">#</a> <code>LootPoolEntry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LootPoolEntry
{
  LootPoolEntry_vtbl *__vftable /*VFT*/;
  int mWeight;
  int mQuality;
  std::vector&lt;std::unique_ptr&lt;LootItemCondition&gt;&gt; mConditions;
  std::unique_ptr&lt;LootPoolEntry&gt; mSubTable;
};

</code></pre></div><h3 id="lootpoolentry-vtbl"><a href="#lootpoolentry-vtbl" class="header-anchor">#</a> <code>LootPoolEntry_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LootPoolEntry_vtbl
{
  bool (__fastcall *_createItem)(LootPoolEntry *this, std::vector&lt;ItemStack&gt; *, Random *, LootTableContext *);
  void (__fastcall *~LootPoolEntry)(LootPoolEntry *this);
};

</code></pre></div><h3 id="lootitemcondition"><a href="#lootitemcondition" class="header-anchor">#</a> <code>LootItemCondition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LootItemCondition
{
  LootItemCondition_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="lootitemcondition-vtbl"><a href="#lootitemcondition-vtbl" class="header-anchor">#</a> <code>LootItemCondition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LootItemCondition_vtbl
{
  void (__fastcall *~LootItemCondition)(LootItemCondition *this);
  bool (__fastcall *applies)(LootItemCondition *this, Random *, LootTableContext *);
};

</code></pre></div><h3 id="lootpooltiers"><a href="#lootpooltiers" class="header-anchor">#</a> <code>LootPoolTiers</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct LootPoolTiers
{
  int mRangeForInitialTier;
  int mBonusRolls;
  float mBonusRollChance;
};

</code></pre></div><h3 id="lootpool"><a href="#lootpool" class="header-anchor">#</a> <code>LootPool</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LootPool
{
  std::vector&lt;std::unique_ptr&lt;LootPoolEntry&gt;&gt; mEntries;
  std::vector&lt;std::unique_ptr&lt;LootItemCondition&gt;&gt; mConditions;
  std::unique_ptr&lt;LootPoolTiers&gt; mTiers;
  RandomValueBounds mRolls;
  RandomValueBounds mBonusRolls;
};

</code></pre></div><h3 id="loottable"><a href="#loottable" class="header-anchor">#</a> <code>LootTable</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj LootTable
{
  std::string mDir;
  std::vector&lt;std::unique_ptr&lt;LootPool&gt;&gt; mPools;
};

</code></pre></div><h3 id="lootitemfunction-vtbl"><a href="#lootitemfunction-vtbl" class="header-anchor">#</a> <code>LootItemFunction_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LootItemFunction_vtbl
{
  void (__fastcall *~LootItemFunction)(LootItemFunction *this);
  int (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemInstance *, Random *, LootTableContext *);
  int (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, const Trade *, LootTableContext *);
  void (__fastcall *apply)(LootItemFunction *this, ItemStack *, Random *, LootTableContext *);
};

</code></pre></div><h3 id="legacystructuresettings"><a href="#legacystructuresettings" class="header-anchor">#</a> <code>LegacyStructureSettings</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyStructureSettings
{
  float mIntegrity;
  unsigned int mSeed;
  Projection mProjection;
  Mirror mMirror;
  Rotation mRotation;
  bool mIgnoreStructureBlocks;
  bool mIgnoreJigsawBlocks;
  bool mWaterBelowSeaLevel;
  const Block *mIgnoreBlock;
  ChunkPos mChunkPos;
  BlockPos mRefPos;
  BoundingBox mBoundingBox;
  std::unordered_map&lt;unsigned char,unsigned char&gt; mSwapAuxValues;
  const std::vector&lt;std::unique_ptr&lt;StructurePoolBlockRule&gt;&gt; *mBlockRules;
  const std::vector&lt;std::unique_ptr&lt;StructurePoolBlockTagRule&gt;&gt; *mBlockTagRules;
};

</code></pre></div><h3 id="leveleventcoordinator"><a href="#leveleventcoordinator" class="header-anchor">#</a> <code>LevelEventCoordinator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelEventCoordinator : EventCoordinator&lt;LevelEventListener&gt;
{
};

</code></pre></div><h3 id="leveldatawrapper"><a href="#leveldatawrapper" class="header-anchor">#</a> <code>LevelDataWrapper</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelDataWrapper
{
  LevelData *mLevelDataFromLevel;
  LevelData mLevelDataFromDisk;
};

</code></pre></div><h3 id="loottables"><a href="#loottables" class="header-anchor">#</a> <code>LootTables</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LootTables
{
  std::unordered_map&lt;std::string,std::unique_ptr&lt;LootTable&gt;&gt; mLootTables;
  std::mutex mLootTableMutex;
};

</code></pre></div><h3 id="level-vtbl"><a href="#level-vtbl" class="header-anchor">#</a> <code>Level_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Level_vtbl
{
  void (__fastcall *~BlockSourceListener)(BlockSourceListener *this);
  void (__fastcall *onSourceCreated)(BlockSourceListener *this, BlockSource *);
  void (__fastcall *onSourceDestroyed)(BlockSourceListener *this, BlockSource *);
  void (__fastcall *onAreaChanged)(BlockSourceListener *this, BlockSource *, const BlockPos *, const BlockPos *);
  void (__fastcall *onBlockChanged)(BlockSourceListener *this, BlockSource *, const BlockPos *, unsigned int, const Block *, const Block *, int, const ActorBlockSyncMessage *);
  void (__fastcall *onBrightnessChanged)(BlockSourceListener *this, BlockSource *, const BlockPos *);
  void (__fastcall *onBlockEntityChanged)(BlockSourceListener *this, BlockSource *, BlockActor *);
  void (__fastcall *onBlockEntityAboutToBeRemoved)(BlockSourceListener *this, BlockSource *, std::shared_ptr&lt;BlockActor&gt;);
  void (__fastcall *onEntityChanged)(BlockSourceListener *this, BlockSource *, Actor *);
  void (__fastcall *onBlockEvent)(BlockSourceListener *this, BlockSource *, int, int, int, int, int);
  bool (__fastcall *initialize)(Level *this, const std::string *, const LevelSettings *, LevelData *, const std::string *);
  bool (__fastcall *postProcessResources)(Level *this);
  void (__fastcall *startLeaveGame)(Level *this);
  Actor *(__fastcall *addEntity)(Level *this, BlockSource *, std::unique_ptr&lt;Actor&gt;);
  Actor *(__fastcall *addGlobalEntity)(Level *this, BlockSource *, std::unique_ptr&lt;Actor&gt;);
  Actor *(__fastcall *addAutonomousEntity)(Level *this, BlockSource *, std::unique_ptr&lt;Actor&gt;);
  void (__fastcall *addPlayer)(Level *this, std::unique_ptr&lt;Player&gt;);
  std::unique_ptr&lt;Actor&gt; *(__fastcall *takeEntity)(Level *this, std::unique_ptr&lt;Actor&gt; *result, ActorUniqueID);
  std::unique_ptr&lt;Actor&gt; *(__fastcall *borrowEntity)(Level *this, std::unique_ptr&lt;Actor&gt; *result, ActorUniqueID, LevelChunk *);
  const Tick *(__fastcall *getCurrentServerTick)(Level *this, const Tick *result);
  Factory&lt;BaseLightTextureImageBuilder,Level &amp;,Scheduler &amp;&gt; *(__fastcall *getLightTextureImageBuilderFactory)(Level *this);
  const Factory&lt;BaseLightTextureImageBuilder,Level &amp;,Scheduler &amp;&gt; *(__fastcall *getLightTextureImageBuilderFactory)(Level *this);
  void (__fastcall *onPlayerDeath)(Level *this, Player *, const ActorDamageSource *);
  void (__fastcall *tick)(Level *this);
  void (__fastcall *directTickEntities)(Level *this, BlockSource *);
  void (__fastcall *updateSleepingPlayerList)(Level *this);
  void (__fastcall *setDifficulty)(Level *this, Difficulty);
  void (__fastcall *setCommandsEnabled)(Level *this, bool);
  void (__fastcall *setWorldTemplateOptionsUnlocked)(Level *this);
  void (__fastcall *saveAdditionalData)(Level *this);
  LevelEventCoordinator *(__fastcall *getLevelEventCoordinator)(Level *this);
  void (__fastcall *onChunkLoaded)(Level *this, ChunkSource *, LevelChunk *);
  void (__fastcall *queueEntityRemoval)(Level *this, std::unique_ptr&lt;Actor&gt; *, bool);
  void (__fastcall *removeEntityReferences)(Level *this, Actor *, bool);
  void (__fastcall *loadFunctionManager)(Level *this);
  ResourcePackManager *(__fastcall *getClientResourcePackManager)(Level *this);
  ResourcePackManager *(__fastcall *getServerResourcePackManager)(Level *this);
  TradeTables *(__fastcall *getTradeTables)(Level *this);
  void (__fastcall *addEntryToTagCache)(Level *this, const std::string *);
  void (__fastcall *addEntriesToTagCache)(Level *this, const std::vector&lt;std::string&gt;);
  void (__fastcall *dropEntryFromTagCache)(Level *this, const std::string *);
  void (__fastcall *clearTagCache)(Level *this);
  void (__fastcall *decrementTagCache)(Level *this, const std::string *, TagRegistry&lt;IDType&lt;LevelTagIDType&gt;,IDType&lt;LevelTagSetIDType&gt; &gt; *);
  void (__fastcall *incrementTagCache)(Level *this, const std::string *, TagRegistry&lt;IDType&lt;LevelTagIDType&gt;,IDType&lt;LevelTagSetIDType&gt; &gt; *);
  void (__fastcall *runCommand)(Level *this, Command *, CommandOrigin *, CommandOriginSystem);
  void (__fastcall *runCommand)(Level *this, const HashedString *, CommandOrigin *, CommandOriginSystem, const CurrentCmdVersion);
  TagRegistry&lt;IDType&lt;LevelTagIDType&gt;,IDType&lt;LevelTagSetIDType&gt; &gt; *(__fastcall *getTagRegistry)(Level *this);
  bool (__fastcall *canUseSkin)(Level *this, const SerializedSkin *, const NetworkIdentifier *, const mce::UUID *, const std::string *);
  PositionTrackingDB::PositionTrackingDBServer *(__fastcall *getPositionTrackerDBServer)(Level *this);
  void (__fastcall *setFinishedInitializing)(Level *this);
};

</code></pre></div><h3 id="lockless-weakatomic-unsigned-int64"><a href="#lockless-weakatomic-unsigned-int64" class="header-anchor">#</a> <code>Lockless::WeakAtomic&lt;unsigned __int64&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Lockless::WeakAtomic&lt;unsigned __int64&gt;
{
  std::atomic&lt;unsigned __int64&gt; mValue;
};

</code></pre></div><h3 id="legacyclientnetworkhandler"><a href="#legacyclientnetworkhandler" class="header-anchor">#</a> <code>LegacyClientNetworkHandler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LegacyClientNetworkHandler : ClientNetworkHandler, LevelListener
{
  std::unique_ptr&lt;LevelStorage&gt; mCacheStorage;
  Bedrock::NonOwnerPointer&lt;SoundPlayerInterface&gt; mSoundPlayer;
  MultiPlayerLevel *mLevel;
  PacketSender *mPacketSender;
  std::vector&lt;ActorLink&gt; mPendingLinks;
  int mPendingTime;
  std::string mServerIdentifier;
  std::unique_ptr&lt;NetworkChunkInserter&gt; mChunkInsertQueue;
  NetworkIdentifier mServerGuid;
  std::unique_ptr&lt;Certificate&gt; mUserCertificate;
  std::shared_ptr&lt;MPMCQueue&lt;unsigned __int64&gt; &gt; mCacheMisses;
  std::shared_ptr&lt;MPMCQueue&lt;unsigned __int64&gt; &gt; mCacheHits;
  std::unordered_set&lt;unsigned __int64&gt; mBlobKeysNeedingResponse;
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mNextChunkRequestDrainTime;
  std::queue&lt;std::pair&lt;mce::UUID,SerializedSkin&gt;&gt; mPendingPersonaSkinsToProcess;
  std::queue&lt;std::pair&lt;mce::UUID,SerializedSkin&gt;&gt; mPendingLegacySkinsToProcess;
  std::shared_ptr&lt;bool&gt; mExistanceTracker;
  std::vector&lt;std::pair&lt;mce::UUID,SerializedSkin&gt;&gt; mSkinsCurrentlyProcessing;
  std::unordered_map&lt;mce::UUID,persona::PersonaCharacterHandle&gt; mSessionPersonas;
  unsigned int mSkinsRemainingToProcess;
};

</code></pre></div><h3 id="levelchunkphase1deleter"><a href="#levelchunkphase1deleter" class="header-anchor">#</a> <code>LevelChunkPhase1Deleter</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelChunkPhase1Deleter
{
};

</code></pre></div><h3 id="levelchunkblockactoraccesstoken"><a href="#levelchunkblockactoraccesstoken" class="header-anchor">#</a> <code>LevelChunkBlockActorAccessToken</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelChunkBlockActorAccessToken
{
};

</code></pre></div><h3 id="lodestonecompasscomponentcalculator"><a href="#lodestonecompasscomponentcalculator" class="header-anchor">#</a> <code>LodestoneCompassComponentCalculator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LodestoneCompassComponentCalculator
{
  CompassSpriteCalculator mSpriteCalculator;
  float mExpiresAtTime;
  bool mTrackOnlyInSameDimension;
  BlockPos mLookFromPos;
  AutomaticID&lt;Dimension,int&gt; mLookFromDimension;
};

</code></pre></div><h3 id="lodestonecompasssystem"><a href="#lodestonecompasssystem" class="header-anchor">#</a> <code>LodestoneCompassSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LodestoneCompassSystem : ITickingSystem
{
  IClientInstance *mClientInstance;
};

</code></pre></div><h3 id="lodestonecompasssystem-vtbl"><a href="#lodestonecompasssystem-vtbl" class="header-anchor">#</a> <code>LodestoneCompassSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LodestoneCompassSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="libraryitem-vtbl"><a href="#libraryitem-vtbl" class="header-anchor">#</a> <code>LibraryItem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LibraryItem_vtbl
{
  void (__fastcall *~LessonItem)(LessonItem *this);
  bool (__fastcall *isValid)(LessonItem *this);
  void (__fastcall *_createImageInfo)(LessonItem *this);
  const ResourceLocation *(__fastcall *_getImageResourceLocation)(LessonItem *this);
};

</code></pre></div><h3 id="librarycollectionconfig"><a href="#librarycollectionconfig" class="header-anchor">#</a> <code>LibraryCollectionConfig</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryCollectionConfig
{
  const WorldTemplateManager *mWorldTemplateManager;
  const std::optional&lt;std::vector&lt;std::string&gt; &gt; mKeywords;
  _BYTE mExcludedDisplayCategories[4];
  _BYTE mCollectionSource[4];
  std::string mChannelName;
};

</code></pre></div><h3 id="librarycollection"><a href="#librarycollection" class="header-anchor">#</a> <code>LibraryCollection</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryCollection : InstructionalContentCollection, std::enable_shared_from_this&lt;LibraryCollection&gt;
{
  std::shared_ptr&lt;LibraryCollectionConfig&gt; mConfig;
  std::shared_ptr&lt;LibraryItem&gt; mInvalidItem;
};

</code></pre></div><h3 id="librarycollection-vtbl"><a href="#librarycollection-vtbl" class="header-anchor">#</a> <code>LibraryCollection_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LibraryCollection_vtbl
{
  void (__fastcall *~InstructionalContentCollection)(InstructionalContentCollection *this);
  void (__fastcall *addItem)(InstructionalContentCollection *this, std::shared_ptr&lt;LessonItem&gt;);
  void (__fastcall *refresh)(InstructionalContentCollection *this);
  void (__fastcall *fetchItems)(InstructionalContentCollection *this);
  void (__fastcall *onItemImported)(InstructionalContentCollection *this, const LessonItem *);
};

</code></pre></div><h3 id="lecternblockactor"><a href="#lecternblockactor" class="header-anchor">#</a> <code>LecternBlockActor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LecternBlockActor : BlockActor, Container
{
  int mPage;
  int mTotalPages;
  ItemStack mBook;
};

</code></pre></div><h3 id="lecternblockactor-vtbl"><a href="#lecternblockactor-vtbl" class="header-anchor">#</a> <code>LecternBlockActor_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LecternBlockActor_vtbl
{
  void (__fastcall *~BlockActor)(BlockActor *this);
  void (__fastcall *load)(BlockActor *this, Level *, const CompoundTag *, DataLoadHelper *);
  bool (__fastcall *save)(BlockActor *this, CompoundTag *);
  bool (__fastcall *saveItemInstanceData)(BlockActor *this, CompoundTag *);
  void (__fastcall *saveBlockData)(BlockActor *this, CompoundTag *, BlockSource *);
  void (__fastcall *loadBlockData)(BlockActor *this, const CompoundTag *, BlockSource *, DataLoadHelper *);
  void (__fastcall *onCustomTagLoadDone)(BlockActor *this, BlockSource *);
  void (__fastcall *tick)(BlockActor *this, BlockSource *);
  bool (__fastcall *isFinished)(BlockActor *this);
  void (__fastcall *onChanged)(BlockActor *this, BlockSource *);
  bool (__fastcall *isMovable)(BlockActor *this, BlockSource *);
  bool (__fastcall *isCustomNameSaved)(BlockActor *this);
  bool (__fastcall *onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *, const Player *);
  void (__fastcall *onPlace)(BlockActor *this, BlockSource *);
  void (__fastcall *onMove)(BlockActor *this);
  void (__fastcall *onRemoved)(BlockActor *this, BlockSource *);
  void (__fastcall *triggerEvent)(BlockActor *this, int, int);
  void (__fastcall *clearCache)(BlockActor *this);
  void (__fastcall *onNeighborChanged)(BlockActor *this, BlockSource *, const BlockPos *);
  float (__fastcall *getShadowRadius)(BlockActor *this, BlockSource *);
  bool (__fastcall *hasAlphaLayer)(BlockActor *this);
  BlockActor *(__fastcall *getCrackEntity)(BlockActor *this, BlockSource *, const BlockPos *);
  void (__fastcall *getDebugText)(BlockActor *this, std::vector&lt;std::string&gt; *, const BlockPos *);
  const std::string *(__fastcall *getCustomName)(BlockActor *this);
  const std::string *(__fastcall *getFilteredCustomName)(BlockActor *this, const UIProfanityContext *);
  std::string *(__fastcall *getName)(BlockActor *this, std::string *result);
  void (__fastcall *setCustomName)(BlockActor *this, const std::string *);
  std::string *(__fastcall *getImmersiveReaderText)(BlockActor *this, std::string *result, BlockSource *);
  int (__fastcall *getRepairCost)(BlockActor *this);
  PistonBlockActor *(__fastcall *getOwningPiston)(BlockActor *this, BlockSource *);
  const Container *(__fastcall *getContainer)(BlockActor *this);
  Container *(__fastcall *getContainer)(BlockActor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(BlockActor *this);
  void (__fastcall *checkWordsOnChunkLoad)(BlockActor *this, LevelChunk *);
  void (__fastcall *checkWordsOnUpdate)(BlockActor *this, Player *);
  void (__fastcall *onChunkLoaded)(BlockActor *this, LevelChunk *);
  void (__fastcall *onChunkUnloaded)(BlockActor *this, LevelChunk *);
  std::unique_ptr&lt;BlockActorDataPacket&gt; *(__fastcall *_getUpdatePacket)(BlockActor *this, std::unique_ptr&lt;BlockActorDataPacket&gt; *result, BlockSource *);
  void (__fastcall *_onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *);
  bool (__fastcall *_playerCanUpdate)(BlockActor *this, const Player *);
};

</code></pre></div><h3 id="loomscreencontrollerproxy"><a href="#loomscreencontrollerproxy" class="header-anchor">#</a> <code>LoomScreenControllerProxy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LoomScreenControllerProxy : ScreenControllerProxy
{
  const LoomScreenControllerProxyCallbacks mCallbacks;
};

</code></pre></div><h3 id="loomscreencontrollerproxy-vtbl"><a href="#loomscreencontrollerproxy-vtbl" class="header-anchor">#</a> <code>LoomScreenControllerProxy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LoomScreenControllerProxy_vtbl
{
  void (__fastcall *~ScreenControllerProxy)(ScreenControllerProxy *this);
};

</code></pre></div><h3 id="levelrenderercamera-levelrendererdebuginformation"><a href="#levelrenderercamera-levelrendererdebuginformation" class="header-anchor">#</a> <code>LevelRendererCamera::LevelRendererDebugInformation</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LevelRendererCamera::LevelRendererDebugInformation
{
  std::vector&lt;FrustumEdges&gt; lastFrusumEdges;
  std::vector&lt;mce::Camera&gt; lastCascadeCameras;
  mce::Camera lastDebugCamera;
  glm::tvec3&lt;float,0&gt; mReferenceForwardVector;
  std::vector&lt;FrustumEdges&gt; frusumEdges;
  std::vector&lt;mce::Camera&gt; cascadeCameras;
  int renderDebugCamera;
};

</code></pre></div><h3 id="linearallocator-crackrenderobject-rebind-crackrenderobject"><a href="#linearallocator-crackrenderobject-rebind-crackrenderobject" class="header-anchor">#</a> <code>LinearAllocator&lt;CrackRenderObject&gt;::rebind&lt;CrackRenderObject&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LinearAllocator&lt;CrackRenderObject&gt;::rebind&lt;CrackRenderObject&gt;
{
};

</code></pre></div><h3 id="linearallocator-crackrenderobject-rebind-std-container-proxy"><a href="#linearallocator-crackrenderobject-rebind-std-container-proxy" class="header-anchor">#</a> <code>LinearAllocator&lt;CrackRenderObject&gt;::rebind&lt;std::_Container_proxy&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LinearAllocator&lt;CrackRenderObject&gt;::rebind&lt;std::_Container_proxy&gt;
{
};

</code></pre></div><h3 id="linearallocator-actorshadowrenderobject-rebind-actorshadowrenderobject"><a href="#linearallocator-actorshadowrenderobject-rebind-actorshadowrenderobject" class="header-anchor">#</a> <code>LinearAllocator&lt;ActorShadowRenderObject&gt;::rebind&lt;ActorShadowRenderObject&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LinearAllocator&lt;ActorShadowRenderObject&gt;::rebind&lt;ActorShadowRenderObject&gt;
{
};

</code></pre></div><h3 id="linearallocator-actorshadowrenderobject-rebind-std-container-proxy"><a href="#linearallocator-actorshadowrenderobject-rebind-std-container-proxy" class="header-anchor">#</a> <code>LinearAllocator&lt;ActorShadowRenderObject&gt;::rebind&lt;std::_Container_proxy&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LinearAllocator&lt;ActorShadowRenderObject&gt;::rebind&lt;std::_Container_proxy&gt;
{
};

</code></pre></div><h3 id="linearallocator-particletyperenderobject-rebind-particletyperenderobject"><a href="#linearallocator-particletyperenderobject-rebind-particletyperenderobject" class="header-anchor">#</a> <code>LinearAllocator&lt;ParticleTypeRenderObject&gt;::rebind&lt;ParticleTypeRenderObject&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LinearAllocator&lt;ParticleTypeRenderObject&gt;::rebind&lt;ParticleTypeRenderObject&gt;
{
};

</code></pre></div><h3 id="linearallocator-particletyperenderobject-rebind-std-container-proxy"><a href="#linearallocator-particletyperenderobject-rebind-std-container-proxy" class="header-anchor">#</a> <code>LinearAllocator&lt;ParticleTypeRenderObject&gt;::rebind&lt;std::_Container_proxy&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LinearAllocator&lt;ParticleTypeRenderObject&gt;::rebind&lt;std::_Container_proxy&gt;
{
};

</code></pre></div><h3 id="linearallocator-nametagrenderobject-rebind-nametagrenderobject"><a href="#linearallocator-nametagrenderobject-rebind-nametagrenderobject" class="header-anchor">#</a> <code>LinearAllocator&lt;NameTagRenderObject&gt;::rebind&lt;NameTagRenderObject&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LinearAllocator&lt;NameTagRenderObject&gt;::rebind&lt;NameTagRenderObject&gt;
{
};

</code></pre></div><h3 id="linearallocator-nametagrenderobject-rebind-std-container-proxy"><a href="#linearallocator-nametagrenderobject-rebind-std-container-proxy" class="header-anchor">#</a> <code>LinearAllocator&lt;NameTagRenderObject&gt;::rebind&lt;std::_Container_proxy&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LinearAllocator&lt;NameTagRenderObject&gt;::rebind&lt;std::_Container_proxy&gt;
{
};

</code></pre></div><h3 id="linearallocator-mce-textureptr-rebind-mce-textureptr"><a href="#linearallocator-mce-textureptr-rebind-mce-textureptr" class="header-anchor">#</a> <code>LinearAllocator&lt;mce::TexturePtr&gt;::rebind&lt;mce::TexturePtr&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LinearAllocator&lt;mce::TexturePtr&gt;::rebind&lt;mce::TexturePtr&gt;
{
};

</code></pre></div><h3 id="linearallocator-mce-textureptr-rebind-std-container-proxy"><a href="#linearallocator-mce-textureptr-rebind-std-container-proxy" class="header-anchor">#</a> <code>LinearAllocator&lt;mce::TexturePtr&gt;::rebind&lt;std::_Container_proxy&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LinearAllocator&lt;mce::TexturePtr&gt;::rebind&lt;std::_Container_proxy&gt;
{
};

</code></pre></div><h3 id="linearallocator-viewrenderobject-rebind-viewrenderobject"><a href="#linearallocator-viewrenderobject-rebind-viewrenderobject" class="header-anchor">#</a> <code>LinearAllocator&lt;ViewRenderObject&gt;::rebind&lt;ViewRenderObject&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LinearAllocator&lt;ViewRenderObject&gt;::rebind&lt;ViewRenderObject&gt;
{
};

</code></pre></div><h3 id="linearallocator-viewrenderobject-rebind-std-container-proxy"><a href="#linearallocator-viewrenderobject-rebind-std-container-proxy" class="header-anchor">#</a> <code>LinearAllocator&lt;ViewRenderObject&gt;::rebind&lt;std::_Container_proxy&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LinearAllocator&lt;ViewRenderObject&gt;::rebind&lt;std::_Container_proxy&gt;
{
};

</code></pre></div><h3 id="list-entry64"><a href="#list-entry64" class="header-anchor">#</a> <code>LIST_ENTRY64</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct LIST_ENTRY64
{
  unsigned __int64 Flink;
  unsigned __int64 Blink;
};

</code></pre></div><h3 id="list-entry32"><a href="#list-entry32" class="header-anchor">#</a> <code>LIST_ENTRY32</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct LIST_ENTRY32
{
  unsigned int Flink;
  unsigned int Blink;
};

</code></pre></div><h3 id="lconv"><a href="#lconv" class="header-anchor">#</a> <code>lconv</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct lconv
{
  char *decimal_point;
  char *thousands_sep;
  char *grouping;
  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;
  char p_cs_precedes;
  char p_sep_by_space;
  char n_cs_precedes;
  char n_sep_by_space;
  char p_sign_posn;
  char n_sign_posn;
  wchar_t *_W_decimal_point;
  wchar_t *_W_thousands_sep;
  wchar_t *_W_int_curr_symbol;
  wchar_t *_W_currency_symbol;
  wchar_t *_W_mon_decimal_point;
  wchar_t *_W_mon_thousands_sep;
  wchar_t *_W_positive_sign;
  wchar_t *_W_negative_sign;
};

</code></pre></div><h3 id="linger"><a href="#linger" class="header-anchor">#</a> <code>linger</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct linger
{
  unsigned __int16 l_onoff;
  unsigned __int16 l_linger;
};

</code></pre></div><h3 id="liquidoffsetbehavior"><a href="#liquidoffsetbehavior" class="header-anchor">#</a> <code>LiquidOffsetBehavior</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LiquidOffsetBehavior : CameraBehavior&lt;LiquidOffsetBehavior&gt;
{
  float mHeightOffset;
};

</code></pre></div><h3 id="liquidoffsetbehavior-vtbl"><a href="#liquidoffsetbehavior-vtbl" class="header-anchor">#</a> <code>LiquidOffsetBehavior_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LiquidOffsetBehavior_vtbl
{
  void (__fastcall *~ICameraBehavior)(ICameraBehavior *this);
  void (__fastcall *onSetup)(ICameraBehavior *this, IClientInstance *, CameraDirector *);
  void (__fastcall *onStart)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *update)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *handleLookInput)(ICameraBehavior *this, Vec2 *, CameraDirector *);
  void (__fastcall *renderDebug)(ICameraBehavior *this, IClientInstance *, float, CameraDirector *);
  bool (__fastcall *handleCameraSetRot)(ICameraBehavior *this, const Vec2 *, CameraDirector *);
  HashedString *(__fastcall *getId)(ICameraBehavior *this, HashedString *result);
  ICameraBehavior::UpdateOrder (__fastcall *getUpdateOrder)(ICameraBehavior *this);
};

</code></pre></div><h3 id="lookatbehavior"><a href="#lookatbehavior" class="header-anchor">#</a> <code>LookAtBehavior</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LookAtBehavior : CameraBehavior&lt;LookAtBehavior&gt;
{
  RectangleArea mSoftBounds;
  RectangleArea mHardBounds;
  CriticallyDampedSpring&lt;float&gt; mSoftBoundsSmoothingSpring;
  float mAngularVelocity;
};

</code></pre></div><h3 id="lookatbehavior-vtbl"><a href="#lookatbehavior-vtbl" class="header-anchor">#</a> <code>LookAtBehavior_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LookAtBehavior_vtbl
{
  void (__fastcall *~ICameraBehavior)(ICameraBehavior *this);
  void (__fastcall *onSetup)(ICameraBehavior *this, IClientInstance *, CameraDirector *);
  void (__fastcall *onStart)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *update)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *handleLookInput)(ICameraBehavior *this, Vec2 *, CameraDirector *);
  void (__fastcall *renderDebug)(ICameraBehavior *this, IClientInstance *, float, CameraDirector *);
  bool (__fastcall *handleCameraSetRot)(ICameraBehavior *this, const Vec2 *, CameraDirector *);
  HashedString *(__fastcall *getId)(ICameraBehavior *this, HashedString *result);
  ICameraBehavior::UpdateOrder (__fastcall *getUpdateOrder)(ICameraBehavior *this);
};

</code></pre></div><h3 id="liquidoffsetbehaviorloader"><a href="#liquidoffsetbehaviorloader" class="header-anchor">#</a> <code>LiquidOffsetBehaviorLoader</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LiquidOffsetBehaviorLoader : CameraBehaviorLoader
{
};

</code></pre></div><h3 id="liquidoffsetbehaviorloader-vtbl"><a href="#liquidoffsetbehaviorloader-vtbl" class="header-anchor">#</a> <code>LiquidOffsetBehaviorLoader_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LiquidOffsetBehaviorLoader_vtbl
{
  void (__fastcall *~CameraBehaviorLoader)(CameraBehaviorLoader *this);
  std::unique_ptr&lt;ICameraBehavior&gt; *(__fastcall *create)(CameraBehaviorLoader *this, std::unique_ptr&lt;ICameraBehavior&gt; *result);
  void (__fastcall *parse)(CameraBehaviorLoader *this, Json::Value *, ICameraBehavior *);
};

</code></pre></div><h3 id="lookatbehaviorloader"><a href="#lookatbehaviorloader" class="header-anchor">#</a> <code>LookAtBehaviorLoader</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LookAtBehaviorLoader : CameraBehaviorLoader
{
};

</code></pre></div><h3 id="lookatbehaviorloader-vtbl"><a href="#lookatbehaviorloader-vtbl" class="header-anchor">#</a> <code>LookAtBehaviorLoader_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LookAtBehaviorLoader_vtbl
{
  void (__fastcall *~CameraBehaviorLoader)(CameraBehaviorLoader *this);
  std::unique_ptr&lt;ICameraBehavior&gt; *(__fastcall *create)(CameraBehaviorLoader *this, std::unique_ptr&lt;ICameraBehavior&gt; *result);
  void (__fastcall *parse)(CameraBehaviorLoader *this, Json::Value *, ICameraBehavior *);
};

</code></pre></div><h3 id="leveldataoverridevalues"><a href="#leveldataoverridevalues" class="header-anchor">#</a> <code>LevelDataOverrideValues</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LevelDataOverrideValues
{
  std::unordered_map&lt;HashedString,LevelDataValue&gt; mOverrides;
  std::vector&lt;GameRule&gt; mGameRules;
  std::unordered_map&lt;enum AbilitiesIndex,Ability&gt; mAbilities;
  AdventureSettingsOverride mAdventureSettings;
};

</code></pre></div><h3 id="legacyworldconversionmanager"><a href="#legacyworldconversionmanager" class="header-anchor">#</a> <code>LegacyWorldConversionManager</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyWorldConversionManager
{
  MainMenuScreenModel *mMainMenuScreenModel;
  _BYTE mConversionState[4];
  float mLegacyWorldConversionProgress;
  std::shared_ptr&lt;bool&gt; mExistenceTracker;
  IDlcBatchModel *mDownloadingContent;
};

</code></pre></div><h3 id="legacy-worldimporter"><a href="#legacy-worldimporter" class="header-anchor">#</a> <code>Legacy::WorldImporter</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Legacy::WorldImporter
{
  Legacy::WorldImporter_vtbl *__vftable /*VFT*/;
  std::shared_ptr&lt;CallbackTokenContext&lt;std::function&lt;void __cdecl(enum Legacy::ImportStatus,float,std::shared_ptr&lt;ImportResult&gt;)&gt; &gt; &gt; mImportContext;
  std::shared_ptr&lt;CallbackTokenContext&lt;std::function&lt;void __cdecl(enum Legacy::RetrieveStatus)&gt; &gt; &gt; mRetrieveContext;
  std::vector&lt;LegacyWorldInfo&gt; mWorldList;
  std::atomic&lt;bool&gt; mFetchInProgress;
  std::mutex mWorldListMutex;
  std::unique_ptr&lt;TaskGroup&gt; mTaskGroup;
  std::shared_ptr&lt;Legacy::WorldConverter&gt; mWorldConverter;
  Legacy::WorldConverter::Type mWorldConverterType;
};

</code></pre></div><h3 id="legacy-worldimporter-vtbl"><a href="#legacy-worldimporter-vtbl" class="header-anchor">#</a> <code>Legacy::WorldImporter_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Legacy::WorldImporter_vtbl
{
  void (__fastcall *~WorldImporter)(Legacy::WorldImporter *this);
  void (__fastcall *deleteWorld)(Legacy::WorldImporter *this, std::shared_ptr&lt;Social::User&gt;, const std::string *, std::function&lt;void __cdecl(void)&gt;);
  void (__fastcall *_doRetrieve)(Legacy::WorldImporter *this, std::shared_ptr&lt;Social::User&gt;, std::shared_ptr&lt;CallbackTokenContext&lt;std::function&lt;void __cdecl(enum Legacy::RetrieveStatus)&gt; &gt; &gt;);
  void (__fastcall *_doImport)(Legacy::WorldImporter *this, std::shared_ptr&lt;Social::User&gt;, const LegacyWorldInfo *, const Core::Path *, std::shared_ptr&lt;CallbackTokenContext&lt;std::function&lt;void __cdecl(enum Legacy::ImportStatus,float,std::shared_ptr&lt;ImportResult&gt;)&gt; &gt; &gt;);
};

</code></pre></div><h3 id="legacy-worldconverter"><a href="#legacy-worldconverter" class="header-anchor">#</a> <code>Legacy::WorldConverter</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Legacy::WorldConverter
{
  Legacy::WorldConverter_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="legacy-worldconverter-vtbl"><a href="#legacy-worldconverter-vtbl" class="header-anchor">#</a> <code>Legacy::WorldConverter_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Legacy::WorldConverter_vtbl
{
  void (__fastcall *~WorldConverter)(Legacy::WorldConverter *this);
  std::shared_future&lt;void&gt; *(__fastcall *addBlob)(Legacy::WorldConverter *this, std::shared_future&lt;void&gt; *result, const std::string *, Legacy::WorldConverterBlobType, std::vector&lt;unsigned char&gt; *);
  std::future&lt;Legacy::WorldConversionReport&gt; *(__fastcall *complete)(Legacy::WorldConverter *this, std::future&lt;Legacy::WorldConversionReport&gt; *result);
  void (__fastcall *setEstimatedBlobCount)(Legacy::WorldConverter *this, unsigned __int64);
  void (__fastcall *setBlobNames)(Legacy::WorldConverter *this, const std::vector&lt;std::string&gt; *);
};

</code></pre></div><h3 id="legacy-worldprocessrequest"><a href="#legacy-worldprocessrequest" class="header-anchor">#</a> <code>Legacy::WorldProcessRequest</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Legacy::WorldProcessRequest
{
  Legacy::WorldProcessRequest_vtbl *__vftable /*VFT*/;
  std::function&lt;void __cdecl(enum Legacy::ImportStatus,float,std::shared_ptr&lt;ImportResult&gt;)&gt; mStatusCallback;
  LegacyWorldInfo mWorldInfo;
};

</code></pre></div><h3 id="legacy-worldprocessrequest-vtbl"><a href="#legacy-worldprocessrequest-vtbl" class="header-anchor">#</a> <code>Legacy::WorldProcessRequest_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Legacy::WorldProcessRequest_vtbl
{
  void (__fastcall *~WorldProcessRequest)(Legacy::WorldProcessRequest *this);
  Legacy::WorldProcessingType (__fastcall *getProcessingType)(Legacy::WorldProcessRequest *this);
  Core::PathBuffer&lt;std::string &gt; *(__fastcall *getOutputPath)(Legacy::WorldProcessRequest *this, Core::PathBuffer&lt;std::string &gt; *result);
};

</code></pre></div><h3 id="legacy-uploadworldprocessrequest"><a href="#legacy-uploadworldprocessrequest" class="header-anchor">#</a> <code>Legacy::UploadWorldProcessRequest</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Legacy::UploadWorldProcessRequest : Legacy::WorldProcessRequest
{
  std::unordered_map&lt;std::string,std::string&gt; mUserData;
};

</code></pre></div><h3 id="legacy-uploadworldprocessrequest-vtbl"><a href="#legacy-uploadworldprocessrequest-vtbl" class="header-anchor">#</a> <code>Legacy::UploadWorldProcessRequest_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Legacy::UploadWorldProcessRequest_vtbl
{
  void (__fastcall *~WorldProcessRequest)(Legacy::WorldProcessRequest *this);
  Legacy::WorldProcessingType (__fastcall *getProcessingType)(Legacy::WorldProcessRequest *this);
  Core::PathBuffer&lt;std::string &gt; *(__fastcall *getOutputPath)(Legacy::WorldProcessRequest *this, Core::PathBuffer&lt;std::string &gt; *result);
};

</code></pre></div><h3 id="lockless-weakatomic-spscqueue-std-string-512-block"><a href="#lockless-weakatomic-spscqueue-std-string-512-block" class="header-anchor">#</a> <code>Lockless::WeakAtomic&lt;SPSCQueue&lt;std::string,512&gt;::Block *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Lockless::WeakAtomic&lt;SPSCQueue&lt;std::string,512&gt;::Block *&gt;
{
  std::atomic&lt;SPSCQueue&lt;std::string,512&gt;::Block *&gt; mValue;
};

</code></pre></div><h3 id="localnetworkpeer"><a href="#localnetworkpeer" class="header-anchor">#</a> <code>LocalNetworkPeer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LocalNetworkPeer : NetworkPeer
{
  std::weak_ptr&lt;LocalNetworkPeer&gt; mOtherPeer;
  std::unique_ptr&lt;SPSCQueue&lt;std::string,512&gt;&gt; mIncomingData;
};

</code></pre></div><h3 id="localnetworkpeer-vtbl"><a href="#localnetworkpeer-vtbl" class="header-anchor">#</a> <code>LocalNetworkPeer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LocalNetworkPeer_vtbl
{
  void (__fastcall *~NetworkPeer)(NetworkPeer *this);
  void (__fastcall *sendPacket)(NetworkPeer *this, const std::string *, NetworkPeer::Reliability, int, unsigned __int16, Compressibility);
  NetworkPeer::DataStatus (__fastcall *receivePacket)(NetworkPeer *this, std::string *);
  NetworkPeer::NetworkStatus *(__fastcall *getNetworkStatus)(NetworkPeer *this, NetworkPeer::NetworkStatus *result);
  void (__fastcall *addIncomingData)(NetworkPeer *this, std::string);
  void (__fastcall *update)(NetworkPeer *this);
  void (__fastcall *flush)(NetworkPeer *this, std::function&lt;void __cdecl(void)&gt; *);
};

</code></pre></div><h3 id="leavelevelprogresshandler"><a href="#leavelevelprogresshandler" class="header-anchor">#</a> <code>LeaveLevelProgressHandler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LeaveLevelProgressHandler : EmptyProgressHandler
{
  std::string mProgressMessage;
  _BYTE mLoadingState[4];
};

</code></pre></div><h3 id="leavelevelprogresshandler-vtbl"><a href="#leavelevelprogresshandler-vtbl" class="header-anchor">#</a> <code>LeaveLevelProgressHandler_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LeaveLevelProgressHandler_vtbl
{
  void (__fastcall *~ProgressHandler)(ProgressHandler *this);
  void (__fastcall *onStart)(ProgressHandler *this, MinecraftScreenModel *);
  void (__fastcall *tick)(ProgressHandler *this, MinecraftScreenModel *);
  void (__fastcall *onCancel)(ProgressHandler *this, MinecraftScreenModel *);
  void (__fastcall *onExit)(ProgressHandler *this, MinecraftScreenModel *);
  LoadingState (__fastcall *getLoadingState)(ProgressHandler *this, MinecraftScreenModel *);
  float (__fastcall *getLoadingProgress)(ProgressHandler *this, MinecraftScreenModel *);
  std::string *(__fastcall *getProgressMessage)(ProgressHandler *this, std::string *result, MinecraftScreenModel *);
  void (__fastcall *addEventProperties)(ProgressHandler *this, std::unordered_map&lt;std::string,std::string&gt; *);
  std::string *(__fastcall *getTTSProgressMessage)(ProgressHandler *this, std::string *result);
  std::string *(__fastcall *getTitleText)(ProgressHandler *this, std::string *result);
  ProgressAnimation (__fastcall *showLoadingBar)(ProgressHandler *this);
};

</code></pre></div><h3 id="librarysearchquery"><a href="#librarysearchquery" class="header-anchor">#</a> <code>LibrarySearchQuery</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibrarySearchQuery
{
  int mSkip;
  std::string mProductId;
  _BYTE mType[1];
  std::optional&lt;std::vector&lt;std::string&gt; &gt; mKeywords;
  std::vector&lt;std::string&gt; mProductIds;
};

</code></pre></div><h3 id="libraryimageparams"><a href="#libraryimageparams" class="header-anchor">#</a> <code>LibraryImageParams</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryImageParams
{
  std::string mContentUrl;
};

</code></pre></div><h3 id="logsettingsupdater"><a href="#logsettingsupdater" class="header-anchor">#</a> <code>LogSettingsUpdater</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LogSettingsUpdater
{
  LogSettingsUpdater_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="logsettingsupdater-vtbl"><a href="#logsettingsupdater-vtbl" class="header-anchor">#</a> <code>LogSettingsUpdater_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LogSettingsUpdater_vtbl
{
  void (__fastcall *~LogSettingsUpdater)(LogSettingsUpdater *this);
  void (__fastcall *save)(LogSettingsUpdater *this);
  bool (__fastcall *getDevLogAppend)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogAppend)(LogSettingsUpdater *this, bool);
  bool (__fastcall *getDevLogFlushImmediate)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogFlushImmediate)(LogSettingsUpdater *this, bool);
  int (__fastcall *getDevLogFlushDelay)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogFlushDelay)(LogSettingsUpdater *this, int);
  bool (__fastcall *getDevLogTimestamp)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogTimestamp)(LogSettingsUpdater *this, bool);
  bool (__fastcall *getDevLogTrace)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogTrace)(LogSettingsUpdater *this, bool);
  bool (__fastcall *getDevLogArea)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogArea)(LogSettingsUpdater *this, bool);
  bool (__fastcall *getDevLogPriority)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogPriority)(LogSettingsUpdater *this, bool);
  bool (__fastcall *getDevLogProcessId)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogProcessId)(LogSettingsUpdater *this, bool);
  bool (__fastcall *getDevLogThreadId)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogThreadId)(LogSettingsUpdater *this, bool);
  bool (__fastcall *getDevLogMessageId)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogMessageId)(LogSettingsUpdater *this, bool);
  bool (__fastcall *getDevLogSilentLogging)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogSilentLogging)(LogSettingsUpdater *this, bool);
  std::string *(__fastcall *getDevLogAreaFilterString)(LogSettingsUpdater *this, std::string *result);
  void (__fastcall *setDevLogAreaFilterString)(LogSettingsUpdater *this, const std::string *);
  unsigned int (__fastcall *getDevLogPriorityFilter)(LogSettingsUpdater *this);
  void (__fastcall *toggleDevLogPriorityFilter)(LogSettingsUpdater *this, unsigned int);
};

</code></pre></div><h3 id="logoptionsupdater"><a href="#logoptionsupdater" class="header-anchor">#</a> <code>LogOptionsUpdater</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LogOptionsUpdater : LogSettingsUpdater
{
  std::shared_ptr&lt;Options&gt; mOptions;
};

</code></pre></div><h3 id="logoptionsupdater-vtbl"><a href="#logoptionsupdater-vtbl" class="header-anchor">#</a> <code>LogOptionsUpdater_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LogOptionsUpdater_vtbl
{
  void (__fastcall *~LogSettingsUpdater)(LogSettingsUpdater *this);
  void (__fastcall *save)(LogSettingsUpdater *this);
  bool (__fastcall *getDevLogAppend)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogAppend)(LogSettingsUpdater *this, bool);
  bool (__fastcall *getDevLogFlushImmediate)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogFlushImmediate)(LogSettingsUpdater *this, bool);
  int (__fastcall *getDevLogFlushDelay)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogFlushDelay)(LogSettingsUpdater *this, int);
  bool (__fastcall *getDevLogTimestamp)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogTimestamp)(LogSettingsUpdater *this, bool);
  bool (__fastcall *getDevLogTrace)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogTrace)(LogSettingsUpdater *this, bool);
  bool (__fastcall *getDevLogArea)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogArea)(LogSettingsUpdater *this, bool);
  bool (__fastcall *getDevLogPriority)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogPriority)(LogSettingsUpdater *this, bool);
  bool (__fastcall *getDevLogProcessId)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogProcessId)(LogSettingsUpdater *this, bool);
  bool (__fastcall *getDevLogThreadId)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogThreadId)(LogSettingsUpdater *this, bool);
  bool (__fastcall *getDevLogMessageId)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogMessageId)(LogSettingsUpdater *this, bool);
  bool (__fastcall *getDevLogSilentLogging)(LogSettingsUpdater *this);
  void (__fastcall *setDevLogSilentLogging)(LogSettingsUpdater *this, bool);
  std::string *(__fastcall *getDevLogAreaFilterString)(LogSettingsUpdater *this, std::string *result);
  void (__fastcall *setDevLogAreaFilterString)(LogSettingsUpdater *this, const std::string *);
  unsigned int (__fastcall *getDevLogPriorityFilter)(LogSettingsUpdater *this);
  void (__fastcall *toggleDevLogPriorityFilter)(LogSettingsUpdater *this, unsigned int);
};

</code></pre></div><h3 id="loginstatemachine-vtbl"><a href="#loginstatemachine-vtbl" class="header-anchor">#</a> <code>LoginStateMachine_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LoginStateMachine_vtbl
{
  void (__fastcall *~LoginStateMachine)(LoginStateMachine *this);
};

</code></pre></div><h3 id="launchscriptstage"><a href="#launchscriptstage" class="header-anchor">#</a> <code>LaunchScriptStage</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LaunchScriptStage : BaseStage
{
};

</code></pre></div><h3 id="launchscriptstage-vtbl"><a href="#launchscriptstage-vtbl" class="header-anchor">#</a> <code>LaunchScriptStage_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LaunchScriptStage_vtbl
{
  void (__fastcall *~BaseStage)(BaseStage *this);
  void (__fastcall *onAwake)(BaseStage *this);
  void (__fastcall *onUpdate)(BaseStage *this);
  bool (__fastcall *ayncTask)(BaseStage *this);
};

</code></pre></div><h3 id="loginfinishstage"><a href="#loginfinishstage" class="header-anchor">#</a> <code>LoginFinishStage</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LoginFinishStage : BaseStage
{
};

</code></pre></div><h3 id="loginfinishstage-vtbl"><a href="#loginfinishstage-vtbl" class="header-anchor">#</a> <code>LoginFinishStage_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LoginFinishStage_vtbl
{
  void (__fastcall *~BaseStage)(BaseStage *this);
  void (__fastcall *onAwake)(BaseStage *this);
  void (__fastcall *onUpdate)(BaseStage *this);
  bool (__fastcall *ayncTask)(BaseStage *this);
};

</code></pre></div><h3 id="leveldbenv"><a href="#leveldbenv" class="header-anchor">#</a> <code>LevelDbEnv</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelDbEnv : leveldb::Env
{
  std::unique_ptr&lt;TaskGroup&gt; mLevelDBTasks;
};

</code></pre></div><h3 id="leveldbenv-vtbl"><a href="#leveldbenv-vtbl" class="header-anchor">#</a> <code>LevelDbEnv_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelDbEnv_vtbl
{
  void (__fastcall *~Env)(leveldb::Env *this);
  leveldb::Status *(__fastcall *NewSequentialFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::SequentialFile **);
  leveldb::Status *(__fastcall *NewRandomAccessFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::RandomAccessFile **);
  leveldb::Status *(__fastcall *NewWritableFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::WritableFile **);
  leveldb::Status *(__fastcall *NewAppendableFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::WritableFile **);
  bool (__fastcall *FileExists)(leveldb::Env *this, const std::string *);
  leveldb::Status *(__fastcall *GetChildren)(leveldb::Env *this, leveldb::Status *result, const std::string *, std::vector&lt;std::string&gt; *);
  leveldb::Status *(__fastcall *DeleteFileA)(leveldb::Env *this, leveldb::Status *result, const std::string *);
  leveldb::Status *(__fastcall *CreateDir)(leveldb::Env *this, leveldb::Status *result, const std::string *);
  leveldb::Status *(__fastcall *DeleteDir)(leveldb::Env *this, leveldb::Status *result, const std::string *);
  leveldb::Status *(__fastcall *GetFileSize)(leveldb::Env *this, leveldb::Status *result, const std::string *, unsigned __int64 *);
  leveldb::Status *(__fastcall *RenameFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, const std::string *);
  leveldb::Status *(__fastcall *LockFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::FileLock **);
  leveldb::Status *(__fastcall *UnlockFile)(leveldb::Env *this, leveldb::Status *result, leveldb::FileLock *);
  void (__fastcall *Schedule)(leveldb::Env *this, void (__fastcall *)(void *), void *);
  void (__fastcall *StartThread)(leveldb::Env *this, void (__fastcall *)(void *), void *);
  leveldb::Status *(__fastcall *GetTestDirectory)(leveldb::Env *this, leveldb::Status *result, std::string *);
  leveldb::Status *(__fastcall *NewLogger)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::Logger **);
  unsigned __int64 (__fastcall *NowMicros)(leveldb::Env *this);
  void (__fastcall *SleepForMicroseconds)(leveldb::Env *this, int);
};

</code></pre></div><h3 id="librarydeeplink"><a href="#librarydeeplink" class="header-anchor">#</a> <code>LibraryDeeplink</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryDeeplink
{
  std::string itemId;
};

</code></pre></div><h3 id="librarydeeplinklistener"><a href="#librarydeeplinklistener" class="header-anchor">#</a> <code>LibraryDeeplinkListener</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryDeeplinkListener : UriListener
{
  std::function&lt;SceneStack &amp; __cdecl(void)&gt; mGetSceneStack;
  std::function&lt;SceneFactory &amp; __cdecl(void)&gt; mGetPrimarySceneFactory;
  std::function&lt;LibraryRepository &amp; __cdecl(void)&gt; mGetLibraryRepository;
  std::function&lt;void __cdecl(void)&gt; mRequestLeaveGame;
  std::function&lt;bool __cdecl(void)&gt; mIsLeavingGameDone;
  std::function&lt;bool __cdecl(void)&gt; mIsInGame;
  std::unique_ptr&lt;LibraryDeeplink&gt; mPendingLink;
  std::mutex mLinkMutex;
  std::shared_ptr&lt;bool&gt; mExistenceTracker;
  std::unique_ptr&lt;LibraryDeeplink&gt; mLeaveGamePendingLink;
};

</code></pre></div><h3 id="librarydeeplinklistener-vtbl"><a href="#librarydeeplinklistener-vtbl" class="header-anchor">#</a> <code>LibraryDeeplinkListener_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LibraryDeeplinkListener_vtbl
{
  void (__fastcall *~UriListener)(UriListener *this);
  void (__fastcall *onUri)(UriListener *this, const ActivationUri *);
  void (__fastcall *tick)(UriListener *this);
};

</code></pre></div><h3 id="lowmemorywatcher"><a href="#lowmemorywatcher" class="header-anchor">#</a> <code>LowMemoryWatcher</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LowMemoryWatcher
{
};

</code></pre></div><h3 id="levelloader-importlevel-l19-lambda-3bb3ecb6e11687a565c90fd72d569076"><a href="#levelloader-importlevel-l19-lambda-3bb3ecb6e11687a565c90fd72d569076" class="header-anchor">#</a> <code>LevelLoader::_importLevel::__l19::&lt;lambda_3bb3ecb6e11687a565c90fd72d569076&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelLoader::_importLevel::__l19::&lt;lambda_3bb3ecb6e11687a565c90fd72d569076&gt;
{
  LevelLoader *const __this;
  std::shared_ptr&lt;ImportLevelData&gt; modalOwnership;
};

</code></pre></div><h3 id="livehorserenderer"><a href="#livehorserenderer" class="header-anchor">#</a> <code>LiveHorseRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LiveHorseRenderer : MinecraftUICustomRenderer
{
};

</code></pre></div><h3 id="livehorserenderer-vtbl"><a href="#livehorserenderer-vtbl" class="header-anchor">#</a> <code>LiveHorseRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LiveHorseRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="liveplayerrenderer"><a href="#liveplayerrenderer" class="header-anchor">#</a> <code>LivePlayerRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LivePlayerRenderer : MinecraftUICustomRenderer
{
};

</code></pre></div><h3 id="liveplayerrenderer-vtbl"><a href="#liveplayerrenderer-vtbl" class="header-anchor">#</a> <code>LivePlayerRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LivePlayerRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="libraryprogresshandler"><a href="#libraryprogresshandler" class="header-anchor">#</a> <code>LibraryProgressHandler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryProgressHandler : StoreProgressHandler
{
  std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; mProperties;
};

</code></pre></div><h3 id="libraryprogresshandler-vtbl"><a href="#libraryprogresshandler-vtbl" class="header-anchor">#</a> <code>LibraryProgressHandler_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LibraryProgressHandler_vtbl
{
  void (__fastcall *~ProgressHandler)(ProgressHandler *this);
  void (__fastcall *onStart)(ProgressHandler *this, MinecraftScreenModel *);
  void (__fastcall *tick)(ProgressHandler *this, MinecraftScreenModel *);
  void (__fastcall *onCancel)(ProgressHandler *this, MinecraftScreenModel *);
  void (__fastcall *onExit)(ProgressHandler *this, MinecraftScreenModel *);
  LoadingState (__fastcall *getLoadingState)(ProgressHandler *this, MinecraftScreenModel *);
  float (__fastcall *getLoadingProgress)(ProgressHandler *this, MinecraftScreenModel *);
  std::string *(__fastcall *getProgressMessage)(ProgressHandler *this, std::string *result, MinecraftScreenModel *);
  void (__fastcall *addEventProperties)(ProgressHandler *this, std::unordered_map&lt;std::string,std::string&gt; *);
  std::string *(__fastcall *getTTSProgressMessage)(ProgressHandler *this, std::string *result);
  std::string *(__fastcall *getTitleText)(ProgressHandler *this, std::string *result);
  ProgressAnimation (__fastcall *showLoadingBar)(ProgressHandler *this);
};

</code></pre></div><h3 id="lodestonecompassitem"><a href="#lodestonecompassitem" class="header-anchor">#</a> <code>LodestoneCompassItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LodestoneCompassItem : Item
{
  int mAtlasWidth;
  int mAtlasHeight;
  TextureUVCoordinateSet mFrames[32];
};

</code></pre></div><h3 id="lodestoneblockactor"><a href="#lodestoneblockactor" class="header-anchor">#</a> <code>LodestoneBlockActor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LodestoneBlockActor : BlockActor
{
  PositionTrackingId mTrackingDBHandle;
};

</code></pre></div><h3 id="lodestoneblockactor-vtbl"><a href="#lodestoneblockactor-vtbl" class="header-anchor">#</a> <code>LodestoneBlockActor_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LodestoneBlockActor_vtbl
{
  void (__fastcall *~BlockActor)(BlockActor *this);
  void (__fastcall *load)(BlockActor *this, Level *, const CompoundTag *, DataLoadHelper *);
  bool (__fastcall *save)(BlockActor *this, CompoundTag *);
  bool (__fastcall *saveItemInstanceData)(BlockActor *this, CompoundTag *);
  void (__fastcall *saveBlockData)(BlockActor *this, CompoundTag *, BlockSource *);
  void (__fastcall *loadBlockData)(BlockActor *this, const CompoundTag *, BlockSource *, DataLoadHelper *);
  void (__fastcall *onCustomTagLoadDone)(BlockActor *this, BlockSource *);
  void (__fastcall *tick)(BlockActor *this, BlockSource *);
  bool (__fastcall *isFinished)(BlockActor *this);
  void (__fastcall *onChanged)(BlockActor *this, BlockSource *);
  bool (__fastcall *isMovable)(BlockActor *this, BlockSource *);
  bool (__fastcall *isCustomNameSaved)(BlockActor *this);
  bool (__fastcall *onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *, const Player *);
  void (__fastcall *onPlace)(BlockActor *this, BlockSource *);
  void (__fastcall *onMove)(BlockActor *this);
  void (__fastcall *onRemoved)(BlockActor *this, BlockSource *);
  void (__fastcall *triggerEvent)(BlockActor *this, int, int);
  void (__fastcall *clearCache)(BlockActor *this);
  void (__fastcall *onNeighborChanged)(BlockActor *this, BlockSource *, const BlockPos *);
  float (__fastcall *getShadowRadius)(BlockActor *this, BlockSource *);
  bool (__fastcall *hasAlphaLayer)(BlockActor *this);
  BlockActor *(__fastcall *getCrackEntity)(BlockActor *this, BlockSource *, const BlockPos *);
  void (__fastcall *getDebugText)(BlockActor *this, std::vector&lt;std::string&gt; *, const BlockPos *);
  const std::string *(__fastcall *getCustomName)(BlockActor *this);
  const std::string *(__fastcall *getFilteredCustomName)(BlockActor *this, const UIProfanityContext *);
  std::string *(__fastcall *getName)(BlockActor *this, std::string *result);
  void (__fastcall *setCustomName)(BlockActor *this, const std::string *);
  std::string *(__fastcall *getImmersiveReaderText)(BlockActor *this, std::string *result, BlockSource *);
  int (__fastcall *getRepairCost)(BlockActor *this);
  PistonBlockActor *(__fastcall *getOwningPiston)(BlockActor *this, BlockSource *);
  const Container *(__fastcall *getContainer)(BlockActor *this);
  Container *(__fastcall *getContainer)(BlockActor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(BlockActor *this);
  void (__fastcall *checkWordsOnChunkLoad)(BlockActor *this, LevelChunk *);
  void (__fastcall *checkWordsOnUpdate)(BlockActor *this, Player *);
  void (__fastcall *onChunkLoaded)(BlockActor *this, LevelChunk *);
  void (__fastcall *onChunkUnloaded)(BlockActor *this, LevelChunk *);
  std::unique_ptr&lt;BlockActorDataPacket&gt; *(__fastcall *_getUpdatePacket)(BlockActor *this, std::unique_ptr&lt;BlockActorDataPacket&gt; *result, BlockSource *);
  void (__fastcall *_onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *);
  bool (__fastcall *_playerCanUpdate)(BlockActor *this, const Player *);
};

</code></pre></div><h3 id="legacyoptionsparser"><a href="#legacyoptionsparser" class="header-anchor">#</a> <code>LegacyOptionsParser</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyOptionsParser
{
  std::unordered_map&lt;enum LegacyOption,std::variant&lt;bool,unsigned char,unsigned int&gt;&gt; mOptions;
  std::unordered_map&lt;enum LegacyStat,std::variant&lt;unsigned int,std::vector&lt;unsigned int&gt; &gt;&gt; mStats;
};

</code></pre></div><h3 id="librarytemplatesscreencontroller"><a href="#librarytemplatesscreencontroller" class="header-anchor">#</a> <code>LibraryTemplatesScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryTemplatesScreenController : MainMenuScreenController
{
  std::shared_ptr&lt;LibraryCollection&gt; mCollection;
};

</code></pre></div><h3 id="librarytemplatesscreencontroller-vtbl"><a href="#librarytemplatesscreencontroller-vtbl" class="header-anchor">#</a> <code>LibraryTemplatesScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LibraryTemplatesScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="latejoinpregamescreencontroller"><a href="#latejoinpregamescreencontroller" class="header-anchor">#</a> <code>LateJoinPreGameScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LateJoinPreGameScreenController : MinecraftScreenController
{
  std::function&lt;void __cdecl(void)&gt; mUserReadyToJoinCallback;
  bool mIsSigningInToXBL;
  bool mIsUserReady;
  bool mShouldPromptForPlatformConnection;
  bool mShouldCheckPremiumPlatformAccess;
  bool mCheckingPremiumPlatformAccess;
  bool mHasBeenPromptedForXBLSignIn;
  bool mAutoXBLSignInAttempted;
  bool mShowingWarning;
  bool mIsAnimatingTextVisible;
  std::string mAnimatedMessage;
  int mAnimationCount;
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mLastAnimatingTextUpdate;
  std::unique_ptr&lt;PlatformMultiplayerRestrictions&gt; mPlatformMultiplayerRestrictions;
  bool mHasXBLBroadcast;
};

</code></pre></div><h3 id="latejoinpregamescreencontroller-vtbl"><a href="#latejoinpregamescreencontroller-vtbl" class="header-anchor">#</a> <code>LateJoinPreGameScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LateJoinPreGameScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="leavelevelprogressscreencontroller"><a href="#leavelevelprogressscreencontroller" class="header-anchor">#</a> <code>LeaveLevelProgressScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LeaveLevelProgressScreenController : MinecraftScreenController
{
  bool mInitiated;
  bool mNext;
  bool mForceRenderBelow;
  std::string mCalledFrom;
  __int64 mLastAudioProgressNotificationUpdate;
  const __int64 mProgressMessageInterval;
  std::unique_ptr&lt;ProgressHandler&gt; mProgressHandler;
  std::deque&lt;std::unique_ptr&lt;ProgressHandler&gt;&gt; mProgressHandlerList;
  bool mHasTicked;
  bool mPostInitEventFired;
};

</code></pre></div><h3 id="leavelevelprogressscreencontroller-vtbl"><a href="#leavelevelprogressscreencontroller-vtbl" class="header-anchor">#</a> <code>LeaveLevelProgressScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LeaveLevelProgressScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="libraryinfo-baselibraryinfo"><a href="#libraryinfo-baselibraryinfo" class="header-anchor">#</a> <code>LibraryInfo::BaseLibraryInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryInfo::BaseLibraryInfo
{
  LibraryInfo::BaseLibraryInfo_vtbl *__vftable /*VFT*/;
  std::string mSectionHeader;
};

</code></pre></div><h3 id="libraryinfo-baselibraryinfo-vtbl"><a href="#libraryinfo-baselibraryinfo-vtbl" class="header-anchor">#</a> <code>LibraryInfo::BaseLibraryInfo_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LibraryInfo::BaseLibraryInfo_vtbl
{
  void (__fastcall *~BaseLibraryInfo)(LibraryInfo::BaseLibraryInfo *this);
  const gsl::basic_string_span&lt;char const ,-1&gt; *(__fastcall *getType)(LibraryInfo::BaseLibraryInfo *this);
};

</code></pre></div><h3 id="libraryinfo-expandable"><a href="#libraryinfo-expandable" class="header-anchor">#</a> <code>LibraryInfo::Expandable</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LibraryInfo::Expandable : LibraryInfo::BaseLibraryInfo
{
  std::string mBodyText;
  bool mCanExpand;
  bool mExpanded;
};

</code></pre></div><h3 id="libraryinfo-expandable-vtbl"><a href="#libraryinfo-expandable-vtbl" class="header-anchor">#</a> <code>LibraryInfo::Expandable_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LibraryInfo::Expandable_vtbl
{
  void (__fastcall *~BaseLibraryInfo)(LibraryInfo::BaseLibraryInfo *this);
  const gsl::basic_string_span&lt;char const ,-1&gt; *(__fastcall *getType)(LibraryInfo::BaseLibraryInfo *this);
};

</code></pre></div><h3 id="libraryitemscreencontroller"><a href="#libraryitemscreencontroller" class="header-anchor">#</a> <code>LibraryItemScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController : MainMenuScreenController
{
  std::vector&lt;std::unique_ptr&lt;LibraryInfo::BaseLibraryInfo&gt;&gt; mInfoSections;
  std::shared_ptr&lt;LibraryItem&gt; mItem;
  std::shared_ptr&lt;EducationContentManagerScreenController&gt; mEducationContentManagerScreenController;
};

</code></pre></div><h3 id="libraryitemscreencontroller-vtbl"><a href="#libraryitemscreencontroller-vtbl" class="header-anchor">#</a> <code>LibraryItemScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LibraryItemScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="librarymodalscreencontroller"><a href="#librarymodalscreencontroller" class="header-anchor">#</a> <code>LibraryModalScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryModalScreenController : MinecraftScreenController
{
  std::function&lt;void __cdecl(bool)&gt; mOnModalDismissed;
  LibraryModalScreenType mType;
  std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; mEventProperties;
};

</code></pre></div><h3 id="librarymodalscreencontroller-vtbl"><a href="#librarymodalscreencontroller-vtbl" class="header-anchor">#</a> <code>LibraryModalScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LibraryModalScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="librarymodalscreencontroller-registerbindings-l2-lambda-087130434c3e499fd28e1431cd7fab25"><a href="#librarymodalscreencontroller-registerbindings-l2-lambda-087130434c3e499fd28e1431cd7fab25" class="header-anchor">#</a> <code>LibraryModalScreenController::_registerBindings::__l2::&lt;lambda_087130434c3e499fd28e1431cd7fab25&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryModalScreenController::_registerBindings::__l2::&lt;lambda_087130434c3e499fd28e1431cd7fab25&gt;
{
  LibraryModalScreenController *const __this;
};

</code></pre></div><h3 id="libraryscreencontroller"><a href="#libraryscreencontroller" class="header-anchor">#</a> <code>LibraryScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LibraryScreenController : MainMenuScreenController
{
  std::shared_ptr&lt;LibraryCollection&gt; mLibraryCollection;
  std::string mLibraryTitle;
  std::string mLibraryIcon;
  std::string mLibraryPageDescription;
  LibraryScreenController::ItemType mItemType;
  _BYTE mOptionalFeatures[4];
  LibraryScreenController::ScreenType mScreenType;
  std::string mSearchFilter;
  bool mShowingError;
  bool mShowingWelcome;
};

</code></pre></div><h3 id="libraryscreencontroller-vtbl"><a href="#libraryscreencontroller-vtbl" class="header-anchor">#</a> <code>LibraryScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LibraryScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="localworlduploadscreencontroller"><a href="#localworlduploadscreencontroller" class="header-anchor">#</a> <code>LocalWorldUploadScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LocalWorldUploadScreenController : PlayScreenController
{
  std::string mRealmID;
};

</code></pre></div><h3 id="localworlduploadscreencontroller-vtbl"><a href="#localworlduploadscreencontroller-vtbl" class="header-anchor">#</a> <code>LocalWorldUploadScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LocalWorldUploadScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="localworlduploadscreencontroller-displaylockedworldpopup-l2-lambda-fae9e036f6a709420bc784d748119f15"><a href="#localworlduploadscreencontroller-displaylockedworldpopup-l2-lambda-fae9e036f6a709420bc784d748119f15" class="header-anchor">#</a> <code>LocalWorldUploadScreenController::_displayLockedWorldPopup::__l2::&lt;lambda_fae9e036f6a709420bc784d748119f15&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LocalWorldUploadScreenController::_displayLockedWorldPopup::__l2::&lt;lambda_fae9e036f6a709420bc784d748119f15&gt;
{
  std::weak_ptr&lt;LocalWorldUploadScreenController&gt; weakThis;
  int worldIndex;
};

</code></pre></div><h3 id="localworlduploadscreencontroller-displaylockedworldpopup-l2-lambda-fae9e036f6a709420bc784d748119f15-l5-lambda-42032e03240096d558f0ecd13cc817c1"><a href="#localworlduploadscreencontroller-displaylockedworldpopup-l2-lambda-fae9e036f6a709420bc784d748119f15-l5-lambda-42032e03240096d558f0ecd13cc817c1" class="header-anchor">#</a> <code>LocalWorldUploadScreenController::_displayLockedWorldPopup::__l2::&lt;lambda_fae9e036f6a709420bc784d748119f15&gt;::()::__l5::&lt;lambda_42032e03240096d558f0ecd13cc817c1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LocalWorldUploadScreenController::_displayLockedWorldPopup::__l2::&lt;lambda_fae9e036f6a709420bc784d748119f15&gt;::()::__l5::&lt;lambda_42032e03240096d558f0ecd13cc817c1&gt;
{
  std::weak_ptr&lt;LocalWorldUploadScreenController&gt; weakThis;
};

</code></pre></div><h3 id="localworlduploadscreencontroller-registereventhandlers-l2-lambda-9fcf662c83052d8e55bcccdf4358cecc"><a href="#localworlduploadscreencontroller-registereventhandlers-l2-lambda-9fcf662c83052d8e55bcccdf4358cecc" class="header-anchor">#</a> <code>LocalWorldUploadScreenController::_registerEventHandlers::__l2::&lt;lambda_9fcf662c83052d8e55bcccdf4358cecc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LocalWorldUploadScreenController::_registerEventHandlers::__l2::&lt;lambda_9fcf662c83052d8e55bcccdf4358cecc&gt;
{
};

</code></pre></div><h3 id="localworlduploadscreencontroller-registereventhandlers-l2-lambda-d4b4b7c4a91a0108e2c65e3720de2740"><a href="#localworlduploadscreencontroller-registereventhandlers-l2-lambda-d4b4b7c4a91a0108e2c65e3720de2740" class="header-anchor">#</a> <code>LocalWorldUploadScreenController::_registerEventHandlers::__l2::&lt;lambda_d4b4b7c4a91a0108e2c65e3720de2740&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LocalWorldUploadScreenController::_registerEventHandlers::__l2::&lt;lambda_d4b4b7c4a91a0108e2c65e3720de2740&gt;
{
};

</code></pre></div><h3 id="localworlduploadscreencontroller-registereventhandlers-l2-lambda-becf3e005d1dab992c4902507fb24787"><a href="#localworlduploadscreencontroller-registereventhandlers-l2-lambda-becf3e005d1dab992c4902507fb24787" class="header-anchor">#</a> <code>LocalWorldUploadScreenController::_registerEventHandlers::__l2::&lt;lambda_becf3e005d1dab992c4902507fb24787&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LocalWorldUploadScreenController::_registerEventHandlers::__l2::&lt;lambda_becf3e005d1dab992c4902507fb24787&gt;
{
  LocalWorldUploadScreenController *const __this;
};

</code></pre></div><h3 id="localworlduploadscreencontroller-registereventhandlers-l2-lambda-becf3e005d1dab992c4902507fb24787-l11-lambda-1066b5068e9cdcc2f4dbd9f71796742d"><a href="#localworlduploadscreencontroller-registereventhandlers-l2-lambda-becf3e005d1dab992c4902507fb24787-l11-lambda-1066b5068e9cdcc2f4dbd9f71796742d" class="header-anchor">#</a> <code>LocalWorldUploadScreenController::_registerEventHandlers::__l2::&lt;lambda_becf3e005d1dab992c4902507fb24787&gt;::()::__l11::&lt;lambda_1066b5068e9cdcc2f4dbd9f71796742d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LocalWorldUploadScreenController::_registerEventHandlers::__l2::&lt;lambda_becf3e005d1dab992c4902507fb24787&gt;::()::__l11::&lt;lambda_1066b5068e9cdcc2f4dbd9f71796742d&gt;
{
  std::weak_ptr&lt;LocalWorldUploadScreenController&gt; weakThis;
  const int index;
  LocalWorldInfo *localWorldInfo;
};

</code></pre></div><h3 id="localworlduploadscreencontroller-upload-l10-lambda-2698453db4a1ba74e29f4215bf63a159"><a href="#localworlduploadscreencontroller-upload-l10-lambda-2698453db4a1ba74e29f4215bf63a159" class="header-anchor">#</a> <code>LocalWorldUploadScreenController::_upload::__l10::&lt;lambda_2698453db4a1ba74e29f4215bf63a159&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LocalWorldUploadScreenController::_upload::__l10::&lt;lambda_2698453db4a1ba74e29f4215bf63a159&gt;
{
  std::weak_ptr&lt;LocalWorldUploadScreenController&gt; weakThis;
  const int worldIndex;
};

</code></pre></div><h3 id="librarytemplatesscreencontroller-ctor-l2-lambda-29746ef258516070803c1c986989629c"><a href="#librarytemplatesscreencontroller-ctor-l2-lambda-29746ef258516070803c1c986989629c" class="header-anchor">#</a> <code>LibraryTemplatesScreenController::{ctor}::__l2::&lt;lambda_29746ef258516070803c1c986989629c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryTemplatesScreenController::{ctor}::__l2::&lt;lambda_29746ef258516070803c1c986989629c&gt;
{
};

</code></pre></div><h3 id="libraryscreencontroller-setsortmethod-l2-lambda-34cf7c76c65b80e6aef470045b73afd4"><a href="#libraryscreencontroller-setsortmethod-l2-lambda-34cf7c76c65b80e6aef470045b73afd4" class="header-anchor">#</a> <code>LibraryScreenController::_setSortMethod::__l2::&lt;lambda_34cf7c76c65b80e6aef470045b73afd4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::_setSortMethod::__l2::&lt;lambda_34cf7c76c65b80e6aef470045b73afd4&gt;
{
  LibraryScreenController::SortMode mode;
};

</code></pre></div><h3 id="libraryscreencontroller-showfetcherror-l2-lambda-526012f7c57d670a5a7e6daa10021cd4"><a href="#libraryscreencontroller-showfetcherror-l2-lambda-526012f7c57d670a5a7e6daa10021cd4" class="header-anchor">#</a> <code>LibraryScreenController::_showFetchError::__l2::&lt;lambda_526012f7c57d670a5a7e6daa10021cd4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::_showFetchError::__l2::&lt;lambda_526012f7c57d670a5a7e6daa10021cd4&gt;
{
  LibraryScreenController *const __this;
};

</code></pre></div><h3 id="libraryscreencontroller-registereventhandlers-l2-lambda-2e85df82a80b79582bd9ee3c2037830b"><a href="#libraryscreencontroller-registereventhandlers-l2-lambda-2e85df82a80b79582bd9ee3c2037830b" class="header-anchor">#</a> <code>LibraryScreenController::_registerEventHandlers::__l2::&lt;lambda_2e85df82a80b79582bd9ee3c2037830b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::_registerEventHandlers::__l2::&lt;lambda_2e85df82a80b79582bd9ee3c2037830b&gt;
{
  LibraryScreenController *const __this;
};

</code></pre></div><h3 id="libraryscreencontroller-registereventhandlers-l2-lambda-40fe056b894a595bec516c0d262394f0"><a href="#libraryscreencontroller-registereventhandlers-l2-lambda-40fe056b894a595bec516c0d262394f0" class="header-anchor">#</a> <code>LibraryScreenController::_registerEventHandlers::__l2::&lt;lambda_40fe056b894a595bec516c0d262394f0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::_registerEventHandlers::__l2::&lt;lambda_40fe056b894a595bec516c0d262394f0&gt;
{
  LibraryScreenController *const __this;
};

</code></pre></div><h3 id="libraryscreencontroller-registereventhandlers-l2-lambda-4fc5d32bf862a581c7a8305ddb3d645a"><a href="#libraryscreencontroller-registereventhandlers-l2-lambda-4fc5d32bf862a581c7a8305ddb3d645a" class="header-anchor">#</a> <code>LibraryScreenController::_registerEventHandlers::__l2::&lt;lambda_4fc5d32bf862a581c7a8305ddb3d645a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::_registerEventHandlers::__l2::&lt;lambda_4fc5d32bf862a581c7a8305ddb3d645a&gt;
{
  LibraryScreenController *const __this;
};

</code></pre></div><h3 id="libraryscreencontroller-registerbindings-l2-lambda-592aaa9af0f34fa7d316807ced80c51d"><a href="#libraryscreencontroller-registerbindings-l2-lambda-592aaa9af0f34fa7d316807ced80c51d" class="header-anchor">#</a> <code>LibraryScreenController::_registerBindings::__l2::&lt;lambda_592aaa9af0f34fa7d316807ced80c51d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::_registerBindings::__l2::&lt;lambda_592aaa9af0f34fa7d316807ced80c51d&gt;
{
  LibraryScreenController *const __this;
};

</code></pre></div><h3 id="libraryscreencontroller-registerbindings-l2-lambda-003322239f7d3b3a0e7dcf32a85acb00"><a href="#libraryscreencontroller-registerbindings-l2-lambda-003322239f7d3b3a0e7dcf32a85acb00" class="header-anchor">#</a> <code>LibraryScreenController::_registerBindings::__l2::&lt;lambda_003322239f7d3b3a0e7dcf32a85acb00&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::_registerBindings::__l2::&lt;lambda_003322239f7d3b3a0e7dcf32a85acb00&gt;
{
  LibraryScreenController *const __this;
};

</code></pre></div><h3 id="libraryscreencontroller-registerbindings-l2-lambda-4ca42b3ff47004f759f016fb1d350a8b"><a href="#libraryscreencontroller-registerbindings-l2-lambda-4ca42b3ff47004f759f016fb1d350a8b" class="header-anchor">#</a> <code>LibraryScreenController::_registerBindings::__l2::&lt;lambda_4ca42b3ff47004f759f016fb1d350a8b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::_registerBindings::__l2::&lt;lambda_4ca42b3ff47004f759f016fb1d350a8b&gt;
{
};

</code></pre></div><h3 id="libraryscreencontroller-registerbindings-l2-lambda-1ad56a19b0aaec404015dfe5e71a7b51"><a href="#libraryscreencontroller-registerbindings-l2-lambda-1ad56a19b0aaec404015dfe5e71a7b51" class="header-anchor">#</a> <code>LibraryScreenController::_registerBindings::__l2::&lt;lambda_1ad56a19b0aaec404015dfe5e71a7b51&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::_registerBindings::__l2::&lt;lambda_1ad56a19b0aaec404015dfe5e71a7b51&gt;
{
  LibraryScreenController *const __this;
};

</code></pre></div><h3 id="libraryscreencontroller-registerbindings-l2-lambda-58f7c788d2793cd65ab27620d2b58e14"><a href="#libraryscreencontroller-registerbindings-l2-lambda-58f7c788d2793cd65ab27620d2b58e14" class="header-anchor">#</a> <code>LibraryScreenController::_registerBindings::__l2::&lt;lambda_58f7c788d2793cd65ab27620d2b58e14&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::_registerBindings::__l2::&lt;lambda_58f7c788d2793cd65ab27620d2b58e14&gt;
{
  LibraryScreenController *const __this;
};

</code></pre></div><h3 id="libraryscreencontroller-registerbindings-l2-lambda-6fc9dddd00491e3231bbb6b94fc16730"><a href="#libraryscreencontroller-registerbindings-l2-lambda-6fc9dddd00491e3231bbb6b94fc16730" class="header-anchor">#</a> <code>LibraryScreenController::_registerBindings::__l2::&lt;lambda_6fc9dddd00491e3231bbb6b94fc16730&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::_registerBindings::__l2::&lt;lambda_6fc9dddd00491e3231bbb6b94fc16730&gt;
{
  LibraryScreenController *const __this;
};

</code></pre></div><h3 id="libraryscreencontroller-registerbindings-l2-lambda-faec0e1c485b695748d343d61d26e335"><a href="#libraryscreencontroller-registerbindings-l2-lambda-faec0e1c485b695748d343d61d26e335" class="header-anchor">#</a> <code>LibraryScreenController::_registerBindings::__l2::&lt;lambda_faec0e1c485b695748d343d61d26e335&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::_registerBindings::__l2::&lt;lambda_faec0e1c485b695748d343d61d26e335&gt;
{
  LibraryScreenController *const __this;
};

</code></pre></div><h3 id="libraryscreencontroller-registerbindings-l2-lambda-a84e6a2879858b01baa1af4dc9cc0d84"><a href="#libraryscreencontroller-registerbindings-l2-lambda-a84e6a2879858b01baa1af4dc9cc0d84" class="header-anchor">#</a> <code>LibraryScreenController::_registerBindings::__l2::&lt;lambda_a84e6a2879858b01baa1af4dc9cc0d84&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::_registerBindings::__l2::&lt;lambda_a84e6a2879858b01baa1af4dc9cc0d84&gt;
{
  LibraryScreenController *const __this;
};

</code></pre></div><h3 id="libraryscreencontroller-registerbindings-l2-lambda-aa3c29a3c9badb697bf403a6eec86020"><a href="#libraryscreencontroller-registerbindings-l2-lambda-aa3c29a3c9badb697bf403a6eec86020" class="header-anchor">#</a> <code>LibraryScreenController::_registerBindings::__l2::&lt;lambda_aa3c29a3c9badb697bf403a6eec86020&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::_registerBindings::__l2::&lt;lambda_aa3c29a3c9badb697bf403a6eec86020&gt;
{
  LibraryScreenController *const __this;
};

</code></pre></div><h3 id="libraryscreencontroller-registerbindings-l2-lambda-4484ddcd96c40510c135b3d3e8d7c7b4"><a href="#libraryscreencontroller-registerbindings-l2-lambda-4484ddcd96c40510c135b3d3e8d7c7b4" class="header-anchor">#</a> <code>LibraryScreenController::_registerBindings::__l2::&lt;lambda_4484ddcd96c40510c135b3d3e8d7c7b4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::_registerBindings::__l2::&lt;lambda_4484ddcd96c40510c135b3d3e8d7c7b4&gt;
{
  LibraryScreenController *const __this;
};

</code></pre></div><h3 id="libraryscreencontroller-registerbindings-l2-lambda-b45253f217c103c3c281f24a56d9cc7a"><a href="#libraryscreencontroller-registerbindings-l2-lambda-b45253f217c103c3c281f24a56d9cc7a" class="header-anchor">#</a> <code>LibraryScreenController::_registerBindings::__l2::&lt;lambda_b45253f217c103c3c281f24a56d9cc7a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::_registerBindings::__l2::&lt;lambda_b45253f217c103c3c281f24a56d9cc7a&gt;
{
  LibraryScreenController *const __this;
};

</code></pre></div><h3 id="libraryscreencontroller-ctor-l2-lambda-e2595befff5f97c37c862491bb6d8dc3"><a href="#libraryscreencontroller-ctor-l2-lambda-e2595befff5f97c37c862491bb6d8dc3" class="header-anchor">#</a> <code>LibraryScreenController::{ctor}::__l2::&lt;lambda_e2595befff5f97c37c862491bb6d8dc3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::{ctor}::__l2::&lt;lambda_e2595befff5f97c37c862491bb6d8dc3&gt;
{
  LibraryScreenController *const __this;
};

</code></pre></div><h3 id="libraryscreencontroller-ctor-l2-lambda-d163638d4056721e193208c1ef876d19"><a href="#libraryscreencontroller-ctor-l2-lambda-d163638d4056721e193208c1ef876d19" class="header-anchor">#</a> <code>LibraryScreenController::{ctor}::__l2::&lt;lambda_d163638d4056721e193208c1ef876d19&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::{ctor}::__l2::&lt;lambda_d163638d4056721e193208c1ef876d19&gt;
{
  LibraryScreenController *const __this;
};

</code></pre></div><h3 id="libraryscreencontroller-ctor-l2-lambda-f522437ef474c2023bbd9f7d37663094"><a href="#libraryscreencontroller-ctor-l2-lambda-f522437ef474c2023bbd9f7d37663094" class="header-anchor">#</a> <code>LibraryScreenController::{ctor}::__l2::&lt;lambda_f522437ef474c2023bbd9f7d37663094&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::{ctor}::__l2::&lt;lambda_f522437ef474c2023bbd9f7d37663094&gt;
{
  LibraryScreenController *const __this;
};

</code></pre></div><h3 id="libraryscreencontroller-ctor-l2-lambda-1d96d24b26056472ec708bba1eb67920"><a href="#libraryscreencontroller-ctor-l2-lambda-1d96d24b26056472ec708bba1eb67920" class="header-anchor">#</a> <code>LibraryScreenController::{ctor}::__l2::&lt;lambda_1d96d24b26056472ec708bba1eb67920&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryScreenController::{ctor}::__l2::&lt;lambda_1d96d24b26056472ec708bba1eb67920&gt;
{
  LibraryScreenController *const __this;
};

</code></pre></div><h3 id="librarymodalscreencontroller-registereventhandlers-l2-lambda-e97a7064925225453990c159c1b5a710"><a href="#librarymodalscreencontroller-registereventhandlers-l2-lambda-e97a7064925225453990c159c1b5a710" class="header-anchor">#</a> <code>LibraryModalScreenController::_registerEventHandlers::__l2::&lt;lambda_e97a7064925225453990c159c1b5a710&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryModalScreenController::_registerEventHandlers::__l2::&lt;lambda_e97a7064925225453990c159c1b5a710&gt;
{
  LibraryModalScreenController *const __this;
};

</code></pre></div><h3 id="librarymodalscreencontroller-registereventhandlers-l2-lambda-cc8d376245468c569ce317f69c50021d"><a href="#librarymodalscreencontroller-registereventhandlers-l2-lambda-cc8d376245468c569ce317f69c50021d" class="header-anchor">#</a> <code>LibraryModalScreenController::_registerEventHandlers::__l2::&lt;lambda_cc8d376245468c569ce317f69c50021d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryModalScreenController::_registerEventHandlers::__l2::&lt;lambda_cc8d376245468c569ce317f69c50021d&gt;
{
  LibraryModalScreenController *const __this;
};

</code></pre></div><h3 id="libraryitemscreencontroller-showdownloaderror-l2-lambda-b67c97bb12ba6d2617e855b44112162c"><a href="#libraryitemscreencontroller-showdownloaderror-l2-lambda-b67c97bb12ba6d2617e855b44112162c" class="header-anchor">#</a> <code>LibraryItemScreenController::_showDownloadError::__l2::&lt;lambda_b67c97bb12ba6d2617e855b44112162c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_showDownloadError::__l2::&lt;lambda_b67c97bb12ba6d2617e855b44112162c&gt;
{
};

</code></pre></div><h3 id="libraryitemscreencontroller-registerexpandableeventhandlers-l2-lambda-504f1c51c45ed55299e1a8b3b4a5e5a0"><a href="#libraryitemscreencontroller-registerexpandableeventhandlers-l2-lambda-504f1c51c45ed55299e1a8b3b4a5e5a0" class="header-anchor">#</a> <code>LibraryItemScreenController::_registerExpandableEventHandlers::__l2::&lt;lambda_504f1c51c45ed55299e1a8b3b4a5e5a0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_registerExpandableEventHandlers::__l2::&lt;lambda_504f1c51c45ed55299e1a8b3b4a5e5a0&gt;
{
  LibraryItemScreenController *const __this;
};

</code></pre></div><h3 id="libraryitemscreencontroller-registerexpandablebindings-l2-lambda-4f0fbf9f691d41dc49368c26c8aab563"><a href="#libraryitemscreencontroller-registerexpandablebindings-l2-lambda-4f0fbf9f691d41dc49368c26c8aab563" class="header-anchor">#</a> <code>LibraryItemScreenController::_registerExpandableBindings::__l2::&lt;lambda_4f0fbf9f691d41dc49368c26c8aab563&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_registerExpandableBindings::__l2::&lt;lambda_4f0fbf9f691d41dc49368c26c8aab563&gt;
{
  LibraryItemScreenController *const __this;
};

</code></pre></div><h3 id="libraryitemscreencontroller-registerexpandablebindings-l2-lambda-835e671893d81523f10198403040902a"><a href="#libraryitemscreencontroller-registerexpandablebindings-l2-lambda-835e671893d81523f10198403040902a" class="header-anchor">#</a> <code>LibraryItemScreenController::_registerExpandableBindings::__l2::&lt;lambda_835e671893d81523f10198403040902a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_registerExpandableBindings::__l2::&lt;lambda_835e671893d81523f10198403040902a&gt;
{
  LibraryItemScreenController *const __this;
};

</code></pre></div><h3 id="libraryitemscreencontroller-registerexpandablebindings-l2-lambda-f83a362b4b3275278afdfba6ad8196fd"><a href="#libraryitemscreencontroller-registerexpandablebindings-l2-lambda-f83a362b4b3275278afdfba6ad8196fd" class="header-anchor">#</a> <code>LibraryItemScreenController::_registerExpandableBindings::__l2::&lt;lambda_f83a362b4b3275278afdfba6ad8196fd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_registerExpandableBindings::__l2::&lt;lambda_f83a362b4b3275278afdfba6ad8196fd&gt;
{
  LibraryItemScreenController *const __this;
};

</code></pre></div><h3 id="libraryitemscreencontroller-registerexpandablebindings-l2-lambda-f88d272e9fe6ad4770165d68281bc662"><a href="#libraryitemscreencontroller-registerexpandablebindings-l2-lambda-f88d272e9fe6ad4770165d68281bc662" class="header-anchor">#</a> <code>LibraryItemScreenController::_registerExpandableBindings::__l2::&lt;lambda_f88d272e9fe6ad4770165d68281bc662&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_registerExpandableBindings::__l2::&lt;lambda_f88d272e9fe6ad4770165d68281bc662&gt;
{
  LibraryItemScreenController *const __this;
};

</code></pre></div><h3 id="libraryitemscreencontroller-registereventhandlers-l2-lambda-03d032e11e2bf2824f88c76f19bce8e1"><a href="#libraryitemscreencontroller-registereventhandlers-l2-lambda-03d032e11e2bf2824f88c76f19bce8e1" class="header-anchor">#</a> <code>LibraryItemScreenController::_registerEventHandlers::__l2::&lt;lambda_03d032e11e2bf2824f88c76f19bce8e1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_registerEventHandlers::__l2::&lt;lambda_03d032e11e2bf2824f88c76f19bce8e1&gt;
{
  LibraryItemScreenController *const __this;
};

</code></pre></div><h3 id="libraryitemscreencontroller-registereventhandlers-l2-lambda-a055fc0148af0ab9dc3c88d9a503c9ba"><a href="#libraryitemscreencontroller-registereventhandlers-l2-lambda-a055fc0148af0ab9dc3c88d9a503c9ba" class="header-anchor">#</a> <code>LibraryItemScreenController::_registerEventHandlers::__l2::&lt;lambda_a055fc0148af0ab9dc3c88d9a503c9ba&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_registerEventHandlers::__l2::&lt;lambda_a055fc0148af0ab9dc3c88d9a503c9ba&gt;
{
  LibraryItemScreenController *const __this;
};

</code></pre></div><h3 id="libraryitemscreencontroller-registereventhandlers-l5-lambda-ad859bdd7a509facab0bc14290af00b8"><a href="#libraryitemscreencontroller-registereventhandlers-l5-lambda-ad859bdd7a509facab0bc14290af00b8" class="header-anchor">#</a> <code>LibraryItemScreenController::_registerEventHandlers::__l5::&lt;lambda_ad859bdd7a509facab0bc14290af00b8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_registerEventHandlers::__l5::&lt;lambda_ad859bdd7a509facab0bc14290af00b8&gt;
{
  LibraryItemScreenController *const __this;
};

</code></pre></div><h3 id="libraryitemscreencontroller-registereventhandlers-l5-lambda-0a736d5bacb4799a4171f194f00e16e5"><a href="#libraryitemscreencontroller-registereventhandlers-l5-lambda-0a736d5bacb4799a4171f194f00e16e5" class="header-anchor">#</a> <code>LibraryItemScreenController::_registerEventHandlers::__l5::&lt;lambda_0a736d5bacb4799a4171f194f00e16e5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_registerEventHandlers::__l5::&lt;lambda_0a736d5bacb4799a4171f194f00e16e5&gt;
{
  LibraryItemScreenController *const __this;
};

</code></pre></div><h3 id="libraryitemscreencontroller-registereventhandlers-l5-lambda-423aa8538b7e6a879e79ac94b8908e05"><a href="#libraryitemscreencontroller-registereventhandlers-l5-lambda-423aa8538b7e6a879e79ac94b8908e05" class="header-anchor">#</a> <code>LibraryItemScreenController::_registerEventHandlers::__l5::&lt;lambda_423aa8538b7e6a879e79ac94b8908e05&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_registerEventHandlers::__l5::&lt;lambda_423aa8538b7e6a879e79ac94b8908e05&gt;
{
  LibraryItemScreenController *const __this;
};

</code></pre></div><h3 id="libraryitemscreencontroller-registereventhandlers-l2-lambda-32691a90d1b36a98278bd07c6302b122"><a href="#libraryitemscreencontroller-registereventhandlers-l2-lambda-32691a90d1b36a98278bd07c6302b122" class="header-anchor">#</a> <code>LibraryItemScreenController::_registerEventHandlers::__l2::&lt;lambda_32691a90d1b36a98278bd07c6302b122&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_registerEventHandlers::__l2::&lt;lambda_32691a90d1b36a98278bd07c6302b122&gt;
{
  LibraryItemScreenController *const __this;
};

</code></pre></div><h3 id="libraryitemscreencontroller-registereventhandlers-l2-lambda-fd86b907f8ac3730499ec26fc21d04e1"><a href="#libraryitemscreencontroller-registereventhandlers-l2-lambda-fd86b907f8ac3730499ec26fc21d04e1" class="header-anchor">#</a> <code>LibraryItemScreenController::_registerEventHandlers::__l2::&lt;lambda_fd86b907f8ac3730499ec26fc21d04e1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_registerEventHandlers::__l2::&lt;lambda_fd86b907f8ac3730499ec26fc21d04e1&gt;
{
  LibraryItemScreenController *const __this;
};

</code></pre></div><h3 id="libraryitemscreencontroller-registerbindings-l2-lambda-9fdcb5459b12627cc618fff16a327770"><a href="#libraryitemscreencontroller-registerbindings-l2-lambda-9fdcb5459b12627cc618fff16a327770" class="header-anchor">#</a> <code>LibraryItemScreenController::_registerBindings::__l2::&lt;lambda_9fdcb5459b12627cc618fff16a327770&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_registerBindings::__l2::&lt;lambda_9fdcb5459b12627cc618fff16a327770&gt;
{
  LibraryItemScreenController *const __this;
};

</code></pre></div><h3 id="libraryitemscreencontroller-registerbindings-l2-lambda-ee6216ed259f203f73f369f52a7fbbcc"><a href="#libraryitemscreencontroller-registerbindings-l2-lambda-ee6216ed259f203f73f369f52a7fbbcc" class="header-anchor">#</a> <code>LibraryItemScreenController::_registerBindings::__l2::&lt;lambda_ee6216ed259f203f73f369f52a7fbbcc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_registerBindings::__l2::&lt;lambda_ee6216ed259f203f73f369f52a7fbbcc&gt;
{
  LibraryItemScreenController *const __this;
};

</code></pre></div><h3 id="libraryitemscreencontroller-registerbindings-l2-lambda-b4bc70e6bc72bba158b072b609a3a118"><a href="#libraryitemscreencontroller-registerbindings-l2-lambda-b4bc70e6bc72bba158b072b609a3a118" class="header-anchor">#</a> <code>LibraryItemScreenController::_registerBindings::__l2::&lt;lambda_b4bc70e6bc72bba158b072b609a3a118&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_registerBindings::__l2::&lt;lambda_b4bc70e6bc72bba158b072b609a3a118&gt;
{
  LibraryItemScreenController *const __this;
};

</code></pre></div><h3 id="libraryitemscreencontroller-registerbindings-l2-lambda-89121a3083e353d2c662975b555e8c15"><a href="#libraryitemscreencontroller-registerbindings-l2-lambda-89121a3083e353d2c662975b555e8c15" class="header-anchor">#</a> <code>LibraryItemScreenController::_registerBindings::__l2::&lt;lambda_89121a3083e353d2c662975b555e8c15&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_registerBindings::__l2::&lt;lambda_89121a3083e353d2c662975b555e8c15&gt;
{
  LibraryItemScreenController *const __this;
};

</code></pre></div><h3 id="libraryitemscreencontroller-registerbindings-l2-lambda-6690d83ebe1652ca5dec16da007ac28d"><a href="#libraryitemscreencontroller-registerbindings-l2-lambda-6690d83ebe1652ca5dec16da007ac28d" class="header-anchor">#</a> <code>LibraryItemScreenController::_registerBindings::__l2::&lt;lambda_6690d83ebe1652ca5dec16da007ac28d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_registerBindings::__l2::&lt;lambda_6690d83ebe1652ca5dec16da007ac28d&gt;
{
  LibraryItemScreenController *const __this;
};

</code></pre></div><h3 id="libraryitemscreencontroller-registerbindings-l2-lambda-69d9433a19f7d10ccb8ee4b8b008d492"><a href="#libraryitemscreencontroller-registerbindings-l2-lambda-69d9433a19f7d10ccb8ee4b8b008d492" class="header-anchor">#</a> <code>LibraryItemScreenController::_registerBindings::__l2::&lt;lambda_69d9433a19f7d10ccb8ee4b8b008d492&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_registerBindings::__l2::&lt;lambda_69d9433a19f7d10ccb8ee4b8b008d492&gt;
{
  LibraryItemScreenController *const __this;
};

</code></pre></div><h3 id="leavelevelprogressscreencontroller-registerprogressbindings-l2-lambda-7226532f83cfe7721df3c8fb6ebef7a2"><a href="#leavelevelprogressscreencontroller-registerprogressbindings-l2-lambda-7226532f83cfe7721df3c8fb6ebef7a2" class="header-anchor">#</a> <code>LeaveLevelProgressScreenController::_registerProgressBindings::__l2::&lt;lambda_7226532f83cfe7721df3c8fb6ebef7a2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LeaveLevelProgressScreenController::_registerProgressBindings::__l2::&lt;lambda_7226532f83cfe7721df3c8fb6ebef7a2&gt;
{
};

</code></pre></div><h3 id="leavelevelprogressscreencontroller-registerprogressbindings-l2-lambda-e9b0f1bfeddb77c39a03f871c3ee1a21"><a href="#leavelevelprogressscreencontroller-registerprogressbindings-l2-lambda-e9b0f1bfeddb77c39a03f871c3ee1a21" class="header-anchor">#</a> <code>LeaveLevelProgressScreenController::_registerProgressBindings::__l2::&lt;lambda_e9b0f1bfeddb77c39a03f871c3ee1a21&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LeaveLevelProgressScreenController::_registerProgressBindings::__l2::&lt;lambda_e9b0f1bfeddb77c39a03f871c3ee1a21&gt;
{
  LeaveLevelProgressScreenController *const __this;
};

</code></pre></div><h3 id="leavelevelprogressscreencontroller-registerprogressbindings-l2-lambda-3403c299cda5ec0a610db5d55a315bbd"><a href="#leavelevelprogressscreencontroller-registerprogressbindings-l2-lambda-3403c299cda5ec0a610db5d55a315bbd" class="header-anchor">#</a> <code>LeaveLevelProgressScreenController::_registerProgressBindings::__l2::&lt;lambda_3403c299cda5ec0a610db5d55a315bbd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LeaveLevelProgressScreenController::_registerProgressBindings::__l2::&lt;lambda_3403c299cda5ec0a610db5d55a315bbd&gt;
{
  LeaveLevelProgressScreenController *const __this;
};

</code></pre></div><h3 id="leavelevelprogressscreencontroller-registerprogressbindings-l2-lambda-72a669de99520c8152738e82da58597f"><a href="#leavelevelprogressscreencontroller-registerprogressbindings-l2-lambda-72a669de99520c8152738e82da58597f" class="header-anchor">#</a> <code>LeaveLevelProgressScreenController::_registerProgressBindings::__l2::&lt;lambda_72a669de99520c8152738e82da58597f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LeaveLevelProgressScreenController::_registerProgressBindings::__l2::&lt;lambda_72a669de99520c8152738e82da58597f&gt;
{
};

</code></pre></div><h3 id="leavelevelprogressscreencontroller-registerprogressbindings-l2-lambda-cbb3e692c34d9e8db877e750b675b2d2"><a href="#leavelevelprogressscreencontroller-registerprogressbindings-l2-lambda-cbb3e692c34d9e8db877e750b675b2d2" class="header-anchor">#</a> <code>LeaveLevelProgressScreenController::_registerProgressBindings::__l2::&lt;lambda_cbb3e692c34d9e8db877e750b675b2d2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LeaveLevelProgressScreenController::_registerProgressBindings::__l2::&lt;lambda_cbb3e692c34d9e8db877e750b675b2d2&gt;
{
  LeaveLevelProgressScreenController *const __this;
};

</code></pre></div><h3 id="leavelevelprogressscreencontroller-registerprogressbindings-l2-lambda-4780206e4404167244a0a482ba6bb3fc"><a href="#leavelevelprogressscreencontroller-registerprogressbindings-l2-lambda-4780206e4404167244a0a482ba6bb3fc" class="header-anchor">#</a> <code>LeaveLevelProgressScreenController::_registerProgressBindings::__l2::&lt;lambda_4780206e4404167244a0a482ba6bb3fc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LeaveLevelProgressScreenController::_registerProgressBindings::__l2::&lt;lambda_4780206e4404167244a0a482ba6bb3fc&gt;
{
  LeaveLevelProgressScreenController *const __this;
};

</code></pre></div><h3 id="latejoinpregamescreencontroller-warnrestrictedplatformmultiplayer-l2-lambda-1be6f90f58b2b81e229f2878164a7de3"><a href="#latejoinpregamescreencontroller-warnrestrictedplatformmultiplayer-l2-lambda-1be6f90f58b2b81e229f2878164a7de3" class="header-anchor">#</a> <code>LateJoinPreGameScreenController::_warnRestrictedPlatformMultiplayer::__l2::&lt;lambda_1be6f90f58b2b81e229f2878164a7de3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LateJoinPreGameScreenController::_warnRestrictedPlatformMultiplayer::__l2::&lt;lambda_1be6f90f58b2b81e229f2878164a7de3&gt;
{
  std::weak_ptr&lt;LateJoinPreGameScreenController&gt; weakThis;
};

</code></pre></div><h3 id="latejoinpregamescreencontroller-warnlockedskin-l2-lambda-19391f408f1629e0c8aeeeb8df94d075"><a href="#latejoinpregamescreencontroller-warnlockedskin-l2-lambda-19391f408f1629e0c8aeeeb8df94d075" class="header-anchor">#</a> <code>LateJoinPreGameScreenController::_warnLockedSkin::__l2::&lt;lambda_19391f408f1629e0c8aeeeb8df94d075&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LateJoinPreGameScreenController::_warnLockedSkin::__l2::&lt;lambda_19391f408f1629e0c8aeeeb8df94d075&gt;
{
  std::weak_ptr&lt;LateJoinPreGameScreenController&gt; weakThis;
};

</code></pre></div><h3 id="latejoinpregamescreencontroller-promptforxblsignin-l5-lambda-df34f8976fe36144931864476a9d9544"><a href="#latejoinpregamescreencontroller-promptforxblsignin-l5-lambda-df34f8976fe36144931864476a9d9544" class="header-anchor">#</a> <code>LateJoinPreGameScreenController::_promptForXBLSignIn::__l5::&lt;lambda_df34f8976fe36144931864476a9d9544&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LateJoinPreGameScreenController::_promptForXBLSignIn::__l5::&lt;lambda_df34f8976fe36144931864476a9d9544&gt;
{
};

</code></pre></div><h3 id="latejoinpregamescreencontroller-checkpremiumaccessandshowupsell-l2-lambda-2760d6c2b2b29a79ae8f23ce45c3a731-l13-lambda-fba2d11ecdbb6d3e527c8ed17d1e13c9"><a href="#latejoinpregamescreencontroller-checkpremiumaccessandshowupsell-l2-lambda-2760d6c2b2b29a79ae8f23ce45c3a731-l13-lambda-fba2d11ecdbb6d3e527c8ed17d1e13c9" class="header-anchor">#</a> <code>LateJoinPreGameScreenController::_checkPremiumAccessAndShowUpsell::__l2::&lt;lambda_2760d6c2b2b29a79ae8f23ce45c3a731&gt;::()::__l13::&lt;lambda_fba2d11ecdbb6d3e527c8ed17d1e13c9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LateJoinPreGameScreenController::_checkPremiumAccessAndShowUpsell::__l2::&lt;lambda_2760d6c2b2b29a79ae8f23ce45c3a731&gt;::()::__l13::&lt;lambda_fba2d11ecdbb6d3e527c8ed17d1e13c9&gt;
{
  std::function&lt;void __cdecl(bool)&gt; callback;
};

</code></pre></div><h3 id="latejoinpregamescreencontroller-promptforplatformconnection-l5-lambda-11ededcc0ecdc0e554d02d3f0cad45f0"><a href="#latejoinpregamescreencontroller-promptforplatformconnection-l5-lambda-11ededcc0ecdc0e554d02d3f0cad45f0" class="header-anchor">#</a> <code>LateJoinPreGameScreenController::_promptForPlatformConnection::__l5::&lt;lambda_11ededcc0ecdc0e554d02d3f0cad45f0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LateJoinPreGameScreenController::_promptForPlatformConnection::__l5::&lt;lambda_11ededcc0ecdc0e554d02d3f0cad45f0&gt;
{
  std::weak_ptr&lt;LateJoinPreGameScreenController&gt; weakThis;
};

</code></pre></div><h3 id="latejoinpregamescreencontroller-handleuserreadytojoingame-l24-lambda-fa7ba01f28dd7b30e619b7a7a3868da8"><a href="#latejoinpregamescreencontroller-handleuserreadytojoingame-l24-lambda-fa7ba01f28dd7b30e619b7a7a3868da8" class="header-anchor">#</a> <code>LateJoinPreGameScreenController::_handleUserReadyToJoinGame::__l24::&lt;lambda_fa7ba01f28dd7b30e619b7a7a3868da8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LateJoinPreGameScreenController::_handleUserReadyToJoinGame::__l24::&lt;lambda_fa7ba01f28dd7b30e619b7a7a3868da8&gt;
{
  std::weak_ptr&lt;LateJoinPreGameScreenController&gt; weakThis;
};

</code></pre></div><h3 id="latejoinpregamescreencontroller-handleuserreadytojoingame-l10-lambda-3c9f9995d67fce18f2bf3e46bc5b70cf"><a href="#latejoinpregamescreencontroller-handleuserreadytojoingame-l10-lambda-3c9f9995d67fce18f2bf3e46bc5b70cf" class="header-anchor">#</a> <code>LateJoinPreGameScreenController::_handleUserReadyToJoinGame::__l10::&lt;lambda_3c9f9995d67fce18f2bf3e46bc5b70cf&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LateJoinPreGameScreenController::_handleUserReadyToJoinGame::__l10::&lt;lambda_3c9f9995d67fce18f2bf3e46bc5b70cf&gt;
{
  std::weak_ptr&lt;LateJoinPreGameScreenController&gt; weakThis;
};

</code></pre></div><h3 id="latejoinpregamescreencontroller-handleuserreadytojoingame-l8-lambda-d8c4c23fdf45a0d6db35f16bc1d463da"><a href="#latejoinpregamescreencontroller-handleuserreadytojoingame-l8-lambda-d8c4c23fdf45a0d6db35f16bc1d463da" class="header-anchor">#</a> <code>LateJoinPreGameScreenController::_handleUserReadyToJoinGame::__l8::&lt;lambda_d8c4c23fdf45a0d6db35f16bc1d463da&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LateJoinPreGameScreenController::_handleUserReadyToJoinGame::__l8::&lt;lambda_d8c4c23fdf45a0d6db35f16bc1d463da&gt;
{
  std::weak_ptr&lt;LateJoinPreGameScreenController&gt; weakThis;
};

</code></pre></div><h3 id="latejoinpregamescreencontroller-tickuserstate-l57-lambda-119962919777b57b4e564f544aadbe2d"><a href="#latejoinpregamescreencontroller-tickuserstate-l57-lambda-119962919777b57b4e564f544aadbe2d" class="header-anchor">#</a> <code>LateJoinPreGameScreenController::_tickUserState::__l57::&lt;lambda_119962919777b57b4e564f544aadbe2d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LateJoinPreGameScreenController::_tickUserState::__l57::&lt;lambda_119962919777b57b4e564f544aadbe2d&gt;
{
  std::weak_ptr&lt;LateJoinPreGameScreenController&gt; weakThis;
};

</code></pre></div><h3 id="latejoinpregamescreencontroller-tickuserstate-l57-lambda-1a10213e3c09240800599327c4c141c2"><a href="#latejoinpregamescreencontroller-tickuserstate-l57-lambda-1a10213e3c09240800599327c4c141c2" class="header-anchor">#</a> <code>LateJoinPreGameScreenController::_tickUserState::__l57::&lt;lambda_1a10213e3c09240800599327c4c141c2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LateJoinPreGameScreenController::_tickUserState::__l57::&lt;lambda_1a10213e3c09240800599327c4c141c2&gt;
{
  std::weak_ptr&lt;LateJoinPreGameScreenController&gt; weakThis;
};

</code></pre></div><h3 id="latejoinpregamescreencontroller-tickuserstate-l50-lambda-5040f9d2caee16f9898a9a6c180a0744"><a href="#latejoinpregamescreencontroller-tickuserstate-l50-lambda-5040f9d2caee16f9898a9a6c180a0744" class="header-anchor">#</a> <code>LateJoinPreGameScreenController::_tickUserState::__l50::&lt;lambda_5040f9d2caee16f9898a9a6c180a0744&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LateJoinPreGameScreenController::_tickUserState::__l50::&lt;lambda_5040f9d2caee16f9898a9a6c180a0744&gt;
{
  std::weak_ptr&lt;LateJoinPreGameScreenController&gt; weakThis;
};

</code></pre></div><h3 id="latejoinpregamescreencontroller-tickuserstate-l50-lambda-5040f9d2caee16f9898a9a6c180a0744-l5-lambda-945543d829378eec2113aad8e7fb2137"><a href="#latejoinpregamescreencontroller-tickuserstate-l50-lambda-5040f9d2caee16f9898a9a6c180a0744-l5-lambda-945543d829378eec2113aad8e7fb2137" class="header-anchor">#</a> <code>LateJoinPreGameScreenController::_tickUserState::__l50::&lt;lambda_5040f9d2caee16f9898a9a6c180a0744&gt;::()::__l5::&lt;lambda_945543d829378eec2113aad8e7fb2137&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LateJoinPreGameScreenController::_tickUserState::__l50::&lt;lambda_5040f9d2caee16f9898a9a6c180a0744&gt;::()::__l5::&lt;lambda_945543d829378eec2113aad8e7fb2137&gt;
{
  std::weak_ptr&lt;LateJoinPreGameScreenController&gt; weakThis;
};

</code></pre></div><h3 id="latejoinpregamescreencontroller-tickuserstate-l50-lambda-5040f9d2caee16f9898a9a6c180a0744-l5-lambda-3fb86b5128e8375f8cefd08fd1a96017"><a href="#latejoinpregamescreencontroller-tickuserstate-l50-lambda-5040f9d2caee16f9898a9a6c180a0744-l5-lambda-3fb86b5128e8375f8cefd08fd1a96017" class="header-anchor">#</a> <code>LateJoinPreGameScreenController::_tickUserState::__l50::&lt;lambda_5040f9d2caee16f9898a9a6c180a0744&gt;::()::__l5::&lt;lambda_3fb86b5128e8375f8cefd08fd1a96017&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LateJoinPreGameScreenController::_tickUserState::__l50::&lt;lambda_5040f9d2caee16f9898a9a6c180a0744&gt;::()::__l5::&lt;lambda_3fb86b5128e8375f8cefd08fd1a96017&gt;
{
  std::weak_ptr&lt;LateJoinPreGameScreenController&gt; weakThis;
};

</code></pre></div><h3 id="latejoinpregamescreencontroller-registerbindings-l2-lambda-5951322b3af1fcd4613a60e8db986b39"><a href="#latejoinpregamescreencontroller-registerbindings-l2-lambda-5951322b3af1fcd4613a60e8db986b39" class="header-anchor">#</a> <code>LateJoinPreGameScreenController::_registerBindings::__l2::&lt;lambda_5951322b3af1fcd4613a60e8db986b39&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LateJoinPreGameScreenController::_registerBindings::__l2::&lt;lambda_5951322b3af1fcd4613a60e8db986b39&gt;
{
  LateJoinPreGameScreenController *const __this;
};

</code></pre></div><h3 id="latejoinpregamescreencontroller-registerbindings-l2-lambda-ad0506e389c52452432310d87eea53d1"><a href="#latejoinpregamescreencontroller-registerbindings-l2-lambda-ad0506e389c52452432310d87eea53d1" class="header-anchor">#</a> <code>LateJoinPreGameScreenController::_registerBindings::__l2::&lt;lambda_ad0506e389c52452432310d87eea53d1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LateJoinPreGameScreenController::_registerBindings::__l2::&lt;lambda_ad0506e389c52452432310d87eea53d1&gt;
{
  LateJoinPreGameScreenController *const __this;
};

</code></pre></div><h3 id="latejoinpregamescreencontroller-registereventhandlers-l2-lambda-d11fdb5ae823c967517c6f51d11fbe2d"><a href="#latejoinpregamescreencontroller-registereventhandlers-l2-lambda-d11fdb5ae823c967517c6f51d11fbe2d" class="header-anchor">#</a> <code>LateJoinPreGameScreenController::_registerEventHandlers::__l2::&lt;lambda_d11fdb5ae823c967517c6f51d11fbe2d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LateJoinPreGameScreenController::_registerEventHandlers::__l2::&lt;lambda_d11fdb5ae823c967517c6f51d11fbe2d&gt;
{
  LateJoinPreGameScreenController *const __this;
};

</code></pre></div><h3 id="libraryitemscreencontroller-registersubcontrollers-l2-lambda-8ae0bfb7c7b89f1a91e50295c6c13497"><a href="#libraryitemscreencontroller-registersubcontrollers-l2-lambda-8ae0bfb7c7b89f1a91e50295c6c13497" class="header-anchor">#</a> <code>LibraryItemScreenController::_registerSubControllers::__l2::&lt;lambda_8ae0bfb7c7b89f1a91e50295c6c13497&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryItemScreenController::_registerSubControllers::__l2::&lt;lambda_8ae0bfb7c7b89f1a91e50295c6c13497&gt;
{
  LibraryItemScreenController *const __this;
};

</code></pre></div><h3 id="levelcontainermanagermodel"><a href="#levelcontainermanagermodel" class="header-anchor">#</a> <code>LevelContainerManagerModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LevelContainerManagerModel : ContainerManagerModel
{
  BlockPos mBlockPos;
  ActorUniqueID mEntityUniqueID;
  BlockActorType mBlockActorType;
};

</code></pre></div><h3 id="levelcontainermanagermodel-vtbl"><a href="#levelcontainermanagermodel-vtbl" class="header-anchor">#</a> <code>LevelContainerManagerModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelContainerManagerModel_vtbl
{
  void (__fastcall *~IContainerManager)(IContainerManager *this);
  ContainerID (__fastcall *getContainerId)(IContainerManager *this);
  void (__fastcall *setContainerId)(IContainerManager *this, ContainerID);
  ContainerType (__fastcall *getContainerType)(IContainerManager *this);
  void (__fastcall *setContainerType)(IContainerManager *this, ContainerType);
  void (__fastcall *serverInitItemStackIds)(IContainerManager *this);
  std::vector&lt;ItemStack&gt; *(__fastcall *getItemCopies)(IContainerManager *this, std::vector&lt;ItemStack&gt; *result);
  void (__fastcall *setSlot)(IContainerManager *this, int, const ItemStack *, bool);
  const ItemStack *(__fastcall *getSlot)(IContainerManager *this, int);
  void (__fastcall *setData)(IContainerManager *this, int, int);
  void (__fastcall *broadcastChanges)(IContainerManager *this);
  bool (__fastcall *validateContainer)(IContainerManager *this);
  bool (__fastcall *isValid)(ContainerManagerModel *this, float);
  ContainerScreenContext *(__fastcall *_postInit)(ContainerManagerModel *this, ContainerScreenContext *result);
};

</code></pre></div><h3 id="layoutvariables-invalidatedependencies-l5-lambda-e07b7deff4995bf8bd69bba837bd8c55"><a href="#layoutvariables-invalidatedependencies-l5-lambda-e07b7deff4995bf8bd69bba837bd8c55" class="header-anchor">#</a> <code>LayoutVariables::invalidateDependencies::__l5::&lt;lambda_e07b7deff4995bf8bd69bba837bd8c55&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayoutVariables::invalidateDependencies::__l5::&lt;lambda_e07b7deff4995bf8bd69bba837bd8c55&gt;
{
  LayoutVariables *const __this;
};

</code></pre></div><h3 id="layoutvariables-invalidate-l5-lambda-b407bc94efcada76e00e0c86eee9e18a"><a href="#layoutvariables-invalidate-l5-lambda-b407bc94efcada76e00e0c86eee9e18a" class="header-anchor">#</a> <code>LayoutVariables::invalidate::__l5::&lt;lambda_b407bc94efcada76e00e0c86eee9e18a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayoutVariables::invalidate::__l5::&lt;lambda_b407bc94efcada76e00e0c86eee9e18a&gt;
{
  LayoutVariables *const __this;
};

</code></pre></div><h3 id="layoutvariable-addpostcomputationalneeds-l12-lambda-9681c2640052c89a49869a8acee0ff4e"><a href="#layoutvariable-addpostcomputationalneeds-l12-lambda-9681c2640052c89a49869a8acee0ff4e" class="header-anchor">#</a> <code>LayoutVariable::addPostComputationalNeeds::__l12::&lt;lambda_9681c2640052c89a49869a8acee0ff4e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayoutVariable::addPostComputationalNeeds::__l12::&lt;lambda_9681c2640052c89a49869a8acee0ff4e&gt;
{
  LayoutVariable *const __this;
  VariableRef var;
};

</code></pre></div><h3 id="layoutvariable-addpostcomputationalneeds-l8-lambda-d5f578f60651d527eac6c074ba6fbc90"><a href="#layoutvariable-addpostcomputationalneeds-l8-lambda-d5f578f60651d527eac6c074ba6fbc90" class="header-anchor">#</a> <code>LayoutVariable::addPostComputationalNeeds::__l8::&lt;lambda_d5f578f60651d527eac6c074ba6fbc90&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayoutVariable::addPostComputationalNeeds::__l8::&lt;lambda_d5f578f60651d527eac6c074ba6fbc90&gt;
{
  LayoutVariable *const __this;
  VariableRef var;
};

</code></pre></div><h3 id="layoutvariable-overriderenderablelayoutrule-l2-lambda-fdcd53cd549c0efcb3113306a5f2b5ff"><a href="#layoutvariable-overriderenderablelayoutrule-l2-lambda-fdcd53cd549c0efcb3113306a5f2b5ff" class="header-anchor">#</a> <code>LayoutVariable::overrideRenderableLayoutRule::__l2::&lt;lambda_fdcd53cd549c0efcb3113306a5f2b5ff&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayoutVariable::overrideRenderableLayoutRule::__l2::&lt;lambda_fdcd53cd549c0efcb3113306a5f2b5ff&gt;
{
  const LayoutVariableType *type;
  float *overrideValue;
  bool *hasOverride;
};

</code></pre></div><h3 id="layoutrule-addstackpanelitemremaindersizeterms-l2-lambda-a7a1569b1f1accbf7feb1785883dbd6f"><a href="#layoutrule-addstackpanelitemremaindersizeterms-l2-lambda-a7a1569b1f1accbf7feb1785883dbd6f" class="header-anchor">#</a> <code>LayoutRule::addStackPanelItemRemainderSizeTerms::__l2::&lt;lambda_a7a1569b1f1accbf7feb1785883dbd6f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LayoutRule::addStackPanelItemRemainderSizeTerms::__l2::&lt;lambda_a7a1569b1f1accbf7feb1785883dbd6f&gt;
{
  UIControl *parent;
  UIControl *control;
  const LayoutVariableType sizeType;
};

</code></pre></div><h3 id="layoutmanager-update-l2-lambda-14197656028e6e2a39273b46fbee8311"><a href="#layoutmanager-update-l2-lambda-14197656028e6e2a39273b46fbee8311" class="header-anchor">#</a> <code>LayoutManager::_update::__l2::&lt;lambda_14197656028e6e2a39273b46fbee8311&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayoutManager::_update::__l2::&lt;lambda_14197656028e6e2a39273b46fbee8311&gt;
{
};

</code></pre></div><h3 id="layoutrule-addfillgriddimensionterm-l2-lambda-5c4d56ce84a9d367db2a6bbb1aa4ff51"><a href="#layoutrule-addfillgriddimensionterm-l2-lambda-5c4d56ce84a9d367db2a6bbb1aa4ff51" class="header-anchor">#</a> <code>LayoutRule::addFillGridDimensionTerm::__l2::&lt;lambda_5c4d56ce84a9d367db2a6bbb1aa4ff51&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) LayoutRule::addFillGridDimensionTerm::__l2::&lt;lambda_5c4d56ce84a9d367db2a6bbb1aa4ff51&gt;
{
  ui::OrientationType rescalingType;
  LayoutVariableType dimensionType;
};

</code></pre></div><h3 id="layoutrule-addrescalinggriddimensionterm-l2-lambda-e2b9bd49291b78dd9523e89aa06e496e"><a href="#layoutrule-addrescalinggriddimensionterm-l2-lambda-e2b9bd49291b78dd9523e89aa06e496e" class="header-anchor">#</a> <code>LayoutRule::addRescalingGridDimensionTerm::__l2::&lt;lambda_e2b9bd49291b78dd9523e89aa06e496e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) LayoutRule::addRescalingGridDimensionTerm::__l2::&lt;lambda_e2b9bd49291b78dd9523e89aa06e496e&gt;
{
  std::weak_ptr&lt;UIControl&gt; weakControl;
  ui::OrientationType rescalingType;
  LayoutVariableType dimensionType;
};

</code></pre></div><h3 id="layoutrule-addgriditemsizeterms-l2-lambda-6805c03e4c85f3b7ce1f7d54eaa2d6c1"><a href="#layoutrule-addgriditemsizeterms-l2-lambda-6805c03e4c85f3b7ce1f7d54eaa2d6c1" class="header-anchor">#</a> <code>LayoutRule::addGridItemSizeTerms::__l2::&lt;lambda_6805c03e4c85f3b7ce1f7d54eaa2d6c1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayoutRule::addGridItemSizeTerms::__l2::&lt;lambda_6805c03e4c85f3b7ce1f7d54eaa2d6c1&gt;
{
};

</code></pre></div><h3 id="layoutrule-addgriditempositionterms-l15-lambda-f27ec7ee38cb33031bbaa23767312977"><a href="#layoutrule-addgriditempositionterms-l15-lambda-f27ec7ee38cb33031bbaa23767312977" class="header-anchor">#</a> <code>LayoutRule::addGridItemPositionTerms::__l15::&lt;lambda_f27ec7ee38cb33031bbaa23767312977&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayoutRule::addGridItemPositionTerms::__l15::&lt;lambda_f27ec7ee38cb33031bbaa23767312977&gt;
{
};

</code></pre></div><h3 id="layoutrule-addgriditempositionterms-l13-lambda-f954b369726128e1a26f9745705bfd06"><a href="#layoutrule-addgriditempositionterms-l13-lambda-f954b369726128e1a26f9745705bfd06" class="header-anchor">#</a> <code>LayoutRule::addGridItemPositionTerms::__l13::&lt;lambda_f954b369726128e1a26f9745705bfd06&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayoutRule::addGridItemPositionTerms::__l13::&lt;lambda_f954b369726128e1a26f9745705bfd06&gt;
{
};

</code></pre></div><h3 id="layoutrule-addaxisoffsetterms-l33-lambda-50705c4513fadd86996a53c169f1338a"><a href="#layoutrule-addaxisoffsetterms-l33-lambda-50705c4513fadd86996a53c169f1338a" class="header-anchor">#</a> <code>LayoutRule::addAxisOffsetTerms::__l33::&lt;lambda_50705c4513fadd86996a53c169f1338a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayoutRule::addAxisOffsetTerms::__l33::&lt;lambda_50705c4513fadd86996a53c169f1338a&gt;
{
};

</code></pre></div><h3 id="layoutrule-addaxisoffsetterms-l28-lambda-91dac979fa969834c8a6db500143ca61"><a href="#layoutrule-addaxisoffsetterms-l28-lambda-91dac979fa969834c8a6db500143ca61" class="header-anchor">#</a> <code>LayoutRule::addAxisOffsetTerms::__l28::&lt;lambda_91dac979fa969834c8a6db500143ca61&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayoutRule::addAxisOffsetTerms::__l28::&lt;lambda_91dac979fa969834c8a6db500143ca61&gt;
{
};

</code></pre></div><h3 id="leaditem"><a href="#leaditem" class="header-anchor">#</a> <code>LeadItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LeadItem : Item
{
};

</code></pre></div><h3 id="leashfenceknotactor"><a href="#leashfenceknotactor" class="header-anchor">#</a> <code>LeashFenceKnotActor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LeashFenceKnotActor : HangingActor
{
};

</code></pre></div><h3 id="leashfenceknotactor-vtbl"><a href="#leashfenceknotactor-vtbl" class="header-anchor">#</a> <code>LeashFenceKnotActor_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LeashFenceKnotActor_vtbl
{
  bool (__fastcall *hasComponent)(Actor *this, const HashedString *);
  void (__fastcall *reloadHardcoded)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadHardcodedClient)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *initializeComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *_serverInitItemStackIds)(Actor *this);
  void (__fastcall *_doInitialMove)(Actor *this);
  bool (__fastcall *checkAllSensitiveWords)(Actor *this);
  bool (__fastcall *checkNameTag)(Actor *this);
  void (__fastcall *~Actor)(Actor *this);
  void (__fastcall *reset)(Actor *this);
  int (__fastcall *getOnDeathExperience)(Actor *this);
  ActorType (__fastcall *getOwnerEntityType)(Actor *this);
  void (__fastcall *remove)(Actor *this);
  void (__fastcall *setPos)(Actor *this, const Vec3 *);
  const PredictedMovementValues *(__fastcall *getPredictedMovementValues)(Actor *this);
  const Vec3 *(__fastcall *getPos)(Actor *this);
  const Vec3 *(__fastcall *getPosOld)(Actor *this);
  const Vec3 *(__fastcall *getPosExtrapolated)(Actor *this, const Vec3 *result, float);
  Vec3 *(__fastcall *getAttachPos)(Actor *this, Vec3 *result, ActorLocation, float);
  Vec3 *(__fastcall *getFiringPos)(Actor *this, Vec3 *result);
  void (__fastcall *setRot)(Actor *this, const Vec2 *);
  void (__fastcall *move)(Actor *this, IActorMovementProxy *, const Vec3 *);
  void (__fastcall *move)(Actor *this, const Vec3 *);
  Vec3 *(__fastcall *getInterpolatedRidingPosition)(Actor *this, Vec3 *result, float);
  float (__fastcall *getInterpolatedBodyRot)(Actor *this, float);
  float (__fastcall *getInterpolatedHeadRot)(Actor *this, float);
  float (__fastcall *getInterpolatedBodyYaw)(Actor *this, float);
  float (__fastcall *getYawSpeedInDegreesPerSecond)(Actor *this);
  float (__fastcall *getInterpolatedWalkAnimSpeed)(Actor *this, float);
  Vec3 *(__fastcall *getInterpolatedRidingOffset)(Actor *this, Vec3 *result, float);
  void (__fastcall *checkBlockCollisions)(Actor *this);
  void (__fastcall *checkBlockCollisions)(Actor *this, const AABB *, std::function&lt;void __cdecl(BlockSource &amp;,Block const &amp;,BlockPos const &amp;,Actor &amp;)&gt;);
  bool (__fastcall *isFireImmune)(Actor *this);
  bool (__fastcall *breaksFallingBlocks)(Actor *this);
  void (__fastcall *blockedByShield)(Actor *this, const ActorDamageSource *, Actor *);
  void (__fastcall *teleportTo)(Actor *this, const Vec3 *, bool, int, int, const ActorUniqueID *);
  bool (__fastcall *tryTeleportTo)(Actor *this, const Vec3 *, bool, bool, int, int);
  void (__fastcall *chorusFruitTeleport)(Actor *this, Vec3 *);
  void (__fastcall *lerpTo)(Actor *this, const Vec3 *, const Vec2 *, int);
  void (__fastcall *lerpMotion)(Actor *this, const Vec3 *);
  std::unique_ptr&lt;AddActorBasePacket&gt; *(__fastcall *getAddPacket)(Actor *this, std::unique_ptr&lt;AddActorBasePacket&gt; *result);
  void (__fastcall *normalTick)(Actor *this);
  void (__fastcall *baseTick)(Actor *this);
  void (__fastcall *rideTick)(Actor *this);
  void (__fastcall *positionRider)(Actor *this, Actor *, float);
  float (__fastcall *getRidingHeight)(Actor *this);
  bool (__fastcall *startRiding)(Actor *this, Actor *);
  void (__fastcall *addRider)(Actor *this, Actor *);
  void (__fastcall *flagRiderToRemove)(Actor *this, Actor *);
  std::string *(__fastcall *getExitTip)(Actor *this, std::string *result, const std::string *, InputMode);
  bool (__fastcall *intersects)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *, float);
  bool (__fastcall *isInWall)(Actor *this);
  bool (__fastcall *isInvisible)(Actor *this);
  bool (__fastcall *canShowNameTag)(Actor *this);
  bool (__fastcall *canExistInPeaceful)(Actor *this);
  void (__fastcall *setNameTagVisible)(Actor *this, bool);
  const std::string *(__fastcall *getNameTag)(Actor *this);
  unsigned __int64 (__fastcall *getNameTagAsHash)(Actor *this);
  std::string *(__fastcall *getFormattedNameTag)(Actor *this, std::string *result);
  void (__fastcall *filterFormattedNameTag)(Actor *this, const UIProfanityContext *);
  void (__fastcall *setNameTag)(Actor *this, const std::string *);
  bool (__fastcall *getAlwaysShowNameTag)(Actor *this);
  void (__fastcall *setScoreTag)(Actor *this, const std::string *);
  const std::string *(__fastcall *getScoreTag)(Actor *this);
  bool (__fastcall *isInWater)(Actor *this);
  bool (__fastcall *hasEnteredWater)(Actor *this);
  bool (__fastcall *isImmersedInWater)(Actor *this);
  bool (__fastcall *isInWaterOrRain)(Actor *this);
  bool (__fastcall *isInLava)(Actor *this);
  bool (__fastcall *isUnderLiquid)(Actor *this, MaterialType);
  bool (__fastcall *isOverWater)(Actor *this);
  void (__fastcall *makeStuckInBlock)(Actor *this, const Vec3 *);
  float (__fastcall *getCameraOffset)(Actor *this);
  float (__fastcall *getShadowHeightOffs)(Actor *this);
  float (__fastcall *getShadowRadius)(Actor *this);
  Vec3 *(__fastcall *getHeadLookVector)(Actor *this, Vec3 *result, float);
  bool (__fastcall *canSeeInvisible)(Actor *this);
  bool (__fastcall *canSee)(Actor *this, const Vec3 *);
  bool (__fastcall *canSee)(Actor *this, const Actor *);
  bool (__fastcall *isSkyLit)(Actor *this, float);
  float (__fastcall *getBrightness)(Actor *this, float);
  bool (__fastcall *interactPreventDefault)(Actor *this);
  void (__fastcall *playerTouch)(Actor *this, Player *);
  void (__fastcall *onAboveBubbleColumn)(Actor *this, const bool);
  void (__fastcall *onInsideBubbleColumn)(Actor *this, const bool);
  bool (__fastcall *isImmobile)(Actor *this);
  bool (__fastcall *isSilent)(Actor *this);
  bool (__fastcall *isPickable)(Actor *this);
  bool (__fastcall *isFishable)(Actor *this);
  bool (__fastcall *isSleeping)(Actor *this);
  bool (__fastcall *isShootable)(Actor *this);
  void (__fastcall *setSneaking)(Actor *this, bool);
  bool (__fastcall *isBlocking)(Actor *this);
  bool (__fastcall *isDamageBlocked)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *isAlive)(Actor *this);
  bool (__fastcall *isOnFire)(Actor *this);
  bool (__fastcall *isOnHotBlock)(Actor *this);
  bool (__fastcall *isCreativeModeAllowed)(Actor *this);
  bool (__fastcall *isSurfaceMob)(Actor *this);
  bool (__fastcall *isTargetable)(Actor *this);
  bool (__fastcall *isLocalPlayer)(Actor *this);
  bool (__fastcall *isPlayer)(Actor *this);
  bool (__fastcall *canAttack)(Actor *this, Actor *, bool);
  void (__fastcall *setTarget)(Actor *this, Actor *);
  Actor *(__fastcall *findAttackTarget)(Actor *this);
  bool (__fastcall *isValidTarget)(Actor *this, Actor *);
  bool (__fastcall *attack)(Actor *this, Actor *);
  void (__fastcall *performRangedAttack)(Actor *this, Actor *, float);
  void (__fastcall *adjustDamageAmount)(Actor *this, int *);
  int (__fastcall *getEquipmentCount)(Actor *this);
  void (__fastcall *setOwner)(Actor *this, const ActorUniqueID);
  void (__fastcall *setSitting)(Actor *this, bool);
  void (__fastcall *onTame)(Actor *this);
  void (__fastcall *onFailedTame)(Actor *this);
  int (__fastcall *getInventorySize)(Actor *this);
  int (__fastcall *getEquipSlots)(Actor *this);
  int (__fastcall *getChestSlots)(Actor *this);
  void (__fastcall *setStanding)(Actor *this, bool);
  bool (__fastcall *canPowerJump)(Actor *this);
  void (__fastcall *setCanPowerJump)(Actor *this, bool);
  bool (__fastcall *isJumping)(Actor *this);
  bool (__fastcall *isEnchanted)(Actor *this);
  void (__fastcall *rideJumped)(Actor *this);
  void (__fastcall *rideLanded)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *shouldRender)(Actor *this);
  bool (__fastcall *isInvulnerableTo)(Actor *this, const ActorDamageSource *);
  ActorDamageCause (__fastcall *getBlockDamageCause)(Actor *this, const Block *);
  void (__fastcall *actuallyHurt)(Actor *this, int, const ActorDamageSource *, bool);
  void (__fastcall *animateHurt)(Actor *this);
  bool (__fastcall *doFireHurt)(Actor *this, int);
  void (__fastcall *onLightningHit)(Actor *this);
  void (__fastcall *onBounceStarted)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *feed)(Actor *this, int);
  void (__fastcall *handleEntityEvent)(Actor *this, ActorEvent, int);
  float (__fastcall *getPickRadius)(Actor *this);
  const HashedString *(__fastcall *getActorRendererId)(Actor *this);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const ItemStack *, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int);
  void (__fastcall *despawn)(Actor *this);
  void (__fastcall *killed)(Actor *this, Actor *);
  void (__fastcall *awardKillScore)(Actor *this, Actor *, int);
  void (__fastcall *setArmor)(Actor *this, ArmorSlot, const ItemStack *);
  const ItemStack *(__fastcall *getArmor)(Actor *this, ArmorSlot);
  ArmorMaterialType (__fastcall *getArmorMaterialTypeInSlot)(Actor *this, ArmorSlot);
  ArmorTextureType (__fastcall *getArmorMaterialTextureTypeInSlot)(Actor *this, ArmorSlot);
  float (__fastcall *getArmorColorInSlot)(Actor *this, ArmorSlot, int);
  const ItemStack *(__fastcall *getEquippedSlot)(Actor *this, EquipmentSlot);
  void (__fastcall *setEquippedSlot)(Actor *this, EquipmentSlot, const ItemStack *);
  const ItemStack *(__fastcall *getCarriedItem)(Actor *this);
  void (__fastcall *setCarriedItem)(Actor *this, const ItemStack *);
  void (__fastcall *setOffhandSlot)(Actor *this, const ItemStack *);
  const ItemStack *(__fastcall *getEquippedTotem)(Actor *this);
  bool (__fastcall *consumeTotem)(Actor *this);
  bool (__fastcall *save)(Actor *this, CompoundTag *);
  void (__fastcall *saveWithoutId)(Actor *this, CompoundTag *);
  bool (__fastcall *load)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *loadLinks)(Actor *this, const CompoundTag *, std::vector&lt;ActorLink&gt; *, DataLoadHelper *);
  ActorType (__fastcall *getEntityTypeId)(Actor *this);
  const HashedString *(__fastcall *queryEntityRenderer)(Actor *this);
  ActorUniqueID *(__fastcall *getSourceUniqueID)(Actor *this, ActorUniqueID *result);
  void (__fastcall *setOnFire)(Actor *this, int);
  AABB *(__fastcall *getHandleWaterAABB)(Actor *this, AABB *result);
  void (__fastcall *handleInsidePortal)(Actor *this, const BlockPos *);
  int (__fastcall *getPortalCooldown)(Actor *this);
  int (__fastcall *getPortalWaitTime)(Actor *this);
  AutomaticID&lt;Dimension,int&gt; *(__fastcall *getDimensionId)(Actor *this, AutomaticID&lt;Dimension,int&gt; *result);
  bool (__fastcall *canChangeDimensions)(Actor *this);
  void (__fastcall *changeDimension)(Actor *this, const ChangeDimensionPacket *);
  void (__fastcall *changeDimension)(Actor *this, AutomaticID&lt;Dimension,int&gt;, bool);
  ActorUniqueID *(__fastcall *getControllingPlayer)(Actor *this, ActorUniqueID *result);
  void (__fastcall *checkFallDamage)(Actor *this, float, bool);
  void (__fastcall *causeFallDamage)(Actor *this, float);
  void (__fastcall *handleFallDistanceOnServer)(Actor *this, float, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, int, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, const Block *, bool);
  void (__fastcall *onSynchedDataUpdate)(Actor *this, int);
  bool (__fastcall *canAddRider)(Actor *this, Actor *);
  bool (__fastcall *canPickupItem)(Actor *this, const ItemStack *);
  bool (__fastcall *canBePulledIntoVehicle)(Actor *this);
  bool (__fastcall *inCaravan)(Actor *this);
  bool (__fastcall *isLeashableType)(Actor *this);
  void (__fastcall *tickLeash)(Actor *this);
  void (__fastcall *sendMotionPacketIfNeeded)(Actor *this);
  bool (__fastcall *canSynchronizeNewEntity)(Actor *this);
  bool (__fastcall *stopRiding)(Actor *this, bool, bool, bool, bool);
  void (__fastcall *startSwimming)(Actor *this);
  void (__fastcall *stopSwimming)(Actor *this);
  void (__fastcall *buildDebugInfo)(Actor *this, std::string *);
  CommandPermissionLevel (__fastcall *getCommandPermissionLevel)(Actor *this);
  AttributeInstance *(__fastcall *getMutableAttribute)(Actor *this, const Attribute *);
  const AttributeInstance *(__fastcall *getAttribute)(Actor *this, const Attribute *);
  int (__fastcall *getDeathTime)(Actor *this);
  void (__fastcall *heal)(Actor *this, int);
  bool (__fastcall *isInvertedHealAndHarm)(Actor *this);
  bool (__fastcall *canBeAffected)(Actor *this, const MobEffectInstance *);
  bool (__fastcall *canBeAffected)(Actor *this, int);
  bool (__fastcall *canBeAffectedByArrow)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectAdded)(Actor *this, MobEffectInstance *);
  void (__fastcall *onEffectUpdated)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectRemoved)(Actor *this, MobEffectInstance *);
  AnimationComponent *(__fastcall *getAnimationComponent)(Actor *this);
  void (__fastcall *openContainerComponent)(Actor *this, Player *);
  void (__fastcall *swing)(Actor *this);
  void (__fastcall *useItem)(Actor *this, ItemStackBase *, ItemUseMethod, bool);
  bool (__fastcall *hasOutputSignal)(Actor *this, unsigned __int8);
  int (__fastcall *getOutputSignal)(Actor *this);
  void (__fastcall *getDebugText)(Actor *this, std::vector&lt;std::string&gt; *);
  float (__fastcall *getMapDecorationRotation)(Actor *this);
  float (__fastcall *getRiderYRotation)(Actor *this, const Actor *);
  float (__fastcall *getYHeadRot)(Actor *this);
  bool (__fastcall *isWorldBuilder)(Actor *this);
  bool (__fastcall *isCreative)(Actor *this);
  bool (__fastcall *isAdventure)(Actor *this);
  bool (__fastcall *add)(Actor *this, ItemStack *);
  bool (__fastcall *drop)(Actor *this, const ItemStack *, bool);
  bool (__fastcall *getInteraction)(Actor *this, Player *, ActorInteraction *, const Vec3 *);
  bool (__fastcall *canDestroyBlock)(Actor *this, const Block *);
  void (__fastcall *setAuxValue)(Actor *this, int);
  void (__fastcall *setSize)(Actor *this, float, float);
  int (__fastcall *getLifeSpan)(Actor *this);
  void (__fastcall *onOrphan)(Actor *this);
  void (__fastcall *wobble)(Actor *this);
  bool (__fastcall *wasHurt)(Actor *this);
  void (__fastcall *startSpinAttack)(Actor *this);
  void (__fastcall *stopSpinAttack)(Actor *this);
  void (__fastcall *setDamageNearbyMobs)(Actor *this, bool);
  bool (__fastcall *hasCritBox)(Actor *this);
  bool (__fastcall *isCritHit)(Actor *this);
  void (__fastcall *renderDebugServerState)(Actor *this, const Options *);
  void (__fastcall *reloadLootTable)(Actor *this, const EquipmentTableDefinition *);
  void (__fastcall *reloadLootTable)(Actor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(Actor *this);
  void (__fastcall *kill)(Actor *this);
  void (__fastcall *die)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *shouldTick)(Actor *this);
  std::shared_ptr&lt;IActorMovementProxy&gt; *(__fastcall *createMovementProxy)(Actor *this, std::shared_ptr&lt;IActorMovementProxy&gt; *result);
  void (__fastcall *updateEntitySpecificMolangVariables)(Actor *this, RenderParams *);
  bool (__fastcall *shouldTryMakeStepSound)(Actor *this);
  float (__fastcall *getNextStep)(Actor *this, const float);
  bool (__fastcall *canMakeStepSound)(Actor *this);
  void (__fastcall *outOfWorld)(Actor *this);
  bool (__fastcall *_hurt)(Actor *this, const ActorDamageSource *, int, bool, bool);
  void (__fastcall *markHurt)(Actor *this);
  void (__fastcall *readAdditionalSaveData)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *addAdditionalSaveData)(Actor *this, CompoundTag *);
  void (__fastcall *_playStepSound)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *_playFlySound)(Actor *this, const BlockPos *, const Block *);
  bool (__fastcall *_makeFlySound)(Actor *this);
  void (__fastcall *checkInsideBlocks)(Actor *this, float);
  void (__fastcall *pushOutOfBlocks)(Actor *this, const Vec3 *);
  bool (__fastcall *updateWaterState)(Actor *this);
  void (__fastcall *doWaterSplashEffect)(Actor *this);
  void (__fastcall *spawnTrailBubbles)(Actor *this);
  void (__fastcall *updateInsideBlock)(Actor *this);
  LootTable *(__fastcall *getLootTable)(Actor *this);
  LootTable *(__fastcall *getDefaultLootTable)(Actor *this);
  void (__fastcall *_removeRider)(Actor *this, const ActorUniqueID *, bool, bool, bool);
  void (__fastcall *_onSizeUpdated)(Actor *this);
  void (__fastcall *_doAutoAttackOnTouch)(Actor *this, Actor *);
  void (__fastcall *setDir)(HangingActor *this, int);
  int (__fastcall *getWidth)(HangingActor *this);
  int (__fastcall *getHeight)(HangingActor *this);
  void (__fastcall *dropItem)(HangingActor *this);
  bool (__fastcall *placeHangingEntity)(HangingActor *this, BlockSource *, int);
  bool (__fastcall *wouldSurvive)(HangingActor *this, BlockSource *);
};

</code></pre></div><h3 id="legacyskinimporter"><a href="#legacyskinimporter" class="header-anchor">#</a> <code>LegacySkinImporter</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacySkinImporter
{
};

</code></pre></div><h3 id="legacy-convertworldprocessrequest"><a href="#legacy-convertworldprocessrequest" class="header-anchor">#</a> <code>Legacy::ConvertWorldProcessRequest</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Legacy::ConvertWorldProcessRequest : Legacy::WorldProcessRequest
{
  const Core::PathBuffer&lt;std::string &gt; mOutputPath;
};

</code></pre></div><h3 id="legacy-convertworldprocessrequest-vtbl"><a href="#legacy-convertworldprocessrequest-vtbl" class="header-anchor">#</a> <code>Legacy::ConvertWorldProcessRequest_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Legacy::ConvertWorldProcessRequest_vtbl
{
  void (__fastcall *~WorldProcessRequest)(Legacy::WorldProcessRequest *this);
  Legacy::WorldProcessingType (__fastcall *getProcessingType)(Legacy::WorldProcessRequest *this);
  Core::PathBuffer&lt;std::string &gt; *(__fastcall *getOutputPath)(Legacy::WorldProcessRequest *this, Core::PathBuffer&lt;std::string &gt; *result);
};

</code></pre></div><h3 id="legacyworldconversionmanager-tryacquiremissingdlc-l13-lambda-c59ca1f0521e57b0b8cb56bd175b7c0d"><a href="#legacyworldconversionmanager-tryacquiremissingdlc-l13-lambda-c59ca1f0521e57b0b8cb56bd175b7c0d" class="header-anchor">#</a> <code>LegacyWorldConversionManager::tryAcquireMissingDlc::__l13::&lt;lambda_c59ca1f0521e57b0b8cb56bd175b7c0d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyWorldConversionManager::tryAcquireMissingDlc::__l13::&lt;lambda_c59ca1f0521e57b0b8cb56bd175b7c0d&gt;
{
  std::function&lt;void __cdecl(bool)&gt; downloadCompleteCallback;
};

</code></pre></div><h3 id="loginscreenmodel"><a href="#loginscreenmodel" class="header-anchor">#</a> <code>LoginScreenModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(2)) LoginScreenModel : MinecraftScreenModel
{
  int _offline_step;
  bool misLocalVerified;
  bool mShowOfflinePanel;
  bool mShowBlockPanel;
};

</code></pre></div><h3 id="loginscreenmodel-vtbl"><a href="#loginscreenmodel-vtbl" class="header-anchor">#</a> <code>LoginScreenModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LoginScreenModel_vtbl
{
  void (__fastcall *~IDlcBatcher)(IDlcBatcher *this);
  IDlcBatchModel *(__fastcall *getDlcBatchModel)(IDlcBatcher *this, const std::vector&lt;PackIdVersion&gt; *);
  IDlcBatchModel *(__fastcall *getDlcBatchModel)(IDlcBatcher *this, const std::vector&lt;std::string&gt; *);
  IDlcBatchModel *(__fastcall *getDlcBatchModel)(IDlcBatcher *this, const std::vector&lt;DlcId&gt; *);
};

</code></pre></div><h3 id="loginscreencontroller"><a href="#loginscreencontroller" class="header-anchor">#</a> <code>LoginScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LoginScreenController : MinecraftScreenController
{
  std::shared_ptr&lt;LoginScreenModel&gt; mModel;
  std::string strCmd;
};

</code></pre></div><h3 id="loginscreencontroller-vtbl"><a href="#loginscreencontroller-vtbl" class="header-anchor">#</a> <code>LoginScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LoginScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="logoscreencontroller"><a href="#logoscreencontroller" class="header-anchor">#</a> <code>LogoScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LogoScreenController : MinecraftScreenController
{
  int mTickCount;
};

</code></pre></div><h3 id="logoscreencontroller-vtbl"><a href="#logoscreencontroller-vtbl" class="header-anchor">#</a> <code>LogoScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LogoScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="legacy-mockworldconverter"><a href="#legacy-mockworldconverter" class="header-anchor">#</a> <code>Legacy::MockWorldConverter</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Legacy::MockWorldConverter : Legacy::WorldConverter
{
  std::vector&lt;std::shared_future&lt;void&gt;&gt; mBlobRequests;
  std::unique_ptr&lt;std::promise&lt;void&gt;&gt; mAddPromise;
  std::unique_ptr&lt;std::promise&lt;Legacy::WorldConversionReport&gt;&gt; mCompletionPromise;
};

</code></pre></div><h3 id="legacy-mockworldconverter-vtbl"><a href="#legacy-mockworldconverter-vtbl" class="header-anchor">#</a> <code>Legacy::MockWorldConverter_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Legacy::MockWorldConverter_vtbl
{
  void (__fastcall *~WorldConverter)(Legacy::WorldConverter *this);
  std::shared_future&lt;void&gt; *(__fastcall *addBlob)(Legacy::WorldConverter *this, std::shared_future&lt;void&gt; *result, const std::string *, Legacy::WorldConverterBlobType, std::vector&lt;unsigned char&gt; *);
  std::future&lt;Legacy::WorldConversionReport&gt; *(__fastcall *complete)(Legacy::WorldConverter *this, std::future&lt;Legacy::WorldConversionReport&gt; *result);
  void (__fastcall *setEstimatedBlobCount)(Legacy::WorldConverter *this, unsigned __int64);
  void (__fastcall *setBlobNames)(Legacy::WorldConverter *this, const std::vector&lt;std::string&gt; *);
};

</code></pre></div><h3 id="legacyoptionsconverterinternal-controlconversionrule"><a href="#legacyoptionsconverterinternal-controlconversionrule" class="header-anchor">#</a> <code>LegacyOptionsConverterInternal::ControlConversionRule</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct LegacyOptionsConverterInternal::ControlConversionRule
{
  LegacyOption mSourceOption;
  Remapping::ActionEnum mTargetOption;
};

</code></pre></div><h3 id="legacy-worldimporternull"><a href="#legacy-worldimporternull" class="header-anchor">#</a> <code>Legacy::WorldImporterNull</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Legacy::WorldImporterNull : Legacy::WorldImporter
{
};

</code></pre></div><h3 id="legacy-worldimporternull-vtbl"><a href="#legacy-worldimporternull-vtbl" class="header-anchor">#</a> <code>Legacy::WorldImporterNull_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Legacy::WorldImporterNull_vtbl
{
  void (__fastcall *~WorldImporter)(Legacy::WorldImporter *this);
  void (__fastcall *deleteWorld)(Legacy::WorldImporter *this, std::shared_ptr&lt;Social::User&gt;, const std::string *, std::function&lt;void __cdecl(void)&gt;);
  void (__fastcall *_doRetrieve)(Legacy::WorldImporter *this, std::shared_ptr&lt;Social::User&gt;, std::shared_ptr&lt;CallbackTokenContext&lt;std::function&lt;void __cdecl(enum Legacy::RetrieveStatus)&gt; &gt; &gt;);
  void (__fastcall *_doImport)(Legacy::WorldImporter *this, std::shared_ptr&lt;Social::User&gt;, const LegacyWorldInfo *, const Core::Path *, std::shared_ptr&lt;CallbackTokenContext&lt;std::function&lt;void __cdecl(enum Legacy::ImportStatus,float,std::shared_ptr&lt;ImportResult&gt;)&gt; &gt; &gt;);
};

</code></pre></div><h3 id="legacy-mockworldconverter-addblob-l2-lambda-d798fe43560fed98984479fd716ec9a4"><a href="#legacy-mockworldconverter-addblob-l2-lambda-d798fe43560fed98984479fd716ec9a4" class="header-anchor">#</a> <code>Legacy::MockWorldConverter::addBlob::__l2::&lt;lambda_d798fe43560fed98984479fd716ec9a4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Legacy::MockWorldConverter::addBlob::__l2::&lt;lambda_d798fe43560fed98984479fd716ec9a4&gt;
{
  Legacy::MockWorldConverter *const __this;
};

</code></pre></div><h3 id="legacy-mockworldconverter-complete-l2-lambda-6225b4d1cc004d91aa6f5d2ac62a66a2"><a href="#legacy-mockworldconverter-complete-l2-lambda-6225b4d1cc004d91aa6f5d2ac62a66a2" class="header-anchor">#</a> <code>Legacy::MockWorldConverter::complete::__l2::&lt;lambda_6225b4d1cc004d91aa6f5d2ac62a66a2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Legacy::MockWorldConverter::complete::__l2::&lt;lambda_6225b4d1cc004d91aa6f5d2ac62a66a2&gt;
{
  Legacy::MockWorldConverter *const __this;
};

</code></pre></div><h3 id="legacy-worldimporternull-doretrieve-l2-lambda-5fd84d04f4d9e18dde859c83a7aeea8c"><a href="#legacy-worldimporternull-doretrieve-l2-lambda-5fd84d04f4d9e18dde859c83a7aeea8c" class="header-anchor">#</a> <code>Legacy::WorldImporterNull::_doRetrieve::__l2::&lt;lambda_5fd84d04f4d9e18dde859c83a7aeea8c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Legacy::WorldImporterNull::_doRetrieve::__l2::&lt;lambda_5fd84d04f4d9e18dde859c83a7aeea8c&gt;
{
  std::shared_ptr&lt;CallbackTokenContext&lt;std::function&lt;void __cdecl(enum Legacy::RetrieveStatus)&gt; &gt; &gt; context;
};

</code></pre></div><h3 id="legacy-worldimporter-importworld-l2-lambda-366519f82ad483b9658c695262c21046-l2-lambda-029db122c2aba31f880589b4e73532c2"><a href="#legacy-worldimporter-importworld-l2-lambda-366519f82ad483b9658c695262c21046-l2-lambda-029db122c2aba31f880589b4e73532c2" class="header-anchor">#</a> <code>Legacy::WorldImporter::importWorld::__l2::&lt;lambda_366519f82ad483b9658c695262c21046&gt;::()::__l2::&lt;lambda_029db122c2aba31f880589b4e73532c2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Legacy::WorldImporter::importWorld::__l2::&lt;lambda_366519f82ad483b9658c695262c21046&gt;::()::__l2::&lt;lambda_029db122c2aba31f880589b4e73532c2&gt;
{
  std::shared_ptr&lt;CallbackTokenContext&lt;std::function&lt;void __cdecl(enum Legacy::ImportStatus,float,std::shared_ptr&lt;ImportResult&gt;)&gt; &gt; &gt; context;
  float percentDone;
};

</code></pre></div><h3 id="legacyoptionsconverterinternal-negatedboolsetter-l2-lambda-b4747c6076915628af900f4b75083eb0"><a href="#legacyoptionsconverterinternal-negatedboolsetter-l2-lambda-b4747c6076915628af900f4b75083eb0" class="header-anchor">#</a> <code>LegacyOptionsConverterInternal::_negatedBoolSetter::__l2::&lt;lambda_b4747c6076915628af900f4b75083eb0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyOptionsConverterInternal::_negatedBoolSetter::__l2::&lt;lambda_b4747c6076915628af900f4b75083eb0&gt;
{
};

</code></pre></div><h3 id="legacyoptionsconverterinternal-percentagefloatsetter-l2-lambda-e887955fbe7612448a5f2a759da3961f"><a href="#legacyoptionsconverterinternal-percentagefloatsetter-l2-lambda-e887955fbe7612448a5f2a759da3961f" class="header-anchor">#</a> <code>LegacyOptionsConverterInternal::_percentageFloatSetter::__l2::&lt;lambda_e887955fbe7612448a5f2a759da3961f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyOptionsConverterInternal::_percentageFloatSetter::__l2::&lt;lambda_e887955fbe7612448a5f2a759da3961f&gt;
{
  bool requiresInputMode;
  const float min;
  const float max;
};

</code></pre></div><h3 id="legacyoptionsconverterinternal-ingamesensitivitysetter-l2-lambda-72df878e104f4ab4b8d6fe67024baa56"><a href="#legacyoptionsconverterinternal-ingamesensitivitysetter-l2-lambda-72df878e104f4ab4b8d6fe67024baa56" class="header-anchor">#</a> <code>LegacyOptionsConverterInternal::_inGameSensitivitySetter::__l2::&lt;lambda_72df878e104f4ab4b8d6fe67024baa56&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyOptionsConverterInternal::_inGameSensitivitySetter::__l2::&lt;lambda_72df878e104f4ab4b8d6fe67024baa56&gt;
{
};

</code></pre></div><h3 id="legacyoptionsconverterinternal-makesplitscreenrecipe-l2-lambda-5b304ff6f5a9c619b90fe260b81fee93"><a href="#legacyoptionsconverterinternal-makesplitscreenrecipe-l2-lambda-5b304ff6f5a9c619b90fe260b81fee93" class="header-anchor">#</a> <code>LegacyOptionsConverterInternal::_makeSplitScreenRecipe::__l2::&lt;lambda_5b304ff6f5a9c619b90fe260b81fee93&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyOptionsConverterInternal::_makeSplitScreenRecipe::__l2::&lt;lambda_5b304ff6f5a9c619b90fe260b81fee93&gt;
{
};

</code></pre></div><h3 id="legacyoptionsconverterinternal-genericoptionsetter-l2-lambda-a3c38dbff1e05b52f7304b834d586c65"><a href="#legacyoptionsconverterinternal-genericoptionsetter-l2-lambda-a3c38dbff1e05b52f7304b834d586c65" class="header-anchor">#</a> <code>LegacyOptionsConverterInternal::_genericOptionSetter::__l2::&lt;lambda_a3c38dbff1e05b52f7304b834d586c65&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyOptionsConverterInternal::_genericOptionSetter::__l2::&lt;lambda_a3c38dbff1e05b52f7304b834d586c65&gt;
{
  bool isInputModeType;
};

</code></pre></div><h3 id="libraryrepository-setbasecategories-l5-lambda-2066f59cd6c06baa6bbdf9824299fff4"><a href="#libraryrepository-setbasecategories-l5-lambda-2066f59cd6c06baa6bbdf9824299fff4" class="header-anchor">#</a> <code>LibraryRepository::_setBaseCategories::__l5::&lt;lambda_2066f59cd6c06baa6bbdf9824299fff4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryRepository::_setBaseCategories::__l5::&lt;lambda_2066f59cd6c06baa6bbdf9824299fff4&gt;
{
};

</code></pre></div><h3 id="libraryrepository-setbasecategories-l5-lambda-787f1a273d7eb8bfb0c708bd7f6fefb2"><a href="#libraryrepository-setbasecategories-l5-lambda-787f1a273d7eb8bfb0c708bd7f6fefb2" class="header-anchor">#</a> <code>LibraryRepository::_setBaseCategories::__l5::&lt;lambda_787f1a273d7eb8bfb0c708bd7f6fefb2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryRepository::_setBaseCategories::__l5::&lt;lambda_787f1a273d7eb8bfb0c708bd7f6fefb2&gt;
{
};

</code></pre></div><h3 id="librarydeeplinklistener-poptopredundantscreensforlink-l2-lambda-92e18333a64979893b240d0e28eda47b"><a href="#librarydeeplinklistener-poptopredundantscreensforlink-l2-lambda-92e18333a64979893b240d0e28eda47b" class="header-anchor">#</a> <code>LibraryDeeplinkListener::_popTopRedundantScreensForLink::__l2::&lt;lambda_92e18333a64979893b240d0e28eda47b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryDeeplinkListener::_popTopRedundantScreensForLink::__l2::&lt;lambda_92e18333a64979893b240d0e28eda47b&gt;
{
  int *popCount;
  const LibraryDeeplink *link;
};

</code></pre></div><h3 id="librarydeeplinklistener-navigatetolink-l2-lambda-c9dd85ac71e71bb44e446e8aa86a665c"><a href="#librarydeeplinklistener-navigatetolink-l2-lambda-c9dd85ac71e71bb44e446e8aa86a665c" class="header-anchor">#</a> <code>LibraryDeeplinkListener::_navigateToLink::__l2::&lt;lambda_c9dd85ac71e71bb44e446e8aa86a665c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryDeeplinkListener::_navigateToLink::__l2::&lt;lambda_c9dd85ac71e71bb44e446e8aa86a665c&gt;
{
  std::shared_ptr&lt;SearchResult&gt; searchResult;
};

</code></pre></div><h3 id="librarydeeplinklistener-tick-l10-lambda-7c8013903e6c620252792920307d3a88"><a href="#librarydeeplinklistener-tick-l10-lambda-7c8013903e6c620252792920307d3a88" class="header-anchor">#</a> <code>LibraryDeeplinkListener::tick::__l10::&lt;lambda_7c8013903e6c620252792920307d3a88&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryDeeplinkListener::tick::__l10::&lt;lambda_7c8013903e6c620252792920307d3a88&gt;
{
  LibraryDeeplinkListener *const __this;
};

</code></pre></div><h3 id="levelstoragewritebatch-perfcontext"><a href="#levelstoragewritebatch-perfcontext" class="header-anchor">#</a> <code>LevelStorageWriteBatch::PerfContext</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelStorageWriteBatch::PerfContext
{
  unsigned __int64 mOperation;
  unsigned __int64 mSize;
  std::string mKey;
  const char *mReason;
};

</code></pre></div><h3 id="labtablereactioncomponent"><a href="#labtablereactioncomponent" class="header-anchor">#</a> <code>LabTableReactionComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LabTableReactionComponent
{
  LabTableReactionComponent_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="labtablereaction"><a href="#labtablereaction" class="header-anchor">#</a> <code>LabTableReaction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LabTableReaction
{
  LabTableReaction_vtbl *__vftable /*VFT*/;
  int mLifetime;
  int mMaxLifetime;
  int mStartDelay;
  std::unique_ptr&lt;ItemStack&gt; mResultItem;
  std::unique_ptr&lt;BlockPos&gt; mPos;
  std::unique_ptr&lt;Random&gt; mRandom;
  std::vector&lt;std::unique_ptr&lt;LabTableReactionComponent&gt;&gt; mComponents;
  LabTableReactionType mType;
  bool mIsClientSide;
};

</code></pre></div><h3 id="labtablereaction-vtbl"><a href="#labtablereaction-vtbl" class="header-anchor">#</a> <code>LabTableReaction_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LabTableReaction_vtbl
{
  void (__fastcall *~LabTableReaction)(LabTableReaction *this);
};

</code></pre></div><h3 id="labtablereactioncomponent-vtbl"><a href="#labtablereactioncomponent-vtbl" class="header-anchor">#</a> <code>LabTableReactionComponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LabTableReactionComponent_vtbl
{
  void (__fastcall *~LabTableReactionComponent)(LabTableReactionComponent *this);
  void (__fastcall *_onStart)(LabTableReactionComponent *this, LabTableReaction *, BlockSource *);
  void (__fastcall *_onTick)(LabTableReactionComponent *this, LabTableReaction *, BlockSource *);
  void (__fastcall *_onEnd)(LabTableReactionComponent *this, LabTableReaction *, BlockSource *);
};

</code></pre></div><h3 id="levelchunkpackethandler"><a href="#levelchunkpackethandler" class="header-anchor">#</a> <code>LevelChunkPacketHandler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LevelChunkPacketHandler
{
  std::unique_ptr&lt;LevelChunk&gt; mChunk;
  std::shared_ptr&lt;ClientBlobCache::Cache&gt; mCache;
  std::shared_ptr&lt;LevelChunkPacket&gt; mPacket;
  std::shared_ptr&lt;MPMCQueue&lt;unsigned __int64&gt; &gt; mCacheMissesSender;
  std::shared_ptr&lt;MPMCQueue&lt;unsigned __int64&gt; &gt; mCacheHitsSender;
  std::queue&lt;std::vector&lt;std::function&lt;TaskResult __cdecl(void)&gt;&gt;&gt; mSteps;
  std::function&lt;void __cdecl(void)&gt; mMainThreadCallback;
  std::string mCacheBuffer;
  unsigned __int64 mReused;
  const unsigned __int64 mSequenceId;
  unsigned __int64 mDeserializeStepID;
  ReadOnlyBinaryStream mInputStream;
  bool mCacheEnabled;
};

</code></pre></div><h3 id="legacyclientnetworkhandler-handle-l5-lambda-50d3db24a5bec797058b2c78ad99f47c"><a href="#legacyclientnetworkhandler-handle-l5-lambda-50d3db24a5bec797058b2c78ad99f47c" class="header-anchor">#</a> <code>LegacyClientNetworkHandler::handle::__l5::&lt;lambda_50d3db24a5bec797058b2c78ad99f47c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyClientNetworkHandler::handle::__l5::&lt;lambda_50d3db24a5bec797058b2c78ad99f47c&gt;
{
  std::shared_ptr&lt;ClientCacheMissResponsePacket&gt; packet;
  std::weak_ptr&lt;ClientBlobCache::Cache&gt; weakCache;
};

</code></pre></div><h3 id="legacyclientnetworkhandler-handle-l5-lambda-e5fb10c013ff0013c5f4f6e683e20f5e"><a href="#legacyclientnetworkhandler-handle-l5-lambda-e5fb10c013ff0013c5f4f6e683e20f5e" class="header-anchor">#</a> <code>LegacyClientNetworkHandler::handle::__l5::&lt;lambda_e5fb10c013ff0013c5f4f6e683e20f5e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyClientNetworkHandler::handle::__l5::&lt;lambda_e5fb10c013ff0013c5f4f6e683e20f5e&gt;
{
  std::shared_ptr&lt;LevelChunkPacketHandler&gt; handler;
};

</code></pre></div><h3 id="legacyclientnetworkhandler-handle-l8-lambda-4527d45382e962cb3d399b4de6ee053d"><a href="#legacyclientnetworkhandler-handle-l8-lambda-4527d45382e962cb3d399b4de6ee053d" class="header-anchor">#</a> <code>LegacyClientNetworkHandler::handle::__l8::&lt;lambda_4527d45382e962cb3d399b4de6ee053d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyClientNetworkHandler::handle::__l8::&lt;lambda_4527d45382e962cb3d399b4de6ee053d&gt;
{
  LegacyClientNetworkHandler *const __this;
  GameType *oldGameType;
  const SetDefaultGameTypePacket *packet;
};

</code></pre></div><h3 id="legacyclientnetworkhandler-handle-l30-lambda-5bbdb8ecc7b00ebae4d53327f056c63c"><a href="#legacyclientnetworkhandler-handle-l30-lambda-5bbdb8ecc7b00ebae4d53327f056c63c" class="header-anchor">#</a> <code>LegacyClientNetworkHandler::handle::__l30::&lt;lambda_5bbdb8ecc7b00ebae4d53327f056c63c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyClientNetworkHandler::handle::__l30::&lt;lambda_5bbdb8ecc7b00ebae4d53327f056c63c&gt;
{
  const AnimatePacket *packet;
  Actor **actor;
};

</code></pre></div><h3 id="legacyclientnetworkhandler-handle-l8-lambda-18a1f2295913ecc0708303e695387a34"><a href="#legacyclientnetworkhandler-handle-l8-lambda-18a1f2295913ecc0708303e695387a34" class="header-anchor">#</a> <code>LegacyClientNetworkHandler::handle::__l8::&lt;lambda_18a1f2295913ecc0708303e695387a34&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyClientNetworkHandler::handle::__l8::&lt;lambda_18a1f2295913ecc0708303e695387a34&gt;
{
  ActorUniqueID actorID;
};

</code></pre></div><h3 id="legacyclientnetworkhandler-handle-l2-lambda-60c978a53a5fe45c288483d97f872bc7"><a href="#legacyclientnetworkhandler-handle-l2-lambda-60c978a53a5fe45c288483d97f872bc7" class="header-anchor">#</a> <code>LegacyClientNetworkHandler::handle::__l2::&lt;lambda_60c978a53a5fe45c288483d97f872bc7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyClientNetworkHandler::handle::__l2::&lt;lambda_60c978a53a5fe45c288483d97f872bc7&gt;
{
  std::shared_ptr&lt;BlockActorDataPacket&gt; packet;
};

</code></pre></div><h3 id="legacyclientnetworkhandler-handleupdateblockpacketcommon-l2-lambda-0ac3299732fa6b5afee2093497510e87"><a href="#legacyclientnetworkhandler-handleupdateblockpacketcommon-l2-lambda-0ac3299732fa6b5afee2093497510e87" class="header-anchor">#</a> <code>LegacyClientNetworkHandler::_handleUpdateBlockPacketCommon::__l2::&lt;lambda_0ac3299732fa6b5afee2093497510e87&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyClientNetworkHandler::_handleUpdateBlockPacketCommon::__l2::&lt;lambda_0ac3299732fa6b5afee2093497510e87&gt;
{
  LegacyClientNetworkHandler *const __this;
  std::shared_ptr&lt;UpdateBlockPacket&gt; packet;
  const ActorBlockSyncMessage *syncMsg;
};

</code></pre></div><h3 id="legacyclientnetworkhandler-handle-l16-lambda-3ce999330be42e727157d222c2549fe1"><a href="#legacyclientnetworkhandler-handle-l16-lambda-3ce999330be42e727157d222c2549fe1" class="header-anchor">#</a> <code>LegacyClientNetworkHandler::handle::__l16::&lt;lambda_3ce999330be42e727157d222c2549fe1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyClientNetworkHandler::handle::__l16::&lt;lambda_3ce999330be42e727157d222c2549fe1&gt;
{
  std::unique_ptr&lt;Actor&gt; *actor;
};

</code></pre></div><h3 id="legacyclientnetworkhandler-handle-l13-lambda-6bdbd85477b87c3c976119e6dc58a2c6"><a href="#legacyclientnetworkhandler-handle-l13-lambda-6bdbd85477b87c3c976119e6dc58a2c6" class="header-anchor">#</a> <code>LegacyClientNetworkHandler::handle::__l13::&lt;lambda_6bdbd85477b87c3c976119e6dc58a2c6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyClientNetworkHandler::handle::__l13::&lt;lambda_6bdbd85477b87c3c976119e6dc58a2c6&gt;
{
  Actor **actorPtr;
};

</code></pre></div><h3 id="legacyclientnetworkhandler-handle-l79-lambda-01023bcc68158513be1b945f962111f7"><a href="#legacyclientnetworkhandler-handle-l79-lambda-01023bcc68158513be1b945f962111f7" class="header-anchor">#</a> <code>LegacyClientNetworkHandler::handle::__l79::&lt;lambda_01023bcc68158513be1b945f962111f7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyClientNetworkHandler::handle::__l79::&lt;lambda_01023bcc68158513be1b945f962111f7&gt;
{
  Player **newPlayer;
};

</code></pre></div><h3 id="legacyclientnetworkhandler-handle-l73-lambda-2d31bee4ec57d2ac4f70c1fb047a841e"><a href="#legacyclientnetworkhandler-handle-l73-lambda-2d31bee4ec57d2ac4f70c1fb047a841e" class="header-anchor">#</a> <code>LegacyClientNetworkHandler::handle::__l73::&lt;lambda_2d31bee4ec57d2ac4f70c1fb047a841e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyClientNetworkHandler::handle::__l73::&lt;lambda_2d31bee4ec57d2ac4f70c1fb047a841e&gt;
{
  Player **newPlayer;
};

</code></pre></div><h3 id="legacyclientnetworkhandler-handle-l80-lambda-bd67e2cdad03d9a8e3ff6597cb9546e0"><a href="#legacyclientnetworkhandler-handle-l80-lambda-bd67e2cdad03d9a8e3ff6597cb9546e0" class="header-anchor">#</a> <code>LegacyClientNetworkHandler::handle::__l80::&lt;lambda_bd67e2cdad03d9a8e3ff6597cb9546e0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyClientNetworkHandler::handle::__l80::&lt;lambda_bd67e2cdad03d9a8e3ff6597cb9546e0&gt;
{
  Actor *e;
  const AddActorPacket *packet;
};

</code></pre></div><h3 id="legacyclientnetworkhandler-handle-l14-lambda-c81464e57e27a752f526241c77eb712d"><a href="#legacyclientnetworkhandler-handle-l14-lambda-c81464e57e27a752f526241c77eb712d" class="header-anchor">#</a> <code>LegacyClientNetworkHandler::handle::__l14::&lt;lambda_c81464e57e27a752f526241c77eb712d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyClientNetworkHandler::handle::__l14::&lt;lambda_c81464e57e27a752f526241c77eb712d&gt;
{
  Actor *e;
};

</code></pre></div><h3 id="levelchunkpackethandler-ctor-l2-lambda-01b139c4196b261d5ccde8d6a94cde0b"><a href="#levelchunkpackethandler-ctor-l2-lambda-01b139c4196b261d5ccde8d6a94cde0b" class="header-anchor">#</a> <code>LevelChunkPacketHandler::{ctor}::__l2::&lt;lambda_01b139c4196b261d5ccde8d6a94cde0b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelChunkPacketHandler::{ctor}::__l2::&lt;lambda_01b139c4196b261d5ccde8d6a94cde0b&gt;
{
  LevelChunkPacketHandler *const __this;
};

</code></pre></div><h3 id="levelchunkpackethandler-ctor-l5-lambda-745e17290d2e5fd570c2fbe56c36a69c"><a href="#levelchunkpackethandler-ctor-l5-lambda-745e17290d2e5fd570c2fbe56c36a69c" class="header-anchor">#</a> <code>LevelChunkPacketHandler::{ctor}::__l5::&lt;lambda_745e17290d2e5fd570c2fbe56c36a69c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelChunkPacketHandler::{ctor}::__l5::&lt;lambda_745e17290d2e5fd570c2fbe56c36a69c&gt;
{
  LevelChunkPacketHandler *const __this;
};

</code></pre></div><h3 id="levelchunkpackethandler-ctor-l25-lambda-676b75949d35579bbaf125e1c21542f7"><a href="#levelchunkpackethandler-ctor-l25-lambda-676b75949d35579bbaf125e1c21542f7" class="header-anchor">#</a> <code>LevelChunkPacketHandler::{ctor}::__l25::&lt;lambda_676b75949d35579bbaf125e1c21542f7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelChunkPacketHandler::{ctor}::__l25::&lt;lambda_676b75949d35579bbaf125e1c21542f7&gt;
{
  LevelChunkPacketHandler *const __this;
  unsigned __int64 i;
};

</code></pre></div><h3 id="levelchunkpackethandler-ctor-l2-lambda-8b9953b041846740f45b6457b5ad7f05"><a href="#levelchunkpackethandler-ctor-l2-lambda-8b9953b041846740f45b6457b5ad7f05" class="header-anchor">#</a> <code>LevelChunkPacketHandler::{ctor}::__l2::&lt;lambda_8b9953b041846740f45b6457b5ad7f05&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelChunkPacketHandler::{ctor}::__l2::&lt;lambda_8b9953b041846740f45b6457b5ad7f05&gt;
{
  LevelChunkPacketHandler *const __this;
  Dimension *dimension;
};

</code></pre></div><h3 id="liquidblock"><a href="#liquidblock" class="header-anchor">#</a> <code>LiquidBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LiquidBlock : BlockLegacy
{
};

</code></pre></div><h3 id="liquidblock-vtbl"><a href="#liquidblock-vtbl" class="header-anchor">#</a> <code>LiquidBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LiquidBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="lavaparticle"><a href="#lavaparticle" class="header-anchor">#</a> <code>LavaParticle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LavaParticle : Particle
{
  float oSize;
};

</code></pre></div><h3 id="lavaparticle-vtbl"><a href="#lavaparticle-vtbl" class="header-anchor">#</a> <code>LavaParticle_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LavaParticle_vtbl
{
  void (__fastcall *init)(Particle *this, const Vec3 *, const Vec3 *, int, ParticleEngine *);
  void (__fastcall *addTagData)(Particle *this, const CompoundTag *);
  void (__fastcall *~Particle)(Particle *this);
  void (__fastcall *normalTick)(Particle *this);
  void (__fastcall *tessellate)(Particle *this, const ParticleRenderContext *);
  const mce::TexturePtr *(__fastcall *getParticleTexture)(Particle *this);
  mce::Color *(__fastcall *getParticleLightColor)(Particle *this, mce::Color *result, float, const LightTexture *);
  void (__fastcall *setEmittingEntity)(Particle *this, Actor *);
  bool (__fastcall *_shouldUpdateVertexData)(Particle *this, float);
};

</code></pre></div><h3 id="levelsoundeventmap"><a href="#levelsoundeventmap" class="header-anchor">#</a> <code>LevelSoundEventMap</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelSoundEventMap
{
};

</code></pre></div><h3 id="loadskinimage-l20-lambda-30762dfb3a744678726a5d657f2e6492"><a href="#loadskinimage-l20-lambda-30762dfb3a744678726a5d657f2e6492" class="header-anchor">#</a> <code>loadSkinImage::__l20::&lt;lambda_30762dfb3a744678726a5d657f2e6492&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj loadSkinImage::__l20::&lt;lambda_30762dfb3a744678726a5d657f2e6492&gt;
{
  std::weak_ptr&lt;FileWatcherUpdate&gt; fileWatcherUpdate;
};

</code></pre></div><h3 id="localplayer-changedimension-l2-lambda-a055da54da88576cc7150c596c08db5b"><a href="#localplayer-changedimension-l2-lambda-a055da54da88576cc7150c596c08db5b" class="header-anchor">#</a> <code>LocalPlayer::changeDimension::__l2::&lt;lambda_a055da54da88576cc7150c596c08db5b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LocalPlayer::changeDimension::__l2::&lt;lambda_a055da54da88576cc7150c596c08db5b&gt;
{
  LocalPlayer *const __this;
  AutomaticID&lt;Dimension,int&gt; *fromId;
  AutomaticID&lt;Dimension,int&gt; *toId;
  const ChangeDimensionPacket *packet;
};

</code></pre></div><h3 id="localplayer-sendclientauthplayeractions-l2-lambda-6ebef926ab90091319f9af2eb20602f6"><a href="#localplayer-sendclientauthplayeractions-l2-lambda-6ebef926ab90091319f9af2eb20602f6" class="header-anchor">#</a> <code>LocalPlayer::_sendClientAuthPlayerActions::__l2::&lt;lambda_6ebef926ab90091319f9af2eb20602f6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LocalPlayer::_sendClientAuthPlayerActions::__l2::&lt;lambda_6ebef926ab90091319f9af2eb20602f6&gt;
{
  PacketSender *packetSender;
};

</code></pre></div><h3 id="localplayer-normaltick-l43-lambda-1c7c59adf65d7bd18b6fc05fa9067a13"><a href="#localplayer-normaltick-l43-lambda-1c7c59adf65d7bd18b6fc05fa9067a13" class="header-anchor">#</a> <code>LocalPlayer::normalTick::__l43::&lt;lambda_1c7c59adf65d7bd18b6fc05fa9067a13&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LocalPlayer::normalTick::__l43::&lt;lambda_1c7c59adf65d7bd18b6fc05fa9067a13&gt;
{
  const ItemStack *offhandItem;
};

</code></pre></div><h3 id="localplayer-normaltick-l37-lambda-412280d90323b2c3367ab255026d5d95"><a href="#localplayer-normaltick-l37-lambda-412280d90323b2c3367ab255026d5d95" class="header-anchor">#</a> <code>LocalPlayer::normalTick::__l37::&lt;lambda_412280d90323b2c3367ab255026d5d95&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LocalPlayer::normalTick::__l37::&lt;lambda_412280d90323b2c3367ab255026d5d95&gt;
{
  const ItemStack *selectedItem;
};

</code></pre></div><h3 id="localplayer-normaltick-l37-lambda-f770b27f9a6723b8f794240b0e693940"><a href="#localplayer-normaltick-l37-lambda-f770b27f9a6723b8f794240b0e693940" class="header-anchor">#</a> <code>LocalPlayer::normalTick::__l37::&lt;lambda_f770b27f9a6723b8f794240b0e693940&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LocalPlayer::normalTick::__l37::&lt;lambda_f770b27f9a6723b8f794240b0e693940&gt;
{
  const ItemStack *selectedItem;
};

</code></pre></div><h3 id="lightningboltrenderer"><a href="#lightningboltrenderer" class="header-anchor">#</a> <code>LightningBoltRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LightningBoltRenderer : ActorRenderer
{
  mce::MaterialPtr mLightningMat;
};

</code></pre></div><h3 id="lightningboltrenderer-vtbl"><a href="#lightningboltrenderer-vtbl" class="header-anchor">#</a> <code>LightningBoltRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LightningBoltRenderer_vtbl
{
  void (__fastcall *~ActorShaderManager)(ActorShaderManager *this);
  mce::Color *(__fastcall *_getOverlayColor)(ActorShaderManager *this, mce::Color *result, Actor *, float);
  void (__fastcall *render)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderDebug)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderEffects)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderTrading)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *, float);
  void (__fastcall *renderFlame)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderLeash)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderWaterHole)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *addAdditionalRenderingIfNeeded)(ActorRenderer *this, mce::TextureGroup *);
  void (__fastcall *renderWeaponEffect)(ActorRenderer *this, BaseActorRenderContext *, Actor *);
  void (__fastcall *renderBindEffects)(ActorRenderer *this, BaseActorRenderContext *, Actor *);
  AABB *(__fastcall *getRenderBounds)(ActorRenderer *this, AABB *result, const Actor *);
  Vec3 *(__fastcall *getLeashOffset)(ActorRenderer *this, Vec3 *result, Actor *, float, float, float, bool, bool);
  void (__fastcall *setIsOnScreen)(ActorRenderer *this, Actor *, const bool, float);
  bool (__fastcall *shouldUpdateBonesAndEffectsIfOffScreen)(ActorRenderer *this, RenderParams *);
  bool (__fastcall *shouldUpdateEffectsIfOffScreen)(ActorRenderer *this, RenderParams *);
  void (__fastcall *_bindModelEffectRender)(ActorRenderer *this, BaseActorRenderContext *, Mob *);
};

</code></pre></div><h3 id="lightningbolt"><a href="#lightningbolt" class="header-anchor">#</a> <code>LightningBolt</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) LightningBolt : Actor
{
  unsigned int mSeed;
  int mLife;
  int mFlashes;
  bool mCanHurt;
  bool mHasTriedToHurt;
};

</code></pre></div><h3 id="lightningbolt-vtbl"><a href="#lightningbolt-vtbl" class="header-anchor">#</a> <code>LightningBolt_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LightningBolt_vtbl
{
  bool (__fastcall *hasComponent)(Actor *this, const HashedString *);
  void (__fastcall *reloadHardcoded)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadHardcodedClient)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *initializeComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *_serverInitItemStackIds)(Actor *this);
  void (__fastcall *_doInitialMove)(Actor *this);
  bool (__fastcall *checkAllSensitiveWords)(Actor *this);
  bool (__fastcall *checkNameTag)(Actor *this);
  void (__fastcall *~Actor)(Actor *this);
  void (__fastcall *reset)(Actor *this);
  int (__fastcall *getOnDeathExperience)(Actor *this);
  ActorType (__fastcall *getOwnerEntityType)(Actor *this);
  void (__fastcall *remove)(Actor *this);
  void (__fastcall *setPos)(Actor *this, const Vec3 *);
  const PredictedMovementValues *(__fastcall *getPredictedMovementValues)(Actor *this);
  const Vec3 *(__fastcall *getPos)(Actor *this);
  const Vec3 *(__fastcall *getPosOld)(Actor *this);
  const Vec3 *(__fastcall *getPosExtrapolated)(Actor *this, const Vec3 *result, float);
  Vec3 *(__fastcall *getAttachPos)(Actor *this, Vec3 *result, ActorLocation, float);
  Vec3 *(__fastcall *getFiringPos)(Actor *this, Vec3 *result);
  void (__fastcall *setRot)(Actor *this, const Vec2 *);
  void (__fastcall *move)(Actor *this, IActorMovementProxy *, const Vec3 *);
  void (__fastcall *move)(Actor *this, const Vec3 *);
  Vec3 *(__fastcall *getInterpolatedRidingPosition)(Actor *this, Vec3 *result, float);
  float (__fastcall *getInterpolatedBodyRot)(Actor *this, float);
  float (__fastcall *getInterpolatedHeadRot)(Actor *this, float);
  float (__fastcall *getInterpolatedBodyYaw)(Actor *this, float);
  float (__fastcall *getYawSpeedInDegreesPerSecond)(Actor *this);
  float (__fastcall *getInterpolatedWalkAnimSpeed)(Actor *this, float);
  Vec3 *(__fastcall *getInterpolatedRidingOffset)(Actor *this, Vec3 *result, float);
  void (__fastcall *checkBlockCollisions)(Actor *this);
  void (__fastcall *checkBlockCollisions)(Actor *this, const AABB *, std::function&lt;void __cdecl(BlockSource &amp;,Block const &amp;,BlockPos const &amp;,Actor &amp;)&gt;);
  bool (__fastcall *isFireImmune)(Actor *this);
  bool (__fastcall *breaksFallingBlocks)(Actor *this);
  void (__fastcall *blockedByShield)(Actor *this, const ActorDamageSource *, Actor *);
  void (__fastcall *teleportTo)(Actor *this, const Vec3 *, bool, int, int, const ActorUniqueID *);
  bool (__fastcall *tryTeleportTo)(Actor *this, const Vec3 *, bool, bool, int, int);
  void (__fastcall *chorusFruitTeleport)(Actor *this, Vec3 *);
  void (__fastcall *lerpTo)(Actor *this, const Vec3 *, const Vec2 *, int);
  void (__fastcall *lerpMotion)(Actor *this, const Vec3 *);
  std::unique_ptr&lt;AddActorBasePacket&gt; *(__fastcall *getAddPacket)(Actor *this, std::unique_ptr&lt;AddActorBasePacket&gt; *result);
  void (__fastcall *normalTick)(Actor *this);
  void (__fastcall *baseTick)(Actor *this);
  void (__fastcall *rideTick)(Actor *this);
  void (__fastcall *positionRider)(Actor *this, Actor *, float);
  float (__fastcall *getRidingHeight)(Actor *this);
  bool (__fastcall *startRiding)(Actor *this, Actor *);
  void (__fastcall *addRider)(Actor *this, Actor *);
  void (__fastcall *flagRiderToRemove)(Actor *this, Actor *);
  std::string *(__fastcall *getExitTip)(Actor *this, std::string *result, const std::string *, InputMode);
  bool (__fastcall *intersects)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *, float);
  bool (__fastcall *isInWall)(Actor *this);
  bool (__fastcall *isInvisible)(Actor *this);
  bool (__fastcall *canShowNameTag)(Actor *this);
  bool (__fastcall *canExistInPeaceful)(Actor *this);
  void (__fastcall *setNameTagVisible)(Actor *this, bool);
  const std::string *(__fastcall *getNameTag)(Actor *this);
  unsigned __int64 (__fastcall *getNameTagAsHash)(Actor *this);
  std::string *(__fastcall *getFormattedNameTag)(Actor *this, std::string *result);
  void (__fastcall *filterFormattedNameTag)(Actor *this, const UIProfanityContext *);
  void (__fastcall *setNameTag)(Actor *this, const std::string *);
  bool (__fastcall *getAlwaysShowNameTag)(Actor *this);
  void (__fastcall *setScoreTag)(Actor *this, const std::string *);
  const std::string *(__fastcall *getScoreTag)(Actor *this);
  bool (__fastcall *isInWater)(Actor *this);
  bool (__fastcall *hasEnteredWater)(Actor *this);
  bool (__fastcall *isImmersedInWater)(Actor *this);
  bool (__fastcall *isInWaterOrRain)(Actor *this);
  bool (__fastcall *isInLava)(Actor *this);
  bool (__fastcall *isUnderLiquid)(Actor *this, MaterialType);
  bool (__fastcall *isOverWater)(Actor *this);
  void (__fastcall *makeStuckInBlock)(Actor *this, const Vec3 *);
  float (__fastcall *getCameraOffset)(Actor *this);
  float (__fastcall *getShadowHeightOffs)(Actor *this);
  float (__fastcall *getShadowRadius)(Actor *this);
  Vec3 *(__fastcall *getHeadLookVector)(Actor *this, Vec3 *result, float);
  bool (__fastcall *canSeeInvisible)(Actor *this);
  bool (__fastcall *canSee)(Actor *this, const Vec3 *);
  bool (__fastcall *canSee)(Actor *this, const Actor *);
  bool (__fastcall *isSkyLit)(Actor *this, float);
  float (__fastcall *getBrightness)(Actor *this, float);
  bool (__fastcall *interactPreventDefault)(Actor *this);
  void (__fastcall *playerTouch)(Actor *this, Player *);
  void (__fastcall *onAboveBubbleColumn)(Actor *this, const bool);
  void (__fastcall *onInsideBubbleColumn)(Actor *this, const bool);
  bool (__fastcall *isImmobile)(Actor *this);
  bool (__fastcall *isSilent)(Actor *this);
  bool (__fastcall *isPickable)(Actor *this);
  bool (__fastcall *isFishable)(Actor *this);
  bool (__fastcall *isSleeping)(Actor *this);
  bool (__fastcall *isShootable)(Actor *this);
  void (__fastcall *setSneaking)(Actor *this, bool);
  bool (__fastcall *isBlocking)(Actor *this);
  bool (__fastcall *isDamageBlocked)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *isAlive)(Actor *this);
  bool (__fastcall *isOnFire)(Actor *this);
  bool (__fastcall *isOnHotBlock)(Actor *this);
  bool (__fastcall *isCreativeModeAllowed)(Actor *this);
  bool (__fastcall *isSurfaceMob)(Actor *this);
  bool (__fastcall *isTargetable)(Actor *this);
  bool (__fastcall *isLocalPlayer)(Actor *this);
  bool (__fastcall *isPlayer)(Actor *this);
  bool (__fastcall *canAttack)(Actor *this, Actor *, bool);
  void (__fastcall *setTarget)(Actor *this, Actor *);
  Actor *(__fastcall *findAttackTarget)(Actor *this);
  bool (__fastcall *isValidTarget)(Actor *this, Actor *);
  bool (__fastcall *attack)(Actor *this, Actor *);
  void (__fastcall *performRangedAttack)(Actor *this, Actor *, float);
  void (__fastcall *adjustDamageAmount)(Actor *this, int *);
  int (__fastcall *getEquipmentCount)(Actor *this);
  void (__fastcall *setOwner)(Actor *this, const ActorUniqueID);
  void (__fastcall *setSitting)(Actor *this, bool);
  void (__fastcall *onTame)(Actor *this);
  void (__fastcall *onFailedTame)(Actor *this);
  int (__fastcall *getInventorySize)(Actor *this);
  int (__fastcall *getEquipSlots)(Actor *this);
  int (__fastcall *getChestSlots)(Actor *this);
  void (__fastcall *setStanding)(Actor *this, bool);
  bool (__fastcall *canPowerJump)(Actor *this);
  void (__fastcall *setCanPowerJump)(Actor *this, bool);
  bool (__fastcall *isJumping)(Actor *this);
  bool (__fastcall *isEnchanted)(Actor *this);
  void (__fastcall *rideJumped)(Actor *this);
  void (__fastcall *rideLanded)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *shouldRender)(Actor *this);
  bool (__fastcall *isInvulnerableTo)(Actor *this, const ActorDamageSource *);
  ActorDamageCause (__fastcall *getBlockDamageCause)(Actor *this, const Block *);
  void (__fastcall *actuallyHurt)(Actor *this, int, const ActorDamageSource *, bool);
  void (__fastcall *animateHurt)(Actor *this);
  bool (__fastcall *doFireHurt)(Actor *this, int);
  void (__fastcall *onLightningHit)(Actor *this);
  void (__fastcall *onBounceStarted)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *feed)(Actor *this, int);
  void (__fastcall *handleEntityEvent)(Actor *this, ActorEvent, int);
  float (__fastcall *getPickRadius)(Actor *this);
  const HashedString *(__fastcall *getActorRendererId)(Actor *this);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const ItemStack *, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int);
  void (__fastcall *despawn)(Actor *this);
  void (__fastcall *killed)(Actor *this, Actor *);
  void (__fastcall *awardKillScore)(Actor *this, Actor *, int);
  void (__fastcall *setArmor)(Actor *this, ArmorSlot, const ItemStack *);
  const ItemStack *(__fastcall *getArmor)(Actor *this, ArmorSlot);
  ArmorMaterialType (__fastcall *getArmorMaterialTypeInSlot)(Actor *this, ArmorSlot);
  ArmorTextureType (__fastcall *getArmorMaterialTextureTypeInSlot)(Actor *this, ArmorSlot);
  float (__fastcall *getArmorColorInSlot)(Actor *this, ArmorSlot, int);
  const ItemStack *(__fastcall *getEquippedSlot)(Actor *this, EquipmentSlot);
  void (__fastcall *setEquippedSlot)(Actor *this, EquipmentSlot, const ItemStack *);
  const ItemStack *(__fastcall *getCarriedItem)(Actor *this);
  void (__fastcall *setCarriedItem)(Actor *this, const ItemStack *);
  void (__fastcall *setOffhandSlot)(Actor *this, const ItemStack *);
  const ItemStack *(__fastcall *getEquippedTotem)(Actor *this);
  bool (__fastcall *consumeTotem)(Actor *this);
  bool (__fastcall *save)(Actor *this, CompoundTag *);
  void (__fastcall *saveWithoutId)(Actor *this, CompoundTag *);
  bool (__fastcall *load)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *loadLinks)(Actor *this, const CompoundTag *, std::vector&lt;ActorLink&gt; *, DataLoadHelper *);
  ActorType (__fastcall *getEntityTypeId)(Actor *this);
  const HashedString *(__fastcall *queryEntityRenderer)(Actor *this);
  ActorUniqueID *(__fastcall *getSourceUniqueID)(Actor *this, ActorUniqueID *result);
  void (__fastcall *setOnFire)(Actor *this, int);
  AABB *(__fastcall *getHandleWaterAABB)(Actor *this, AABB *result);
  void (__fastcall *handleInsidePortal)(Actor *this, const BlockPos *);
  int (__fastcall *getPortalCooldown)(Actor *this);
  int (__fastcall *getPortalWaitTime)(Actor *this);
  AutomaticID&lt;Dimension,int&gt; *(__fastcall *getDimensionId)(Actor *this, AutomaticID&lt;Dimension,int&gt; *result);
  bool (__fastcall *canChangeDimensions)(Actor *this);
  void (__fastcall *changeDimension)(Actor *this, const ChangeDimensionPacket *);
  void (__fastcall *changeDimension)(Actor *this, AutomaticID&lt;Dimension,int&gt;, bool);
  ActorUniqueID *(__fastcall *getControllingPlayer)(Actor *this, ActorUniqueID *result);
  void (__fastcall *checkFallDamage)(Actor *this, float, bool);
  void (__fastcall *causeFallDamage)(Actor *this, float);
  void (__fastcall *handleFallDistanceOnServer)(Actor *this, float, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, int, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, const Block *, bool);
  void (__fastcall *onSynchedDataUpdate)(Actor *this, int);
  bool (__fastcall *canAddRider)(Actor *this, Actor *);
  bool (__fastcall *canPickupItem)(Actor *this, const ItemStack *);
  bool (__fastcall *canBePulledIntoVehicle)(Actor *this);
  bool (__fastcall *inCaravan)(Actor *this);
  bool (__fastcall *isLeashableType)(Actor *this);
  void (__fastcall *tickLeash)(Actor *this);
  void (__fastcall *sendMotionPacketIfNeeded)(Actor *this);
  bool (__fastcall *canSynchronizeNewEntity)(Actor *this);
  bool (__fastcall *stopRiding)(Actor *this, bool, bool, bool, bool);
  void (__fastcall *startSwimming)(Actor *this);
  void (__fastcall *stopSwimming)(Actor *this);
  void (__fastcall *buildDebugInfo)(Actor *this, std::string *);
  CommandPermissionLevel (__fastcall *getCommandPermissionLevel)(Actor *this);
  AttributeInstance *(__fastcall *getMutableAttribute)(Actor *this, const Attribute *);
  const AttributeInstance *(__fastcall *getAttribute)(Actor *this, const Attribute *);
  int (__fastcall *getDeathTime)(Actor *this);
  void (__fastcall *heal)(Actor *this, int);
  bool (__fastcall *isInvertedHealAndHarm)(Actor *this);
  bool (__fastcall *canBeAffected)(Actor *this, const MobEffectInstance *);
  bool (__fastcall *canBeAffected)(Actor *this, int);
  bool (__fastcall *canBeAffectedByArrow)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectAdded)(Actor *this, MobEffectInstance *);
  void (__fastcall *onEffectUpdated)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectRemoved)(Actor *this, MobEffectInstance *);
  AnimationComponent *(__fastcall *getAnimationComponent)(Actor *this);
  void (__fastcall *openContainerComponent)(Actor *this, Player *);
  void (__fastcall *swing)(Actor *this);
  void (__fastcall *useItem)(Actor *this, ItemStackBase *, ItemUseMethod, bool);
  bool (__fastcall *hasOutputSignal)(Actor *this, unsigned __int8);
  int (__fastcall *getOutputSignal)(Actor *this);
  void (__fastcall *getDebugText)(Actor *this, std::vector&lt;std::string&gt; *);
  float (__fastcall *getMapDecorationRotation)(Actor *this);
  float (__fastcall *getRiderYRotation)(Actor *this, const Actor *);
  float (__fastcall *getYHeadRot)(Actor *this);
  bool (__fastcall *isWorldBuilder)(Actor *this);
  bool (__fastcall *isCreative)(Actor *this);
  bool (__fastcall *isAdventure)(Actor *this);
  bool (__fastcall *add)(Actor *this, ItemStack *);
  bool (__fastcall *drop)(Actor *this, const ItemStack *, bool);
  bool (__fastcall *getInteraction)(Actor *this, Player *, ActorInteraction *, const Vec3 *);
  bool (__fastcall *canDestroyBlock)(Actor *this, const Block *);
  void (__fastcall *setAuxValue)(Actor *this, int);
  void (__fastcall *setSize)(Actor *this, float, float);
  int (__fastcall *getLifeSpan)(Actor *this);
  void (__fastcall *onOrphan)(Actor *this);
  void (__fastcall *wobble)(Actor *this);
  bool (__fastcall *wasHurt)(Actor *this);
  void (__fastcall *startSpinAttack)(Actor *this);
  void (__fastcall *stopSpinAttack)(Actor *this);
  void (__fastcall *setDamageNearbyMobs)(Actor *this, bool);
  bool (__fastcall *hasCritBox)(Actor *this);
  bool (__fastcall *isCritHit)(Actor *this);
  void (__fastcall *renderDebugServerState)(Actor *this, const Options *);
  void (__fastcall *reloadLootTable)(Actor *this, const EquipmentTableDefinition *);
  void (__fastcall *reloadLootTable)(Actor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(Actor *this);
  void (__fastcall *kill)(Actor *this);
  void (__fastcall *die)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *shouldTick)(Actor *this);
  std::shared_ptr&lt;IActorMovementProxy&gt; *(__fastcall *createMovementProxy)(Actor *this, std::shared_ptr&lt;IActorMovementProxy&gt; *result);
  void (__fastcall *updateEntitySpecificMolangVariables)(Actor *this, RenderParams *);
  bool (__fastcall *shouldTryMakeStepSound)(Actor *this);
  float (__fastcall *getNextStep)(Actor *this, const float);
  bool (__fastcall *canMakeStepSound)(Actor *this);
  void (__fastcall *outOfWorld)(Actor *this);
  bool (__fastcall *_hurt)(Actor *this, const ActorDamageSource *, int, bool, bool);
  void (__fastcall *markHurt)(Actor *this);
  void (__fastcall *readAdditionalSaveData)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *addAdditionalSaveData)(Actor *this, CompoundTag *);
  void (__fastcall *_playStepSound)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *_playFlySound)(Actor *this, const BlockPos *, const Block *);
  bool (__fastcall *_makeFlySound)(Actor *this);
  void (__fastcall *checkInsideBlocks)(Actor *this, float);
  void (__fastcall *pushOutOfBlocks)(Actor *this, const Vec3 *);
  bool (__fastcall *updateWaterState)(Actor *this);
  void (__fastcall *doWaterSplashEffect)(Actor *this);
  void (__fastcall *spawnTrailBubbles)(Actor *this);
  void (__fastcall *updateInsideBlock)(Actor *this);
  LootTable *(__fastcall *getLootTable)(Actor *this);
  LootTable *(__fastcall *getDefaultLootTable)(Actor *this);
  void (__fastcall *_removeRider)(Actor *this, const ActorUniqueID *, bool, bool, bool);
  void (__fastcall *_onSizeUpdated)(Actor *this);
  void (__fastcall *_doAutoAttackOnTouch)(Actor *this, Actor *);
  bool (__fastcall *shouldAlwaysRender)(LightningBolt *this);
};

</code></pre></div><h3 id="leafblock"><a href="#leafblock" class="header-anchor">#</a> <code>LeafBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LeafBlock : BlockLegacy
{
  bool mHasTransparentLeaves;
  bool mHasFastAlphaTest;
  WeakPtr&lt;BlockLegacy&gt; mSapling;
};

</code></pre></div><h3 id="leafblock-vtbl"><a href="#leafblock-vtbl" class="header-anchor">#</a> <code>LeafBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LeafBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getExtraResourceItem)(LeafBlock *this, ItemInstance *result, const Block *);
};

</code></pre></div><h3 id="lecternrenderer"><a href="#lecternrenderer" class="header-anchor">#</a> <code>LecternRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LecternRenderer : BlockActorRenderer
{
  mce::TexturePtr mBookTex;
  EnchantingBookModel mBook;
};

</code></pre></div><h3 id="lecternrenderer-vtbl"><a href="#lecternrenderer-vtbl" class="header-anchor">#</a> <code>LecternRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LecternRenderer_vtbl
{
  void (__fastcall *~ActorShaderManager)(ActorShaderManager *this);
  mce::Color *(__fastcall *_getOverlayColor)(ActorShaderManager *this, mce::Color *result, Actor *, float);
  void (__fastcall *render)(BlockActorRenderer *this, BaseActorRenderContext *, BlockActorRenderData *);
  void (__fastcall *renderAlpha)(BlockActorRenderer *this, BaseActorRenderContext *, BlockActorRenderData *);
  std::vector&lt;NameTagRenderObject&gt; *(__fastcall *extractText)(BlockActorRenderer *this, std::vector&lt;NameTagRenderObject&gt; *result, Tessellator *, BlockActor *, const std::string *, const std::vector&lt;int&gt; *, Vec3, bool);
};

</code></pre></div><h3 id="levelcullercachedbase-changeelement"><a href="#levelcullercachedbase-changeelement" class="header-anchor">#</a> <code>LevelCullerCachedBase::ChangeElement</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct LevelCullerCachedBase::ChangeElement
{
  LevelCullerCachedBase::ChangeID mChangeType;
  unsigned __int64 mListIdx;
};

</code></pre></div><h3 id="levelcullercachedbase-resetcullingworlddimensions"><a href="#levelcullercachedbase-resetcullingworlddimensions" class="header-anchor">#</a> <code>LevelCullerCachedBase::ResetCullingWorldDimensions</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelCullerCachedBase::ResetCullingWorldDimensions
{
  int mViewSideSize;
  DimensionHeightRange mHeightRange;
  int mMaxCullingSteps;
};

</code></pre></div><h3 id="levelcullercachedbase"><a href="#levelcullercachedbase" class="header-anchor">#</a> <code>LevelCullerCachedBase</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelCullerCachedBase : LevelCullerBase
{
  std::unique_ptr&lt;ChunkVisibilityCache&gt; mChunkVisibilityCache;
  int mChunkViewAreaSide;
  std::optional&lt;DimensionHeightRange&gt; mHeightRange;
  int mMaxCullingSteps;
  ChunkPos mLastCullingChunkPos;
  unsigned __int8 mChunkVisibilityFrameID;
  std::vector&lt;LevelCullerCachedBase::ChangeElement&gt; mChangeList;
  std::vector&lt;SubChunkPos&gt; mApplyInvalidateList;
  std::vector&lt;LevelCullerCachedBase::UpdateChunkData&gt; mApplyUpdatesList;
  std::vector&lt;LevelCullerCachedBase::ResetCullingWorldDimensions&gt; mApplyResetCullingWorldDataList;
  std::vector&lt;Bounds&gt; mChangeValidAreaList;
  Bounds mValidArea;
  SpinLock mApplyChangesSpinLock;
};

</code></pre></div><h3 id="levelcullercachedbase-vtbl"><a href="#levelcullercachedbase-vtbl" class="header-anchor">#</a> <code>LevelCullerCachedBase_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelCullerCachedBase_vtbl
{
  void (__fastcall *~LevelCullerBase)(LevelCullerBase *this);
  void (__fastcall *handleCullingDutiesThisUpdate)(LevelCullerBase *this, const Vec3 *, const Vec3 *, LevelRendererCamera *);
  void (__fastcall *triggerCull)(LevelCullerBase *this, bool);
  void (__fastcall *getVisibleSubchunks)(LevelCullerBase *this, std::vector&lt;SubChunkPos&gt; *);
  void (__fastcall *resetCullingWorldDimensions)(LevelCullerBase *this, int, const DimensionHeightRange *, int);
  void (__fastcall *changeValidArea)(LevelCullerBase *this, const Bounds *);
  void (__fastcall *updateChunkData)(LevelCullerBase *this, const RenderChunkShared *);
  bool (__fastcall *isBlockPositionVisible)(LevelCullerBase *this, const BlockPos *);
  void (__fastcall *invalidateChunk)(LevelCullerBase *this, const SubChunkPos *);
  void (__fastcall *setEmpty)(LevelCullerBase *this, const SubChunkPos *, bool);
  bool (__fastcall *isBusy)(LevelCullerBase *this);
  bool (__fastcall *shouldRecullAfterChunkChange)(LevelCullerBase *this, const RenderChunkShared *);
  unsigned int (__fastcall *getCullIteration)(LevelCullerBase *this);
};

</code></pre></div><h3 id="levelcullerdistancefield"><a href="#levelcullerdistancefield" class="header-anchor">#</a> <code>LevelCullerDistanceField</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LevelCullerDistanceField : LevelCullerCachedBase, std::enable_shared_from_this&lt;LevelCullerDistanceField&gt;
{
  std::vector&lt;DistanceFieldCullingStep&gt; mNarrowPhaseHeap;
  SpinLock mRenderChunksVisibleFromCullingPointSpinLock;
  std::vector&lt;SubChunkPos&gt; mRenderChunksVisibleFromCullingPoint[2];
  unsigned __int64 mActiveRenderChunksVisibleList;
  unsigned __int64 mWorldingRenderChunksVisibleList;
  std::atomic&lt;unsigned int&gt; mTasksCount;
  std::atomic&lt;unsigned int&gt; mCullIteration;
  bool mCullNextFrame;
  Vec3 mCullingOrigin;
  ChunkPos mCullingOriginCP;
  DistanceFieldCullingStep mSwapTemp;
  std::atomic&lt;bool&gt; mTaskScheduled;
  Vec3 mCurrentCameraPos;
  Vec3 mCurrentCameraForward;
  Vec3 mNextCameraPos;
  Vec3 mNextCameraForward;
  int mSteps;
  float mTotalTime;
};

</code></pre></div><h3 id="levelcullerdistancefield-vtbl"><a href="#levelcullerdistancefield-vtbl" class="header-anchor">#</a> <code>LevelCullerDistanceField_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelCullerDistanceField_vtbl
{
  void (__fastcall *~LevelCullerBase)(LevelCullerBase *this);
  void (__fastcall *handleCullingDutiesThisUpdate)(LevelCullerBase *this, const Vec3 *, const Vec3 *, LevelRendererCamera *);
  void (__fastcall *triggerCull)(LevelCullerBase *this, bool);
  void (__fastcall *getVisibleSubchunks)(LevelCullerBase *this, std::vector&lt;SubChunkPos&gt; *);
  void (__fastcall *resetCullingWorldDimensions)(LevelCullerBase *this, int, const DimensionHeightRange *, int);
  void (__fastcall *changeValidArea)(LevelCullerBase *this, const Bounds *);
  void (__fastcall *updateChunkData)(LevelCullerBase *this, const RenderChunkShared *);
  bool (__fastcall *isBlockPositionVisible)(LevelCullerBase *this, const BlockPos *);
  void (__fastcall *invalidateChunk)(LevelCullerBase *this, const SubChunkPos *);
  void (__fastcall *setEmpty)(LevelCullerBase *this, const SubChunkPos *, bool);
  bool (__fastcall *isBusy)(LevelCullerBase *this);
  bool (__fastcall *shouldRecullAfterChunkChange)(LevelCullerBase *this, const RenderChunkShared *);
  unsigned int (__fastcall *getCullIteration)(LevelCullerBase *this);
  void (__fastcall *_prepareForCulling)(LevelCullerDistanceField *this, LevelRendererCamera *);
  float (__fastcall *_computeLinearDistance)(LevelCullerDistanceField *this, const Vec3 *);
  bool (__fastcall *_doesRenderDistanceApply)(LevelCullerDistanceField *this);
  bool (__fastcall *_checkPositionAgainstBounds)(LevelCullerDistanceField *this, const SubChunkPos *);
  bool (__fastcall *_checkDistanceDelta)(LevelCullerDistanceField *this, float);
};

</code></pre></div><h3 id="levelcullerdistancefieldorthographic"><a href="#levelcullerdistancefieldorthographic" class="header-anchor">#</a> <code>LevelCullerDistanceFieldOrthographic</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelCullerDistanceFieldOrthographic : LevelCullerDistanceField
{
  Bounds mBounds;
  glm::tvec4&lt;float,0&gt; mSidePlanes[4];
};

</code></pre></div><h3 id="levelcullerdistancefieldorthographic-vtbl"><a href="#levelcullerdistancefieldorthographic-vtbl" class="header-anchor">#</a> <code>LevelCullerDistanceFieldOrthographic_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelCullerDistanceFieldOrthographic_vtbl
{
  void (__fastcall *~LevelCullerBase)(LevelCullerBase *this);
  void (__fastcall *handleCullingDutiesThisUpdate)(LevelCullerBase *this, const Vec3 *, const Vec3 *, LevelRendererCamera *);
  void (__fastcall *triggerCull)(LevelCullerBase *this, bool);
  void (__fastcall *getVisibleSubchunks)(LevelCullerBase *this, std::vector&lt;SubChunkPos&gt; *);
  void (__fastcall *resetCullingWorldDimensions)(LevelCullerBase *this, int, const DimensionHeightRange *, int);
  void (__fastcall *changeValidArea)(LevelCullerBase *this, const Bounds *);
  void (__fastcall *updateChunkData)(LevelCullerBase *this, const RenderChunkShared *);
  bool (__fastcall *isBlockPositionVisible)(LevelCullerBase *this, const BlockPos *);
  void (__fastcall *invalidateChunk)(LevelCullerBase *this, const SubChunkPos *);
  void (__fastcall *setEmpty)(LevelCullerBase *this, const SubChunkPos *, bool);
  bool (__fastcall *isBusy)(LevelCullerBase *this);
  bool (__fastcall *shouldRecullAfterChunkChange)(LevelCullerBase *this, const RenderChunkShared *);
  unsigned int (__fastcall *getCullIteration)(LevelCullerBase *this);
  void (__fastcall *_prepareForCulling)(LevelCullerDistanceField *this, LevelRendererCamera *);
  float (__fastcall *_computeLinearDistance)(LevelCullerDistanceField *this, const Vec3 *);
  bool (__fastcall *_doesRenderDistanceApply)(LevelCullerDistanceField *this);
  bool (__fastcall *_checkPositionAgainstBounds)(LevelCullerDistanceField *this, const SubChunkPos *);
  bool (__fastcall *_checkDistanceDelta)(LevelCullerDistanceField *this, float);
};

</code></pre></div><h3 id="levelcullerdistancefieldperspective"><a href="#levelcullerdistancefieldperspective" class="header-anchor">#</a> <code>LevelCullerDistanceFieldPerspective</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelCullerDistanceFieldPerspective : LevelCullerDistanceField
{
};

</code></pre></div><h3 id="levelcullerdistancefieldperspective-vtbl"><a href="#levelcullerdistancefieldperspective-vtbl" class="header-anchor">#</a> <code>LevelCullerDistanceFieldPerspective_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelCullerDistanceFieldPerspective_vtbl
{
  void (__fastcall *~LevelCullerBase)(LevelCullerBase *this);
  void (__fastcall *handleCullingDutiesThisUpdate)(LevelCullerBase *this, const Vec3 *, const Vec3 *, LevelRendererCamera *);
  void (__fastcall *triggerCull)(LevelCullerBase *this, bool);
  void (__fastcall *getVisibleSubchunks)(LevelCullerBase *this, std::vector&lt;SubChunkPos&gt; *);
  void (__fastcall *resetCullingWorldDimensions)(LevelCullerBase *this, int, const DimensionHeightRange *, int);
  void (__fastcall *changeValidArea)(LevelCullerBase *this, const Bounds *);
  void (__fastcall *updateChunkData)(LevelCullerBase *this, const RenderChunkShared *);
  bool (__fastcall *isBlockPositionVisible)(LevelCullerBase *this, const BlockPos *);
  void (__fastcall *invalidateChunk)(LevelCullerBase *this, const SubChunkPos *);
  void (__fastcall *setEmpty)(LevelCullerBase *this, const SubChunkPos *, bool);
  bool (__fastcall *isBusy)(LevelCullerBase *this);
  bool (__fastcall *shouldRecullAfterChunkChange)(LevelCullerBase *this, const RenderChunkShared *);
  unsigned int (__fastcall *getCullIteration)(LevelCullerBase *this);
  void (__fastcall *_prepareForCulling)(LevelCullerDistanceField *this, LevelRendererCamera *);
  float (__fastcall *_computeLinearDistance)(LevelCullerDistanceField *this, const Vec3 *);
  bool (__fastcall *_doesRenderDistanceApply)(LevelCullerDistanceField *this);
  bool (__fastcall *_checkPositionAgainstBounds)(LevelCullerDistanceField *this, const SubChunkPos *);
  bool (__fastcall *_checkDistanceDelta)(LevelCullerDistanceField *this, float);
};

</code></pre></div><h3 id="levelcullersunshadow"><a href="#levelcullersunshadow" class="header-anchor">#</a> <code>LevelCullerSunShadow</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelCullerSunShadow : LevelCullerCachedBase
{
  bool mCullNextFrame;
  SpinLock mRenderChunksVisibleFromCullingPointSpinLock;
  std::vector&lt;SubChunkPos&gt; mRenderChunksVisibleFromCullingPoint[2];
  unsigned __int64 mActiveRenderChunksVisibleList;
  unsigned __int64 mWorldingRenderChunksVisibleList;
  Vec3 mCurrentCameraPos;
  Vec3 mCullingOrigin;
  ChunkPos mCullingOriginCP;
  std::atomic&lt;unsigned int&gt; mCullIteration;
  Bounds mBounds;
  glm::tvec4&lt;float,0&gt; mSidePlanes[4];
  std::atomic&lt;bool&gt; mTaskScheduled;
  std::atomic&lt;unsigned int&gt; mTasksCount;
  Vec3 mNextCameraPos;
};

</code></pre></div><h3 id="levelcullersunshadow-vtbl"><a href="#levelcullersunshadow-vtbl" class="header-anchor">#</a> <code>LevelCullerSunShadow_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelCullerSunShadow_vtbl
{
  void (__fastcall *~LevelCullerBase)(LevelCullerBase *this);
  void (__fastcall *handleCullingDutiesThisUpdate)(LevelCullerBase *this, const Vec3 *, const Vec3 *, LevelRendererCamera *);
  void (__fastcall *triggerCull)(LevelCullerBase *this, bool);
  void (__fastcall *getVisibleSubchunks)(LevelCullerBase *this, std::vector&lt;SubChunkPos&gt; *);
  void (__fastcall *resetCullingWorldDimensions)(LevelCullerBase *this, int, const DimensionHeightRange *, int);
  void (__fastcall *changeValidArea)(LevelCullerBase *this, const Bounds *);
  void (__fastcall *updateChunkData)(LevelCullerBase *this, const RenderChunkShared *);
  bool (__fastcall *isBlockPositionVisible)(LevelCullerBase *this, const BlockPos *);
  void (__fastcall *invalidateChunk)(LevelCullerBase *this, const SubChunkPos *);
  void (__fastcall *setEmpty)(LevelCullerBase *this, const SubChunkPos *, bool);
  bool (__fastcall *isBusy)(LevelCullerBase *this);
  bool (__fastcall *shouldRecullAfterChunkChange)(LevelCullerBase *this, const RenderChunkShared *);
  unsigned int (__fastcall *getCullIteration)(LevelCullerBase *this);
};

</code></pre></div><h3 id="levelcullernone"><a href="#levelcullernone" class="header-anchor">#</a> <code>LevelCullerNone</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelCullerNone : LevelCullerBase
{
  std::vector&lt;SubChunkPos&gt; mVisibleSubChunks;
};

</code></pre></div><h3 id="levelcullernone-vtbl"><a href="#levelcullernone-vtbl" class="header-anchor">#</a> <code>LevelCullerNone_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelCullerNone_vtbl
{
  void (__fastcall *~LevelCullerBase)(LevelCullerBase *this);
  void (__fastcall *handleCullingDutiesThisUpdate)(LevelCullerBase *this, const Vec3 *, const Vec3 *, LevelRendererCamera *);
  void (__fastcall *triggerCull)(LevelCullerBase *this, bool);
  void (__fastcall *getVisibleSubchunks)(LevelCullerBase *this, std::vector&lt;SubChunkPos&gt; *);
  void (__fastcall *resetCullingWorldDimensions)(LevelCullerBase *this, int, const DimensionHeightRange *, int);
  void (__fastcall *changeValidArea)(LevelCullerBase *this, const Bounds *);
  void (__fastcall *updateChunkData)(LevelCullerBase *this, const RenderChunkShared *);
  bool (__fastcall *isBlockPositionVisible)(LevelCullerBase *this, const BlockPos *);
  void (__fastcall *invalidateChunk)(LevelCullerBase *this, const SubChunkPos *);
  void (__fastcall *setEmpty)(LevelCullerBase *this, const SubChunkPos *, bool);
  bool (__fastcall *isBusy)(LevelCullerBase *this);
  bool (__fastcall *shouldRecullAfterChunkChange)(LevelCullerBase *this, const RenderChunkShared *);
  unsigned int (__fastcall *getCullIteration)(LevelCullerBase *this);
};

</code></pre></div><h3 id="levelbuilder-schedulechunksort-l2-lambda-ca9f475f5abe9fd2bd8d315c3e337e8a"><a href="#levelbuilder-schedulechunksort-l2-lambda-ca9f475f5abe9fd2bd8d315c3e337e8a" class="header-anchor">#</a> <code>LevelBuilder::scheduleChunkSort::__l2::&lt;lambda_ca9f475f5abe9fd2bd8d315c3e337e8a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelBuilder::scheduleChunkSort::__l2::&lt;lambda_ca9f475f5abe9fd2bd8d315c3e337e8a&gt;
{
  const std::shared_ptr&lt;RenderChunkInstanced&gt; renderChunkInstanced;
  std::shared_ptr&lt;SortTaskContext&gt; sortTaskContext;
  LevelBuilder *const __this;
};

</code></pre></div><h3 id="levelbuilder-schedulechunksort-l2-lambda-0213a46f6c28c89d46d5304ec9dc3af0"><a href="#levelbuilder-schedulechunksort-l2-lambda-0213a46f6c28c89d46d5304ec9dc3af0" class="header-anchor">#</a> <code>LevelBuilder::scheduleChunkSort::__l2::&lt;lambda_0213a46f6c28c89d46d5304ec9dc3af0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelBuilder::scheduleChunkSort::__l2::&lt;lambda_0213a46f6c28c89d46d5304ec9dc3af0&gt;
{
  const std::shared_ptr&lt;RenderChunkInstanced&gt; renderChunkInstanced;
  std::shared_ptr&lt;SortTaskContext&gt; sortTaskContext;
};

</code></pre></div><h3 id="levelbuilder-schedulechunksort-l19-lambda-645c2dfcf2f77d157bab94892f7fdf5b"><a href="#levelbuilder-schedulechunksort-l19-lambda-645c2dfcf2f77d157bab94892f7fdf5b" class="header-anchor">#</a> <code>LevelBuilder::scheduleChunkSort::__l19::&lt;lambda_645c2dfcf2f77d157bab94892f7fdf5b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelBuilder::scheduleChunkSort::__l19::&lt;lambda_645c2dfcf2f77d157bab94892f7fdf5b&gt;
{
  LevelBuilder *const __this;
};

</code></pre></div><h3 id="levelbuilder-schedulechunkbuild-l11-lambda-1a475e5ac8540ac7cb31a3455a6528d7"><a href="#levelbuilder-schedulechunkbuild-l11-lambda-1a475e5ac8540ac7cb31a3455a6528d7" class="header-anchor">#</a> <code>LevelBuilder::scheduleChunkBuild::__l11::&lt;lambda_1a475e5ac8540ac7cb31a3455a6528d7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelBuilder::scheduleChunkBuild::__l11::&lt;lambda_1a475e5ac8540ac7cb31a3455a6528d7&gt;
{
  LevelBuilder *const __this;
};

</code></pre></div><h3 id="levelbuilder-schedulechunkbuild-l2-lambda-781943cdbadde60e3ecf438faf85c914"><a href="#levelbuilder-schedulechunkbuild-l2-lambda-781943cdbadde60e3ecf438faf85c914" class="header-anchor">#</a> <code>LevelBuilder::scheduleChunkBuild::__l2::&lt;lambda_781943cdbadde60e3ecf438faf85c914&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelBuilder::scheduleChunkBuild::__l2::&lt;lambda_781943cdbadde60e3ecf438faf85c914&gt;
{
  LevelBuilder *const __this;
  ClientBlockPipeline::TessellatorContext *pipelineContext;
  BlockSource **region;
};

</code></pre></div><h3 id="levelbuilder-recreatebuilders-l13-lambda-f7e2fe60366fd092cba4f0d948a03be6"><a href="#levelbuilder-recreatebuilders-l13-lambda-f7e2fe60366fd092cba4f0d948a03be6" class="header-anchor">#</a> <code>LevelBuilder::recreateBuilders::__l13::&lt;lambda_f7e2fe60366fd092cba4f0d948a03be6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelBuilder::recreateBuilders::__l13::&lt;lambda_f7e2fe60366fd092cba4f0d948a03be6&gt;
{
  LevelBuilder *const __this;
};

</code></pre></div><h3 id="levelbuilder-recreatebuilders-l13-lambda-ea2e2c03424d2e9ca36c3a4505d717b2"><a href="#levelbuilder-recreatebuilders-l13-lambda-ea2e2c03424d2e9ca36c3a4505d717b2" class="header-anchor">#</a> <code>LevelBuilder::recreateBuilders::__l13::&lt;lambda_ea2e2c03424d2e9ca36c3a4505d717b2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelBuilder::recreateBuilders::__l13::&lt;lambda_ea2e2c03424d2e9ca36c3a4505d717b2&gt;
{
  MinecraftGameplayGraphicsResources *minecraftGameplayGraphicsResources;
  ClientBlockPipeline::TessellatorContext *pipelineContext;
  BlockSource **region;
};

</code></pre></div><h3 id="levelbuilder-buildrenderchunks-l2-lambda-a08ac9d83425319e6a6e10392713a815"><a href="#levelbuilder-buildrenderchunks-l2-lambda-a08ac9d83425319e6a6e10392713a815" class="header-anchor">#</a> <code>LevelBuilder::_buildRenderChunks::__l2::&lt;lambda_a08ac9d83425319e6a6e10392713a815&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelBuilder::_buildRenderChunks::__l2::&lt;lambda_a08ac9d83425319e6a6e10392713a815&gt;
{
  LevelBuilder *const __this;
  const Vec3 cameraPos;
  Vec3 cameraForward;
};

</code></pre></div><h3 id="levelrenderer-takepicture-l25-lambda-966f471d8bd52e85682cd189483f4859"><a href="#levelrenderer-takepicture-l25-lambda-966f471d8bd52e85682cd189483f4859" class="header-anchor">#</a> <code>LevelRenderer::takePicture::__l25::&lt;lambda_966f471d8bd52e85682cd189483f4859&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRenderer::takePicture::__l25::&lt;lambda_966f471d8bd52e85682cd189483f4859&gt;
{
  LevelRenderer *const __this;
};

</code></pre></div><h3 id="levelrenderercamera-createviewrenderobject-l2-lambda-06c0d9ebcdc7bb0d6b8014e75fd06a48"><a href="#levelrenderercamera-createviewrenderobject-l2-lambda-06c0d9ebcdc7bb0d6b8014e75fd06a48" class="header-anchor">#</a> <code>LevelRendererCamera::createViewRenderObject::__l2::&lt;lambda_06c0d9ebcdc7bb0d6b8014e75fd06a48&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::createViewRenderObject::__l2::&lt;lambda_06c0d9ebcdc7bb0d6b8014e75fd06a48&gt;
{
  ScreenContext *screenContext;
  unsigned __int8 *oldScreenContextSubClientId;
};

</code></pre></div><h3 id="levelrenderercamera-queuechunk-l14-lambda-2ad54a24c26a56bab19ead12d48483ee"><a href="#levelrenderercamera-queuechunk-l14-lambda-2ad54a24c26a56bab19ead12d48483ee" class="header-anchor">#</a> <code>LevelRendererCamera::queueChunk::__l14::&lt;lambda_2ad54a24c26a56bab19ead12d48483ee&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::queueChunk::__l14::&lt;lambda_2ad54a24c26a56bab19ead12d48483ee&gt;
{
};

</code></pre></div><h3 id="levelrenderercamera-queuechunk-l14-lambda-1c7bae9e0e8e75154218cbbb1a06b46f"><a href="#levelrenderercamera-queuechunk-l14-lambda-1c7bae9e0e8e75154218cbbb1a06b46f" class="header-anchor">#</a> <code>LevelRendererCamera::queueChunk::__l14::&lt;lambda_1c7bae9e0e8e75154218cbbb1a06b46f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::queueChunk::__l14::&lt;lambda_1c7bae9e0e8e75154218cbbb1a06b46f&gt;
{
};

</code></pre></div><h3 id="levelrenderercamera-queuechunk-l14-lambda-e3ecd698544eea2955d458a6197fb71e"><a href="#levelrenderercamera-queuechunk-l14-lambda-e3ecd698544eea2955d458a6197fb71e" class="header-anchor">#</a> <code>LevelRendererCamera::queueChunk::__l14::&lt;lambda_e3ecd698544eea2955d458a6197fb71e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::queueChunk::__l14::&lt;lambda_e3ecd698544eea2955d458a6197fb71e&gt;
{
};

</code></pre></div><h3 id="levelrenderercamera-queuechunk-l17-lambda-f80110362d34345c177c11033da0fab1"><a href="#levelrenderercamera-queuechunk-l17-lambda-f80110362d34345c177c11033da0fab1" class="header-anchor">#</a> <code>LevelRendererCamera::queueChunk::__l17::&lt;lambda_f80110362d34345c177c11033da0fab1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::queueChunk::__l17::&lt;lambda_f80110362d34345c177c11033da0fab1&gt;
{
};

</code></pre></div><h3 id="levelrenderercamera-queuechunk-l17-lambda-a5f77baf381576dd0df113ed6627093f"><a href="#levelrenderercamera-queuechunk-l17-lambda-a5f77baf381576dd0df113ed6627093f" class="header-anchor">#</a> <code>LevelRendererCamera::queueChunk::__l17::&lt;lambda_a5f77baf381576dd0df113ed6627093f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::queueChunk::__l17::&lt;lambda_a5f77baf381576dd0df113ed6627093f&gt;
{
};

</code></pre></div><h3 id="levelrenderercamera-queuechunk-l17-lambda-5f1fe1d401ded85d05fced13872eea5b"><a href="#levelrenderercamera-queuechunk-l17-lambda-5f1fe1d401ded85d05fced13872eea5b" class="header-anchor">#</a> <code>LevelRendererCamera::queueChunk::__l17::&lt;lambda_5f1fe1d401ded85d05fced13872eea5b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::queueChunk::__l17::&lt;lambda_5f1fe1d401ded85d05fced13872eea5b&gt;
{
};

</code></pre></div><h3 id="levelrenderercamera-updateeditviewarea-l12-lambda-783b19e5ed4e5307f406058f5c908b18"><a href="#levelrenderercamera-updateeditviewarea-l12-lambda-783b19e5ed4e5307f406058f5c908b18" class="header-anchor">#</a> <code>LevelRendererCamera::updateEditViewArea::__l12::&lt;lambda_783b19e5ed4e5307f406058f5c908b18&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LevelRendererCamera::updateEditViewArea::__l12::&lt;lambda_783b19e5ed4e5307f406058f5c908b18&gt;
{
  LevelRendererCamera *const __this;
  bool isOrthoCamera;
};

</code></pre></div><h3 id="levelrenderercamera-render-l136-lambda-95f9375e63923262021f4f30b6a3d7f7"><a href="#levelrenderercamera-render-l136-lambda-95f9375e63923262021f4f30b6a3d7f7" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l136::&lt;lambda_95f9375e63923262021f4f30b6a3d7f7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l136::&lt;lambda_95f9375e63923262021f4f30b6a3d7f7&gt;
{
  LevelRendererCamera *const __this;
  ScreenContext *screenContext;
};

</code></pre></div><h3 id="levelrenderercamera-render-l133-lambda-4764c359c2ec24a8a0939836d0dd3563"><a href="#levelrenderercamera-render-l133-lambda-4764c359c2ec24a8a0939836d0dd3563" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l133::&lt;lambda_4764c359c2ec24a8a0939836d0dd3563&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l133::&lt;lambda_4764c359c2ec24a8a0939836d0dd3563&gt;
{
  ScreenContext *screenContext;
  const ViewRenderObject *renderObj;
};

</code></pre></div><h3 id="levelrenderercamera-render-l123-lambda-9d443ce3f6a4f06289231c5ca55306cc"><a href="#levelrenderercamera-render-l123-lambda-9d443ce3f6a4f06289231c5ca55306cc" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l123::&lt;lambda_9d443ce3f6a4f06289231c5ca55306cc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l123::&lt;lambda_9d443ce3f6a4f06289231c5ca55306cc&gt;
{
  LevelRendererCamera *const __this;
  ScreenContext *screenContext;
  const ViewRenderObject *renderObj;
  FontHandle *fontHandle;
};

</code></pre></div><h3 id="levelrenderercamera-render-l117-lambda-318f9183abd68b382aa93085aacaff59"><a href="#levelrenderercamera-render-l117-lambda-318f9183abd68b382aa93085aacaff59" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l117::&lt;lambda_318f9183abd68b382aa93085aacaff59&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l117::&lt;lambda_318f9183abd68b382aa93085aacaff59&gt;
{
  LevelRendererCamera *const __this;
  BaseActorRenderContext *baseEntityRenderContext;
};

</code></pre></div><h3 id="levelrenderercamera-render-l109-lambda-e354dc0c7e5eadaff08b5d6664232090"><a href="#levelrenderercamera-render-l109-lambda-e354dc0c7e5eadaff08b5d6664232090" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l109::&lt;lambda_e354dc0c7e5eadaff08b5d6664232090&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l109::&lt;lambda_e354dc0c7e5eadaff08b5d6664232090&gt;
{
  LevelRendererCamera *const __this;
  BaseActorRenderContext *baseEntityRenderContext;
  const ViewRenderObject *renderObj;
};

</code></pre></div><h3 id="levelrenderercamera-render-l105-lambda-4fe7d505b0540ad3ff640da8f3a8c852"><a href="#levelrenderercamera-render-l105-lambda-4fe7d505b0540ad3ff640da8f3a8c852" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l105::&lt;lambda_4fe7d505b0540ad3ff640da8f3a8c852&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l105::&lt;lambda_4fe7d505b0540ad3ff640da8f3a8c852&gt;
{
  ScreenContext *screenContext;
  const ViewRenderObject *renderObj;
};

</code></pre></div><h3 id="levelrenderercamera-render-l102-lambda-8eaadf639f8a587c43525cc3ddbd5cc3"><a href="#levelrenderercamera-render-l102-lambda-8eaadf639f8a587c43525cc3ddbd5cc3" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l102::&lt;lambda_8eaadf639f8a587c43525cc3ddbd5cc3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l102::&lt;lambda_8eaadf639f8a587c43525cc3ddbd5cc3&gt;
{
  ScreenContext *screenContext;
  const ViewRenderObject *renderObj;
};

</code></pre></div><h3 id="levelrenderercamera-render-l99-lambda-b77b8e6ba7ca21f3c605c9c0aa5a50de"><a href="#levelrenderercamera-render-l99-lambda-b77b8e6ba7ca21f3c605c9c0aa5a50de" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l99::&lt;lambda_b77b8e6ba7ca21f3c605c9c0aa5a50de&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l99::&lt;lambda_b77b8e6ba7ca21f3c605c9c0aa5a50de&gt;
{
  ScreenContext *screenContext;
  const ViewRenderObject *renderObj;
  LevelRendererCamera *const __this;
  BaseActorRenderContext *baseEntityRenderContext;
};

</code></pre></div><h3 id="levelrenderercamera-render-l93-lambda-f3cc7f48a90c411b5548465bf4eb0500"><a href="#levelrenderercamera-render-l93-lambda-f3cc7f48a90c411b5548465bf4eb0500" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l93::&lt;lambda_f3cc7f48a90c411b5548465bf4eb0500&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l93::&lt;lambda_f3cc7f48a90c411b5548465bf4eb0500&gt;
{
  LevelRendererCamera *const __this;
  BaseActorRenderContext *baseEntityRenderContext;
};

</code></pre></div><h3 id="levelrenderercamera-render-l90-lambda-8ef8c01b7db41447ee8f6790dba84dc2"><a href="#levelrenderercamera-render-l90-lambda-8ef8c01b7db41447ee8f6790dba84dc2" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l90::&lt;lambda_8ef8c01b7db41447ee8f6790dba84dc2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l90::&lt;lambda_8ef8c01b7db41447ee8f6790dba84dc2&gt;
{
  ScreenContext *screenContext;
  const ViewRenderObject *renderObj;
};

</code></pre></div><h3 id="levelrenderercamera-render-l86-lambda-92c4a9c5072df1bf21f23835db0b55b3"><a href="#levelrenderercamera-render-l86-lambda-92c4a9c5072df1bf21f23835db0b55b3" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l86::&lt;lambda_92c4a9c5072df1bf21f23835db0b55b3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l86::&lt;lambda_92c4a9c5072df1bf21f23835db0b55b3&gt;
{
  LevelRendererCamera *const __this;
  ScreenContext *screenContext;
};

</code></pre></div><h3 id="levelrenderercamera-render-l83-lambda-570d4a787024f68a608698b74170fdba"><a href="#levelrenderercamera-render-l83-lambda-570d4a787024f68a608698b74170fdba" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l83::&lt;lambda_570d4a787024f68a608698b74170fdba&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l83::&lt;lambda_570d4a787024f68a608698b74170fdba&gt;
{
  LevelRendererCamera *const __this;
  BaseActorRenderContext *baseEntityRenderContext;
};

</code></pre></div><h3 id="levelrenderercamera-render-l80-lambda-63d7ae77897f6b7eed49e76ef924ebca"><a href="#levelrenderercamera-render-l80-lambda-63d7ae77897f6b7eed49e76ef924ebca" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l80::&lt;lambda_63d7ae77897f6b7eed49e76ef924ebca&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l80::&lt;lambda_63d7ae77897f6b7eed49e76ef924ebca&gt;
{
  ScreenContext *screenContext;
  const ViewRenderObject *renderObj;
};

</code></pre></div><h3 id="levelrenderercamera-render-l76-lambda-716be9c58d56683595928c27d77b513c"><a href="#levelrenderercamera-render-l76-lambda-716be9c58d56683595928c27d77b513c" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l76::&lt;lambda_716be9c58d56683595928c27d77b513c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l76::&lt;lambda_716be9c58d56683595928c27d77b513c&gt;
{
  LevelRendererCamera *const __this;
  ScreenContext *screenContext;
};

</code></pre></div><h3 id="levelrenderercamera-render-l73-lambda-d57d135460e5fe98e6080c441bc8e7e1"><a href="#levelrenderercamera-render-l73-lambda-d57d135460e5fe98e6080c441bc8e7e1" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l73::&lt;lambda_d57d135460e5fe98e6080c441bc8e7e1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l73::&lt;lambda_d57d135460e5fe98e6080c441bc8e7e1&gt;
{
  ScreenContext *screenContext;
  const ViewRenderObject *renderObj;
};

</code></pre></div><h3 id="levelrenderercamera-render-l67-lambda-7b9c96c25bd51daa0708c6f6129d6813"><a href="#levelrenderercamera-render-l67-lambda-7b9c96c25bd51daa0708c6f6129d6813" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l67::&lt;lambda_7b9c96c25bd51daa0708c6f6129d6813&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l67::&lt;lambda_7b9c96c25bd51daa0708c6f6129d6813&gt;
{
  LevelRendererCamera *const __this;
  BaseActorRenderContext *baseEntityRenderContext;
};

</code></pre></div><h3 id="levelrenderercamera-render-l2-lambda-e5cf65af315eee176ad31648f3749adc"><a href="#levelrenderercamera-render-l2-lambda-e5cf65af315eee176ad31648f3749adc" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l2::&lt;lambda_e5cf65af315eee176ad31648f3749adc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l2::&lt;lambda_e5cf65af315eee176ad31648f3749adc&gt;
{
  LevelRendererCamera *const __this;
  ScreenContext *screenContext;
};

</code></pre></div><h3 id="levelrenderercamera-render-l2-lambda-528f95f81012b8c94d11f5be3db617db"><a href="#levelrenderercamera-render-l2-lambda-528f95f81012b8c94d11f5be3db617db" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l2::&lt;lambda_528f95f81012b8c94d11f5be3db617db&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l2::&lt;lambda_528f95f81012b8c94d11f5be3db617db&gt;
{
  LevelRendererCamera *const __this;
  ScreenContext *screenContext;
  const ViewRenderObject *renderObj;
  bool *drawSky;
};

</code></pre></div><h3 id="levelrenderercamera-render-l55-lambda-c69ba69cc2350aedc765efc2f688c073"><a href="#levelrenderercamera-render-l55-lambda-c69ba69cc2350aedc765efc2f688c073" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l55::&lt;lambda_c69ba69cc2350aedc765efc2f688c073&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l55::&lt;lambda_c69ba69cc2350aedc765efc2f688c073&gt;
{
  LevelRendererCamera *const __this;
  BaseActorRenderContext *baseEntityRenderContext;
};

</code></pre></div><h3 id="levelrenderercamera-render-l51-lambda-98cf3401a20e8e5843b28a87774a2606"><a href="#levelrenderercamera-render-l51-lambda-98cf3401a20e8e5843b28a87774a2606" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l51::&lt;lambda_98cf3401a20e8e5843b28a87774a2606&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l51::&lt;lambda_98cf3401a20e8e5843b28a87774a2606&gt;
{
  LevelRendererCamera *const __this;
  BaseActorRenderContext *baseEntityRenderContext;
};

</code></pre></div><h3 id="levelrenderercamera-render-l44-lambda-3a2cf6803c057b1f0eedb96b6c8e35ae"><a href="#levelrenderercamera-render-l44-lambda-3a2cf6803c057b1f0eedb96b6c8e35ae" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l44::&lt;lambda_3a2cf6803c057b1f0eedb96b6c8e35ae&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l44::&lt;lambda_3a2cf6803c057b1f0eedb96b6c8e35ae&gt;
{
  LevelRendererCamera *const __this;
  ScreenContext *screenContext;
};

</code></pre></div><h3 id="levelrenderercamera-render-l41-lambda-67ec6388db038753bb187b676b98ee9d"><a href="#levelrenderercamera-render-l41-lambda-67ec6388db038753bb187b676b98ee9d" class="header-anchor">#</a> <code>LevelRendererCamera::render::__l41::&lt;lambda_67ec6388db038753bb187b676b98ee9d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::render::__l41::&lt;lambda_67ec6388db038753bb187b676b98ee9d&gt;
{
  LevelRendererCamera *const __this;
  BaseActorRenderContext *baseEntityRenderContext;
  IClientInstance *ci;
  const ViewRenderObject *renderObj;
};

</code></pre></div><h3 id="levelrenderercamera-updateperchunkfacesortstate-l10-lambda-ad3c5498b074c18dbed9687ee13fd757"><a href="#levelrenderercamera-updateperchunkfacesortstate-l10-lambda-ad3c5498b074c18dbed9687ee13fd757" class="header-anchor">#</a> <code>LevelRendererCamera::updatePerChunkFaceSortState::__l10::&lt;lambda_ad3c5498b074c18dbed9687ee13fd757&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::updatePerChunkFaceSortState::__l10::&lt;lambda_ad3c5498b074c18dbed9687ee13fd757&gt;
{
  std::shared_ptr&lt;GridArea&lt;std::shared_ptr&lt;RenderChunkInstanced&gt; &gt; &gt; bufferedarea;
};

</code></pre></div><h3 id="levelrenderercamera-updateviewarea-l15-lambda-9e7cacf76a280e28aa6f2804db39f29f"><a href="#levelrenderercamera-updateviewarea-l15-lambda-9e7cacf76a280e28aa6f2804db39f29f" class="header-anchor">#</a> <code>LevelRendererCamera::updateViewArea::__l15::&lt;lambda_9e7cacf76a280e28aa6f2804db39f29f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LevelRendererCamera::updateViewArea::__l15::&lt;lambda_9e7cacf76a280e28aa6f2804db39f29f&gt;
{
  LevelRendererCamera *const __this;
  bool isOrthoCamera;
  const Vec3 cameraPos;
  const Vec3 cameraForward;
};

</code></pre></div><h3 id="levelrenderercamera-tickclouds-l16-lambda-c498a643277d80fd7defa07ea47ad7b1"><a href="#levelrenderercamera-tickclouds-l16-lambda-c498a643277d80fd7defa07ea47ad7b1" class="header-anchor">#</a> <code>LevelRendererCamera::tickClouds::__l16::&lt;lambda_c498a643277d80fd7defa07ea47ad7b1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) LevelRendererCamera::tickClouds::__l16::&lt;lambda_c498a643277d80fd7defa07ea47ad7b1&gt;
{
  LevelRendererCamera *const __this;
  const Vec3 cloudCenterPos;
  unsigned __int8 cloudSide;
};

</code></pre></div><h3 id="levelrenderercamera-tickclouds-l16-lambda-0fcd12c8aea96aebe4424114849d6276"><a href="#levelrenderercamera-tickclouds-l16-lambda-0fcd12c8aea96aebe4424114849d6276" class="header-anchor">#</a> <code>LevelRendererCamera::tickClouds::__l16::&lt;lambda_0fcd12c8aea96aebe4424114849d6276&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) LevelRendererCamera::tickClouds::__l16::&lt;lambda_0fcd12c8aea96aebe4424114849d6276&gt;
{
  LevelRendererCamera *const __this;
  std::weak_ptr&lt;cg::ImageBuffer&gt; weakCloudsImage;
  const Vec3 cloudCenterPos;
  unsigned __int8 cloudSide;
  const bool tessellateBothSides;
};

</code></pre></div><h3 id="levelrenderercamera-ctor-l2-lambda-2b79d398d8ef1477337b0f5b1b355659"><a href="#levelrenderercamera-ctor-l2-lambda-2b79d398d8ef1477337b0f5b1b355659" class="header-anchor">#</a> <code>LevelRendererCamera::{ctor}::__l2::&lt;lambda_2b79d398d8ef1477337b0f5b1b355659&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::{ctor}::__l2::&lt;lambda_2b79d398d8ef1477337b0f5b1b355659&gt;
{
  LevelRendererCamera *const __this;
};

</code></pre></div><h3 id="levelrenderer-initpipelinetessellatorresources-l2-lambda-9b5a046e70bef75fe559e6f2f6d097f3"><a href="#levelrenderer-initpipelinetessellatorresources-l2-lambda-9b5a046e70bef75fe559e6f2f6d097f3" class="header-anchor">#</a> <code>LevelRenderer::_initPipelineTessellatorResources::__l2::&lt;lambda_9b5a046e70bef75fe559e6f2f6d097f3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRenderer::_initPipelineTessellatorResources::__l2::&lt;lambda_9b5a046e70bef75fe559e6f2f6d097f3&gt;
{
  EntityRegistryOwned *registry;
};

</code></pre></div><h3 id="levelrenderer-frameupdate-l2-lambda-f701b1f8a7c0d93b2005ab7edabc9284"><a href="#levelrenderer-frameupdate-l2-lambda-f701b1f8a7c0d93b2005ab7edabc9284" class="header-anchor">#</a> <code>LevelRenderer::frameUpdate::__l2::&lt;lambda_f701b1f8a7c0d93b2005ab7edabc9284&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRenderer::frameUpdate::__l2::&lt;lambda_f701b1f8a7c0d93b2005ab7edabc9284&gt;
{
  Tessellator *tessellator;
};

</code></pre></div><h3 id="levelrenderer-frameupdate-l2-lambda-335d2fb1dc9014b3677a9cffb46c1dff"><a href="#levelrenderer-frameupdate-l2-lambda-335d2fb1dc9014b3677a9cffb46c1dff" class="header-anchor">#</a> <code>LevelRenderer::frameUpdate::__l2::&lt;lambda_335d2fb1dc9014b3677a9cffb46c1dff&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRenderer::frameUpdate::__l2::&lt;lambda_335d2fb1dc9014b3677a9cffb46c1dff&gt;
{
  Tessellator *tessellator;
};

</code></pre></div><h3 id="levelrenderer-frameupdate-l2-lambda-1b526a2d8548c21b383a97342d5ad487"><a href="#levelrenderer-frameupdate-l2-lambda-1b526a2d8548c21b383a97342d5ad487" class="header-anchor">#</a> <code>LevelRenderer::frameUpdate::__l2::&lt;lambda_1b526a2d8548c21b383a97342d5ad487&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRenderer::frameUpdate::__l2::&lt;lambda_1b526a2d8548c21b383a97342d5ad487&gt;
{
  Tessellator *tessellator;
};

</code></pre></div><h3 id="levelrenderer-frameupdate-l12-lambda-9fcbb6855f88afb816127fda2a20d74b"><a href="#levelrenderer-frameupdate-l12-lambda-9fcbb6855f88afb816127fda2a20d74b" class="header-anchor">#</a> <code>LevelRenderer::frameUpdate::__l12::&lt;lambda_9fcbb6855f88afb816127fda2a20d74b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LevelRenderer::frameUpdate::__l12::&lt;lambda_9fcbb6855f88afb816127fda2a20d74b&gt;
{
  Tessellator *tessellator;
  int i;
};

</code></pre></div><h3 id="levelrenderer-frameupdate-l7-lambda-ea844ceccd1de22890beb07c0e8397bd"><a href="#levelrenderer-frameupdate-l7-lambda-ea844ceccd1de22890beb07c0e8397bd" class="header-anchor">#</a> <code>LevelRenderer::frameUpdate::__l7::&lt;lambda_ea844ceccd1de22890beb07c0e8397bd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRenderer::frameUpdate::__l7::&lt;lambda_ea844ceccd1de22890beb07c0e8397bd&gt;
{
  Tessellator *tessellator;
};

</code></pre></div><h3 id="levelrenderer-frameupdate-l4-lambda-f01a01cf11ce104a02ae2020719b2211"><a href="#levelrenderer-frameupdate-l4-lambda-f01a01cf11ce104a02ae2020719b2211" class="header-anchor">#</a> <code>LevelRenderer::frameUpdate::__l4::&lt;lambda_f01a01cf11ce104a02ae2020719b2211&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LevelRenderer::frameUpdate::__l4::&lt;lambda_f01a01cf11ce104a02ae2020719b2211&gt;
{
  Tessellator *tessellator;
  int i;
};

</code></pre></div><h3 id="levelrenderer-frameupdate-l2-lambda-758885b258945a6ca5117dcdf942ff98"><a href="#levelrenderer-frameupdate-l2-lambda-758885b258945a6ca5117dcdf942ff98" class="header-anchor">#</a> <code>LevelRenderer::frameUpdate::__l2::&lt;lambda_758885b258945a6ca5117dcdf942ff98&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRenderer::frameUpdate::__l2::&lt;lambda_758885b258945a6ca5117dcdf942ff98&gt;
{
  Tessellator *tessellator;
};

</code></pre></div><h3 id="levelrenderer-frameupdate-l2-lambda-0a9ac793f429e4a5f673b4e4d4c70978"><a href="#levelrenderer-frameupdate-l2-lambda-0a9ac793f429e4a5f673b4e4d4c70978" class="header-anchor">#</a> <code>LevelRenderer::frameUpdate::__l2::&lt;lambda_0a9ac793f429e4a5f673b4e4d4c70978&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRenderer::frameUpdate::__l2::&lt;lambda_0a9ac793f429e4a5f673b4e4d4c70978&gt;
{
  Tessellator *tessellator;
};

</code></pre></div><h3 id="levelrenderer-frameupdate-l2-lambda-71f033f9b3e4d327aca2e59532492b67"><a href="#levelrenderer-frameupdate-l2-lambda-71f033f9b3e4d327aca2e59532492b67" class="header-anchor">#</a> <code>LevelRenderer::frameUpdate::__l2::&lt;lambda_71f033f9b3e4d327aca2e59532492b67&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRenderer::frameUpdate::__l2::&lt;lambda_71f033f9b3e4d327aca2e59532492b67&gt;
{
  Tessellator *tessellator;
};

</code></pre></div><h3 id="levelrenderer-frameupdate-l2-lambda-acf188f954ccaf27d95c5bbd57ac08c6"><a href="#levelrenderer-frameupdate-l2-lambda-acf188f954ccaf27d95c5bbd57ac08c6" class="header-anchor">#</a> <code>LevelRenderer::frameUpdate::__l2::&lt;lambda_acf188f954ccaf27d95c5bbd57ac08c6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRenderer::frameUpdate::__l2::&lt;lambda_acf188f954ccaf27d95c5bbd57ac08c6&gt;
{
  ClientFrameUpdateContext *clientFrameUpdateContext;
};

</code></pre></div><h3 id="levelrenderer-ctor-l2-lambda-85bf7fc9e6a1eeb9e971efa9bf3ba2ca"><a href="#levelrenderer-ctor-l2-lambda-85bf7fc9e6a1eeb9e971efa9bf3ba2ca" class="header-anchor">#</a> <code>LevelRenderer::{ctor}::__l2::&lt;lambda_85bf7fc9e6a1eeb9e971efa9bf3ba2ca&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRenderer::{ctor}::__l2::&lt;lambda_85bf7fc9e6a1eeb9e971efa9bf3ba2ca&gt;
{
  LevelRenderer *const __this;
};

</code></pre></div><h3 id="levelrenderer-ctor-l2-lambda-f4d845fc283e1eef5eaad1dddf1583e3"><a href="#levelrenderer-ctor-l2-lambda-f4d845fc283e1eef5eaad1dddf1583e3" class="header-anchor">#</a> <code>LevelRenderer::{ctor}::__l2::&lt;lambda_f4d845fc283e1eef5eaad1dddf1583e3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRenderer::{ctor}::__l2::&lt;lambda_f4d845fc283e1eef5eaad1dddf1583e3&gt;
{
  LevelRenderer *const __this;
};

</code></pre></div><h3 id="levelrenderer-ctor-l2-lambda-1c42f68ee32956de6883e2d635c9f079"><a href="#levelrenderer-ctor-l2-lambda-1c42f68ee32956de6883e2d635c9f079" class="header-anchor">#</a> <code>LevelRenderer::{ctor}::__l2::&lt;lambda_1c42f68ee32956de6883e2d635c9f079&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRenderer::{ctor}::__l2::&lt;lambda_1c42f68ee32956de6883e2d635c9f079&gt;
{
  LevelRenderer *const __this;
};

</code></pre></div><h3 id="levelcullersunshadow-handlecullingdutiesthisupdate-l5-lambda-16329a48841731d4df3946d7f44c0fbf"><a href="#levelcullersunshadow-handlecullingdutiesthisupdate-l5-lambda-16329a48841731d4df3946d7f44c0fbf" class="header-anchor">#</a> <code>LevelCullerSunShadow::handleCullingDutiesThisUpdate::__l5::&lt;lambda_16329a48841731d4df3946d7f44c0fbf&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelCullerSunShadow::handleCullingDutiesThisUpdate::__l5::&lt;lambda_16329a48841731d4df3946d7f44c0fbf&gt;
{
  LevelCullerSunShadow *const __this;
  LevelRendererCamera *levelRendererCamera;
};

</code></pre></div><h3 id="levelcullerdistancefield-handlecullingdutiesthisupdate-l5-lambda-fde9076c36ef6dc7b65d1999d984afcb"><a href="#levelcullerdistancefield-handlecullingdutiesthisupdate-l5-lambda-fde9076c36ef6dc7b65d1999d984afcb" class="header-anchor">#</a> <code>LevelCullerDistanceField::handleCullingDutiesThisUpdate::__l5::&lt;lambda_fde9076c36ef6dc7b65d1999d984afcb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelCullerDistanceField::handleCullingDutiesThisUpdate::__l5::&lt;lambda_fde9076c36ef6dc7b65d1999d984afcb&gt;
{
  std::weak_ptr&lt;LevelCullerDistanceField&gt; weakThis;
  LevelRendererCamera *levelRendererCamera;
};

</code></pre></div><h3 id="levelrenderercamera-setupviewarea-l2-lambda-d53e0703952e2c097317ba99365db65e"><a href="#levelrenderercamera-setupviewarea-l2-lambda-d53e0703952e2c097317ba99365db65e" class="header-anchor">#</a> <code>LevelRendererCamera::setupViewArea::__l2::&lt;lambda_d53e0703952e2c097317ba99365db65e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelRendererCamera::setupViewArea::__l2::&lt;lambda_d53e0703952e2c097317ba99365db65e&gt;
{
  LevelRendererCamera *const __this;
};

</code></pre></div><h3 id="lessonactionrequest"><a href="#lessonactionrequest" class="header-anchor">#</a> <code>LessonActionRequest</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LessonActionRequest : RequestHandler
{
  const LessonProgressionService *mService;
  const std::string mHostUrl;
  LessonInfo mLessonInfo;
  LessonActionData mRequestData;
  std::function&lt;void __cdecl(bool,std::string const &amp;)&gt; mResponseCallback;
  std::string mStatus;
  bool mSuccess;
};

</code></pre></div><h3 id="lessonactionrequest-vtbl"><a href="#lessonactionrequest-vtbl" class="header-anchor">#</a> <code>LessonActionRequest_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LessonActionRequest_vtbl
{
  void (__fastcall *~RequestHandler)(RequestHandler *this);
  void (__fastcall *send)(RequestHandler *this);
  void (__fastcall *sendCachedRequest)(RequestHandler *this);
  bool (__fastcall *update)(RequestHandler *this);
  bool (__fastcall *isDone)(RequestHandler *this);
  void (__fastcall *onComplete)(RequestHandler *this);
  bool (__fastcall *canSendRequest)(RequestHandler *this);
  void (__fastcall *fireTelemetry)(RequestHandler *this, IMinecraftEventing *);
};

</code></pre></div><h3 id="lessonstatusrequest"><a href="#lessonstatusrequest" class="header-anchor">#</a> <code>LessonStatusRequest</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LessonStatusRequest : RequestHandler
{
  const LessonProgressionService *mService;
  const std::string mHostUrl;
  LessonInfo mLessonInfo;
  std::function&lt;void __cdecl(bool,enum CompletionState::Value,std::optional&lt;std::string &gt;)&gt; mResponseCallback;
  std::string mStatus;
  bool mSuccess;
  CompletionState::Value mLessonState;
  std::optional&lt;std::string &gt; mQuizUrl;
};

</code></pre></div><h3 id="lessonstatusrequest-vtbl"><a href="#lessonstatusrequest-vtbl" class="header-anchor">#</a> <code>LessonStatusRequest_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LessonStatusRequest_vtbl
{
  void (__fastcall *~RequestHandler)(RequestHandler *this);
  void (__fastcall *send)(RequestHandler *this);
  void (__fastcall *sendCachedRequest)(RequestHandler *this);
  bool (__fastcall *update)(RequestHandler *this);
  bool (__fastcall *isDone)(RequestHandler *this);
  void (__fastcall *onComplete)(RequestHandler *this);
  bool (__fastcall *canSendRequest)(RequestHandler *this);
  void (__fastcall *fireTelemetry)(RequestHandler *this, IMinecraftEventing *);
};

</code></pre></div><h3 id="librarysearchrequest-cachemetadata"><a href="#librarysearchrequest-cachemetadata" class="header-anchor">#</a> <code>LibrarySearchRequest::CacheMetadata</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibrarySearchRequest::CacheMetadata
{
  std::string mCacheWriteDate;
  std::string mAcceptLanguage;
  std::string mRequestedBy;
  std::string mClientVersion;
};

</code></pre></div><h3 id="librarysearchrequest"><a href="#librarysearchrequest" class="header-anchor">#</a> <code>LibrarySearchRequest</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibrarySearchRequest : CachedRequest
{
  gsl::not_null&lt;Bedrock::NonOwnerPointer&lt;DateManager const &gt; &gt; mDateManager;
  const std::string mHostUrl;
  const std::string mAcceptLanguage;
  const std::string mDateCreated;
  LibrarySearchQuery mQuery;
  std::string mGetQuery;
  std::function&lt;void __cdecl(std::vector&lt;std::shared_ptr&lt;LibraryItem&gt;&gt; &amp;,std::vector&lt;std::string&gt; &amp;,bool)&gt; mResponseCallback;
  LibrarySearchRequest::CacheMetadata mCacheMetadata;
  unsigned int mCacheMaxAgeHours;
  std::vector&lt;std::shared_ptr&lt;LibraryItem&gt;&gt; mResults;
  std::vector&lt;std::string&gt; mBadProductIds;
  bool mHasMorePages;
  std::string mCorrelationVector;
};

</code></pre></div><h3 id="librarysearchrequest-vtbl"><a href="#librarysearchrequest-vtbl" class="header-anchor">#</a> <code>LibrarySearchRequest_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LibrarySearchRequest_vtbl
{
  void (__fastcall *~RequestHandler)(RequestHandler *this);
  void (__fastcall *send)(RequestHandler *this);
  void (__fastcall *sendCachedRequest)(RequestHandler *this);
  bool (__fastcall *update)(RequestHandler *this);
  bool (__fastcall *isDone)(RequestHandler *this);
  void (__fastcall *onComplete)(RequestHandler *this);
  bool (__fastcall *canSendRequest)(RequestHandler *this);
  void (__fastcall *fireTelemetry)(RequestHandler *this, IMinecraftEventing *);
};

</code></pre></div><h3 id="libraryimagerequest"><a href="#libraryimagerequest" class="header-anchor">#</a> <code>LibraryImageRequest</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LibraryImageRequest : FileDataRequest
{
};

</code></pre></div><h3 id="libraryimagerequest-vtbl"><a href="#libraryimagerequest-vtbl" class="header-anchor">#</a> <code>LibraryImageRequest_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LibraryImageRequest_vtbl
{
  void (__fastcall *~RequestHandler)(RequestHandler *this);
  void (__fastcall *send)(RequestHandler *this);
  void (__fastcall *sendCachedRequest)(RequestHandler *this);
  bool (__fastcall *update)(RequestHandler *this);
  bool (__fastcall *isDone)(RequestHandler *this);
  void (__fastcall *onComplete)(RequestHandler *this);
  bool (__fastcall *canSendRequest)(RequestHandler *this);
  void (__fastcall *fireTelemetry)(RequestHandler *this, IMinecraftEventing *);
};

</code></pre></div><h3 id="lodestoneblock"><a href="#lodestoneblock" class="header-anchor">#</a> <code>LodestoneBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LodestoneBlock : ActorBlock
{
};

</code></pre></div><h3 id="lodestoneblock-vtbl"><a href="#lodestoneblock-vtbl" class="header-anchor">#</a> <code>LodestoneBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LodestoneBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
};

</code></pre></div><h3 id="layerdetails-storage"><a href="#layerdetails-storage" class="header-anchor">#</a> <code>LayerDetails::Storage</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayerDetails::Storage
{
  unsigned __int64 mReadableBytes;
  unsigned __int64 mWriteableBytes;
  std::unique_ptr&lt;char [0]&gt; mReadStorage;
  std::unique_ptr&lt;char [0]&gt; mWriteStorage;
};

</code></pre></div><h3 id="layerdetails-layerbase-vtbl"><a href="#layerdetails-layerbase-vtbl" class="header-anchor">#</a> <code>LayerDetails::LayerBase_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LayerDetails::LayerBase_vtbl
{
  void (__fastcall *~LayerBase)(LayerDetails::LayerBase *this);
  void (__fastcall *init)(LayerDetails::LayerBase *this, __int64);
};

</code></pre></div><h3 id="layerdetails-transferdata-float"><a href="#layerdetails-transferdata-float" class="header-anchor">#</a> <code>LayerDetails::TransferData&lt;float&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayerDetails::TransferData&lt;float&gt; : LayerDetails::Storage
{
};

</code></pre></div><h3 id="layer-float"><a href="#layer-float" class="header-anchor">#</a> <code>Layer&lt;float&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Layer&lt;float&gt; : LayerDetails::LayerBase
{
};

</code></pre></div><h3 id="layer-float-vtbl"><a href="#layer-float-vtbl" class="header-anchor">#</a> <code>Layer&lt;float&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Layer&lt;float&gt;_vtbl
{
  void (__fastcall *~LayerBase)(LayerDetails::LayerBase *this);
  void (__fastcall *init)(LayerDetails::LayerBase *this, __int64);
  LayerDetails::TransferData&lt;float&gt; *(__fastcall *_allocateAndFill)(Layer&lt;float&gt; *this, LayerDetails::TransferData&lt;float&gt; *result, unsigned __int64, int, int, unsigned int, unsigned int);
};

</code></pre></div><h3 id="layerdetails-bufferaccessor-char"><a href="#layerdetails-bufferaccessor-char" class="header-anchor">#</a> <code>LayerDetails::BufferAccessor&lt;char&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj LayerDetails::BufferAccessor&lt;char&gt;
{
  char *mStorage;
  unsigned __int64 mCount;
};

</code></pre></div><h3 id="layerdetails-bufferaccessor-float"><a href="#layerdetails-bufferaccessor-float" class="header-anchor">#</a> <code>LayerDetails::BufferAccessor&lt;float&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayerDetails::BufferAccessor&lt;float&gt;
{
  char *mStorage;
  unsigned __int64 mCount;
};

</code></pre></div><h3 id="layerdetails-workingdata-float-char"><a href="#layerdetails-workingdata-float-char" class="header-anchor">#</a> <code>LayerDetails::WorkingData&lt;float,char&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayerDetails::WorkingData&lt;float,char&gt; : LayerDetails::Storage
{
  const LayerDetails::BufferAccessor&lt;char&gt; mParentArea;
  LayerDetails::BufferAccessor&lt;float&gt; mResult;
};

</code></pre></div><h3 id="layerdetails-transferdata-char"><a href="#layerdetails-transferdata-char" class="header-anchor">#</a> <code>LayerDetails::TransferData&lt;char&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayerDetails::TransferData&lt;char&gt; : LayerDetails::Storage
{
};

</code></pre></div><h3 id="layerdetails-bufferaccessor-float-typedbits"><a href="#layerdetails-bufferaccessor-float-typedbits" class="header-anchor">#</a> <code>LayerDetails::BufferAccessor&lt;float&gt;::TypedBits</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayerDetails::BufferAccessor&lt;float&gt;::TypedBits
{
  char *mLocation;
};

</code></pre></div><h3 id="loottablecontext-builder"><a href="#loottablecontext-builder" class="header-anchor">#</a> <code>LootTableContext::Builder</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LootTableContext::Builder
{
  Level *mLevel;
  BlockSource *mRegion;
  float mLuck;
  Actor *mThisEntity;
  Player *mKillerPlayer;
  const ActorDamageSource *mDeathSource;
  float mExplosionRadius;
  std::string mOriginalItemName;
};

</code></pre></div><h3 id="leashabledefinition"><a href="#leashabledefinition" class="header-anchor">#</a> <code>LeashableDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LeashableDefinition
{
  float mSoftDistance;
  float mHardDistance;
  float mMaxDistance;
  DefinitionTrigger mOnLeash;
  DefinitionTrigger mOnUnleash;
  bool mCanBeStolen;
};

</code></pre></div><h3 id="leashablecomponent"><a href="#leashablecomponent" class="header-anchor">#</a> <code>LeashableComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LeashableComponent : IEntityComponent
{
};

</code></pre></div><h3 id="legacytradeabledefinition"><a href="#legacytradeabledefinition" class="header-anchor">#</a> <code>LegacyTradeableDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LegacyTradeableDefinition
{
  std::string mDisplayName;
  std::string mTradeTablePath;
  bool mUseNewTradeScreen;
  bool mPersistTrades;
  bool mConvertTradesEconomy;
};

</code></pre></div><h3 id="lookatcomponent"><a href="#lookatcomponent" class="header-anchor">#</a> <code>LookAtComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LookAtComponent : IEntityComponent
{
  bool mSetTarget;
  float mSearchRadius;
  bool mAllowInvulnerable;
  int mCoolingTime;
};

</code></pre></div><h3 id="lookcontrol"><a href="#lookcontrol" class="header-anchor">#</a> <code>LookControl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LookControl : Control
{
};

</code></pre></div><h3 id="lookcontrol-vtbl"><a href="#lookcontrol-vtbl" class="header-anchor">#</a> <code>LookControl_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LookControl_vtbl
{
  void (__fastcall *~Control)(Control *this);
  void (__fastcall *initializeInternal)(LookControl *this, Mob *);
  void (__fastcall *tick)(LookControl *this, Mob *);
};

</code></pre></div><h3 id="legacytradeablecomponent-getinteraction-l17-lambda-92c5888b87b9a838aa19e047a1eced20"><a href="#legacytradeablecomponent-getinteraction-l17-lambda-92c5888b87b9a838aa19e047a1eced20" class="header-anchor">#</a> <code>LegacyTradeableComponent::getInteraction::__l17::&lt;lambda_92c5888b87b9a838aa19e047a1eced20&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LegacyTradeableComponent::getInteraction::__l17::&lt;lambda_92c5888b87b9a838aa19e047a1eced20&gt;
{
  Player *player;
  Actor *owner;
  const bool useNewTradeScreen;
};

</code></pre></div><h3 id="leashablecomponent-getinteraction-l22-lambda-702674731951615cfb31cf33ab54eea3"><a href="#leashablecomponent-getinteraction-l22-lambda-702674731951615cfb31cf33ab54eea3" class="header-anchor">#</a> <code>LeashableComponent::getInteraction::__l22::&lt;lambda_702674731951615cfb31cf33ab54eea3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LeashableComponent::getInteraction::__l22::&lt;lambda_702674731951615cfb31cf33ab54eea3&gt;
{
  Actor *owner;
  Player *player;
  LeashableComponent *const __this;
};

</code></pre></div><h3 id="leashablecomponent-getinteraction-l11-lambda-bfec5b7a45ae662edfa6da94275f0ae2"><a href="#leashablecomponent-getinteraction-l11-lambda-bfec5b7a45ae662edfa6da94275f0ae2" class="header-anchor">#</a> <code>LeashableComponent::getInteraction::__l11::&lt;lambda_bfec5b7a45ae662edfa6da94275f0ae2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LeashableComponent::getInteraction::__l11::&lt;lambda_bfec5b7a45ae662edfa6da94275f0ae2&gt;
{
  Actor *owner;
  LeashableComponent *const __this;
};

</code></pre></div><h3 id="leashabledefinition-buildschema-l2-lambda-3ad7096af803fcc3f75cab3f5e6e033d"><a href="#leashabledefinition-buildschema-l2-lambda-3ad7096af803fcc3f75cab3f5e6e033d" class="header-anchor">#</a> <code>LeashableDefinition::buildSchema::__l2::&lt;lambda_3ad7096af803fcc3f75cab3f5e6e033d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LeashableDefinition::buildSchema::__l2::&lt;lambda_3ad7096af803fcc3f75cab3f5e6e033d&gt;
{
};

</code></pre></div><h3 id="lookatposgoal"><a href="#lookatposgoal" class="header-anchor">#</a> <code>LookAtPosGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LookAtPosGoal : Goal
{
  BlockPos mLookAt;
  bool mIsLooking;
  bool mRejectOther;
  int mAngleOfViewX;
  int mAngleOfViewY;
  int mLookTime;
  int mMinLookTime;
  int mMaxLookTime;
  float mProbability;
  Mob *mMob;
};

</code></pre></div><h3 id="lookatposgoal-vtbl"><a href="#lookatposgoal-vtbl" class="header-anchor">#</a> <code>LookAtPosGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LookAtPosGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="lookatsystem"><a href="#lookatsystem" class="header-anchor">#</a> <code>LookAtSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LookAtSystem : ITickingSystem
{
};

</code></pre></div><h3 id="lookatsystem-vtbl"><a href="#lookatsystem-vtbl" class="header-anchor">#</a> <code>LookAtSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LookAtSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="lookcontrolsystem"><a href="#lookcontrolsystem" class="header-anchor">#</a> <code>LookControlSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LookControlSystem : ITickingSystem
{
};

</code></pre></div><h3 id="lookcontrolsystem-vtbl"><a href="#lookcontrolsystem-vtbl" class="header-anchor">#</a> <code>LookControlSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LookControlSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="leveldbsequentialfile"><a href="#leveldbsequentialfile" class="header-anchor">#</a> <code>LevelDbSequentialFile</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelDbSequentialFile : leveldb::SequentialFile
{
  Core::File mFile;
};

</code></pre></div><h3 id="leveldbsequentialfile-vtbl"><a href="#leveldbsequentialfile-vtbl" class="header-anchor">#</a> <code>LevelDbSequentialFile_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelDbSequentialFile_vtbl
{
  void (__fastcall *~SequentialFile)(leveldb::SequentialFile *this);
  leveldb::Status *(__fastcall *Read)(leveldb::SequentialFile *this, leveldb::Status *result, unsigned __int64, leveldb::Slice *, char *);
  leveldb::Status *(__fastcall *Skip)(leveldb::SequentialFile *this, leveldb::Status *result, unsigned __int64);
};

</code></pre></div><h3 id="leveldbrandomaccessfile"><a href="#leveldbrandomaccessfile" class="header-anchor">#</a> <code>LevelDbRandomAccessFile</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelDbRandomAccessFile : leveldb::RandomAccessFile
{
  Core::File mFile;
  std::mutex mMutex;
};

</code></pre></div><h3 id="leveldbrandomaccessfile-vtbl"><a href="#leveldbrandomaccessfile-vtbl" class="header-anchor">#</a> <code>LevelDbRandomAccessFile_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelDbRandomAccessFile_vtbl
{
  void (__fastcall *~RandomAccessFile)(leveldb::RandomAccessFile *this);
  leveldb::Status *(__fastcall *Read)(leveldb::RandomAccessFile *this, leveldb::Status *result, unsigned __int64, unsigned __int64, leveldb::Slice *, char *);
};

</code></pre></div><h3 id="leveldbwritablefile"><a href="#leveldbwritablefile" class="header-anchor">#</a> <code>LevelDbWritableFile</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelDbWritableFile : leveldb::WritableFile
{
  Core::File mFile;
  std::string mFilenameHackForManifestSync;
};

</code></pre></div><h3 id="leveldbwritablefile-vtbl"><a href="#leveldbwritablefile-vtbl" class="header-anchor">#</a> <code>LevelDbWritableFile_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelDbWritableFile_vtbl
{
  void (__fastcall *~WritableFile)(leveldb::WritableFile *this);
  leveldb::Status *(__fastcall *Append)(leveldb::WritableFile *this, leveldb::Status *result, const leveldb::Slice *);
  leveldb::Status *(__fastcall *Close)(leveldb::WritableFile *this, leveldb::Status *result);
  leveldb::Status *(__fastcall *Flush)(leveldb::WritableFile *this, leveldb::Status *result);
  leveldb::Status *(__fastcall *Sync)(leveldb::WritableFile *this, leveldb::Status *result);
};

</code></pre></div><h3 id="leveldbfilelock"><a href="#leveldbfilelock" class="header-anchor">#</a> <code>LevelDbFileLock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelDbFileLock : leveldb::FileLock
{
};

</code></pre></div><h3 id="leveldbfilelock-vtbl"><a href="#leveldbfilelock-vtbl" class="header-anchor">#</a> <code>LevelDbFileLock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelDbFileLock_vtbl
{
  void (__fastcall *~FileLock)(leveldb::FileLock *this);
};

</code></pre></div><h3 id="leveldblogger"><a href="#leveldblogger" class="header-anchor">#</a> <code>LevelDbLogger</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelDbLogger : leveldb::Logger
{
};

</code></pre></div><h3 id="leveldblogger-vtbl"><a href="#leveldblogger-vtbl" class="header-anchor">#</a> <code>LevelDbLogger_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelDbLogger_vtbl
{
  void (__fastcall *~Logger)(leveldb::Logger *this);
  void (__fastcall *Logv)(leveldb::Logger *this, const char *, char *);
};

</code></pre></div><h3 id="leveldbenv-schedule-l2-lambda-f49969aee8341d0263f8b75ad776edc4"><a href="#leveldbenv-schedule-l2-lambda-f49969aee8341d0263f8b75ad776edc4" class="header-anchor">#</a> <code>LevelDbEnv::Schedule::__l2::&lt;lambda_f49969aee8341d0263f8b75ad776edc4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelDbEnv::Schedule::__l2::&lt;lambda_f49969aee8341d0263f8b75ad776edc4&gt;
{
  void (__fastcall *function)(void *);
  void *arg;
};

</code></pre></div><h3 id="leveldb-zlibcompressorbase-vtbl"><a href="#leveldb-zlibcompressorbase-vtbl" class="header-anchor">#</a> <code>leveldb::ZlibCompressorBase_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ leveldb::ZlibCompressorBase_vtbl
{
  void (__fastcall *~Compressor)(leveldb::Compressor *this);
  void (__fastcall *compressImpl)(leveldb::Compressor *this, const char *, unsigned __int64, std::string *);
  bool (__fastcall *decompress)(leveldb::Compressor *this, const char *, unsigned __int64, std::string *);
};

</code></pre></div><h3 id="leveldb-zlibcompressor"><a href="#leveldb-zlibcompressor" class="header-anchor">#</a> <code>leveldb::ZlibCompressor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj leveldb::ZlibCompressor : leveldb::ZlibCompressorBase
{
};

</code></pre></div><h3 id="leveldb-zlibcompressor-vtbl"><a href="#leveldb-zlibcompressor-vtbl" class="header-anchor">#</a> <code>leveldb::ZlibCompressor_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ leveldb::ZlibCompressor_vtbl
{
  void (__fastcall *~Compressor)(leveldb::Compressor *this);
  void (__fastcall *compressImpl)(leveldb::Compressor *this, const char *, unsigned __int64, std::string *);
  bool (__fastcall *decompress)(leveldb::Compressor *this, const char *, unsigned __int64, std::string *);
};

</code></pre></div><h3 id="leveldb-zlibcompressorraw"><a href="#leveldb-zlibcompressorraw" class="header-anchor">#</a> <code>leveldb::ZlibCompressorRaw</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj leveldb::ZlibCompressorRaw : leveldb::ZlibCompressorBase
{
};

</code></pre></div><h3 id="leveldb-zlibcompressorraw-vtbl"><a href="#leveldb-zlibcompressorraw-vtbl" class="header-anchor">#</a> <code>leveldb::ZlibCompressorRaw_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ leveldb::ZlibCompressorRaw_vtbl
{
  void (__fastcall *~Compressor)(leveldb::Compressor *this);
  void (__fastcall *compressImpl)(leveldb::Compressor *this, const char *, unsigned __int64, std::string *);
  bool (__fastcall *decompress)(leveldb::Compressor *this, const char *, unsigned __int64, std::string *);
};

</code></pre></div><h3 id="localconnector-onremotedisconnected-l5-lambda-f93dfeaa3e76b9e290819e2fab7d0ef9"><a href="#localconnector-onremotedisconnected-l5-lambda-f93dfeaa3e76b9e290819e2fab7d0ef9" class="header-anchor">#</a> <code>LocalConnector::onRemoteDisconnected::__l5::&lt;lambda_f93dfeaa3e76b9e290819e2fab7d0ef9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LocalConnector::onRemoteDisconnected::__l5::&lt;lambda_f93dfeaa3e76b9e290819e2fab7d0ef9&gt;
{
  NetworkIdentifier otherId;
  LocalConnector *const __this;
};

</code></pre></div><h3 id="listcommand"><a href="#listcommand" class="header-anchor">#</a> <code>ListCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ListCommand : ServerCommand
{
};

</code></pre></div><h3 id="listcommand-vtbl"><a href="#listcommand-vtbl" class="header-anchor">#</a> <code>ListCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ListCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="listdcommand"><a href="#listdcommand" class="header-anchor">#</a> <code>ListDCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ListDCommand : ServerCommand
{
  _BYTE mDetails[4];
};

</code></pre></div><h3 id="listdcommand-vtbl"><a href="#listdcommand-vtbl" class="header-anchor">#</a> <code>ListDCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ListDCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="locatecommand"><a href="#locatecommand" class="header-anchor">#</a> <code>LocateCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LocateCommand : Command
{
  StructureFeatureType mFeature;
};

</code></pre></div><h3 id="locatecommand-vtbl"><a href="#locatecommand-vtbl" class="header-anchor">#</a> <code>LocateCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LocateCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="listcommand-execute-l15-lambda-0d606404f3730d0f1e0a107965271e32"><a href="#listcommand-execute-l15-lambda-0d606404f3730d0f1e0a107965271e32" class="header-anchor">#</a> <code>ListCommand::execute::__l15::&lt;lambda_0d606404f3730d0f1e0a107965271e32&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ListCommand::execute::__l15::&lt;lambda_0d606404f3730d0f1e0a107965271e32&gt;
{
  std::vector&lt;Player const *&gt; *players;
};

</code></pre></div><h3 id="listcommand-execute-l13-lambda-2e7f0392e569b6bdc30e6bc9305fa0a4"><a href="#listcommand-execute-l13-lambda-2e7f0392e569b6bdc30e6bc9305fa0a4" class="header-anchor">#</a> <code>ListCommand::execute::__l13::&lt;lambda_2e7f0392e569b6bdc30e6bc9305fa0a4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ListCommand::execute::__l13::&lt;lambda_2e7f0392e569b6bdc30e6bc9305fa0a4&gt;
{
  std::vector&lt;Player const *&gt; *players;
  std::string *resultList;
};

</code></pre></div><h3 id="loottabledefinition"><a href="#loottabledefinition" class="header-anchor">#</a> <code>LootTableDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LootTableDefinition
{
  std::string mFilePath;
};

</code></pre></div><h3 id="legacybodycontrol"><a href="#legacybodycontrol" class="header-anchor">#</a> <code>LegacyBodyControl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LegacyBodyControl : BodyControl
{
};

</code></pre></div><h3 id="legacybodycontrol-vtbl"><a href="#legacybodycontrol-vtbl" class="header-anchor">#</a> <code>LegacyBodyControl_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LegacyBodyControl_vtbl
{
  void (__fastcall *~Control)(Control *this);
  void (__fastcall *clientTick)(BodyControl *this, Mob *);
};

</code></pre></div><h3 id="llama"><a href="#llama" class="header-anchor">#</a> <code>Llama</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Llama : Animal
{
};

</code></pre></div><h3 id="lookatblocknode"><a href="#lookatblocknode" class="header-anchor">#</a> <code>LookAtBlockNode</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LookAtBlockNode : BehaviorNode
{
  BlockPos mBlockPos;
  int mDelayTicks;
  int mDelayCounter;
};

</code></pre></div><h3 id="lookatblocknode-vtbl"><a href="#lookatblocknode-vtbl" class="header-anchor">#</a> <code>LookAtBlockNode_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LookAtBlockNode_vtbl
{
  void (__fastcall *~BehaviorNode)(BehaviorNode *this);
  BehaviorStatus (__fastcall *tick)(BehaviorNode *this, Actor *);
  void (__fastcall *initializeFromDefinition)(BehaviorNode *this, Actor *);
};

</code></pre></div><h3 id="lookatblockdefinition"><a href="#lookatblockdefinition" class="header-anchor">#</a> <code>LookAtBlockDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LookAtBlockDefinition : BehaviorDefinition
{
  BlockPos mBlockPos;
  std::string mBlockPosId;
};

</code></pre></div><h3 id="lookatblockdefinition-vtbl"><a href="#lookatblockdefinition-vtbl" class="header-anchor">#</a> <code>LookAtBlockDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LookAtBlockDefinition_vtbl
{
  void (__fastcall *~BehaviorDefinition)(BehaviorDefinition *this);
  void (__fastcall *load)(BehaviorDefinition *this, Json::Value, const BehaviorFactory *);
  std::unique_ptr&lt;BehaviorNode&gt; *(__fastcall *createNode)(BehaviorDefinition *this, std::unique_ptr&lt;BehaviorNode&gt; *result, Actor *, const BehaviorFactory *, BehaviorNode *, BehaviorData *);
};

</code></pre></div><h3 id="lookatactornode"><a href="#lookatactornode" class="header-anchor">#</a> <code>LookAtActorNode</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LookAtActorNode : BehaviorNode
{
  int mDelayTicks;
  int mDelayCounter;
  ActorType mEntityType;
  int mSearchRadius;
};

</code></pre></div><h3 id="lookatactornode-vtbl"><a href="#lookatactornode-vtbl" class="header-anchor">#</a> <code>LookAtActorNode_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LookAtActorNode_vtbl
{
  void (__fastcall *~BehaviorNode)(BehaviorNode *this);
  BehaviorStatus (__fastcall *tick)(BehaviorNode *this, Actor *);
  void (__fastcall *initializeFromDefinition)(BehaviorNode *this, Actor *);
};

</code></pre></div><h3 id="lookatactordefinition"><a href="#lookatactordefinition" class="header-anchor">#</a> <code>LookAtActorDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LookAtActorDefinition : BehaviorDefinition
{
  std::string mEntityName;
  std::string mEntityType;
  int mSearchRadius;
  std::string mSearchRadiusId;
};

</code></pre></div><h3 id="lookatactordefinition-vtbl"><a href="#lookatactordefinition-vtbl" class="header-anchor">#</a> <code>LookAtActorDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LookAtActorDefinition_vtbl
{
  void (__fastcall *~BehaviorDefinition)(BehaviorDefinition *this);
  void (__fastcall *load)(BehaviorDefinition *this, Json::Value, const BehaviorFactory *);
  std::unique_ptr&lt;BehaviorNode&gt; *(__fastcall *createNode)(BehaviorDefinition *this, std::unique_ptr&lt;BehaviorNode&gt; *result, Actor *, const BehaviorFactory *, BehaviorNode *, BehaviorData *);
};

</code></pre></div><h3 id="leashfenceknotactor-getinteraction-l5-lambda-fba8b1fcb26f3ee345fc375a962d8254"><a href="#leashfenceknotactor-getinteraction-l5-lambda-fba8b1fcb26f3ee345fc375a962d8254" class="header-anchor">#</a> <code>LeashFenceKnotActor::getInteraction::__l5::&lt;lambda_fba8b1fcb26f3ee345fc375a962d8254&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LeashFenceKnotActor::getInteraction::__l5::&lt;lambda_fba8b1fcb26f3ee345fc375a962d8254&gt;
{
  LeashFenceKnotActor *const __this;
};

</code></pre></div><h3 id="leashfenceknotactor-numberofanimalsattached-l2-lambda-48e561cf7a23ad8053577180ab266e54"><a href="#leashfenceknotactor-numberofanimalsattached-l2-lambda-48e561cf7a23ad8053577180ab266e54" class="header-anchor">#</a> <code>LeashFenceKnotActor::numberofAnimalsAttached::__l2::&lt;lambda_48e561cf7a23ad8053577180ab266e54&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LeashFenceKnotActor::numberofAnimalsAttached::__l2::&lt;lambda_48e561cf7a23ad8053577180ab266e54&gt;
{
  int *count;
};

</code></pre></div><h3 id="leashfenceknotactor-removeanimals-l2-lambda-3bbb238cec2a42e346a1795feb7cd16f"><a href="#leashfenceknotactor-removeanimals-l2-lambda-3bbb238cec2a42e346a1795feb7cd16f" class="header-anchor">#</a> <code>LeashFenceKnotActor::removeAnimals::__l2::&lt;lambda_3bbb238cec2a42e346a1795feb7cd16f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LeashFenceKnotActor::removeAnimals::__l2::&lt;lambda_3bbb238cec2a42e346a1795feb7cd16f&gt;
{
  Player *player;
};

</code></pre></div><h3 id="lavaslime"><a href="#lavaslime" class="header-anchor">#</a> <code>LavaSlime</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LavaSlime : Slime
{
};

</code></pre></div><h3 id="largefireball"><a href="#largefireball" class="header-anchor">#</a> <code>LargeFireball</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LargeFireball : Fireball
{
  int mExplosionPower;
};

</code></pre></div><h3 id="largefireball-vtbl"><a href="#largefireball-vtbl" class="header-anchor">#</a> <code>LargeFireball_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LargeFireball_vtbl
{
  bool (__fastcall *hasComponent)(Actor *this, const HashedString *);
  void (__fastcall *reloadHardcoded)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadHardcodedClient)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *initializeComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *_serverInitItemStackIds)(Actor *this);
  void (__fastcall *_doInitialMove)(Actor *this);
  bool (__fastcall *checkAllSensitiveWords)(Actor *this);
  bool (__fastcall *checkNameTag)(Actor *this);
  void (__fastcall *~Actor)(Actor *this);
  void (__fastcall *reset)(Actor *this);
  int (__fastcall *getOnDeathExperience)(Actor *this);
  ActorType (__fastcall *getOwnerEntityType)(Actor *this);
  void (__fastcall *remove)(Actor *this);
  void (__fastcall *setPos)(Actor *this, const Vec3 *);
  const PredictedMovementValues *(__fastcall *getPredictedMovementValues)(Actor *this);
  const Vec3 *(__fastcall *getPos)(Actor *this);
  const Vec3 *(__fastcall *getPosOld)(Actor *this);
  const Vec3 *(__fastcall *getPosExtrapolated)(Actor *this, const Vec3 *result, float);
  Vec3 *(__fastcall *getAttachPos)(Actor *this, Vec3 *result, ActorLocation, float);
  Vec3 *(__fastcall *getFiringPos)(Actor *this, Vec3 *result);
  void (__fastcall *setRot)(Actor *this, const Vec2 *);
  void (__fastcall *move)(Actor *this, IActorMovementProxy *, const Vec3 *);
  void (__fastcall *move)(Actor *this, const Vec3 *);
  Vec3 *(__fastcall *getInterpolatedRidingPosition)(Actor *this, Vec3 *result, float);
  float (__fastcall *getInterpolatedBodyRot)(Actor *this, float);
  float (__fastcall *getInterpolatedHeadRot)(Actor *this, float);
  float (__fastcall *getInterpolatedBodyYaw)(Actor *this, float);
  float (__fastcall *getYawSpeedInDegreesPerSecond)(Actor *this);
  float (__fastcall *getInterpolatedWalkAnimSpeed)(Actor *this, float);
  Vec3 *(__fastcall *getInterpolatedRidingOffset)(Actor *this, Vec3 *result, float);
  void (__fastcall *checkBlockCollisions)(Actor *this);
  void (__fastcall *checkBlockCollisions)(Actor *this, const AABB *, std::function&lt;void __cdecl(BlockSource &amp;,Block const &amp;,BlockPos const &amp;,Actor &amp;)&gt;);
  bool (__fastcall *isFireImmune)(Actor *this);
  bool (__fastcall *breaksFallingBlocks)(Actor *this);
  void (__fastcall *blockedByShield)(Actor *this, const ActorDamageSource *, Actor *);
  void (__fastcall *teleportTo)(Actor *this, const Vec3 *, bool, int, int, const ActorUniqueID *);
  bool (__fastcall *tryTeleportTo)(Actor *this, const Vec3 *, bool, bool, int, int);
  void (__fastcall *chorusFruitTeleport)(Actor *this, Vec3 *);
  void (__fastcall *lerpTo)(Actor *this, const Vec3 *, const Vec2 *, int);
  void (__fastcall *lerpMotion)(Actor *this, const Vec3 *);
  std::unique_ptr&lt;AddActorBasePacket&gt; *(__fastcall *getAddPacket)(Actor *this, std::unique_ptr&lt;AddActorBasePacket&gt; *result);
  void (__fastcall *normalTick)(Actor *this);
  void (__fastcall *baseTick)(Actor *this);
  void (__fastcall *rideTick)(Actor *this);
  void (__fastcall *positionRider)(Actor *this, Actor *, float);
  float (__fastcall *getRidingHeight)(Actor *this);
  bool (__fastcall *startRiding)(Actor *this, Actor *);
  void (__fastcall *addRider)(Actor *this, Actor *);
  void (__fastcall *flagRiderToRemove)(Actor *this, Actor *);
  std::string *(__fastcall *getExitTip)(Actor *this, std::string *result, const std::string *, InputMode);
  bool (__fastcall *intersects)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *, float);
  bool (__fastcall *isInWall)(Actor *this);
  bool (__fastcall *isInvisible)(Actor *this);
  bool (__fastcall *canShowNameTag)(Actor *this);
  bool (__fastcall *canExistInPeaceful)(Actor *this);
  void (__fastcall *setNameTagVisible)(Actor *this, bool);
  const std::string *(__fastcall *getNameTag)(Actor *this);
  unsigned __int64 (__fastcall *getNameTagAsHash)(Actor *this);
  std::string *(__fastcall *getFormattedNameTag)(Actor *this, std::string *result);
  void (__fastcall *filterFormattedNameTag)(Actor *this, const UIProfanityContext *);
  void (__fastcall *setNameTag)(Actor *this, const std::string *);
  bool (__fastcall *getAlwaysShowNameTag)(Actor *this);
  void (__fastcall *setScoreTag)(Actor *this, const std::string *);
  const std::string *(__fastcall *getScoreTag)(Actor *this);
  bool (__fastcall *isInWater)(Actor *this);
  bool (__fastcall *hasEnteredWater)(Actor *this);
  bool (__fastcall *isImmersedInWater)(Actor *this);
  bool (__fastcall *isInWaterOrRain)(Actor *this);
  bool (__fastcall *isInLava)(Actor *this);
  bool (__fastcall *isUnderLiquid)(Actor *this, MaterialType);
  bool (__fastcall *isOverWater)(Actor *this);
  void (__fastcall *makeStuckInBlock)(Actor *this, const Vec3 *);
  float (__fastcall *getCameraOffset)(Actor *this);
  float (__fastcall *getShadowHeightOffs)(Actor *this);
  float (__fastcall *getShadowRadius)(Actor *this);
  Vec3 *(__fastcall *getHeadLookVector)(Actor *this, Vec3 *result, float);
  bool (__fastcall *canSeeInvisible)(Actor *this);
  bool (__fastcall *canSee)(Actor *this, const Vec3 *);
  bool (__fastcall *canSee)(Actor *this, const Actor *);
  bool (__fastcall *isSkyLit)(Actor *this, float);
  float (__fastcall *getBrightness)(Actor *this, float);
  bool (__fastcall *interactPreventDefault)(Actor *this);
  void (__fastcall *playerTouch)(Actor *this, Player *);
  void (__fastcall *onAboveBubbleColumn)(Actor *this, const bool);
  void (__fastcall *onInsideBubbleColumn)(Actor *this, const bool);
  bool (__fastcall *isImmobile)(Actor *this);
  bool (__fastcall *isSilent)(Actor *this);
  bool (__fastcall *isPickable)(Actor *this);
  bool (__fastcall *isFishable)(Actor *this);
  bool (__fastcall *isSleeping)(Actor *this);
  bool (__fastcall *isShootable)(Actor *this);
  void (__fastcall *setSneaking)(Actor *this, bool);
  bool (__fastcall *isBlocking)(Actor *this);
  bool (__fastcall *isDamageBlocked)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *isAlive)(Actor *this);
  bool (__fastcall *isOnFire)(Actor *this);
  bool (__fastcall *isOnHotBlock)(Actor *this);
  bool (__fastcall *isCreativeModeAllowed)(Actor *this);
  bool (__fastcall *isSurfaceMob)(Actor *this);
  bool (__fastcall *isTargetable)(Actor *this);
  bool (__fastcall *isLocalPlayer)(Actor *this);
  bool (__fastcall *isPlayer)(Actor *this);
  bool (__fastcall *canAttack)(Actor *this, Actor *, bool);
  void (__fastcall *setTarget)(Actor *this, Actor *);
  Actor *(__fastcall *findAttackTarget)(Actor *this);
  bool (__fastcall *isValidTarget)(Actor *this, Actor *);
  bool (__fastcall *attack)(Actor *this, Actor *);
  void (__fastcall *performRangedAttack)(Actor *this, Actor *, float);
  void (__fastcall *adjustDamageAmount)(Actor *this, int *);
  int (__fastcall *getEquipmentCount)(Actor *this);
  void (__fastcall *setOwner)(Actor *this, const ActorUniqueID);
  void (__fastcall *setSitting)(Actor *this, bool);
  void (__fastcall *onTame)(Actor *this);
  void (__fastcall *onFailedTame)(Actor *this);
  int (__fastcall *getInventorySize)(Actor *this);
  int (__fastcall *getEquipSlots)(Actor *this);
  int (__fastcall *getChestSlots)(Actor *this);
  void (__fastcall *setStanding)(Actor *this, bool);
  bool (__fastcall *canPowerJump)(Actor *this);
  void (__fastcall *setCanPowerJump)(Actor *this, bool);
  bool (__fastcall *isJumping)(Actor *this);
  bool (__fastcall *isEnchanted)(Actor *this);
  void (__fastcall *rideJumped)(Actor *this);
  void (__fastcall *rideLanded)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *shouldRender)(Actor *this);
  bool (__fastcall *isInvulnerableTo)(Actor *this, const ActorDamageSource *);
  ActorDamageCause (__fastcall *getBlockDamageCause)(Actor *this, const Block *);
  void (__fastcall *actuallyHurt)(Actor *this, int, const ActorDamageSource *, bool);
  void (__fastcall *animateHurt)(Actor *this);
  bool (__fastcall *doFireHurt)(Actor *this, int);
  void (__fastcall *onLightningHit)(Actor *this);
  void (__fastcall *onBounceStarted)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *feed)(Actor *this, int);
  void (__fastcall *handleEntityEvent)(Actor *this, ActorEvent, int);
  float (__fastcall *getPickRadius)(Actor *this);
  const HashedString *(__fastcall *getActorRendererId)(Actor *this);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const ItemStack *, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int);
  void (__fastcall *despawn)(Actor *this);
  void (__fastcall *killed)(Actor *this, Actor *);
  void (__fastcall *awardKillScore)(Actor *this, Actor *, int);
  void (__fastcall *setArmor)(Actor *this, ArmorSlot, const ItemStack *);
  const ItemStack *(__fastcall *getArmor)(Actor *this, ArmorSlot);
  ArmorMaterialType (__fastcall *getArmorMaterialTypeInSlot)(Actor *this, ArmorSlot);
  ArmorTextureType (__fastcall *getArmorMaterialTextureTypeInSlot)(Actor *this, ArmorSlot);
  float (__fastcall *getArmorColorInSlot)(Actor *this, ArmorSlot, int);
  const ItemStack *(__fastcall *getEquippedSlot)(Actor *this, EquipmentSlot);
  void (__fastcall *setEquippedSlot)(Actor *this, EquipmentSlot, const ItemStack *);
  const ItemStack *(__fastcall *getCarriedItem)(Actor *this);
  void (__fastcall *setCarriedItem)(Actor *this, const ItemStack *);
  void (__fastcall *setOffhandSlot)(Actor *this, const ItemStack *);
  const ItemStack *(__fastcall *getEquippedTotem)(Actor *this);
  bool (__fastcall *consumeTotem)(Actor *this);
  bool (__fastcall *save)(Actor *this, CompoundTag *);
  void (__fastcall *saveWithoutId)(Actor *this, CompoundTag *);
  bool (__fastcall *load)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *loadLinks)(Actor *this, const CompoundTag *, std::vector&lt;ActorLink&gt; *, DataLoadHelper *);
  ActorType (__fastcall *getEntityTypeId)(Actor *this);
  const HashedString *(__fastcall *queryEntityRenderer)(Actor *this);
  ActorUniqueID *(__fastcall *getSourceUniqueID)(Actor *this, ActorUniqueID *result);
  void (__fastcall *setOnFire)(Actor *this, int);
  AABB *(__fastcall *getHandleWaterAABB)(Actor *this, AABB *result);
  void (__fastcall *handleInsidePortal)(Actor *this, const BlockPos *);
  int (__fastcall *getPortalCooldown)(Actor *this);
  int (__fastcall *getPortalWaitTime)(Actor *this);
  AutomaticID&lt;Dimension,int&gt; *(__fastcall *getDimensionId)(Actor *this, AutomaticID&lt;Dimension,int&gt; *result);
  bool (__fastcall *canChangeDimensions)(Actor *this);
  void (__fastcall *changeDimension)(Actor *this, const ChangeDimensionPacket *);
  void (__fastcall *changeDimension)(Actor *this, AutomaticID&lt;Dimension,int&gt;, bool);
  ActorUniqueID *(__fastcall *getControllingPlayer)(Actor *this, ActorUniqueID *result);
  void (__fastcall *checkFallDamage)(Actor *this, float, bool);
  void (__fastcall *causeFallDamage)(Actor *this, float);
  void (__fastcall *handleFallDistanceOnServer)(Actor *this, float, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, int, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, const Block *, bool);
  void (__fastcall *onSynchedDataUpdate)(Actor *this, int);
  bool (__fastcall *canAddRider)(Actor *this, Actor *);
  bool (__fastcall *canPickupItem)(Actor *this, const ItemStack *);
  bool (__fastcall *canBePulledIntoVehicle)(Actor *this);
  bool (__fastcall *inCaravan)(Actor *this);
  bool (__fastcall *isLeashableType)(Actor *this);
  void (__fastcall *tickLeash)(Actor *this);
  void (__fastcall *sendMotionPacketIfNeeded)(Actor *this);
  bool (__fastcall *canSynchronizeNewEntity)(Actor *this);
  bool (__fastcall *stopRiding)(Actor *this, bool, bool, bool, bool);
  void (__fastcall *startSwimming)(Actor *this);
  void (__fastcall *stopSwimming)(Actor *this);
  void (__fastcall *buildDebugInfo)(Actor *this, std::string *);
  CommandPermissionLevel (__fastcall *getCommandPermissionLevel)(Actor *this);
  AttributeInstance *(__fastcall *getMutableAttribute)(Actor *this, const Attribute *);
  const AttributeInstance *(__fastcall *getAttribute)(Actor *this, const Attribute *);
  int (__fastcall *getDeathTime)(Actor *this);
  void (__fastcall *heal)(Actor *this, int);
  bool (__fastcall *isInvertedHealAndHarm)(Actor *this);
  bool (__fastcall *canBeAffected)(Actor *this, const MobEffectInstance *);
  bool (__fastcall *canBeAffected)(Actor *this, int);
  bool (__fastcall *canBeAffectedByArrow)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectAdded)(Actor *this, MobEffectInstance *);
  void (__fastcall *onEffectUpdated)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectRemoved)(Actor *this, MobEffectInstance *);
  AnimationComponent *(__fastcall *getAnimationComponent)(Actor *this);
  void (__fastcall *openContainerComponent)(Actor *this, Player *);
  void (__fastcall *swing)(Actor *this);
  void (__fastcall *useItem)(Actor *this, ItemStackBase *, ItemUseMethod, bool);
  bool (__fastcall *hasOutputSignal)(Actor *this, unsigned __int8);
  int (__fastcall *getOutputSignal)(Actor *this);
  void (__fastcall *getDebugText)(Actor *this, std::vector&lt;std::string&gt; *);
  float (__fastcall *getMapDecorationRotation)(Actor *this);
  float (__fastcall *getRiderYRotation)(Actor *this, const Actor *);
  float (__fastcall *getYHeadRot)(Actor *this);
  bool (__fastcall *isWorldBuilder)(Actor *this);
  bool (__fastcall *isCreative)(Actor *this);
  bool (__fastcall *isAdventure)(Actor *this);
  bool (__fastcall *add)(Actor *this, ItemStack *);
  bool (__fastcall *drop)(Actor *this, const ItemStack *, bool);
  bool (__fastcall *getInteraction)(Actor *this, Player *, ActorInteraction *, const Vec3 *);
  bool (__fastcall *canDestroyBlock)(Actor *this, const Block *);
  void (__fastcall *setAuxValue)(Actor *this, int);
  void (__fastcall *setSize)(Actor *this, float, float);
  int (__fastcall *getLifeSpan)(Actor *this);
  void (__fastcall *onOrphan)(Actor *this);
  void (__fastcall *wobble)(Actor *this);
  bool (__fastcall *wasHurt)(Actor *this);
  void (__fastcall *startSpinAttack)(Actor *this);
  void (__fastcall *stopSpinAttack)(Actor *this);
  void (__fastcall *setDamageNearbyMobs)(Actor *this, bool);
  bool (__fastcall *hasCritBox)(Actor *this);
  bool (__fastcall *isCritHit)(Actor *this);
  void (__fastcall *renderDebugServerState)(Actor *this, const Options *);
  void (__fastcall *reloadLootTable)(Actor *this, const EquipmentTableDefinition *);
  void (__fastcall *reloadLootTable)(Actor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(Actor *this);
  void (__fastcall *kill)(Actor *this);
  void (__fastcall *die)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *shouldTick)(Actor *this);
  std::shared_ptr&lt;IActorMovementProxy&gt; *(__fastcall *createMovementProxy)(Actor *this, std::shared_ptr&lt;IActorMovementProxy&gt; *result);
  void (__fastcall *updateEntitySpecificMolangVariables)(Actor *this, RenderParams *);
  bool (__fastcall *shouldTryMakeStepSound)(Actor *this);
  float (__fastcall *getNextStep)(Actor *this, const float);
  bool (__fastcall *canMakeStepSound)(Actor *this);
  void (__fastcall *outOfWorld)(Actor *this);
  bool (__fastcall *_hurt)(Actor *this, const ActorDamageSource *, int, bool, bool);
  void (__fastcall *markHurt)(Actor *this);
  void (__fastcall *readAdditionalSaveData)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *addAdditionalSaveData)(Actor *this, CompoundTag *);
  void (__fastcall *_playStepSound)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *_playFlySound)(Actor *this, const BlockPos *, const Block *);
  bool (__fastcall *_makeFlySound)(Actor *this);
  void (__fastcall *checkInsideBlocks)(Actor *this, float);
  void (__fastcall *pushOutOfBlocks)(Actor *this, const Vec3 *);
  bool (__fastcall *updateWaterState)(Actor *this);
  void (__fastcall *doWaterSplashEffect)(Actor *this);
  void (__fastcall *spawnTrailBubbles)(Actor *this);
  void (__fastcall *updateInsideBlock)(Actor *this);
  LootTable *(__fastcall *getLootTable)(Actor *this);
  LootTable *(__fastcall *getDefaultLootTable)(Actor *this);
  void (__fastcall *_removeRider)(Actor *this, const ActorUniqueID *, bool, bool, bool);
  void (__fastcall *_onSizeUpdated)(Actor *this);
  void (__fastcall *_doAutoAttackOnTouch)(Actor *this, Actor *);
  float (__fastcall *getInertia)(Fireball *this);
  void (__fastcall *onHit)(Fireball *this, const HitResult *);
  ParticleType (__fastcall *getTrailParticle)(Fireball *this);
  bool (__fastcall *shouldBurn)(Fireball *this);
};

</code></pre></div><h3 id="llamaspit"><a href="#llamaspit" class="header-anchor">#</a> <code>LlamaSpit</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LlamaSpit : PredictableProjectile
{
  ActorUniqueID ownerId;
  MovementInterpolator mInterpolation;
};

</code></pre></div><h3 id="llamaspit-vtbl"><a href="#llamaspit-vtbl" class="header-anchor">#</a> <code>LlamaSpit_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LlamaSpit_vtbl
{
  bool (__fastcall *hasComponent)(Actor *this, const HashedString *);
  void (__fastcall *reloadHardcoded)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadHardcodedClient)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *initializeComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *_serverInitItemStackIds)(Actor *this);
  void (__fastcall *_doInitialMove)(Actor *this);
  bool (__fastcall *checkAllSensitiveWords)(Actor *this);
  bool (__fastcall *checkNameTag)(Actor *this);
  void (__fastcall *~Actor)(Actor *this);
  void (__fastcall *reset)(Actor *this);
  int (__fastcall *getOnDeathExperience)(Actor *this);
  ActorType (__fastcall *getOwnerEntityType)(Actor *this);
  void (__fastcall *remove)(Actor *this);
  void (__fastcall *setPos)(Actor *this, const Vec3 *);
  const PredictedMovementValues *(__fastcall *getPredictedMovementValues)(Actor *this);
  const Vec3 *(__fastcall *getPos)(Actor *this);
  const Vec3 *(__fastcall *getPosOld)(Actor *this);
  const Vec3 *(__fastcall *getPosExtrapolated)(Actor *this, const Vec3 *result, float);
  Vec3 *(__fastcall *getAttachPos)(Actor *this, Vec3 *result, ActorLocation, float);
  Vec3 *(__fastcall *getFiringPos)(Actor *this, Vec3 *result);
  void (__fastcall *setRot)(Actor *this, const Vec2 *);
  void (__fastcall *move)(Actor *this, IActorMovementProxy *, const Vec3 *);
  void (__fastcall *move)(Actor *this, const Vec3 *);
  Vec3 *(__fastcall *getInterpolatedRidingPosition)(Actor *this, Vec3 *result, float);
  float (__fastcall *getInterpolatedBodyRot)(Actor *this, float);
  float (__fastcall *getInterpolatedHeadRot)(Actor *this, float);
  float (__fastcall *getInterpolatedBodyYaw)(Actor *this, float);
  float (__fastcall *getYawSpeedInDegreesPerSecond)(Actor *this);
  float (__fastcall *getInterpolatedWalkAnimSpeed)(Actor *this, float);
  Vec3 *(__fastcall *getInterpolatedRidingOffset)(Actor *this, Vec3 *result, float);
  void (__fastcall *checkBlockCollisions)(Actor *this);
  void (__fastcall *checkBlockCollisions)(Actor *this, const AABB *, std::function&lt;void __cdecl(BlockSource &amp;,Block const &amp;,BlockPos const &amp;,Actor &amp;)&gt;);
  bool (__fastcall *isFireImmune)(Actor *this);
  bool (__fastcall *breaksFallingBlocks)(Actor *this);
  void (__fastcall *blockedByShield)(Actor *this, const ActorDamageSource *, Actor *);
  void (__fastcall *teleportTo)(Actor *this, const Vec3 *, bool, int, int, const ActorUniqueID *);
  bool (__fastcall *tryTeleportTo)(Actor *this, const Vec3 *, bool, bool, int, int);
  void (__fastcall *chorusFruitTeleport)(Actor *this, Vec3 *);
  void (__fastcall *lerpTo)(Actor *this, const Vec3 *, const Vec2 *, int);
  void (__fastcall *lerpMotion)(Actor *this, const Vec3 *);
  std::unique_ptr&lt;AddActorBasePacket&gt; *(__fastcall *getAddPacket)(Actor *this, std::unique_ptr&lt;AddActorBasePacket&gt; *result);
  void (__fastcall *normalTick)(Actor *this);
  void (__fastcall *baseTick)(Actor *this);
  void (__fastcall *rideTick)(Actor *this);
  void (__fastcall *positionRider)(Actor *this, Actor *, float);
  float (__fastcall *getRidingHeight)(Actor *this);
  bool (__fastcall *startRiding)(Actor *this, Actor *);
  void (__fastcall *addRider)(Actor *this, Actor *);
  void (__fastcall *flagRiderToRemove)(Actor *this, Actor *);
  std::string *(__fastcall *getExitTip)(Actor *this, std::string *result, const std::string *, InputMode);
  bool (__fastcall *intersects)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *, float);
  bool (__fastcall *isInWall)(Actor *this);
  bool (__fastcall *isInvisible)(Actor *this);
  bool (__fastcall *canShowNameTag)(Actor *this);
  bool (__fastcall *canExistInPeaceful)(Actor *this);
  void (__fastcall *setNameTagVisible)(Actor *this, bool);
  const std::string *(__fastcall *getNameTag)(Actor *this);
  unsigned __int64 (__fastcall *getNameTagAsHash)(Actor *this);
  std::string *(__fastcall *getFormattedNameTag)(Actor *this, std::string *result);
  void (__fastcall *filterFormattedNameTag)(Actor *this, const UIProfanityContext *);
  void (__fastcall *setNameTag)(Actor *this, const std::string *);
  bool (__fastcall *getAlwaysShowNameTag)(Actor *this);
  void (__fastcall *setScoreTag)(Actor *this, const std::string *);
  const std::string *(__fastcall *getScoreTag)(Actor *this);
  bool (__fastcall *isInWater)(Actor *this);
  bool (__fastcall *hasEnteredWater)(Actor *this);
  bool (__fastcall *isImmersedInWater)(Actor *this);
  bool (__fastcall *isInWaterOrRain)(Actor *this);
  bool (__fastcall *isInLava)(Actor *this);
  bool (__fastcall *isUnderLiquid)(Actor *this, MaterialType);
  bool (__fastcall *isOverWater)(Actor *this);
  void (__fastcall *makeStuckInBlock)(Actor *this, const Vec3 *);
  float (__fastcall *getCameraOffset)(Actor *this);
  float (__fastcall *getShadowHeightOffs)(Actor *this);
  float (__fastcall *getShadowRadius)(Actor *this);
  Vec3 *(__fastcall *getHeadLookVector)(Actor *this, Vec3 *result, float);
  bool (__fastcall *canSeeInvisible)(Actor *this);
  bool (__fastcall *canSee)(Actor *this, const Vec3 *);
  bool (__fastcall *canSee)(Actor *this, const Actor *);
  bool (__fastcall *isSkyLit)(Actor *this, float);
  float (__fastcall *getBrightness)(Actor *this, float);
  bool (__fastcall *interactPreventDefault)(Actor *this);
  void (__fastcall *playerTouch)(Actor *this, Player *);
  void (__fastcall *onAboveBubbleColumn)(Actor *this, const bool);
  void (__fastcall *onInsideBubbleColumn)(Actor *this, const bool);
  bool (__fastcall *isImmobile)(Actor *this);
  bool (__fastcall *isSilent)(Actor *this);
  bool (__fastcall *isPickable)(Actor *this);
  bool (__fastcall *isFishable)(Actor *this);
  bool (__fastcall *isSleeping)(Actor *this);
  bool (__fastcall *isShootable)(Actor *this);
  void (__fastcall *setSneaking)(Actor *this, bool);
  bool (__fastcall *isBlocking)(Actor *this);
  bool (__fastcall *isDamageBlocked)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *isAlive)(Actor *this);
  bool (__fastcall *isOnFire)(Actor *this);
  bool (__fastcall *isOnHotBlock)(Actor *this);
  bool (__fastcall *isCreativeModeAllowed)(Actor *this);
  bool (__fastcall *isSurfaceMob)(Actor *this);
  bool (__fastcall *isTargetable)(Actor *this);
  bool (__fastcall *isLocalPlayer)(Actor *this);
  bool (__fastcall *isPlayer)(Actor *this);
  bool (__fastcall *canAttack)(Actor *this, Actor *, bool);
  void (__fastcall *setTarget)(Actor *this, Actor *);
  Actor *(__fastcall *findAttackTarget)(Actor *this);
  bool (__fastcall *isValidTarget)(Actor *this, Actor *);
  bool (__fastcall *attack)(Actor *this, Actor *);
  void (__fastcall *performRangedAttack)(Actor *this, Actor *, float);
  void (__fastcall *adjustDamageAmount)(Actor *this, int *);
  int (__fastcall *getEquipmentCount)(Actor *this);
  void (__fastcall *setOwner)(Actor *this, const ActorUniqueID);
  void (__fastcall *setSitting)(Actor *this, bool);
  void (__fastcall *onTame)(Actor *this);
  void (__fastcall *onFailedTame)(Actor *this);
  int (__fastcall *getInventorySize)(Actor *this);
  int (__fastcall *getEquipSlots)(Actor *this);
  int (__fastcall *getChestSlots)(Actor *this);
  void (__fastcall *setStanding)(Actor *this, bool);
  bool (__fastcall *canPowerJump)(Actor *this);
  void (__fastcall *setCanPowerJump)(Actor *this, bool);
  bool (__fastcall *isJumping)(Actor *this);
  bool (__fastcall *isEnchanted)(Actor *this);
  void (__fastcall *rideJumped)(Actor *this);
  void (__fastcall *rideLanded)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *shouldRender)(Actor *this);
  bool (__fastcall *isInvulnerableTo)(Actor *this, const ActorDamageSource *);
  ActorDamageCause (__fastcall *getBlockDamageCause)(Actor *this, const Block *);
  void (__fastcall *actuallyHurt)(Actor *this, int, const ActorDamageSource *, bool);
  void (__fastcall *animateHurt)(Actor *this);
  bool (__fastcall *doFireHurt)(Actor *this, int);
  void (__fastcall *onLightningHit)(Actor *this);
  void (__fastcall *onBounceStarted)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *feed)(Actor *this, int);
  void (__fastcall *handleEntityEvent)(Actor *this, ActorEvent, int);
  float (__fastcall *getPickRadius)(Actor *this);
  const HashedString *(__fastcall *getActorRendererId)(Actor *this);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const ItemStack *, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int);
  void (__fastcall *despawn)(Actor *this);
  void (__fastcall *killed)(Actor *this, Actor *);
  void (__fastcall *awardKillScore)(Actor *this, Actor *, int);
  void (__fastcall *setArmor)(Actor *this, ArmorSlot, const ItemStack *);
  const ItemStack *(__fastcall *getArmor)(Actor *this, ArmorSlot);
  ArmorMaterialType (__fastcall *getArmorMaterialTypeInSlot)(Actor *this, ArmorSlot);
  ArmorTextureType (__fastcall *getArmorMaterialTextureTypeInSlot)(Actor *this, ArmorSlot);
  float (__fastcall *getArmorColorInSlot)(Actor *this, ArmorSlot, int);
  const ItemStack *(__fastcall *getEquippedSlot)(Actor *this, EquipmentSlot);
  void (__fastcall *setEquippedSlot)(Actor *this, EquipmentSlot, const ItemStack *);
  const ItemStack *(__fastcall *getCarriedItem)(Actor *this);
  void (__fastcall *setCarriedItem)(Actor *this, const ItemStack *);
  void (__fastcall *setOffhandSlot)(Actor *this, const ItemStack *);
  const ItemStack *(__fastcall *getEquippedTotem)(Actor *this);
  bool (__fastcall *consumeTotem)(Actor *this);
  bool (__fastcall *save)(Actor *this, CompoundTag *);
  void (__fastcall *saveWithoutId)(Actor *this, CompoundTag *);
  bool (__fastcall *load)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *loadLinks)(Actor *this, const CompoundTag *, std::vector&lt;ActorLink&gt; *, DataLoadHelper *);
  ActorType (__fastcall *getEntityTypeId)(Actor *this);
  const HashedString *(__fastcall *queryEntityRenderer)(Actor *this);
  ActorUniqueID *(__fastcall *getSourceUniqueID)(Actor *this, ActorUniqueID *result);
  void (__fastcall *setOnFire)(Actor *this, int);
  AABB *(__fastcall *getHandleWaterAABB)(Actor *this, AABB *result);
  void (__fastcall *handleInsidePortal)(Actor *this, const BlockPos *);
  int (__fastcall *getPortalCooldown)(Actor *this);
  int (__fastcall *getPortalWaitTime)(Actor *this);
  AutomaticID&lt;Dimension,int&gt; *(__fastcall *getDimensionId)(Actor *this, AutomaticID&lt;Dimension,int&gt; *result);
  bool (__fastcall *canChangeDimensions)(Actor *this);
  void (__fastcall *changeDimension)(Actor *this, const ChangeDimensionPacket *);
  void (__fastcall *changeDimension)(Actor *this, AutomaticID&lt;Dimension,int&gt;, bool);
  ActorUniqueID *(__fastcall *getControllingPlayer)(Actor *this, ActorUniqueID *result);
  void (__fastcall *checkFallDamage)(Actor *this, float, bool);
  void (__fastcall *causeFallDamage)(Actor *this, float);
  void (__fastcall *handleFallDistanceOnServer)(Actor *this, float, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, int, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, const Block *, bool);
  void (__fastcall *onSynchedDataUpdate)(Actor *this, int);
  bool (__fastcall *canAddRider)(Actor *this, Actor *);
  bool (__fastcall *canPickupItem)(Actor *this, const ItemStack *);
  bool (__fastcall *canBePulledIntoVehicle)(Actor *this);
  bool (__fastcall *inCaravan)(Actor *this);
  bool (__fastcall *isLeashableType)(Actor *this);
  void (__fastcall *tickLeash)(Actor *this);
  void (__fastcall *sendMotionPacketIfNeeded)(Actor *this);
  bool (__fastcall *canSynchronizeNewEntity)(Actor *this);
  bool (__fastcall *stopRiding)(Actor *this, bool, bool, bool, bool);
  void (__fastcall *startSwimming)(Actor *this);
  void (__fastcall *stopSwimming)(Actor *this);
  void (__fastcall *buildDebugInfo)(Actor *this, std::string *);
  CommandPermissionLevel (__fastcall *getCommandPermissionLevel)(Actor *this);
  AttributeInstance *(__fastcall *getMutableAttribute)(Actor *this, const Attribute *);
  const AttributeInstance *(__fastcall *getAttribute)(Actor *this, const Attribute *);
  int (__fastcall *getDeathTime)(Actor *this);
  void (__fastcall *heal)(Actor *this, int);
  bool (__fastcall *isInvertedHealAndHarm)(Actor *this);
  bool (__fastcall *canBeAffected)(Actor *this, const MobEffectInstance *);
  bool (__fastcall *canBeAffected)(Actor *this, int);
  bool (__fastcall *canBeAffectedByArrow)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectAdded)(Actor *this, MobEffectInstance *);
  void (__fastcall *onEffectUpdated)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectRemoved)(Actor *this, MobEffectInstance *);
  AnimationComponent *(__fastcall *getAnimationComponent)(Actor *this);
  void (__fastcall *openContainerComponent)(Actor *this, Player *);
  void (__fastcall *swing)(Actor *this);
  void (__fastcall *useItem)(Actor *this, ItemStackBase *, ItemUseMethod, bool);
  bool (__fastcall *hasOutputSignal)(Actor *this, unsigned __int8);
  int (__fastcall *getOutputSignal)(Actor *this);
  void (__fastcall *getDebugText)(Actor *this, std::vector&lt;std::string&gt; *);
  float (__fastcall *getMapDecorationRotation)(Actor *this);
  float (__fastcall *getRiderYRotation)(Actor *this, const Actor *);
  float (__fastcall *getYHeadRot)(Actor *this);
  bool (__fastcall *isWorldBuilder)(Actor *this);
  bool (__fastcall *isCreative)(Actor *this);
  bool (__fastcall *isAdventure)(Actor *this);
  bool (__fastcall *add)(Actor *this, ItemStack *);
  bool (__fastcall *drop)(Actor *this, const ItemStack *, bool);
  bool (__fastcall *getInteraction)(Actor *this, Player *, ActorInteraction *, const Vec3 *);
  bool (__fastcall *canDestroyBlock)(Actor *this, const Block *);
  void (__fastcall *setAuxValue)(Actor *this, int);
  void (__fastcall *setSize)(Actor *this, float, float);
  int (__fastcall *getLifeSpan)(Actor *this);
  void (__fastcall *onOrphan)(Actor *this);
  void (__fastcall *wobble)(Actor *this);
  bool (__fastcall *wasHurt)(Actor *this);
  void (__fastcall *startSpinAttack)(Actor *this);
  void (__fastcall *stopSpinAttack)(Actor *this);
  void (__fastcall *setDamageNearbyMobs)(Actor *this, bool);
  bool (__fastcall *hasCritBox)(Actor *this);
  bool (__fastcall *isCritHit)(Actor *this);
  void (__fastcall *renderDebugServerState)(Actor *this, const Options *);
  void (__fastcall *reloadLootTable)(Actor *this, const EquipmentTableDefinition *);
  void (__fastcall *reloadLootTable)(Actor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(Actor *this);
  void (__fastcall *kill)(Actor *this);
  void (__fastcall *die)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *shouldTick)(Actor *this);
  std::shared_ptr&lt;IActorMovementProxy&gt; *(__fastcall *createMovementProxy)(Actor *this, std::shared_ptr&lt;IActorMovementProxy&gt; *result);
  void (__fastcall *updateEntitySpecificMolangVariables)(Actor *this, RenderParams *);
  bool (__fastcall *shouldTryMakeStepSound)(Actor *this);
  float (__fastcall *getNextStep)(Actor *this, const float);
  bool (__fastcall *canMakeStepSound)(Actor *this);
  void (__fastcall *outOfWorld)(Actor *this);
  bool (__fastcall *_hurt)(Actor *this, const ActorDamageSource *, int, bool, bool);
  void (__fastcall *markHurt)(Actor *this);
  void (__fastcall *readAdditionalSaveData)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *addAdditionalSaveData)(Actor *this, CompoundTag *);
  void (__fastcall *_playStepSound)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *_playFlySound)(Actor *this, const BlockPos *, const Block *);
  bool (__fastcall *_makeFlySound)(Actor *this);
  void (__fastcall *checkInsideBlocks)(Actor *this, float);
  void (__fastcall *pushOutOfBlocks)(Actor *this, const Vec3 *);
  bool (__fastcall *updateWaterState)(Actor *this);
  void (__fastcall *doWaterSplashEffect)(Actor *this);
  void (__fastcall *spawnTrailBubbles)(Actor *this);
  void (__fastcall *updateInsideBlock)(Actor *this);
  LootTable *(__fastcall *getLootTable)(Actor *this);
  LootTable *(__fastcall *getDefaultLootTable)(Actor *this);
  void (__fastcall *_removeRider)(Actor *this, const ActorUniqueID *, bool, bool, bool);
  void (__fastcall *_onSizeUpdated)(Actor *this);
  void (__fastcall *_doAutoAttackOnTouch)(Actor *this, Actor *);
};

</code></pre></div><h3 id="levelcontainermodel"><a href="#levelcontainermodel" class="header-anchor">#</a> <code>LevelContainerModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelContainerModel : ContainerModel
{
  Player *mPlayer;
  BlockPos mBlockPos;
  BlockActorType mBlockEntityType;
  ActorUniqueID mEntityUniqueId;
  std::vector&lt;Container *&gt; initContainerList;
};

</code></pre></div><h3 id="levelcontainermodel-vtbl"><a href="#levelcontainermodel-vtbl" class="header-anchor">#</a> <code>LevelContainerModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LevelContainerModel_vtbl
{
  void (__fastcall *containerContentChanged)(ContainerContentChangeListener *this, int);
  void (__fastcall *~ContainerContentChangeListener)(ContainerContentChangeListener *this);
  void (__fastcall *containerAddCallback)(ContainerContentChangeListener *this, Container *);
  void (__fastcall *containerRemoveCallback)(ContainerContentChangeListener *this, Container *);
  void (__fastcall *postInit)(ContainerModel *this);
  void (__fastcall *releaseResources)(ContainerModel *this);
  int (__fastcall *getContainerSize)(ContainerModel *this);
  int (__fastcall *getFilteredContainerSize)(ContainerModel *this);
  void (__fastcall *tick)(ContainerModel *this, int);
  ContainerWeakRef *(__fastcall *getContainerWeakRef)(ContainerModel *this, ContainerWeakRef *result);
  const ItemStack *(__fastcall *getItemStack)(ContainerModel *this, int);
  const std::vector&lt;ItemStack&gt; *(__fastcall *getItems)(ContainerModel *this);
  const ItemInstance *(__fastcall *getItemInstance)(ContainerModel *this, int);
  const ItemStackBase *(__fastcall *getItemStackBase)(ContainerModel *this, int);
  bool (__fastcall *isItemInstanceBased)(ContainerModel *this);
  void (__fastcall *setItem)(ContainerModel *this, int, const ItemStack *);
  bool (__fastcall *isValid)(ContainerModel *this);
  bool (__fastcall *isItemFiltered)(ContainerModel *this, const ItemStackBase *);
  bool (__fastcall *isExpanableItemFiltered)(ContainerModel *this, int);
  ContainerExpandStatus (__fastcall *getItemExpandStatus)(ContainerModel *this, int);
  const std::string *(__fastcall *getItemGroupName)(ContainerModel *this, int);
  void (__fastcall *switchItemExpando)(ContainerModel *this, int);
  Container *(__fastcall *_getContainer)(ContainerModel *this);
  int (__fastcall *_getContainerOffset)(ContainerModel *this);
  void (__fastcall *_onItemChanged)(ContainerModel *this, int, const ItemStack *, const ItemStack *);
};

</code></pre></div><h3 id="levelcontainermanagermodel-postinit-l2-lambda-3dd4d1f2c36000a64e678bfd6b26033b"><a href="#levelcontainermanagermodel-postinit-l2-lambda-3dd4d1f2c36000a64e678bfd6b26033b" class="header-anchor">#</a> <code>LevelContainerManagerModel::_postInit::__l2::&lt;lambda_3dd4d1f2c36000a64e678bfd6b26033b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelContainerManagerModel::_postInit::__l2::&lt;lambda_3dd4d1f2c36000a64e678bfd6b26033b&gt;
{
  LevelContainerManagerModel *const __this;
};

</code></pre></div><h3 id="leveleventcoordinator-sendlevelbiomesregistered-l2-lambda-ddc846bd8e8a8ff1387a315cf3b7d60c"><a href="#leveleventcoordinator-sendlevelbiomesregistered-l2-lambda-ddc846bd8e8a8ff1387a315cf3b7d60c" class="header-anchor">#</a> <code>LevelEventCoordinator::sendLevelBiomesRegistered::__l2::&lt;lambda_ddc846bd8e8a8ff1387a315cf3b7d60c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelEventCoordinator::sendLevelBiomesRegistered::__l2::&lt;lambda_ddc846bd8e8a8ff1387a315cf3b7d60c&gt;
{
  BiomeRegistry *biomeRegistry;
};

</code></pre></div><h3 id="leveleventcoordinator-sendleveltick-l2-lambda-ec1aec075e5a64d264e03959a3191abd"><a href="#leveleventcoordinator-sendleveltick-l2-lambda-ec1aec075e5a64d264e03959a3191abd" class="header-anchor">#</a> <code>LevelEventCoordinator::sendLevelTick::__l2::&lt;lambda_ec1aec075e5a64d264e03959a3191abd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelEventCoordinator::sendLevelTick::__l2::&lt;lambda_ec1aec075e5a64d264e03959a3191abd&gt;
{
};

</code></pre></div><h3 id="leveleventcoordinator-sendleveladdedactor-l2-lambda-2070b6ba94f287344509b3253827d448"><a href="#leveleventcoordinator-sendleveladdedactor-l2-lambda-2070b6ba94f287344509b3253827d448" class="header-anchor">#</a> <code>LevelEventCoordinator::sendLevelAddedActor::__l2::&lt;lambda_2070b6ba94f287344509b3253827d448&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelEventCoordinator::sendLevelAddedActor::__l2::&lt;lambda_2070b6ba94f287344509b3253827d448&gt;
{
  Level *level;
  Actor *actor;
};

</code></pre></div><h3 id="leveleventcoordinator-sendlevelremovedactor-l2-lambda-e9c3114ff799af2f6b051c7a5dd1a2a5"><a href="#leveleventcoordinator-sendlevelremovedactor-l2-lambda-e9c3114ff799af2f6b051c7a5dd1a2a5" class="header-anchor">#</a> <code>LevelEventCoordinator::sendLevelRemovedActor::__l2::&lt;lambda_e9c3114ff799af2f6b051c7a5dd1a2a5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelEventCoordinator::sendLevelRemovedActor::__l2::&lt;lambda_e9c3114ff799af2f6b051c7a5dd1a2a5&gt;
{
  Level *level;
  Actor *actor;
};

</code></pre></div><h3 id="leveleventcoordinator-sendlevelinitialized-l2-lambda-a4358936410fc0ba7f7d64f32435908c"><a href="#leveleventcoordinator-sendlevelinitialized-l2-lambda-a4358936410fc0ba7f7d64f32435908c" class="header-anchor">#</a> <code>LevelEventCoordinator::sendLevelInitialized::__l2::&lt;lambda_a4358936410fc0ba7f7d64f32435908c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LevelEventCoordinator::sendLevelInitialized::__l2::&lt;lambda_a4358936410fc0ba7f7d64f32435908c&gt;
{
  Level *level;
};

</code></pre></div><h3 id="lootenchant"><a href="#lootenchant" class="header-anchor">#</a> <code>LootEnchant</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LootEnchant : Enchant
{
};

</code></pre></div><h3 id="lootenchant-vtbl"><a href="#lootenchant-vtbl" class="header-anchor">#</a> <code>LootEnchant_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LootEnchant_vtbl
{
  void (__fastcall *~Enchant)(Enchant *this);
  bool (__fastcall *isCompatibleWith)(Enchant *this, Enchant::Type);
  int (__fastcall *getMinCost)(Enchant *this, int);
  int (__fastcall *getMaxCost)(Enchant *this, int);
  int (__fastcall *getMinLevel)(Enchant *this);
  int (__fastcall *getMaxLevel)(Enchant *this);
  int (__fastcall *getDamageProtection)(Enchant *this, int, const ActorDamageSource *);
  float (__fastcall *getDamageBonus)(Enchant *this, int, const Actor *);
  void (__fastcall *doPostAttack)(Enchant *this, Actor *, Actor *, int);
  void (__fastcall *doPostHurt)(Enchant *this, ItemInstance *, Actor *, Actor *, int);
  bool (__fastcall *isMeleeDamageEnchant)(Enchant *this);
  bool (__fastcall *isProtectionEnchant)(Enchant *this);
  bool (__fastcall *isTreasureOnly)(Enchant *this);
  bool (__fastcall *isDiscoverable)(Enchant *this);
};

</code></pre></div><h3 id="lingeringpotionitem"><a href="#lingeringpotionitem" class="header-anchor">#</a> <code>LingeringPotionItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) LingeringPotionItem : PotionItem
{
  TextureUVCoordinateSet mLingeringIcons[17];
  _BYTE mLingeringPotionVariants[68];
};

</code></pre></div><h3 id="leafblockitem"><a href="#leafblockitem" class="header-anchor">#</a> <code>LeafBlockItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LeafBlockItem : BlockItem
{
  const Block *m_parentBlock;
};

</code></pre></div><h3 id="layerdetails-transferdata-biome"><a href="#layerdetails-transferdata-biome" class="header-anchor">#</a> <code>LayerDetails::TransferData&lt;Biome *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LayerDetails::TransferData&lt;Biome *&gt; : LayerDetails::Storage
{
};

</code></pre></div><h3 id="layer-biome-vtbl"><a href="#layer-biome-vtbl" class="header-anchor">#</a> <code>Layer&lt;Biome *&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Layer&lt;Biome *&gt;_vtbl
{
  void (__fastcall *~LayerBase)(LayerDetails::LayerBase *this);
  void (__fastcall *init)(LayerDetails::LayerBase *this, __int64);
  LayerDetails::TransferData&lt;Biome *&gt; *(__fastcall *_allocateAndFill)(Layer&lt;Biome *&gt; *this, LayerDetails::TransferData&lt;Biome *&gt; *result, unsigned __int64, int, int, unsigned int, unsigned int);
};

</code></pre></div><h3 id="layerbiomesource-vtbl"><a href="#layerbiomesource-vtbl" class="header-anchor">#</a> <code>LayerBiomeSource_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LayerBiomeSource_vtbl
{
  void (__fastcall *~BiomeSource)(BiomeSource *this);
  void (__fastcall *fillBiomes)(BiomeSource *this, LevelChunk *);
  BiomeArea *(__fastcall *getBiomeArea)(BiomeSource *this, BiomeArea *result, const BoundingBox *, unsigned int);
  bool (__fastcall *containsOnly)(BiomeSource *this, int, int, int, gsl::span&lt;int const ,-1&gt;);
  const Biome *(__fastcall *getBiome)(BiomeSource *this, int, int);
};

</code></pre></div><h3 id="lecternblock"><a href="#lecternblock" class="header-anchor">#</a> <code>LecternBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj LecternBlock : ActorBlock
{
};

</code></pre></div><h3 id="lecternblock-vtbl"><a href="#lecternblock-vtbl" class="header-anchor">#</a> <code>LecternBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LecternBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
};

</code></pre></div><h3 id="lootcomponent"><a href="#lootcomponent" class="header-anchor">#</a> <code>LootComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LootComponent
{
  std::string mLootTable;
};

</code></pre></div><h3 id="listenonremovecomponentdescription"><a href="#listenonremovecomponentdescription" class="header-anchor">#</a> <code>ListenOnRemoveComponentDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ListenOnRemoveComponentDescription : BlockComponentDescription
{
  bool mValue;
};

</code></pre></div><h3 id="listenonremovecomponentdescription-vtbl"><a href="#listenonremovecomponentdescription-vtbl" class="header-anchor">#</a> <code>ListenOnRemoveComponentDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ListenOnRemoveComponentDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="listenonremovecomponent"><a href="#listenonremovecomponent" class="header-anchor">#</a> <code>ListenOnRemoveComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ListenOnRemoveComponent
{
  bool mValue;
};

</code></pre></div><h3 id="lootcomponentdescription"><a href="#lootcomponentdescription" class="header-anchor">#</a> <code>LootComponentDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LootComponentDescription : BlockComponentDescription
{
  std::string mLootTable;
};

</code></pre></div><h3 id="lootcomponentdescription-vtbl"><a href="#lootcomponentdescription-vtbl" class="header-anchor">#</a> <code>LootComponentDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LootComponentDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="lootcomponentdescription-buildschema-l2-lambda-3945d8a3b1d9e1908875af1d7a69fb2d"><a href="#lootcomponentdescription-buildschema-l2-lambda-3945d8a3b1d9e1908875af1d7a69fb2d" class="header-anchor">#</a> <code>LootComponentDescription::buildSchema::__l2::&lt;lambda_3945d8a3b1d9e1908875af1d7a69fb2d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LootComponentDescription::buildSchema::__l2::&lt;lambda_3945d8a3b1d9e1908875af1d7a69fb2d&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="ladderblock"><a href="#ladderblock" class="header-anchor">#</a> <code>LadderBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LadderBlock : BlockLegacy
{
};

</code></pre></div><h3 id="ladderblock-vtbl"><a href="#ladderblock-vtbl" class="header-anchor">#</a> <code>LadderBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LadderBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="lanternblock"><a href="#lanternblock" class="header-anchor">#</a> <code>LanternBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LanternBlock : BlockLegacy
{
};

</code></pre></div><h3 id="lanternblock-vtbl"><a href="#lanternblock-vtbl" class="header-anchor">#</a> <code>LanternBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LanternBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="leverblock"><a href="#leverblock" class="header-anchor">#</a> <code>LeverBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LeverBlock : BlockLegacy
{
};

</code></pre></div><h3 id="leverblock-vtbl"><a href="#leverblock-vtbl" class="header-anchor">#</a> <code>LeverBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LeverBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *updateShape)(LeverBlock *this, BlockSource *, const BlockPos *);
};

</code></pre></div><h3 id="lightblock"><a href="#lightblock" class="header-anchor">#</a> <code>LightBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LightBlock : AirBlock
{
};

</code></pre></div><h3 id="lightblock-vtbl"><a href="#lightblock-vtbl" class="header-anchor">#</a> <code>LightBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ LightBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="lightgemblock"><a href="#lightgemblock" class="header-anchor">#</a> <code>LightGemBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj LightGemBlock : BlockLegacy
{
};

</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      
      <a href="/mcstructure/1.16.201/structure/K.html" class="prev">
        K
      </a></span> <span class="next"><a href="/mcstructure/1.16.201/structure/L~1.html">
        L~1
      </a>
      
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/mcstructure/assets/js/app.56b0ab36.js" defer></script><script src="/mcstructure/assets/js/2.56e23786.js" defer></script><script src="/mcstructure/assets/js/119.0b88b1c0.js" defer></script>
  </body>
</html>
