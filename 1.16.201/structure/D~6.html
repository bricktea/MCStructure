<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>D~6 | MC TIL</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Some structure and enum information for minecraft bedrock edition.">
    
    <link rel="preload" href="/mcstructure/assets/css/0.styles.5de0a167.css" as="style"><link rel="preload" href="/mcstructure/assets/js/app.56b0ab36.js" as="script"><link rel="preload" href="/mcstructure/assets/js/2.56e23786.js" as="script"><link rel="preload" href="/mcstructure/assets/js/104.4a4116d4.js" as="script"><link rel="prefetch" href="/mcstructure/assets/js/10.dda8da32.js"><link rel="prefetch" href="/mcstructure/assets/js/100.d193fca3.js"><link rel="prefetch" href="/mcstructure/assets/js/101.324df8d1.js"><link rel="prefetch" href="/mcstructure/assets/js/102.81d32953.js"><link rel="prefetch" href="/mcstructure/assets/js/103.bafffe55.js"><link rel="prefetch" href="/mcstructure/assets/js/105.ee5ab7c3.js"><link rel="prefetch" href="/mcstructure/assets/js/106.16520c01.js"><link rel="prefetch" href="/mcstructure/assets/js/107.e4e2fef9.js"><link rel="prefetch" href="/mcstructure/assets/js/108.9771cecd.js"><link rel="prefetch" href="/mcstructure/assets/js/109.07a059f8.js"><link rel="prefetch" href="/mcstructure/assets/js/11.84aff5f4.js"><link rel="prefetch" href="/mcstructure/assets/js/110.79e73184.js"><link rel="prefetch" href="/mcstructure/assets/js/111.735fe11b.js"><link rel="prefetch" href="/mcstructure/assets/js/112.5b8c9633.js"><link rel="prefetch" href="/mcstructure/assets/js/113.a961fd7d.js"><link rel="prefetch" href="/mcstructure/assets/js/114.f46e6ac6.js"><link rel="prefetch" href="/mcstructure/assets/js/115.29d129b9.js"><link rel="prefetch" href="/mcstructure/assets/js/116.0761604d.js"><link rel="prefetch" href="/mcstructure/assets/js/117.8fa51bbe.js"><link rel="prefetch" href="/mcstructure/assets/js/118.65b68c09.js"><link rel="prefetch" href="/mcstructure/assets/js/119.0b88b1c0.js"><link rel="prefetch" href="/mcstructure/assets/js/12.fb0b2343.js"><link rel="prefetch" href="/mcstructure/assets/js/120.6514cc60.js"><link rel="prefetch" href="/mcstructure/assets/js/121.30792057.js"><link rel="prefetch" href="/mcstructure/assets/js/122.ac6c9052.js"><link rel="prefetch" href="/mcstructure/assets/js/123.9dde14ff.js"><link rel="prefetch" href="/mcstructure/assets/js/124.1b8cd48f.js"><link rel="prefetch" href="/mcstructure/assets/js/125.ba14f223.js"><link rel="prefetch" href="/mcstructure/assets/js/126.5dd69ba6.js"><link rel="prefetch" href="/mcstructure/assets/js/127.32df8d72.js"><link rel="prefetch" href="/mcstructure/assets/js/128.aa9a14cc.js"><link rel="prefetch" href="/mcstructure/assets/js/129.d7a703a5.js"><link rel="prefetch" href="/mcstructure/assets/js/13.b8437649.js"><link rel="prefetch" href="/mcstructure/assets/js/130.d8f7ecf5.js"><link rel="prefetch" href="/mcstructure/assets/js/131.0c1d33fe.js"><link rel="prefetch" href="/mcstructure/assets/js/132.8b6e6ff3.js"><link rel="prefetch" href="/mcstructure/assets/js/133.f999118d.js"><link rel="prefetch" href="/mcstructure/assets/js/134.bc4a2893.js"><link rel="prefetch" href="/mcstructure/assets/js/135.e6e793b3.js"><link rel="prefetch" href="/mcstructure/assets/js/136.c50dcaff.js"><link rel="prefetch" href="/mcstructure/assets/js/137.209d5c8a.js"><link rel="prefetch" href="/mcstructure/assets/js/138.3eed47db.js"><link rel="prefetch" href="/mcstructure/assets/js/139.5e9afeaa.js"><link rel="prefetch" href="/mcstructure/assets/js/14.c94aa248.js"><link rel="prefetch" href="/mcstructure/assets/js/140.ac85c96f.js"><link rel="prefetch" href="/mcstructure/assets/js/141.82f0f06f.js"><link rel="prefetch" href="/mcstructure/assets/js/142.08052153.js"><link rel="prefetch" href="/mcstructure/assets/js/143.97d16176.js"><link rel="prefetch" href="/mcstructure/assets/js/144.66c74f2b.js"><link rel="prefetch" href="/mcstructure/assets/js/145.58e96ed1.js"><link rel="prefetch" href="/mcstructure/assets/js/146.4c73b3b4.js"><link rel="prefetch" href="/mcstructure/assets/js/147.0e0e09a7.js"><link rel="prefetch" href="/mcstructure/assets/js/148.a8c2c253.js"><link rel="prefetch" href="/mcstructure/assets/js/149.99f1b4f1.js"><link rel="prefetch" href="/mcstructure/assets/js/15.fd6df6e3.js"><link rel="prefetch" href="/mcstructure/assets/js/16.855c8adf.js"><link rel="prefetch" href="/mcstructure/assets/js/17.860009b0.js"><link rel="prefetch" href="/mcstructure/assets/js/18.63105a6b.js"><link rel="prefetch" href="/mcstructure/assets/js/19.fbddb16b.js"><link rel="prefetch" href="/mcstructure/assets/js/20.605578ab.js"><link rel="prefetch" href="/mcstructure/assets/js/21.1e5adf90.js"><link rel="prefetch" href="/mcstructure/assets/js/22.29bfa69a.js"><link rel="prefetch" href="/mcstructure/assets/js/23.566201a2.js"><link rel="prefetch" href="/mcstructure/assets/js/24.d912e845.js"><link rel="prefetch" href="/mcstructure/assets/js/25.8885d257.js"><link rel="prefetch" href="/mcstructure/assets/js/26.8409713f.js"><link rel="prefetch" href="/mcstructure/assets/js/27.49cb5267.js"><link rel="prefetch" href="/mcstructure/assets/js/28.2a890355.js"><link rel="prefetch" href="/mcstructure/assets/js/29.6ea7598b.js"><link rel="prefetch" href="/mcstructure/assets/js/3.50967458.js"><link rel="prefetch" href="/mcstructure/assets/js/30.1a3c3902.js"><link rel="prefetch" href="/mcstructure/assets/js/31.24ec9e8b.js"><link rel="prefetch" href="/mcstructure/assets/js/32.40831503.js"><link rel="prefetch" href="/mcstructure/assets/js/33.6602f7d9.js"><link rel="prefetch" href="/mcstructure/assets/js/34.75d333d9.js"><link rel="prefetch" href="/mcstructure/assets/js/35.84bf3e5a.js"><link rel="prefetch" href="/mcstructure/assets/js/36.fe4e7307.js"><link rel="prefetch" href="/mcstructure/assets/js/37.b2ee95ad.js"><link rel="prefetch" href="/mcstructure/assets/js/38.c03d5dee.js"><link rel="prefetch" href="/mcstructure/assets/js/39.a60df6e0.js"><link rel="prefetch" href="/mcstructure/assets/js/4.f5835878.js"><link rel="prefetch" href="/mcstructure/assets/js/40.6322a006.js"><link rel="prefetch" href="/mcstructure/assets/js/41.420acfde.js"><link rel="prefetch" href="/mcstructure/assets/js/42.a4ef9cfe.js"><link rel="prefetch" href="/mcstructure/assets/js/43.660cc3cf.js"><link rel="prefetch" href="/mcstructure/assets/js/44.683fc1e0.js"><link rel="prefetch" href="/mcstructure/assets/js/45.f27a9ad0.js"><link rel="prefetch" href="/mcstructure/assets/js/46.9f9edd2c.js"><link rel="prefetch" href="/mcstructure/assets/js/47.fd3ae547.js"><link rel="prefetch" href="/mcstructure/assets/js/48.375f8f97.js"><link rel="prefetch" href="/mcstructure/assets/js/49.e0d0f024.js"><link rel="prefetch" href="/mcstructure/assets/js/5.e0bd9261.js"><link rel="prefetch" href="/mcstructure/assets/js/50.aa126f14.js"><link rel="prefetch" href="/mcstructure/assets/js/51.e939b03e.js"><link rel="prefetch" href="/mcstructure/assets/js/52.a2d46eef.js"><link rel="prefetch" href="/mcstructure/assets/js/53.72de48c3.js"><link rel="prefetch" href="/mcstructure/assets/js/54.54675155.js"><link rel="prefetch" href="/mcstructure/assets/js/55.8b419ad8.js"><link rel="prefetch" href="/mcstructure/assets/js/56.07af8dcf.js"><link rel="prefetch" href="/mcstructure/assets/js/57.0bedaec9.js"><link rel="prefetch" href="/mcstructure/assets/js/58.37c94f2a.js"><link rel="prefetch" href="/mcstructure/assets/js/59.b0866a6a.js"><link rel="prefetch" href="/mcstructure/assets/js/6.04e2a2d2.js"><link rel="prefetch" href="/mcstructure/assets/js/60.5c5afc8c.js"><link rel="prefetch" href="/mcstructure/assets/js/61.ea56e4d6.js"><link rel="prefetch" href="/mcstructure/assets/js/62.3cb13464.js"><link rel="prefetch" href="/mcstructure/assets/js/63.83c0082d.js"><link rel="prefetch" href="/mcstructure/assets/js/64.2cd02c8b.js"><link rel="prefetch" href="/mcstructure/assets/js/65.c16cc8f2.js"><link rel="prefetch" href="/mcstructure/assets/js/66.ad2d4521.js"><link rel="prefetch" href="/mcstructure/assets/js/67.83e59ab1.js"><link rel="prefetch" href="/mcstructure/assets/js/68.beec9ddd.js"><link rel="prefetch" href="/mcstructure/assets/js/69.b4bc257c.js"><link rel="prefetch" href="/mcstructure/assets/js/7.fd995bdf.js"><link rel="prefetch" href="/mcstructure/assets/js/70.1ea3abef.js"><link rel="prefetch" href="/mcstructure/assets/js/71.3cf65839.js"><link rel="prefetch" href="/mcstructure/assets/js/72.6f64c4ab.js"><link rel="prefetch" href="/mcstructure/assets/js/73.452d7013.js"><link rel="prefetch" href="/mcstructure/assets/js/74.0660e6d9.js"><link rel="prefetch" href="/mcstructure/assets/js/75.b7b5e783.js"><link rel="prefetch" href="/mcstructure/assets/js/76.5fddaea1.js"><link rel="prefetch" href="/mcstructure/assets/js/77.be26bbc6.js"><link rel="prefetch" href="/mcstructure/assets/js/78.0e00fef4.js"><link rel="prefetch" href="/mcstructure/assets/js/79.731c37fb.js"><link rel="prefetch" href="/mcstructure/assets/js/8.1cbf1ff3.js"><link rel="prefetch" href="/mcstructure/assets/js/80.2282d655.js"><link rel="prefetch" href="/mcstructure/assets/js/81.33a53399.js"><link rel="prefetch" href="/mcstructure/assets/js/82.196f3fc3.js"><link rel="prefetch" href="/mcstructure/assets/js/83.e9cb3f05.js"><link rel="prefetch" href="/mcstructure/assets/js/84.35c05041.js"><link rel="prefetch" href="/mcstructure/assets/js/85.16e996b6.js"><link rel="prefetch" href="/mcstructure/assets/js/86.97412bd5.js"><link rel="prefetch" href="/mcstructure/assets/js/87.2244cc28.js"><link rel="prefetch" href="/mcstructure/assets/js/88.f00d5fcc.js"><link rel="prefetch" href="/mcstructure/assets/js/89.13359307.js"><link rel="prefetch" href="/mcstructure/assets/js/9.86a5a003.js"><link rel="prefetch" href="/mcstructure/assets/js/90.3b4668a2.js"><link rel="prefetch" href="/mcstructure/assets/js/91.85f8c578.js"><link rel="prefetch" href="/mcstructure/assets/js/92.c7bfeb53.js"><link rel="prefetch" href="/mcstructure/assets/js/93.87278538.js"><link rel="prefetch" href="/mcstructure/assets/js/94.9636adb8.js"><link rel="prefetch" href="/mcstructure/assets/js/95.49a2df5b.js"><link rel="prefetch" href="/mcstructure/assets/js/96.f84087c6.js"><link rel="prefetch" href="/mcstructure/assets/js/97.777e52ef.js"><link rel="prefetch" href="/mcstructure/assets/js/98.95f637bf.js"><link rel="prefetch" href="/mcstructure/assets/js/99.535a1eab.js">
    <link rel="stylesheet" href="/mcstructure/assets/css/0.styles.5de0a167.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/mcstructure/" class="home-link router-link-active"><!----> <span class="site-name">MC TIL</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/mcstructure/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/Redbeanw44602/mcstructure" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/mcstructure/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/Redbeanw44602/mcstructure" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Struct</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/mcstructure/1.16.201/structure/A.html" class="sidebar-link">A</a></li><li><a href="/mcstructure/1.16.201/structure/A~1.html" class="sidebar-link">A~1</a></li><li><a href="/mcstructure/1.16.201/structure/B.html" class="sidebar-link">B</a></li><li><a href="/mcstructure/1.16.201/structure/B~1.html" class="sidebar-link">B~1</a></li><li><a href="/mcstructure/1.16.201/structure/B~2.html" class="sidebar-link">B~2</a></li><li><a href="/mcstructure/1.16.201/structure/C.html" class="sidebar-link">C</a></li><li><a href="/mcstructure/1.16.201/structure/C~1.html" class="sidebar-link">C~1</a></li><li><a href="/mcstructure/1.16.201/structure/C~2.html" class="sidebar-link">C~2</a></li><li><a href="/mcstructure/1.16.201/structure/C~3.html" class="sidebar-link">C~3</a></li><li><a href="/mcstructure/1.16.201/structure/D.html" class="sidebar-link">D</a></li><li><a href="/mcstructure/1.16.201/structure/D~1.html" class="sidebar-link">D~1</a></li><li><a href="/mcstructure/1.16.201/structure/D~2.html" class="sidebar-link">D~2</a></li><li><a href="/mcstructure/1.16.201/structure/D~3.html" class="sidebar-link">D~3</a></li><li><a href="/mcstructure/1.16.201/structure/D~4.html" class="sidebar-link">D~4</a></li><li><a href="/mcstructure/1.16.201/structure/D~5.html" class="sidebar-link">D~5</a></li><li><a href="/mcstructure/1.16.201/structure/D~6.html" aria-current="page" class="active sidebar-link">D~6</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/mcstructure/1.16.201/structure/D~7.html" class="sidebar-link">D~7</a></li><li><a href="/mcstructure/1.16.201/structure/D~8.html" class="sidebar-link">D~8</a></li><li><a href="/mcstructure/1.16.201/structure/D~9.html" class="sidebar-link">D~9</a></li><li><a href="/mcstructure/1.16.201/structure/D~10.html" class="sidebar-link">D~10</a></li><li><a href="/mcstructure/1.16.201/structure/E.html" class="sidebar-link">E</a></li><li><a href="/mcstructure/1.16.201/structure/E~1.html" class="sidebar-link">E~1</a></li><li><a href="/mcstructure/1.16.201/structure/F.html" class="sidebar-link">F</a></li><li><a href="/mcstructure/1.16.201/structure/F~1.html" class="sidebar-link">F~1</a></li><li><a href="/mcstructure/1.16.201/structure/G.html" class="sidebar-link">G</a></li><li><a href="/mcstructure/1.16.201/structure/H.html" class="sidebar-link">H</a></li><li><a href="/mcstructure/1.16.201/structure/I.html" class="sidebar-link">I</a></li><li><a href="/mcstructure/1.16.201/structure/I~1.html" class="sidebar-link">I~1</a></li><li><a href="/mcstructure/1.16.201/structure/I~2.html" class="sidebar-link">I~2</a></li><li><a href="/mcstructure/1.16.201/structure/J.html" class="sidebar-link">J</a></li><li><a href="/mcstructure/1.16.201/structure/K.html" class="sidebar-link">K</a></li><li><a href="/mcstructure/1.16.201/structure/L.html" class="sidebar-link">L</a></li><li><a href="/mcstructure/1.16.201/structure/L~1.html" class="sidebar-link">L~1</a></li><li><a href="/mcstructure/1.16.201/structure/M.html" class="sidebar-link">M</a></li><li><a href="/mcstructure/1.16.201/structure/M~1.html" class="sidebar-link">M~1</a></li><li><a href="/mcstructure/1.16.201/structure/M~2.html" class="sidebar-link">M~2</a></li><li><a href="/mcstructure/1.16.201/structure/M~3.html" class="sidebar-link">M~3</a></li><li><a href="/mcstructure/1.16.201/structure/N.html" class="sidebar-link">N</a></li><li><a href="/mcstructure/1.16.201/structure/O.html" class="sidebar-link">O</a></li><li><a href="/mcstructure/1.16.201/structure/P.html" class="sidebar-link">P</a></li><li><a href="/mcstructure/1.16.201/structure/P~1.html" class="sidebar-link">P~1</a></li><li><a href="/mcstructure/1.16.201/structure/P~2.html" class="sidebar-link">P~2</a></li><li><a href="/mcstructure/1.16.201/structure/P~3.html" class="sidebar-link">P~3</a></li><li><a href="/mcstructure/1.16.201/structure/Q.html" class="sidebar-link">Q</a></li><li><a href="/mcstructure/1.16.201/structure/R.html" class="sidebar-link">R</a></li><li><a href="/mcstructure/1.16.201/structure/R~1.html" class="sidebar-link">R~1</a></li><li><a href="/mcstructure/1.16.201/structure/R~2.html" class="sidebar-link">R~2</a></li><li><a href="/mcstructure/1.16.201/structure/R~3.html" class="sidebar-link">R~3</a></li><li><a href="/mcstructure/1.16.201/structure/S.html" class="sidebar-link">S</a></li><li><a href="/mcstructure/1.16.201/structure/S~1.html" class="sidebar-link">S~1</a></li><li><a href="/mcstructure/1.16.201/structure/S~2.html" class="sidebar-link">S~2</a></li><li><a href="/mcstructure/1.16.201/structure/S~3.html" class="sidebar-link">S~3</a></li><li><a href="/mcstructure/1.16.201/structure/S~4.html" class="sidebar-link">S~4</a></li><li><a href="/mcstructure/1.16.201/structure/T.html" class="sidebar-link">T</a></li><li><a href="/mcstructure/1.16.201/structure/T~1.html" class="sidebar-link">T~1</a></li><li><a href="/mcstructure/1.16.201/structure/U.html" class="sidebar-link">U</a></li><li><a href="/mcstructure/1.16.201/structure/V.html" class="sidebar-link">V</a></li><li><a href="/mcstructure/1.16.201/structure/W.html" class="sidebar-link">W</a></li><li><a href="/mcstructure/1.16.201/structure/W~1.html" class="sidebar-link">W~1</a></li><li><a href="/mcstructure/1.16.201/structure/X.html" class="sidebar-link">X</a></li><li><a href="/mcstructure/1.16.201/structure/Z.html" class="sidebar-link">Z</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Enums</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="d-6"><a href="#d-6" class="header-anchor">#</a> D~6</h1> <h3 id="definitioninstance-entitycontext-despawndefinition-despawncomponent"><a href="#definitioninstance-entitycontext-despawndefinition-despawncomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,DespawnDefinition,DespawnComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,DespawnDefinition,DespawnComponent&gt; : DefinitionInstanceTyped&lt;DespawnDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-despawndefinition-despawncomponent-vtbl"><a href="#definitioninstance-entitycontext-despawndefinition-despawncomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,DespawnDefinition,DespawnComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,DespawnDefinition,DespawnComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,DespawnDefinition,DespawnComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,DespawnDefinition,DespawnComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,DespawnDefinition,DespawnComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,DespawnDefinition,DespawnComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-despawndefinition"><a href="#definitionserializer-despawndefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;DespawnDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;DespawnDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;DespawnDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,DespawnDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-despawndefinition-vtbl"><a href="#definitionserializer-despawndefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;DespawnDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;DespawnDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-entitysensordefinition"><a href="#definitioninstancetyped-entitysensordefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;EntitySensorDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;EntitySensorDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;EntitySensorDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-entitysensordefinition-vtbl"><a href="#definitioninstancetyped-entitysensordefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;EntitySensorDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;EntitySensorDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-entitysensordefinition-entitysensorcomponent"><a href="#definitioninstance-entitycontext-entitysensordefinition-entitysensorcomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,EntitySensorDefinition,EntitySensorComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,EntitySensorDefinition,EntitySensorComponent&gt; : DefinitionInstanceTyped&lt;EntitySensorDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-entitysensordefinition-entitysensorcomponent-vtbl"><a href="#definitioninstance-entitycontext-entitysensordefinition-entitysensorcomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,EntitySensorDefinition,EntitySensorComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,EntitySensorDefinition,EntitySensorComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,EntitySensorDefinition,EntitySensorComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,EntitySensorDefinition,EntitySensorComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,EntitySensorDefinition,EntitySensorComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,EntitySensorDefinition,EntitySensorComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-entitysensordefinition"><a href="#definitionserializer-entitysensordefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;EntitySensorDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;EntitySensorDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;EntitySensorDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,EntitySensorDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-entitysensordefinition-vtbl"><a href="#definitionserializer-entitysensordefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;EntitySensorDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;EntitySensorDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-environmentsensordefinition-actorflagcomponent-environmentsensorflag"><a href="#definitioninstance-entitycontext-environmentsensordefinition-actorflagcomponent-environmentsensorflag" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,EnvironmentSensorDefinition,ActorFlagComponent&lt;EnvironmentSensorFlag&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,EnvironmentSensorDefinition,ActorFlagComponent&lt;EnvironmentSensorFlag&gt; &gt; : DefinitionInstanceTyped&lt;EnvironmentSensorDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-environmentsensordefinition-actorflagcomponent-environmentsensorflag-vtbl"><a href="#definitioninstance-entitycontext-environmentsensordefinition-actorflagcomponent-environmentsensorflag-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,EnvironmentSensorDefinition,ActorFlagComponent&lt;EnvironmentSensorFlag&gt; &gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,EnvironmentSensorDefinition,ActorFlagComponent&lt;EnvironmentSensorFlag&gt; &gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,EnvironmentSensorDefinition,ActorFlagComponent&lt;EnvironmentSensorFlag&gt; &gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,EnvironmentSensorDefinition,ActorFlagComponent&lt;EnvironmentSensorFlag&gt; &gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,EnvironmentSensorDefinition,ActorFlagComponent&lt;EnvironmentSensorFlag&gt; &gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,EnvironmentSensorDefinition,ActorFlagComponent&lt;EnvironmentSensorFlag&gt; &gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-environmentsensordefinition"><a href="#definitionserializer-environmentsensordefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;EnvironmentSensorDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;EnvironmentSensorDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;EnvironmentSensorDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,EnvironmentSensorDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-environmentsensordefinition-vtbl"><a href="#definitionserializer-environmentsensordefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;EnvironmentSensorDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;EnvironmentSensorDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-equipitemcomponent-definition"><a href="#definitioninstancetyped-equipitemcomponent-definition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;EquipItemComponent::Definition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;EquipItemComponent::Definition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;EquipItemComponent::Definition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-equipitemcomponent-definition-vtbl"><a href="#definitioninstancetyped-equipitemcomponent-definition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;EquipItemComponent::Definition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;EquipItemComponent::Definition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-equipitemcomponent-definition-equipitemcomponent"><a href="#definitioninstance-entitycontext-equipitemcomponent-definition-equipitemcomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,EquipItemComponent::Definition,EquipItemComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,EquipItemComponent::Definition,EquipItemComponent&gt; : DefinitionInstanceTyped&lt;EquipItemComponent::Definition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-equipitemcomponent-definition-equipitemcomponent-vtbl"><a href="#definitioninstance-entitycontext-equipitemcomponent-definition-equipitemcomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,EquipItemComponent::Definition,EquipItemComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,EquipItemComponent::Definition,EquipItemComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,EquipItemComponent::Definition,EquipItemComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,EquipItemComponent::Definition,EquipItemComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,EquipItemComponent::Definition,EquipItemComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,EquipItemComponent::Definition,EquipItemComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-equipitemcomponent-definition"><a href="#definitionserializer-equipitemcomponent-definition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;EquipItemComponent::Definition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;EquipItemComponent::Definition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;EquipItemComponent::Definition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,EquipItemComponent::Definition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-equipitemcomponent-definition-vtbl"><a href="#definitionserializer-equipitemcomponent-definition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;EquipItemComponent::Definition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;EquipItemComponent::Definition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-equippabledefinition-equippablecomponent"><a href="#definitioninstance-entitycontext-equippabledefinition-equippablecomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,EquippableDefinition,EquippableComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,EquippableDefinition,EquippableComponent&gt; : DefinitionInstanceTyped&lt;EquippableDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-equippabledefinition-equippablecomponent-vtbl"><a href="#definitioninstance-entitycontext-equippabledefinition-equippablecomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,EquippableDefinition,EquippableComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,EquippableDefinition,EquippableComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,EquippableDefinition,EquippableComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,EquippableDefinition,EquippableComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,EquippableDefinition,EquippableComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,EquippableDefinition,EquippableComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-equippabledefinition"><a href="#definitionserializer-equippabledefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;EquippableDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;EquippableDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;EquippableDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,EquippableDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-equippabledefinition-vtbl"><a href="#definitionserializer-equippabledefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;EquippableDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;EquippableDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-experiencerewarddefinition"><a href="#definitioninstancetyped-experiencerewarddefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;ExperienceRewardDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;ExperienceRewardDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;ExperienceRewardDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-experiencerewarddefinition-vtbl"><a href="#definitioninstancetyped-experiencerewarddefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;ExperienceRewardDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;ExperienceRewardDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-experiencerewarddefinition-experiencerewardcomponent"><a href="#definitioninstance-entitycontext-experiencerewarddefinition-experiencerewardcomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ExperienceRewardDefinition,ExperienceRewardComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,ExperienceRewardDefinition,ExperienceRewardComponent&gt; : DefinitionInstanceTyped&lt;ExperienceRewardDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-experiencerewarddefinition-experiencerewardcomponent-vtbl"><a href="#definitioninstance-entitycontext-experiencerewarddefinition-experiencerewardcomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ExperienceRewardDefinition,ExperienceRewardComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,ExperienceRewardDefinition,ExperienceRewardComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,ExperienceRewardDefinition,ExperienceRewardComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,ExperienceRewardDefinition,ExperienceRewardComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,ExperienceRewardDefinition,ExperienceRewardComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,ExperienceRewardDefinition,ExperienceRewardComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-experiencerewarddefinition"><a href="#definitionserializer-experiencerewarddefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ExperienceRewardDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;ExperienceRewardDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;ExperienceRewardDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,ExperienceRewardDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-experiencerewarddefinition-vtbl"><a href="#definitionserializer-experiencerewarddefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ExperienceRewardDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;ExperienceRewardDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-explodedefinition-explodecomponent"><a href="#definitioninstance-entitycontext-explodedefinition-explodecomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ExplodeDefinition,ExplodeComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,ExplodeDefinition,ExplodeComponent&gt; : DefinitionInstanceTyped&lt;ExplodeDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-explodedefinition-explodecomponent-vtbl"><a href="#definitioninstance-entitycontext-explodedefinition-explodecomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ExplodeDefinition,ExplodeComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,ExplodeDefinition,ExplodeComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,ExplodeDefinition,ExplodeComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,ExplodeDefinition,ExplodeComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,ExplodeDefinition,ExplodeComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,ExplodeDefinition,ExplodeComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-explodedefinition"><a href="#definitionserializer-explodedefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ExplodeDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;ExplodeDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;ExplodeDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,ExplodeDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-explodedefinition-vtbl"><a href="#definitionserializer-explodedefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ExplodeDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;ExplodeDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-flockingdefinition"><a href="#definitioninstancetyped-flockingdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;FlockingDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;FlockingDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;FlockingDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-flockingdefinition-vtbl"><a href="#definitioninstancetyped-flockingdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;FlockingDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;FlockingDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-flockingdefinition-flockingcomponent"><a href="#definitioninstance-entitycontext-flockingdefinition-flockingcomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,FlockingDefinition,FlockingComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,FlockingDefinition,FlockingComponent&gt; : DefinitionInstanceTyped&lt;FlockingDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-flockingdefinition-flockingcomponent-vtbl"><a href="#definitioninstance-entitycontext-flockingdefinition-flockingcomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,FlockingDefinition,FlockingComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,FlockingDefinition,FlockingComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,FlockingDefinition,FlockingComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,FlockingDefinition,FlockingComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,FlockingDefinition,FlockingComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,FlockingDefinition,FlockingComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-flockingdefinition"><a href="#definitionserializer-flockingdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;FlockingDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;FlockingDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;FlockingDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,FlockingDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-flockingdefinition-vtbl"><a href="#definitionserializer-flockingdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;FlockingDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;FlockingDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-geneticsdefinition-geneticscomponent"><a href="#definitioninstance-entitycontext-geneticsdefinition-geneticscomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,GeneticsDefinition,GeneticsComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,GeneticsDefinition,GeneticsComponent&gt; : DefinitionInstanceTyped&lt;GeneticsDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-geneticsdefinition-geneticscomponent-vtbl"><a href="#definitioninstance-entitycontext-geneticsdefinition-geneticscomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,GeneticsDefinition,GeneticsComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,GeneticsDefinition,GeneticsComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,GeneticsDefinition,GeneticsComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,GeneticsDefinition,GeneticsComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,GeneticsDefinition,GeneticsComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,GeneticsDefinition,GeneticsComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-geneticsdefinition"><a href="#definitionserializer-geneticsdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;GeneticsDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;GeneticsDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;GeneticsDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,GeneticsDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-geneticsdefinition-vtbl"><a href="#definitionserializer-geneticsdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;GeneticsDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;GeneticsDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-giveabledefinition-giveablecomponent"><a href="#definitioninstance-entitycontext-giveabledefinition-giveablecomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,GiveableDefinition,GiveableComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,GiveableDefinition,GiveableComponent&gt; : DefinitionInstanceTyped&lt;GiveableDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-giveabledefinition-giveablecomponent-vtbl"><a href="#definitioninstance-entitycontext-giveabledefinition-giveablecomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,GiveableDefinition,GiveableComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,GiveableDefinition,GiveableComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,GiveableDefinition,GiveableComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,GiveableDefinition,GiveableComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,GiveableDefinition,GiveableComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,GiveableDefinition,GiveableComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-giveabledefinition"><a href="#definitionserializer-giveabledefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;GiveableDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;GiveableDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;GiveableDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,GiveableDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-giveabledefinition-vtbl"><a href="#definitionserializer-giveabledefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;GiveableDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;GiveableDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-groupsizedefinition-groupsizecomponent"><a href="#definitioninstance-entitycontext-groupsizedefinition-groupsizecomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,GroupSizeDefinition,GroupSizeComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,GroupSizeDefinition,GroupSizeComponent&gt; : DefinitionInstanceTyped&lt;GroupSizeDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-groupsizedefinition-groupsizecomponent-vtbl"><a href="#definitioninstance-entitycontext-groupsizedefinition-groupsizecomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,GroupSizeDefinition,GroupSizeComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,GroupSizeDefinition,GroupSizeComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,GroupSizeDefinition,GroupSizeComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,GroupSizeDefinition,GroupSizeComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,GroupSizeDefinition,GroupSizeComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,GroupSizeDefinition,GroupSizeComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-groupsizedefinition"><a href="#definitionserializer-groupsizedefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;GroupSizeDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;GroupSizeDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;GroupSizeDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,GroupSizeDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-groupsizedefinition-vtbl"><a href="#definitionserializer-groupsizedefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;GroupSizeDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;GroupSizeDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-growscropdefinition-growscropcomponent"><a href="#definitioninstance-entitycontext-growscropdefinition-growscropcomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,GrowsCropDefinition,GrowsCropComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,GrowsCropDefinition,GrowsCropComponent&gt; : DefinitionInstanceTyped&lt;GrowsCropDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-growscropdefinition-growscropcomponent-vtbl"><a href="#definitioninstance-entitycontext-growscropdefinition-growscropcomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,GrowsCropDefinition,GrowsCropComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,GrowsCropDefinition,GrowsCropComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,GrowsCropDefinition,GrowsCropComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,GrowsCropDefinition,GrowsCropComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,GrowsCropDefinition,GrowsCropComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,GrowsCropDefinition,GrowsCropComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-growscropdefinition"><a href="#definitionserializer-growscropdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;GrowsCropDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;GrowsCropDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;GrowsCropDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,GrowsCropDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-growscropdefinition-vtbl"><a href="#definitionserializer-growscropdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;GrowsCropDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;GrowsCropDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-healabledefinition-healablecomponent"><a href="#definitioninstance-entitycontext-healabledefinition-healablecomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,HealableDefinition,HealableComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,HealableDefinition,HealableComponent&gt; : DefinitionInstanceTyped&lt;HealableDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-healabledefinition-healablecomponent-vtbl"><a href="#definitioninstance-entitycontext-healabledefinition-healablecomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,HealableDefinition,HealableComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,HealableDefinition,HealableComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,HealableDefinition,HealableComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,HealableDefinition,HealableComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,HealableDefinition,HealableComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,HealableDefinition,HealableComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-healabledefinition"><a href="#definitionserializer-healabledefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;HealableDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;HealableDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;HealableDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,HealableDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-healabledefinition-vtbl"><a href="#definitionserializer-healabledefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;HealableDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;HealableDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-hitboxdefinition"><a href="#definitioninstancetyped-hitboxdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;HitboxDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;HitboxDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;HitboxDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-hitboxdefinition-vtbl"><a href="#definitioninstancetyped-hitboxdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;HitboxDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;HitboxDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-hitboxdefinition-hitboxcomponent"><a href="#definitioninstance-entitycontext-hitboxdefinition-hitboxcomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,HitboxDefinition,HitboxComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,HitboxDefinition,HitboxComponent&gt; : DefinitionInstanceTyped&lt;HitboxDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-hitboxdefinition-hitboxcomponent-vtbl"><a href="#definitioninstance-entitycontext-hitboxdefinition-hitboxcomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,HitboxDefinition,HitboxComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,HitboxDefinition,HitboxComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,HitboxDefinition,HitboxComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,HitboxDefinition,HitboxComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,HitboxDefinition,HitboxComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,HitboxDefinition,HitboxComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-hitboxdefinition"><a href="#definitionserializer-hitboxdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;HitboxDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;HitboxDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;HitboxDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,HitboxDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-hitboxdefinition-vtbl"><a href="#definitionserializer-hitboxdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;HitboxDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;HitboxDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-homedefinition-homecomponent"><a href="#definitioninstance-entitycontext-homedefinition-homecomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,HomeDefinition,HomeComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,HomeDefinition,HomeComponent&gt; : DefinitionInstanceTyped&lt;HomeDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-homedefinition-homecomponent-vtbl"><a href="#definitioninstance-entitycontext-homedefinition-homecomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,HomeDefinition,HomeComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,HomeDefinition,HomeComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,HomeDefinition,HomeComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,HomeDefinition,HomeComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,HomeDefinition,HomeComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,HomeDefinition,HomeComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-homedefinition"><a href="#definitionserializer-homedefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;HomeDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;HomeDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;HomeDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,HomeDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-homedefinition-vtbl"><a href="#definitionserializer-homedefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;HomeDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;HomeDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-hopperdefinition"><a href="#definitioninstancetyped-hopperdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;HopperDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;HopperDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;HopperDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-hopperdefinition-vtbl"><a href="#definitioninstancetyped-hopperdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;HopperDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;HopperDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-hopperdefinition-hoppercomponent"><a href="#definitioninstance-entitycontext-hopperdefinition-hoppercomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,HopperDefinition,HopperComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,HopperDefinition,HopperComponent&gt; : DefinitionInstanceTyped&lt;HopperDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-hopperdefinition-hoppercomponent-vtbl"><a href="#definitioninstance-entitycontext-hopperdefinition-hoppercomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,HopperDefinition,HopperComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,HopperDefinition,HopperComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,HopperDefinition,HopperComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,HopperDefinition,HopperComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,HopperDefinition,HopperComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,HopperDefinition,HopperComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-hopperdefinition"><a href="#definitionserializer-hopperdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;HopperDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;HopperDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;HopperDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,HopperDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-hopperdefinition-vtbl"><a href="#definitionserializer-hopperdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;HopperDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;HopperDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-hurtonconditiondefinition-hurtonconditioncomponent"><a href="#definitioninstance-entitycontext-hurtonconditiondefinition-hurtonconditioncomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,HurtOnConditionDefinition,HurtOnConditionComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,HurtOnConditionDefinition,HurtOnConditionComponent&gt; : DefinitionInstanceTyped&lt;HurtOnConditionDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-hurtonconditiondefinition-hurtonconditioncomponent-vtbl"><a href="#definitioninstance-entitycontext-hurtonconditiondefinition-hurtonconditioncomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,HurtOnConditionDefinition,HurtOnConditionComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,HurtOnConditionDefinition,HurtOnConditionComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,HurtOnConditionDefinition,HurtOnConditionComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,HurtOnConditionDefinition,HurtOnConditionComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,HurtOnConditionDefinition,HurtOnConditionComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,HurtOnConditionDefinition,HurtOnConditionComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-hurtonconditiondefinition"><a href="#definitionserializer-hurtonconditiondefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;HurtOnConditionDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;HurtOnConditionDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;HurtOnConditionDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,HurtOnConditionDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-hurtonconditiondefinition-vtbl"><a href="#definitionserializer-hurtonconditiondefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;HurtOnConditionDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;HurtOnConditionDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-insideblocknotifierdefinition"><a href="#definitioninstancetyped-insideblocknotifierdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;InsideBlockNotifierDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;InsideBlockNotifierDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;InsideBlockNotifierDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-insideblocknotifierdefinition-vtbl"><a href="#definitioninstancetyped-insideblocknotifierdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;InsideBlockNotifierDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;InsideBlockNotifierDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-insideblocknotifierdefinition-insideblocknotifiercomponent"><a href="#definitioninstance-entitycontext-insideblocknotifierdefinition-insideblocknotifiercomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,InsideBlockNotifierDefinition,InsideBlockNotifierComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,InsideBlockNotifierDefinition,InsideBlockNotifierComponent&gt; : DefinitionInstanceTyped&lt;InsideBlockNotifierDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-insideblocknotifierdefinition-insideblocknotifiercomponent-vtbl"><a href="#definitioninstance-entitycontext-insideblocknotifierdefinition-insideblocknotifiercomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,InsideBlockNotifierDefinition,InsideBlockNotifierComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,InsideBlockNotifierDefinition,InsideBlockNotifierComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,InsideBlockNotifierDefinition,InsideBlockNotifierComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,InsideBlockNotifierDefinition,InsideBlockNotifierComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,InsideBlockNotifierDefinition,InsideBlockNotifierComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,InsideBlockNotifierDefinition,InsideBlockNotifierComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-insideblocknotifierdefinition"><a href="#definitionserializer-insideblocknotifierdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;InsideBlockNotifierDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;InsideBlockNotifierDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;InsideBlockNotifierDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,InsideBlockNotifierDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-insideblocknotifierdefinition-vtbl"><a href="#definitionserializer-insideblocknotifierdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;InsideBlockNotifierDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;InsideBlockNotifierDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-insomniadefinition-insomniacomponent"><a href="#definitioninstance-entitycontext-insomniadefinition-insomniacomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,InsomniaDefinition,InsomniaComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,InsomniaDefinition,InsomniaComponent&gt; : DefinitionInstanceTyped&lt;InsomniaDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-insomniadefinition-insomniacomponent-vtbl"><a href="#definitioninstance-entitycontext-insomniadefinition-insomniacomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,InsomniaDefinition,InsomniaComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,InsomniaDefinition,InsomniaComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,InsomniaDefinition,InsomniaComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,InsomniaDefinition,InsomniaComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,InsomniaDefinition,InsomniaComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,InsomniaDefinition,InsomniaComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-insomniadefinition"><a href="#definitionserializer-insomniadefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;InsomniaDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;InsomniaDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;InsomniaDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,InsomniaDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-insomniadefinition-vtbl"><a href="#definitionserializer-insomniadefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;InsomniaDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;InsomniaDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-instantdespawndefinition-instantdespawncomponent"><a href="#definitioninstance-entitycontext-instantdespawndefinition-instantdespawncomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,InstantDespawnDefinition,InstantDespawnComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,InstantDespawnDefinition,InstantDespawnComponent&gt; : DefinitionInstanceTyped&lt;InstantDespawnDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-instantdespawndefinition-instantdespawncomponent-vtbl"><a href="#definitioninstance-entitycontext-instantdespawndefinition-instantdespawncomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,InstantDespawnDefinition,InstantDespawnComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,InstantDespawnDefinition,InstantDespawnComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,InstantDespawnDefinition,InstantDespawnComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,InstantDespawnDefinition,InstantDespawnComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,InstantDespawnDefinition,InstantDespawnComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,InstantDespawnDefinition,InstantDespawnComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-instantdespawndefinition"><a href="#definitionserializer-instantdespawndefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;InstantDespawnDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;InstantDespawnDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;InstantDespawnDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,InstantDespawnDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-instantdespawndefinition-vtbl"><a href="#definitionserializer-instantdespawndefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;InstantDespawnDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;InstantDespawnDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-interactdefinition-interactcomponent"><a href="#definitioninstance-entitycontext-interactdefinition-interactcomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,InteractDefinition,InteractComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,InteractDefinition,InteractComponent&gt; : DefinitionInstanceTyped&lt;InteractDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-interactdefinition-interactcomponent-vtbl"><a href="#definitioninstance-entitycontext-interactdefinition-interactcomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,InteractDefinition,InteractComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,InteractDefinition,InteractComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,InteractDefinition,InteractComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,InteractDefinition,InteractComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,InteractDefinition,InteractComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,InteractDefinition,InteractComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-interactdefinition"><a href="#definitionserializer-interactdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;InteractDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;InteractDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;InteractDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,InteractDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-interactdefinition-vtbl"><a href="#definitionserializer-interactdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;InteractDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;InteractDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-leashabledefinition-leashablecomponent"><a href="#definitioninstance-entitycontext-leashabledefinition-leashablecomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,LeashableDefinition,LeashableComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,LeashableDefinition,LeashableComponent&gt; : DefinitionInstanceTyped&lt;LeashableDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-leashabledefinition-leashablecomponent-vtbl"><a href="#definitioninstance-entitycontext-leashabledefinition-leashablecomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,LeashableDefinition,LeashableComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,LeashableDefinition,LeashableComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,LeashableDefinition,LeashableComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,LeashableDefinition,LeashableComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,LeashableDefinition,LeashableComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,LeashableDefinition,LeashableComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-leashabledefinition"><a href="#definitionserializer-leashabledefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;LeashableDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;LeashableDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;LeashableDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,LeashableDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-leashabledefinition-vtbl"><a href="#definitionserializer-leashabledefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;LeashableDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;LeashableDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-legacytradeabledefinition-legacytradeablecomponent"><a href="#definitioninstance-entitycontext-legacytradeabledefinition-legacytradeablecomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,LegacyTradeableDefinition,LegacyTradeableComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,LegacyTradeableDefinition,LegacyTradeableComponent&gt; : DefinitionInstanceTyped&lt;LegacyTradeableDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-legacytradeabledefinition-legacytradeablecomponent-vtbl"><a href="#definitioninstance-entitycontext-legacytradeabledefinition-legacytradeablecomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,LegacyTradeableDefinition,LegacyTradeableComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,LegacyTradeableDefinition,LegacyTradeableComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,LegacyTradeableDefinition,LegacyTradeableComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,LegacyTradeableDefinition,LegacyTradeableComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,LegacyTradeableDefinition,LegacyTradeableComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,LegacyTradeableDefinition,LegacyTradeableComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-legacytradeabledefinition"><a href="#definitionserializer-legacytradeabledefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;LegacyTradeableDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;LegacyTradeableDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;LegacyTradeableDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,LegacyTradeableDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-legacytradeabledefinition-vtbl"><a href="#definitionserializer-legacytradeabledefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;LegacyTradeableDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;LegacyTradeableDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-lookatdefinition-lookatcomponent"><a href="#definitioninstance-entitycontext-lookatdefinition-lookatcomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,LookAtDefinition,LookAtComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,LookAtDefinition,LookAtComponent&gt; : DefinitionInstanceTyped&lt;LookAtDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-lookatdefinition-lookatcomponent-vtbl"><a href="#definitioninstance-entitycontext-lookatdefinition-lookatcomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,LookAtDefinition,LookAtComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,LookAtDefinition,LookAtComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,LookAtDefinition,LookAtComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,LookAtDefinition,LookAtComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,LookAtDefinition,LookAtComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,LookAtDefinition,LookAtComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-lookatdefinition"><a href="#definitionserializer-lookatdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;LookAtDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;LookAtDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;LookAtDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,LookAtDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-lookatdefinition-vtbl"><a href="#definitionserializer-lookatdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;LookAtDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;LookAtDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-mobeffectdefinition"><a href="#definitioninstancetyped-mobeffectdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;MobEffectDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;MobEffectDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;MobEffectDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-mobeffectdefinition-vtbl"><a href="#definitioninstancetyped-mobeffectdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;MobEffectDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;MobEffectDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-mobeffectdefinition-mobeffectcomponent"><a href="#definitioninstance-entitycontext-mobeffectdefinition-mobeffectcomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,MobEffectDefinition,MobEffectComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,MobEffectDefinition,MobEffectComponent&gt; : DefinitionInstanceTyped&lt;MobEffectDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-mobeffectdefinition-mobeffectcomponent-vtbl"><a href="#definitioninstance-entitycontext-mobeffectdefinition-mobeffectcomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,MobEffectDefinition,MobEffectComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,MobEffectDefinition,MobEffectComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,MobEffectDefinition,MobEffectComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,MobEffectDefinition,MobEffectComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,MobEffectDefinition,MobEffectComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,MobEffectDefinition,MobEffectComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-mobeffectdefinition"><a href="#definitionserializer-mobeffectdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;MobEffectDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;MobEffectDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;MobEffectDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,MobEffectDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-mobeffectdefinition-vtbl"><a href="#definitionserializer-mobeffectdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;MobEffectDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;MobEffectDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-mounttameabledefinition-mounttamingcomponent"><a href="#definitioninstance-entitycontext-mounttameabledefinition-mounttamingcomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,MountTameableDefinition,MountTamingComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,MountTameableDefinition,MountTamingComponent&gt; : DefinitionInstanceTyped&lt;MountTameableDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-mounttameabledefinition-mounttamingcomponent-vtbl"><a href="#definitioninstance-entitycontext-mounttameabledefinition-mounttamingcomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,MountTameableDefinition,MountTamingComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,MountTameableDefinition,MountTamingComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,MountTameableDefinition,MountTamingComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,MountTameableDefinition,MountTamingComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,MountTameableDefinition,MountTamingComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,MountTameableDefinition,MountTamingComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-mounttameabledefinition"><a href="#definitionserializer-mounttameabledefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;MountTameableDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;MountTameableDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;MountTameableDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,MountTameableDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-mounttameabledefinition-vtbl"><a href="#definitionserializer-mounttameabledefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;MountTameableDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;MountTameableDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-nameabledefinition-nameablecomponent"><a href="#definitioninstance-entitycontext-nameabledefinition-nameablecomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,NameableDefinition,NameableComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,NameableDefinition,NameableComponent&gt; : DefinitionInstanceTyped&lt;NameableDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-nameabledefinition-nameablecomponent-vtbl"><a href="#definitioninstance-entitycontext-nameabledefinition-nameablecomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,NameableDefinition,NameableComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,NameableDefinition,NameableComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,NameableDefinition,NameableComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,NameableDefinition,NameableComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,NameableDefinition,NameableComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,NameableDefinition,NameableComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-nameabledefinition"><a href="#definitionserializer-nameabledefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;NameableDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;NameableDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;NameableDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,NameableDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-nameabledefinition-vtbl"><a href="#definitionserializer-nameabledefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;NameableDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;NameableDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-outofcontroldefinition"><a href="#definitioninstancetyped-outofcontroldefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;OutOfControlDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;OutOfControlDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;OutOfControlDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-outofcontroldefinition-vtbl"><a href="#definitioninstancetyped-outofcontroldefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;OutOfControlDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;OutOfControlDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-outofcontroldefinition-outofcontrolcomponent"><a href="#definitioninstance-entitycontext-outofcontroldefinition-outofcontrolcomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,OutOfControlDefinition,OutOfControlComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,OutOfControlDefinition,OutOfControlComponent&gt; : DefinitionInstanceTyped&lt;OutOfControlDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-outofcontroldefinition-outofcontrolcomponent-vtbl"><a href="#definitioninstance-entitycontext-outofcontroldefinition-outofcontrolcomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,OutOfControlDefinition,OutOfControlComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,OutOfControlDefinition,OutOfControlComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,OutOfControlDefinition,OutOfControlComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,OutOfControlDefinition,OutOfControlComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,OutOfControlDefinition,OutOfControlComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,OutOfControlDefinition,OutOfControlComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-outofcontroldefinition"><a href="#definitionserializer-outofcontroldefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;OutOfControlDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;OutOfControlDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;OutOfControlDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,OutOfControlDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-outofcontroldefinition-vtbl"><a href="#definitionserializer-outofcontroldefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;OutOfControlDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;OutOfControlDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-peekdefinition"><a href="#definitioninstancetyped-peekdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;PeekDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;PeekDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;PeekDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-peekdefinition-vtbl"><a href="#definitioninstancetyped-peekdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;PeekDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;PeekDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-peekdefinition-peekcomponent"><a href="#definitioninstance-entitycontext-peekdefinition-peekcomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,PeekDefinition,PeekComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,PeekDefinition,PeekComponent&gt; : DefinitionInstanceTyped&lt;PeekDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-peekdefinition-peekcomponent-vtbl"><a href="#definitioninstance-entitycontext-peekdefinition-peekcomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,PeekDefinition,PeekComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,PeekDefinition,PeekComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,PeekDefinition,PeekComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,PeekDefinition,PeekComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,PeekDefinition,PeekComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,PeekDefinition,PeekComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-peekdefinition"><a href="#definitionserializer-peekdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;PeekDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;PeekDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;PeekDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,PeekDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-peekdefinition-vtbl"><a href="#definitionserializer-peekdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;PeekDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;PeekDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-physicsdefinition"><a href="#definitioninstancetyped-physicsdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;PhysicsDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;PhysicsDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;PhysicsDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-physicsdefinition-vtbl"><a href="#definitioninstancetyped-physicsdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;PhysicsDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;PhysicsDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-physicsdefinition-physicscomponent"><a href="#definitioninstance-entitycontext-physicsdefinition-physicscomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,PhysicsDefinition,PhysicsComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,PhysicsDefinition,PhysicsComponent&gt; : DefinitionInstanceTyped&lt;PhysicsDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-physicsdefinition-physicscomponent-vtbl"><a href="#definitioninstance-entitycontext-physicsdefinition-physicscomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,PhysicsDefinition,PhysicsComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,PhysicsDefinition,PhysicsComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,PhysicsDefinition,PhysicsComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,PhysicsDefinition,PhysicsComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,PhysicsDefinition,PhysicsComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,PhysicsDefinition,PhysicsComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-physicsdefinition"><a href="#definitionserializer-physicsdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;PhysicsDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;PhysicsDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;PhysicsDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,PhysicsDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-physicsdefinition-vtbl"><a href="#definitionserializer-physicsdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;PhysicsDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;PhysicsDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-railactivatordefinition"><a href="#definitioninstancetyped-railactivatordefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;RailActivatorDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;RailActivatorDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;RailActivatorDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-railactivatordefinition-vtbl"><a href="#definitioninstancetyped-railactivatordefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;RailActivatorDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;RailActivatorDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-railactivatordefinition-railactivatorcomponent"><a href="#definitioninstance-entitycontext-railactivatordefinition-railactivatorcomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,RailActivatorDefinition,RailActivatorComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,RailActivatorDefinition,RailActivatorComponent&gt; : DefinitionInstanceTyped&lt;RailActivatorDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-railactivatordefinition-railactivatorcomponent-vtbl"><a href="#definitioninstance-entitycontext-railactivatordefinition-railactivatorcomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,RailActivatorDefinition,RailActivatorComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,RailActivatorDefinition,RailActivatorComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,RailActivatorDefinition,RailActivatorComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,RailActivatorDefinition,RailActivatorComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,RailActivatorDefinition,RailActivatorComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,RailActivatorDefinition,RailActivatorComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-railactivatordefinition"><a href="#definitionserializer-railactivatordefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;RailActivatorDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;RailActivatorDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;RailActivatorDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,RailActivatorDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-railactivatordefinition-vtbl"><a href="#definitionserializer-railactivatordefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;RailActivatorDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;RailActivatorDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-railmovementdefinition"><a href="#definitioninstancetyped-railmovementdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;RailMovementDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;RailMovementDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;RailMovementDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-railmovementdefinition-vtbl"><a href="#definitioninstancetyped-railmovementdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;RailMovementDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;RailMovementDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-railmovementdefinition-railmovementcomponent"><a href="#definitioninstance-entitycontext-railmovementdefinition-railmovementcomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,RailMovementDefinition,RailMovementComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,RailMovementDefinition,RailMovementComponent&gt; : DefinitionInstanceTyped&lt;RailMovementDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-railmovementdefinition-railmovementcomponent-vtbl"><a href="#definitioninstance-entitycontext-railmovementdefinition-railmovementcomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,RailMovementDefinition,RailMovementComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,RailMovementDefinition,RailMovementComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,RailMovementDefinition,RailMovementComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,RailMovementDefinition,RailMovementComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,RailMovementDefinition,RailMovementComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,RailMovementDefinition,RailMovementComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-railmovementdefinition"><a href="#definitionserializer-railmovementdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;RailMovementDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;RailMovementDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;RailMovementDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,RailMovementDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-railmovementdefinition-vtbl"><a href="#definitionserializer-railmovementdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;RailMovementDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;RailMovementDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-rideabledefinition-rideablecomponent"><a href="#definitioninstance-entitycontext-rideabledefinition-rideablecomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,RideableDefinition,RideableComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,RideableDefinition,RideableComponent&gt; : DefinitionInstanceTyped&lt;RideableDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-rideabledefinition-rideablecomponent-vtbl"><a href="#definitioninstance-entitycontext-rideabledefinition-rideablecomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,RideableDefinition,RideableComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,RideableDefinition,RideableComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,RideableDefinition,RideableComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,RideableDefinition,RideableComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,RideableDefinition,RideableComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,RideableDefinition,RideableComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-rideabledefinition"><a href="#definitionserializer-rideabledefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;RideableDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;RideableDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;RideableDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,RideableDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-rideabledefinition-vtbl"><a href="#definitionserializer-rideabledefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;RideableDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;RideableDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-scaffoldingclimberdefinition"><a href="#definitioninstancetyped-scaffoldingclimberdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;ScaffoldingClimberDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;ScaffoldingClimberDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;ScaffoldingClimberDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-scaffoldingclimberdefinition-vtbl"><a href="#definitioninstancetyped-scaffoldingclimberdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;ScaffoldingClimberDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;ScaffoldingClimberDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-scaffoldingclimberdefinition-scaffoldingclimbercomponent"><a href="#definitioninstance-entitycontext-scaffoldingclimberdefinition-scaffoldingclimbercomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ScaffoldingClimberDefinition,ScaffoldingClimberComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,ScaffoldingClimberDefinition,ScaffoldingClimberComponent&gt; : DefinitionInstanceTyped&lt;ScaffoldingClimberDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-scaffoldingclimberdefinition-scaffoldingclimbercomponent-vtbl"><a href="#definitioninstance-entitycontext-scaffoldingclimberdefinition-scaffoldingclimbercomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ScaffoldingClimberDefinition,ScaffoldingClimberComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,ScaffoldingClimberDefinition,ScaffoldingClimberComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,ScaffoldingClimberDefinition,ScaffoldingClimberComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,ScaffoldingClimberDefinition,ScaffoldingClimberComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,ScaffoldingClimberDefinition,ScaffoldingClimberComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,ScaffoldingClimberDefinition,ScaffoldingClimberComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-scaffoldingclimberdefinition"><a href="#definitionserializer-scaffoldingclimberdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ScaffoldingClimberDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;ScaffoldingClimberDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;ScaffoldingClimberDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,ScaffoldingClimberDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-scaffoldingclimberdefinition-vtbl"><a href="#definitionserializer-scaffoldingclimberdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ScaffoldingClimberDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;ScaffoldingClimberDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-scalebyagedefinition-scalebyagecomponent"><a href="#definitioninstance-entitycontext-scalebyagedefinition-scalebyagecomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ScaleByAgeDefinition,ScaleByAgeComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,ScaleByAgeDefinition,ScaleByAgeComponent&gt; : DefinitionInstanceTyped&lt;ScaleByAgeDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-scalebyagedefinition-scalebyagecomponent-vtbl"><a href="#definitioninstance-entitycontext-scalebyagedefinition-scalebyagecomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ScaleByAgeDefinition,ScaleByAgeComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,ScaleByAgeDefinition,ScaleByAgeComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,ScaleByAgeDefinition,ScaleByAgeComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,ScaleByAgeDefinition,ScaleByAgeComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,ScaleByAgeDefinition,ScaleByAgeComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,ScaleByAgeDefinition,ScaleByAgeComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-scalebyagedefinition"><a href="#definitionserializer-scalebyagedefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ScaleByAgeDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;ScaleByAgeDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;ScaleByAgeDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,ScaleByAgeDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-scalebyagedefinition-vtbl"><a href="#definitionserializer-scalebyagedefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ScaleByAgeDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;ScaleByAgeDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-schedulerdefinition-schedulercomponent"><a href="#definitioninstance-entitycontext-schedulerdefinition-schedulercomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,SchedulerDefinition,SchedulerComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,SchedulerDefinition,SchedulerComponent&gt; : DefinitionInstanceTyped&lt;SchedulerDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-schedulerdefinition-schedulercomponent-vtbl"><a href="#definitioninstance-entitycontext-schedulerdefinition-schedulercomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,SchedulerDefinition,SchedulerComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,SchedulerDefinition,SchedulerComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,SchedulerDefinition,SchedulerComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,SchedulerDefinition,SchedulerComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,SchedulerDefinition,SchedulerComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,SchedulerDefinition,SchedulerComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-schedulerdefinition"><a href="#definitionserializer-schedulerdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;SchedulerDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;SchedulerDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;SchedulerDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,SchedulerDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-schedulerdefinition-vtbl"><a href="#definitionserializer-schedulerdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;SchedulerDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;SchedulerDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-shareabledefinition-shareablecomponent"><a href="#definitioninstance-entitycontext-shareabledefinition-shareablecomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ShareableDefinition,ShareableComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,ShareableDefinition,ShareableComponent&gt; : DefinitionInstanceTyped&lt;ShareableDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-shareabledefinition-shareablecomponent-vtbl"><a href="#definitioninstance-entitycontext-shareabledefinition-shareablecomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ShareableDefinition,ShareableComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,ShareableDefinition,ShareableComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,ShareableDefinition,ShareableComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,ShareableDefinition,ShareableComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,ShareableDefinition,ShareableComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,ShareableDefinition,ShareableComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-shareabledefinition"><a href="#definitionserializer-shareabledefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ShareableDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;ShareableDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;ShareableDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,ShareableDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-shareabledefinition-vtbl"><a href="#definitionserializer-shareabledefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ShareableDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;ShareableDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-shooterdefinition-shootercomponent"><a href="#definitioninstance-entitycontext-shooterdefinition-shootercomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ShooterDefinition,ShooterComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,ShooterDefinition,ShooterComponent&gt; : DefinitionInstanceTyped&lt;ShooterDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-shooterdefinition-shootercomponent-vtbl"><a href="#definitioninstance-entitycontext-shooterdefinition-shootercomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ShooterDefinition,ShooterComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,ShooterDefinition,ShooterComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,ShooterDefinition,ShooterComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,ShooterDefinition,ShooterComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,ShooterDefinition,ShooterComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,ShooterDefinition,ShooterComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-shooterdefinition"><a href="#definitionserializer-shooterdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ShooterDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;ShooterDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;ShooterDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,ShooterDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-shooterdefinition-vtbl"><a href="#definitionserializer-shooterdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ShooterDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;ShooterDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-sittabledefinition-sitcomponent"><a href="#definitioninstance-entitycontext-sittabledefinition-sitcomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,SittableDefinition,SitComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,SittableDefinition,SitComponent&gt; : DefinitionInstanceTyped&lt;SittableDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-sittabledefinition-sitcomponent-vtbl"><a href="#definitioninstance-entitycontext-sittabledefinition-sitcomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,SittableDefinition,SitComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,SittableDefinition,SitComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,SittableDefinition,SitComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,SittableDefinition,SitComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,SittableDefinition,SitComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,SittableDefinition,SitComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-sittabledefinition"><a href="#definitionserializer-sittabledefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;SittableDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;SittableDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;SittableDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,SittableDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-sittabledefinition-vtbl"><a href="#definitionserializer-sittabledefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;SittableDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;SittableDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-tameabledefinition-tameablecomponent"><a href="#definitioninstance-entitycontext-tameabledefinition-tameablecomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,TameableDefinition,TameableComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,TameableDefinition,TameableComponent&gt; : DefinitionInstanceTyped&lt;TameableDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-tameabledefinition-tameablecomponent-vtbl"><a href="#definitioninstance-entitycontext-tameabledefinition-tameablecomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,TameableDefinition,TameableComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,TameableDefinition,TameableComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,TameableDefinition,TameableComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,TameableDefinition,TameableComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,TameableDefinition,TameableComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,TameableDefinition,TameableComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-tameabledefinition"><a href="#definitionserializer-tameabledefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;TameableDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;TameableDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;TameableDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,TameableDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-tameabledefinition-vtbl"><a href="#definitionserializer-tameabledefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;TameableDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;TameableDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-timerdefinition-timercomponent"><a href="#definitioninstance-entitycontext-timerdefinition-timercomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,TimerDefinition,TimerComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,TimerDefinition,TimerComponent&gt; : DefinitionInstanceTyped&lt;TimerDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-timerdefinition-timercomponent-vtbl"><a href="#definitioninstance-entitycontext-timerdefinition-timercomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,TimerDefinition,TimerComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,TimerDefinition,TimerComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,TimerDefinition,TimerComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,TimerDefinition,TimerComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,TimerDefinition,TimerComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,TimerDefinition,TimerComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-timerdefinition"><a href="#definitionserializer-timerdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;TimerDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;TimerDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;TimerDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,TimerDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-timerdefinition-vtbl"><a href="#definitionserializer-timerdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;TimerDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;TimerDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-spawnactordefinition-spawnactorcomponent"><a href="#definitioninstance-entitycontext-spawnactordefinition-spawnactorcomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,SpawnActorDefinition,SpawnActorComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,SpawnActorDefinition,SpawnActorComponent&gt; : DefinitionInstanceTyped&lt;SpawnActorDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-spawnactordefinition-spawnactorcomponent-vtbl"><a href="#definitioninstance-entitycontext-spawnactordefinition-spawnactorcomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,SpawnActorDefinition,SpawnActorComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,SpawnActorDefinition,SpawnActorComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,SpawnActorDefinition,SpawnActorComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,SpawnActorDefinition,SpawnActorComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,SpawnActorDefinition,SpawnActorComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,SpawnActorDefinition,SpawnActorComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-spawnactordefinition"><a href="#definitionserializer-spawnactordefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;SpawnActorDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;SpawnActorDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;SpawnActorDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,SpawnActorDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-spawnactordefinition-vtbl"><a href="#definitionserializer-spawnactordefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;SpawnActorDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;SpawnActorDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-trustingdefinition-trustingcomponent"><a href="#definitioninstance-entitycontext-trustingdefinition-trustingcomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,TrustingDefinition,TrustingComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,TrustingDefinition,TrustingComponent&gt; : DefinitionInstanceTyped&lt;TrustingDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-trustingdefinition-trustingcomponent-vtbl"><a href="#definitioninstance-entitycontext-trustingdefinition-trustingcomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,TrustingDefinition,TrustingComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,TrustingDefinition,TrustingComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,TrustingDefinition,TrustingComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,TrustingDefinition,TrustingComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,TrustingDefinition,TrustingComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,TrustingDefinition,TrustingComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-trustingdefinition"><a href="#definitionserializer-trustingdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;TrustingDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;TrustingDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;TrustingDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,TrustingDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-trustingdefinition-vtbl"><a href="#definitionserializer-trustingdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;TrustingDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;TrustingDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-balloondefinition-ballooncomponent"><a href="#definitioninstance-entitycontext-balloondefinition-ballooncomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,BalloonDefinition,BalloonComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,BalloonDefinition,BalloonComponent&gt; : DefinitionInstanceTyped&lt;BalloonDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-balloondefinition-ballooncomponent-vtbl"><a href="#definitioninstance-entitycontext-balloondefinition-ballooncomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,BalloonDefinition,BalloonComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,BalloonDefinition,BalloonComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,BalloonDefinition,BalloonComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,BalloonDefinition,BalloonComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,BalloonDefinition,BalloonComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,BalloonDefinition,BalloonComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-balloondefinition"><a href="#definitionserializer-balloondefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;BalloonDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;BalloonDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;BalloonDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BalloonDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-balloondefinition-vtbl"><a href="#definitionserializer-balloondefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;BalloonDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;BalloonDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-balloonabledefinition-balloonablecomponent"><a href="#definitioninstance-entitycontext-balloonabledefinition-balloonablecomponent" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,BalloonableDefinition,BalloonableComponent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,BalloonableDefinition,BalloonableComponent&gt; : DefinitionInstanceTyped&lt;BalloonableDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-balloonabledefinition-balloonablecomponent-vtbl"><a href="#definitioninstance-entitycontext-balloonabledefinition-balloonablecomponent-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,BalloonableDefinition,BalloonableComponent&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,BalloonableDefinition,BalloonableComponent&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,BalloonableDefinition,BalloonableComponent&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,BalloonableDefinition,BalloonableComponent&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,BalloonableDefinition,BalloonableComponent&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,BalloonableDefinition,BalloonableComponent&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-balloonabledefinition"><a href="#definitionserializer-balloonabledefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;BalloonableDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;BalloonableDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;BalloonableDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BalloonableDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-balloonabledefinition-vtbl"><a href="#definitionserializer-balloonabledefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;BalloonableDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;BalloonableDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-nearestattackabletargetdefinition"><a href="#definitioninstancetyped-nearestattackabletargetdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;NearestAttackableTargetDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;NearestAttackableTargetDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;NearestAttackableTargetDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-nearestattackabletargetdefinition-vtbl"><a href="#definitioninstancetyped-nearestattackabletargetdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;NearestAttackableTargetDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;NearestAttackableTargetDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-nearestattackabletargetdefinition-nearestattackabletargetgoal"><a href="#definitioninstance-entitycontext-nearestattackabletargetdefinition-nearestattackabletargetgoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,NearestAttackableTargetDefinition,NearestAttackableTargetGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,NearestAttackableTargetDefinition,NearestAttackableTargetGoal&gt; : DefinitionInstanceTyped&lt;NearestAttackableTargetDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-nearestattackabletargetdefinition-nearestattackabletargetgoal-vtbl"><a href="#definitioninstance-entitycontext-nearestattackabletargetdefinition-nearestattackabletargetgoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,NearestAttackableTargetDefinition,NearestAttackableTargetGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,NearestAttackableTargetDefinition,NearestAttackableTargetGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,NearestAttackableTargetDefinition,NearestAttackableTargetGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,NearestAttackableTargetDefinition,NearestAttackableTargetGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,NearestAttackableTargetDefinition,NearestAttackableTargetGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,NearestAttackableTargetDefinition,NearestAttackableTargetGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-nearestattackabletargetdefinition"><a href="#definitionserializer-nearestattackabletargetdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;NearestAttackableTargetDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;NearestAttackableTargetDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;NearestAttackableTargetDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,NearestAttackableTargetDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-nearestattackabletargetdefinition-vtbl"><a href="#definitionserializer-nearestattackabletargetdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;NearestAttackableTargetDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;NearestAttackableTargetDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="drinkpotiongoal"><a href="#drinkpotiongoal" class="header-anchor">#</a> <code>DrinkPotionGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DrinkPotionGoal : Goal
{
  Mob *mMob;
  const float mWalkSpeedModifier;
  const std::vector&lt;DrinkPotionData&gt; mDrinkPotionData;
  int mThrottleCooldown;
  int mUsingTime;
  AttributeModifier mSpeedAttributeModifier;
};

</code></pre></div><h3 id="drinkpotiongoal-vtbl"><a href="#drinkpotiongoal-vtbl" class="header-anchor">#</a> <code>DrinkPotionGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DrinkPotionGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="defendtrustedtargetgoal"><a href="#defendtrustedtargetgoal" class="header-anchor">#</a> <code>DefendTrustedTargetGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefendTrustedTargetGoal : NearestAttackableTargetGoal
{
  LevelSoundEvent mAggroSound;
  const DefinitionTrigger mOnStartEvent;
};

</code></pre></div><h3 id="defendtrustedtargetgoal-vtbl"><a href="#defendtrustedtargetgoal-vtbl" class="header-anchor">#</a> <code>DefendTrustedTargetGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefendTrustedTargetGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
  bool (__fastcall *_canAttack)(TargetGoal *this, Mob *, Actor *, bool, bool, const MobDescriptor **);
  ActorUniqueID *(__fastcall *_findTarget)(NearestAttackableTargetGoal *this, ActorUniqueID *result, const MobDescriptor **);
};

</code></pre></div><h3 id="dolphin"><a href="#dolphin" class="header-anchor">#</a> <code>Dolphin</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Dolphin : WaterAnimal
{
  int mBreatheCounter;
};

</code></pre></div><h3 id="decoratordefinition"><a href="#decoratordefinition" class="header-anchor">#</a> <code>DecoratorDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DecoratorDefinition : BehaviorDefinition
{
  std::unique_ptr&lt;BehaviorDefinition&gt; mChild;
};

</code></pre></div><h3 id="decoratordefinition-vtbl"><a href="#decoratordefinition-vtbl" class="header-anchor">#</a> <code>DecoratorDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DecoratorDefinition_vtbl
{
  void (__fastcall *~BehaviorDefinition)(BehaviorDefinition *this);
  void (__fastcall *load)(BehaviorDefinition *this, Json::Value, const BehaviorFactory *);
  std::unique_ptr&lt;BehaviorNode&gt; *(__fastcall *createNode)(BehaviorDefinition *this, std::unique_ptr&lt;BehaviorNode&gt; *result, Actor *, const BehaviorFactory *, BehaviorNode *, BehaviorData *);
};

</code></pre></div><h3 id="destroyblocks-l14-lambda-ec037d1b7fb645caffe4fefc3634d19a"><a href="#destroyblocks-l14-lambda-ec037d1b7fb645caffe4fefc3634d19a" class="header-anchor">#</a> <code>destroyBlocks::__l14::&lt;lambda_ec037d1b7fb645caffe4fefc3634d19a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj destroyBlocks::__l14::&lt;lambda_ec037d1b7fb645caffe4fefc3634d19a&gt;
{
  const std::string *actorId;
  const Block *block;
  BlockPos *targetBlockPos;
  BlockSource *region;
};

</code></pre></div><h3 id="dispenserblockactor"><a href="#dispenserblockactor" class="header-anchor">#</a> <code>DispenserBlockActor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) DispenserBlockActor : RandomizableBlockActorContainer
{
  ItemStack mItems[9];
  Random mRandom;
};

</code></pre></div><h3 id="dropperblockactor"><a href="#dropperblockactor" class="header-anchor">#</a> <code>DropperBlockActor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DropperBlockActor : DispenserBlockActor
{
};

</code></pre></div><h3 id="directmobmovementproxy"><a href="#directmobmovementproxy" class="header-anchor">#</a> <code>DirectMobMovementProxy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DirectMobMovementProxy : DirectMobMovementProxyImpl&lt;IMobMovementProxy&gt;
{
};

</code></pre></div><h3 id="dragonfireball"><a href="#dragonfireball" class="header-anchor">#</a> <code>DragonFireball</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DragonFireball : Fireball
{
};

</code></pre></div><h3 id="dragonfireball-vtbl"><a href="#dragonfireball-vtbl" class="header-anchor">#</a> <code>DragonFireball_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DragonFireball_vtbl
{
  bool (__fastcall *hasComponent)(Actor *this, const HashedString *);
  void (__fastcall *reloadHardcoded)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadHardcodedClient)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *initializeComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *_serverInitItemStackIds)(Actor *this);
  void (__fastcall *_doInitialMove)(Actor *this);
  bool (__fastcall *checkAllSensitiveWords)(Actor *this);
  bool (__fastcall *checkNameTag)(Actor *this);
  void (__fastcall *~Actor)(Actor *this);
  void (__fastcall *reset)(Actor *this);
  int (__fastcall *getOnDeathExperience)(Actor *this);
  ActorType (__fastcall *getOwnerEntityType)(Actor *this);
  void (__fastcall *remove)(Actor *this);
  void (__fastcall *setPos)(Actor *this, const Vec3 *);
  const PredictedMovementValues *(__fastcall *getPredictedMovementValues)(Actor *this);
  const Vec3 *(__fastcall *getPos)(Actor *this);
  const Vec3 *(__fastcall *getPosOld)(Actor *this);
  const Vec3 *(__fastcall *getPosExtrapolated)(Actor *this, const Vec3 *result, float);
  Vec3 *(__fastcall *getAttachPos)(Actor *this, Vec3 *result, ActorLocation, float);
  Vec3 *(__fastcall *getFiringPos)(Actor *this, Vec3 *result);
  void (__fastcall *setRot)(Actor *this, const Vec2 *);
  void (__fastcall *move)(Actor *this, IActorMovementProxy *, const Vec3 *);
  void (__fastcall *move)(Actor *this, const Vec3 *);
  Vec3 *(__fastcall *getInterpolatedRidingPosition)(Actor *this, Vec3 *result, float);
  float (__fastcall *getInterpolatedBodyRot)(Actor *this, float);
  float (__fastcall *getInterpolatedHeadRot)(Actor *this, float);
  float (__fastcall *getInterpolatedBodyYaw)(Actor *this, float);
  float (__fastcall *getYawSpeedInDegreesPerSecond)(Actor *this);
  float (__fastcall *getInterpolatedWalkAnimSpeed)(Actor *this, float);
  Vec3 *(__fastcall *getInterpolatedRidingOffset)(Actor *this, Vec3 *result, float);
  void (__fastcall *checkBlockCollisions)(Actor *this);
  void (__fastcall *checkBlockCollisions)(Actor *this, const AABB *, std::function&lt;void __cdecl(BlockSource &amp;,Block const &amp;,BlockPos const &amp;,Actor &amp;)&gt;);
  bool (__fastcall *isFireImmune)(Actor *this);
  bool (__fastcall *breaksFallingBlocks)(Actor *this);
  void (__fastcall *blockedByShield)(Actor *this, const ActorDamageSource *, Actor *);
  void (__fastcall *teleportTo)(Actor *this, const Vec3 *, bool, int, int, const ActorUniqueID *);
  bool (__fastcall *tryTeleportTo)(Actor *this, const Vec3 *, bool, bool, int, int);
  void (__fastcall *chorusFruitTeleport)(Actor *this, Vec3 *);
  void (__fastcall *lerpTo)(Actor *this, const Vec3 *, const Vec2 *, int);
  void (__fastcall *lerpMotion)(Actor *this, const Vec3 *);
  std::unique_ptr&lt;AddActorBasePacket&gt; *(__fastcall *getAddPacket)(Actor *this, std::unique_ptr&lt;AddActorBasePacket&gt; *result);
  void (__fastcall *normalTick)(Actor *this);
  void (__fastcall *baseTick)(Actor *this);
  void (__fastcall *rideTick)(Actor *this);
  void (__fastcall *positionRider)(Actor *this, Actor *, float);
  float (__fastcall *getRidingHeight)(Actor *this);
  bool (__fastcall *startRiding)(Actor *this, Actor *);
  void (__fastcall *addRider)(Actor *this, Actor *);
  void (__fastcall *flagRiderToRemove)(Actor *this, Actor *);
  std::string *(__fastcall *getExitTip)(Actor *this, std::string *result, const std::string *, InputMode);
  bool (__fastcall *intersects)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *, float);
  bool (__fastcall *isInWall)(Actor *this);
  bool (__fastcall *isInvisible)(Actor *this);
  bool (__fastcall *canShowNameTag)(Actor *this);
  bool (__fastcall *canExistInPeaceful)(Actor *this);
  void (__fastcall *setNameTagVisible)(Actor *this, bool);
  const std::string *(__fastcall *getNameTag)(Actor *this);
  unsigned __int64 (__fastcall *getNameTagAsHash)(Actor *this);
  std::string *(__fastcall *getFormattedNameTag)(Actor *this, std::string *result);
  void (__fastcall *filterFormattedNameTag)(Actor *this, const UIProfanityContext *);
  void (__fastcall *setNameTag)(Actor *this, const std::string *);
  bool (__fastcall *getAlwaysShowNameTag)(Actor *this);
  void (__fastcall *setScoreTag)(Actor *this, const std::string *);
  const std::string *(__fastcall *getScoreTag)(Actor *this);
  bool (__fastcall *isInWater)(Actor *this);
  bool (__fastcall *hasEnteredWater)(Actor *this);
  bool (__fastcall *isImmersedInWater)(Actor *this);
  bool (__fastcall *isInWaterOrRain)(Actor *this);
  bool (__fastcall *isInLava)(Actor *this);
  bool (__fastcall *isUnderLiquid)(Actor *this, MaterialType);
  bool (__fastcall *isOverWater)(Actor *this);
  void (__fastcall *makeStuckInBlock)(Actor *this, const Vec3 *);
  float (__fastcall *getCameraOffset)(Actor *this);
  float (__fastcall *getShadowHeightOffs)(Actor *this);
  float (__fastcall *getShadowRadius)(Actor *this);
  Vec3 *(__fastcall *getHeadLookVector)(Actor *this, Vec3 *result, float);
  bool (__fastcall *canSeeInvisible)(Actor *this);
  bool (__fastcall *canSee)(Actor *this, const Vec3 *);
  bool (__fastcall *canSee)(Actor *this, const Actor *);
  bool (__fastcall *isSkyLit)(Actor *this, float);
  float (__fastcall *getBrightness)(Actor *this, float);
  bool (__fastcall *interactPreventDefault)(Actor *this);
  void (__fastcall *playerTouch)(Actor *this, Player *);
  void (__fastcall *onAboveBubbleColumn)(Actor *this, const bool);
  void (__fastcall *onInsideBubbleColumn)(Actor *this, const bool);
  bool (__fastcall *isImmobile)(Actor *this);
  bool (__fastcall *isSilent)(Actor *this);
  bool (__fastcall *isPickable)(Actor *this);
  bool (__fastcall *isFishable)(Actor *this);
  bool (__fastcall *isSleeping)(Actor *this);
  bool (__fastcall *isShootable)(Actor *this);
  void (__fastcall *setSneaking)(Actor *this, bool);
  bool (__fastcall *isBlocking)(Actor *this);
  bool (__fastcall *isDamageBlocked)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *isAlive)(Actor *this);
  bool (__fastcall *isOnFire)(Actor *this);
  bool (__fastcall *isOnHotBlock)(Actor *this);
  bool (__fastcall *isCreativeModeAllowed)(Actor *this);
  bool (__fastcall *isSurfaceMob)(Actor *this);
  bool (__fastcall *isTargetable)(Actor *this);
  bool (__fastcall *isLocalPlayer)(Actor *this);
  bool (__fastcall *isPlayer)(Actor *this);
  bool (__fastcall *canAttack)(Actor *this, Actor *, bool);
  void (__fastcall *setTarget)(Actor *this, Actor *);
  Actor *(__fastcall *findAttackTarget)(Actor *this);
  bool (__fastcall *isValidTarget)(Actor *this, Actor *);
  bool (__fastcall *attack)(Actor *this, Actor *);
  void (__fastcall *performRangedAttack)(Actor *this, Actor *, float);
  void (__fastcall *adjustDamageAmount)(Actor *this, int *);
  int (__fastcall *getEquipmentCount)(Actor *this);
  void (__fastcall *setOwner)(Actor *this, const ActorUniqueID);
  void (__fastcall *setSitting)(Actor *this, bool);
  void (__fastcall *onTame)(Actor *this);
  void (__fastcall *onFailedTame)(Actor *this);
  int (__fastcall *getInventorySize)(Actor *this);
  int (__fastcall *getEquipSlots)(Actor *this);
  int (__fastcall *getChestSlots)(Actor *this);
  void (__fastcall *setStanding)(Actor *this, bool);
  bool (__fastcall *canPowerJump)(Actor *this);
  void (__fastcall *setCanPowerJump)(Actor *this, bool);
  bool (__fastcall *isJumping)(Actor *this);
  bool (__fastcall *isEnchanted)(Actor *this);
  void (__fastcall *rideJumped)(Actor *this);
  void (__fastcall *rideLanded)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *shouldRender)(Actor *this);
  bool (__fastcall *isInvulnerableTo)(Actor *this, const ActorDamageSource *);
  ActorDamageCause (__fastcall *getBlockDamageCause)(Actor *this, const Block *);
  void (__fastcall *actuallyHurt)(Actor *this, int, const ActorDamageSource *, bool);
  void (__fastcall *animateHurt)(Actor *this);
  bool (__fastcall *doFireHurt)(Actor *this, int);
  void (__fastcall *onLightningHit)(Actor *this);
  void (__fastcall *onBounceStarted)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *feed)(Actor *this, int);
  void (__fastcall *handleEntityEvent)(Actor *this, ActorEvent, int);
  float (__fastcall *getPickRadius)(Actor *this);
  const HashedString *(__fastcall *getActorRendererId)(Actor *this);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const ItemStack *, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int);
  void (__fastcall *despawn)(Actor *this);
  void (__fastcall *killed)(Actor *this, Actor *);
  void (__fastcall *awardKillScore)(Actor *this, Actor *, int);
  void (__fastcall *setArmor)(Actor *this, ArmorSlot, const ItemStack *);
  const ItemStack *(__fastcall *getArmor)(Actor *this, ArmorSlot);
  ArmorMaterialType (__fastcall *getArmorMaterialTypeInSlot)(Actor *this, ArmorSlot);
  ArmorTextureType (__fastcall *getArmorMaterialTextureTypeInSlot)(Actor *this, ArmorSlot);
  float (__fastcall *getArmorColorInSlot)(Actor *this, ArmorSlot, int);
  const ItemStack *(__fastcall *getEquippedSlot)(Actor *this, EquipmentSlot);
  void (__fastcall *setEquippedSlot)(Actor *this, EquipmentSlot, const ItemStack *);
  const ItemStack *(__fastcall *getCarriedItem)(Actor *this);
  void (__fastcall *setCarriedItem)(Actor *this, const ItemStack *);
  void (__fastcall *setOffhandSlot)(Actor *this, const ItemStack *);
  const ItemStack *(__fastcall *getEquippedTotem)(Actor *this);
  bool (__fastcall *consumeTotem)(Actor *this);
  bool (__fastcall *save)(Actor *this, CompoundTag *);
  void (__fastcall *saveWithoutId)(Actor *this, CompoundTag *);
  bool (__fastcall *load)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *loadLinks)(Actor *this, const CompoundTag *, std::vector&lt;ActorLink&gt; *, DataLoadHelper *);
  ActorType (__fastcall *getEntityTypeId)(Actor *this);
  const HashedString *(__fastcall *queryEntityRenderer)(Actor *this);
  ActorUniqueID *(__fastcall *getSourceUniqueID)(Actor *this, ActorUniqueID *result);
  void (__fastcall *setOnFire)(Actor *this, int);
  AABB *(__fastcall *getHandleWaterAABB)(Actor *this, AABB *result);
  void (__fastcall *handleInsidePortal)(Actor *this, const BlockPos *);
  int (__fastcall *getPortalCooldown)(Actor *this);
  int (__fastcall *getPortalWaitTime)(Actor *this);
  AutomaticID&lt;Dimension,int&gt; *(__fastcall *getDimensionId)(Actor *this, AutomaticID&lt;Dimension,int&gt; *result);
  bool (__fastcall *canChangeDimensions)(Actor *this);
  void (__fastcall *changeDimension)(Actor *this, const ChangeDimensionPacket *);
  void (__fastcall *changeDimension)(Actor *this, AutomaticID&lt;Dimension,int&gt;, bool);
  ActorUniqueID *(__fastcall *getControllingPlayer)(Actor *this, ActorUniqueID *result);
  void (__fastcall *checkFallDamage)(Actor *this, float, bool);
  void (__fastcall *causeFallDamage)(Actor *this, float);
  void (__fastcall *handleFallDistanceOnServer)(Actor *this, float, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, int, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, const Block *, bool);
  void (__fastcall *onSynchedDataUpdate)(Actor *this, int);
  bool (__fastcall *canAddRider)(Actor *this, Actor *);
  bool (__fastcall *canPickupItem)(Actor *this, const ItemStack *);
  bool (__fastcall *canBePulledIntoVehicle)(Actor *this);
  bool (__fastcall *inCaravan)(Actor *this);
  bool (__fastcall *isLeashableType)(Actor *this);
  void (__fastcall *tickLeash)(Actor *this);
  void (__fastcall *sendMotionPacketIfNeeded)(Actor *this);
  bool (__fastcall *canSynchronizeNewEntity)(Actor *this);
  bool (__fastcall *stopRiding)(Actor *this, bool, bool, bool, bool);
  void (__fastcall *startSwimming)(Actor *this);
  void (__fastcall *stopSwimming)(Actor *this);
  void (__fastcall *buildDebugInfo)(Actor *this, std::string *);
  CommandPermissionLevel (__fastcall *getCommandPermissionLevel)(Actor *this);
  AttributeInstance *(__fastcall *getMutableAttribute)(Actor *this, const Attribute *);
  const AttributeInstance *(__fastcall *getAttribute)(Actor *this, const Attribute *);
  int (__fastcall *getDeathTime)(Actor *this);
  void (__fastcall *heal)(Actor *this, int);
  bool (__fastcall *isInvertedHealAndHarm)(Actor *this);
  bool (__fastcall *canBeAffected)(Actor *this, const MobEffectInstance *);
  bool (__fastcall *canBeAffected)(Actor *this, int);
  bool (__fastcall *canBeAffectedByArrow)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectAdded)(Actor *this, MobEffectInstance *);
  void (__fastcall *onEffectUpdated)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectRemoved)(Actor *this, MobEffectInstance *);
  AnimationComponent *(__fastcall *getAnimationComponent)(Actor *this);
  void (__fastcall *openContainerComponent)(Actor *this, Player *);
  void (__fastcall *swing)(Actor *this);
  void (__fastcall *useItem)(Actor *this, ItemStackBase *, ItemUseMethod, bool);
  bool (__fastcall *hasOutputSignal)(Actor *this, unsigned __int8);
  int (__fastcall *getOutputSignal)(Actor *this);
  void (__fastcall *getDebugText)(Actor *this, std::vector&lt;std::string&gt; *);
  float (__fastcall *getMapDecorationRotation)(Actor *this);
  float (__fastcall *getRiderYRotation)(Actor *this, const Actor *);
  float (__fastcall *getYHeadRot)(Actor *this);
  bool (__fastcall *isWorldBuilder)(Actor *this);
  bool (__fastcall *isCreative)(Actor *this);
  bool (__fastcall *isAdventure)(Actor *this);
  bool (__fastcall *add)(Actor *this, ItemStack *);
  bool (__fastcall *drop)(Actor *this, const ItemStack *, bool);
  bool (__fastcall *getInteraction)(Actor *this, Player *, ActorInteraction *, const Vec3 *);
  bool (__fastcall *canDestroyBlock)(Actor *this, const Block *);
  void (__fastcall *setAuxValue)(Actor *this, int);
  void (__fastcall *setSize)(Actor *this, float, float);
  int (__fastcall *getLifeSpan)(Actor *this);
  void (__fastcall *onOrphan)(Actor *this);
  void (__fastcall *wobble)(Actor *this);
  bool (__fastcall *wasHurt)(Actor *this);
  void (__fastcall *startSpinAttack)(Actor *this);
  void (__fastcall *stopSpinAttack)(Actor *this);
  void (__fastcall *setDamageNearbyMobs)(Actor *this, bool);
  bool (__fastcall *hasCritBox)(Actor *this);
  bool (__fastcall *isCritHit)(Actor *this);
  void (__fastcall *renderDebugServerState)(Actor *this, const Options *);
  void (__fastcall *reloadLootTable)(Actor *this, const EquipmentTableDefinition *);
  void (__fastcall *reloadLootTable)(Actor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(Actor *this);
  void (__fastcall *kill)(Actor *this);
  void (__fastcall *die)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *shouldTick)(Actor *this);
  std::shared_ptr&lt;IActorMovementProxy&gt; *(__fastcall *createMovementProxy)(Actor *this, std::shared_ptr&lt;IActorMovementProxy&gt; *result);
  void (__fastcall *updateEntitySpecificMolangVariables)(Actor *this, RenderParams *);
  bool (__fastcall *shouldTryMakeStepSound)(Actor *this);
  float (__fastcall *getNextStep)(Actor *this, const float);
  bool (__fastcall *canMakeStepSound)(Actor *this);
  void (__fastcall *outOfWorld)(Actor *this);
  bool (__fastcall *_hurt)(Actor *this, const ActorDamageSource *, int, bool, bool);
  void (__fastcall *markHurt)(Actor *this);
  void (__fastcall *readAdditionalSaveData)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *addAdditionalSaveData)(Actor *this, CompoundTag *);
  void (__fastcall *_playStepSound)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *_playFlySound)(Actor *this, const BlockPos *, const Block *);
  bool (__fastcall *_makeFlySound)(Actor *this);
  void (__fastcall *checkInsideBlocks)(Actor *this, float);
  void (__fastcall *pushOutOfBlocks)(Actor *this, const Vec3 *);
  bool (__fastcall *updateWaterState)(Actor *this);
  void (__fastcall *doWaterSplashEffect)(Actor *this);
  void (__fastcall *spawnTrailBubbles)(Actor *this);
  void (__fastcall *updateInsideBlock)(Actor *this);
  LootTable *(__fastcall *getLootTable)(Actor *this);
  LootTable *(__fastcall *getDefaultLootTable)(Actor *this);
  void (__fastcall *_removeRider)(Actor *this, const ActorUniqueID *, bool, bool, bool);
  void (__fastcall *_onSizeUpdated)(Actor *this);
  void (__fastcall *_doAutoAttackOnTouch)(Actor *this, Actor *);
  float (__fastcall *getInertia)(Fireball *this);
  void (__fastcall *onHit)(Fireball *this, const HitResult *);
  ParticleType (__fastcall *getTrailParticle)(Fireball *this);
  bool (__fastcall *shouldBurn)(Fireball *this);
};

</code></pre></div><h3 id="dispenserblock"><a href="#dispenserblock" class="header-anchor">#</a> <code>DispenserBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DispenserBlock : ActorBlock
{
};

</code></pre></div><h3 id="dispenserblock-vtbl"><a href="#dispenserblock-vtbl" class="header-anchor">#</a> <code>DispenserBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DispenserBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
  int (__fastcall *getTickDelay)(DispenserBlock *this);
  void (__fastcall *dispenseFrom)(DispenserBlock *this, BlockSource *, const BlockPos *);
};

</code></pre></div><h3 id="dirtblock"><a href="#dirtblock" class="header-anchor">#</a> <code>DirtBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DirtBlock : BlockLegacy
{
};

</code></pre></div><h3 id="dirtblock-vtbl"><a href="#dirtblock-vtbl" class="header-anchor">#</a> <code>DirtBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DirtBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="diggeritem"><a href="#diggeritem" class="header-anchor">#</a> <code>DiggerItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DiggerItem : Item
{
  float mSpeed;
  const Item::Tier mTier;
  int mAttackDamage;
  std::vector&lt;Block const *&gt; mBlocks;
  std::set&lt;BlockLegacy const *&gt; m_bBlocks;
};

</code></pre></div><h3 id="dooritem"><a href="#dooritem" class="header-anchor">#</a> <code>DoorItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) DoorItem : Item
{
  DoorBlock::DoorType mType;
};

</code></pre></div><h3 id="dyepowderitem"><a href="#dyepowderitem" class="header-anchor">#</a> <code>DyePowderItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DyePowderItem : FertilizerItem
{
  _BYTE mColor[1];
  bool mIsFertilizer;
  bool mIsCocoaBean;
  TextureAtlasItem m_uvTextureItem;
};

</code></pre></div><h3 id="diggingenchant"><a href="#diggingenchant" class="header-anchor">#</a> <code>DiggingEnchant</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DiggingEnchant : Enchant
{
};

</code></pre></div><h3 id="diggingenchant-vtbl"><a href="#diggingenchant-vtbl" class="header-anchor">#</a> <code>DiggingEnchant_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DiggingEnchant_vtbl
{
  void (__fastcall *~Enchant)(Enchant *this);
  bool (__fastcall *isCompatibleWith)(Enchant *this, Enchant::Type);
  int (__fastcall *getMinCost)(Enchant *this, int);
  int (__fastcall *getMaxCost)(Enchant *this, int);
  int (__fastcall *getMinLevel)(Enchant *this);
  int (__fastcall *getMaxLevel)(Enchant *this);
  int (__fastcall *getDamageProtection)(Enchant *this, int, const ActorDamageSource *);
  float (__fastcall *getDamageBonus)(Enchant *this, int, const Actor *);
  void (__fastcall *doPostAttack)(Enchant *this, Actor *, Actor *, int);
  void (__fastcall *doPostHurt)(Enchant *this, ItemInstance *, Actor *, Actor *, int);
  bool (__fastcall *isMeleeDamageEnchant)(Enchant *this);
  bool (__fastcall *isProtectionEnchant)(Enchant *this);
  bool (__fastcall *isTreasureOnly)(Enchant *this);
  bool (__fastcall *isDiscoverable)(Enchant *this);
};

</code></pre></div><h3 id="deprecatedslabblockitem"><a href="#deprecatedslabblockitem" class="header-anchor">#</a> <code>DeprecatedSlabBlockItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DeprecatedSlabBlockItem : BlockItem
{
};

</code></pre></div><h3 id="daylightdetectorblockactor"><a href="#daylightdetectorblockactor" class="header-anchor">#</a> <code>DaylightDetectorBlockActor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DaylightDetectorBlockActor : BlockActor
{
};

</code></pre></div><h3 id="daylightdetectorblockactor-vtbl"><a href="#daylightdetectorblockactor-vtbl" class="header-anchor">#</a> <code>DaylightDetectorBlockActor_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DaylightDetectorBlockActor_vtbl
{
  void (__fastcall *~BlockActor)(BlockActor *this);
  void (__fastcall *load)(BlockActor *this, Level *, const CompoundTag *, DataLoadHelper *);
  bool (__fastcall *save)(BlockActor *this, CompoundTag *);
  bool (__fastcall *saveItemInstanceData)(BlockActor *this, CompoundTag *);
  void (__fastcall *saveBlockData)(BlockActor *this, CompoundTag *, BlockSource *);
  void (__fastcall *loadBlockData)(BlockActor *this, const CompoundTag *, BlockSource *, DataLoadHelper *);
  void (__fastcall *onCustomTagLoadDone)(BlockActor *this, BlockSource *);
  void (__fastcall *tick)(BlockActor *this, BlockSource *);
  bool (__fastcall *isFinished)(BlockActor *this);
  void (__fastcall *onChanged)(BlockActor *this, BlockSource *);
  bool (__fastcall *isMovable)(BlockActor *this, BlockSource *);
  bool (__fastcall *isCustomNameSaved)(BlockActor *this);
  bool (__fastcall *onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *, const Player *);
  void (__fastcall *onPlace)(BlockActor *this, BlockSource *);
  void (__fastcall *onMove)(BlockActor *this);
  void (__fastcall *onRemoved)(BlockActor *this, BlockSource *);
  void (__fastcall *triggerEvent)(BlockActor *this, int, int);
  void (__fastcall *clearCache)(BlockActor *this);
  void (__fastcall *onNeighborChanged)(BlockActor *this, BlockSource *, const BlockPos *);
  float (__fastcall *getShadowRadius)(BlockActor *this, BlockSource *);
  bool (__fastcall *hasAlphaLayer)(BlockActor *this);
  BlockActor *(__fastcall *getCrackEntity)(BlockActor *this, BlockSource *, const BlockPos *);
  void (__fastcall *getDebugText)(BlockActor *this, std::vector&lt;std::string&gt; *, const BlockPos *);
  const std::string *(__fastcall *getCustomName)(BlockActor *this);
  const std::string *(__fastcall *getFilteredCustomName)(BlockActor *this, const UIProfanityContext *);
  std::string *(__fastcall *getName)(BlockActor *this, std::string *result);
  void (__fastcall *setCustomName)(BlockActor *this, const std::string *);
  std::string *(__fastcall *getImmersiveReaderText)(BlockActor *this, std::string *result, BlockSource *);
  int (__fastcall *getRepairCost)(BlockActor *this);
  PistonBlockActor *(__fastcall *getOwningPiston)(BlockActor *this, BlockSource *);
  const Container *(__fastcall *getContainer)(BlockActor *this);
  Container *(__fastcall *getContainer)(BlockActor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(BlockActor *this);
  void (__fastcall *checkWordsOnChunkLoad)(BlockActor *this, LevelChunk *);
  void (__fastcall *checkWordsOnUpdate)(BlockActor *this, Player *);
  void (__fastcall *onChunkLoaded)(BlockActor *this, LevelChunk *);
  void (__fastcall *onChunkUnloaded)(BlockActor *this, LevelChunk *);
  std::unique_ptr&lt;BlockActorDataPacket&gt; *(__fastcall *_getUpdatePacket)(BlockActor *this, std::unique_ptr&lt;BlockActorDataPacket&gt; *result, BlockSource *);
  void (__fastcall *_onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *);
  bool (__fastcall *_playerCanUpdate)(BlockActor *this, const Player *);
};

</code></pre></div><h3 id="daylightdetectorblock"><a href="#daylightdetectorblock" class="header-anchor">#</a> <code>DaylightDetectorBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) DaylightDetectorBlock : ActorBlock
{
  bool mIsInverted;
};

</code></pre></div><h3 id="daylightdetectorblock-vtbl"><a href="#daylightdetectorblock-vtbl" class="header-anchor">#</a> <code>DaylightDetectorBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DaylightDetectorBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
  void (__fastcall *updateShape)(DaylightDetectorBlock *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateSignalStrength)(DaylightDetectorBlock *this, BlockSource *, const BlockPos *);
};

</code></pre></div><h3 id="dropperblock"><a href="#dropperblock" class="header-anchor">#</a> <code>DropperBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DropperBlock : DispenserBlock
{
};

</code></pre></div><h3 id="dropperblock-vtbl"><a href="#dropperblock-vtbl" class="header-anchor">#</a> <code>DropperBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DropperBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
  int (__fastcall *getTickDelay)(DispenserBlock *this);
  void (__fastcall *dispenseFrom)(DispenserBlock *this, BlockSource *, const BlockPos *);
};

</code></pre></div><h3 id="defaultmobspawner"><a href="#defaultmobspawner" class="header-anchor">#</a> <code>DefaultMobSpawner</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefaultMobSpawner : BaseMobSpawner
{
  MobSpawnerBlockActor *mOwner;
};

</code></pre></div><h3 id="defaultmobspawner-vtbl"><a href="#defaultmobspawner-vtbl" class="header-anchor">#</a> <code>DefaultMobSpawner_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefaultMobSpawner_vtbl
{
  void (__fastcall *~BaseMobSpawner)(BaseMobSpawner *this);
  void (__fastcall *tick)(BaseMobSpawner *this, BlockSource *);
  void (__fastcall *load)(BaseMobSpawner *this, const CompoundTag *);
  void (__fastcall *save)(BaseMobSpawner *this, CompoundTag *);
  const BlockPos *(__fastcall *getPos)(BaseMobSpawner *this);
};

</code></pre></div><h3 id="deadbush"><a href="#deadbush" class="header-anchor">#</a> <code>DeadBush</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DeadBush : BushBlock
{
};

</code></pre></div><h3 id="deadbush-vtbl"><a href="#deadbush-vtbl" class="header-anchor">#</a> <code>DeadBush_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DeadBush_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *checkAlive)(BushBlock *this, BlockSource *, const BlockPos *);
};

</code></pre></div><h3 id="detectorrailblock"><a href="#detectorrailblock" class="header-anchor">#</a> <code>DetectorRailBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DetectorRailBlock : BaseRailBlock
{
};

</code></pre></div><h3 id="detectorrailblock-vtbl"><a href="#detectorrailblock-vtbl" class="header-anchor">#</a> <code>DetectorRailBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DetectorRailBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="dragoneggblock"><a href="#dragoneggblock" class="header-anchor">#</a> <code>DragonEggBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DragonEggBlock : HeavyBlock
{
};

</code></pre></div><h3 id="dragoneggblock-vtbl"><a href="#dragoneggblock-vtbl" class="header-anchor">#</a> <code>DragonEggBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DragonEggBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  mce::Color *(__fastcall *getDustColor)(HeavyBlock *this, mce::Color *result, const Block *);
  std::string *(__fastcall *getDustParticleName)(HeavyBlock *this, std::string *result, const Block *);
  bool (__fastcall *falling)(HeavyBlock *this);
  void (__fastcall *onLand)(HeavyBlock *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isFreeToFall)(HeavyBlock *this, BlockSource *, const BlockPos *);
  void (__fastcall *startFalling)(HeavyBlock *this, BlockSource *, const BlockPos *, const Block *, bool);
};

</code></pre></div><h3 id="driedkelpblock"><a href="#driedkelpblock" class="header-anchor">#</a> <code>DriedKelpBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DriedKelpBlock : BlockLegacy
{
};

</code></pre></div><h3 id="driedkelpblock-vtbl"><a href="#driedkelpblock-vtbl" class="header-anchor">#</a> <code>DriedKelpBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DriedKelpBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="dimension-tryloadlimboentities-l2-lambda-957a6a9f8df991c2cd75a74c66548bb0"><a href="#dimension-tryloadlimboentities-l2-lambda-957a6a9f8df991c2cd75a74c66548bb0" class="header-anchor">#</a> <code>Dimension::tryLoadLimboEntities::__l2::&lt;lambda_957a6a9f8df991c2cd75a74c66548bb0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Dimension::tryLoadLimboEntities::__l2::&lt;lambda_957a6a9f8df991c2cd75a74c66548bb0&gt;
{
  Dimension *const __this;
  const ChunkPos *loadPos;
  ActorFactory *actorFactory;
  DefaultDataLoadHelper *dataLoadHelper;
};

</code></pre></div><h3 id="dimension-sendpacketforentity-l2-lambda-5347cf0c96c68c8f1c1d2cd5fcf0f654"><a href="#dimension-sendpacketforentity-l2-lambda-5347cf0c96c68c8f1c1d2cd5fcf0f654" class="header-anchor">#</a> <code>Dimension::sendPacketForEntity::__l2::&lt;lambda_5347cf0c96c68c8f1c1d2cd5fcf0f654&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Dimension::sendPacketForEntity::__l2::&lt;lambda_5347cf0c96c68c8f1c1d2cd5fcf0f654&gt;
{
  std::vector&lt;NetworkIdentifierWithSubId&gt; *ids;
  const Player **except;
  const Actor *entity;
  Dimension *const __this;
};

</code></pre></div><h3 id="dimension-sendpacketforposition-l2-lambda-5c32e6cbe81653b3e3fc0884fe7a6e00"><a href="#dimension-sendpacketforposition-l2-lambda-5c32e6cbe81653b3e3fc0884fe7a6e00" class="header-anchor">#</a> <code>Dimension::sendPacketForPosition::__l2::&lt;lambda_5c32e6cbe81653b3e3fc0884fe7a6e00&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Dimension::sendPacketForPosition::__l2::&lt;lambda_5c32e6cbe81653b3e3fc0884fe7a6e00&gt;
{
  Dimension *const __this;
  std::vector&lt;NetworkIdentifierWithSubId&gt; *ids;
  const Player **except;
  const BlockPos *position;
};

</code></pre></div><h3 id="dimension-sendbroadcast-l2-lambda-4a04bb60d83343c5fc4a0580ed8cad38"><a href="#dimension-sendbroadcast-l2-lambda-4a04bb60d83343c5fc4a0580ed8cad38" class="header-anchor">#</a> <code>Dimension::sendBroadcast::__l2::&lt;lambda_4a04bb60d83343c5fc4a0580ed8cad38&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Dimension::sendBroadcast::__l2::&lt;lambda_4a04bb60d83343c5fc4a0580ed8cad38&gt;
{
  Player **except;
  std::vector&lt;NetworkIdentifierWithSubId&gt; *ids;
};

</code></pre></div><h3 id="dimension-onleveldestruction-l2-lambda-931a35fe94392b4d9295e10589efda8e"><a href="#dimension-onleveldestruction-l2-lambda-931a35fe94392b4d9295e10589efda8e" class="header-anchor">#</a> <code>Dimension::onLevelDestruction::__l2::&lt;lambda_931a35fe94392b4d9295e10589efda8e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Dimension::onLevelDestruction::__l2::&lt;lambda_931a35fe94392b4d9295e10589efda8e&gt;
{
};

</code></pre></div><h3 id="dimension-trygetclosestpublicregion-l2-lambda-fc74881ffd5910f8a281febf198344f4"><a href="#dimension-trygetclosestpublicregion-l2-lambda-fc74881ffd5910f8a281febf198344f4" class="header-anchor">#</a> <code>Dimension::tryGetClosestPublicRegion::__l2::&lt;lambda_fc74881ffd5910f8a281febf198344f4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Dimension::tryGetClosestPublicRegion::__l2::&lt;lambda_fc74881ffd5910f8a281febf198344f4&gt;
{
  const ChunkPos *pos;
  BlockSource **foundSource;
};

</code></pre></div><h3 id="dimension-distancetonearestplayersqr2d-l2-lambda-39375131f5bbcd2095ae9756e0651d1b"><a href="#dimension-distancetonearestplayersqr2d-l2-lambda-39375131f5bbcd2095ae9756e0651d1b" class="header-anchor">#</a> <code>Dimension::distanceToNearestPlayerSqr2D::__l2::&lt;lambda_39375131f5bbcd2095ae9756e0651d1b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Dimension::distanceToNearestPlayerSqr2D::__l2::&lt;lambda_39375131f5bbcd2095ae9756e0651d1b&gt;
{
  float *closestPlayer;
  Vec3 *origin;
};

</code></pre></div><h3 id="dimension-fetchnearestattackableplayer-l2-lambda-7321a85d3f27d611db74167257847709"><a href="#dimension-fetchnearestattackableplayer-l2-lambda-7321a85d3f27d611db74167257847709" class="header-anchor">#</a> <code>Dimension::fetchNearestAttackablePlayer::__l2::&lt;lambda_7321a85d3f27d611db74167257847709&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Dimension::fetchNearestAttackablePlayer::__l2::&lt;lambda_7321a85d3f27d611db74167257847709&gt;
{
  float *best;
  BlockPos *source;
  float *maxDist;
  Actor **sourceEntity;
  Player **result;
};

</code></pre></div><h3 id="dimension-fetchnearestplayer-l2-lambda-4b487e18adc39fbe8472d60003172668"><a href="#dimension-fetchnearestplayer-l2-lambda-4b487e18adc39fbe8472d60003172668" class="header-anchor">#</a> <code>Dimension::fetchNearestPlayer::__l2::&lt;lambda_4b487e18adc39fbe8472d60003172668&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Dimension::fetchNearestPlayer::__l2::&lt;lambda_4b487e18adc39fbe8472d60003172668&gt;
{
  float *maxDist;
  float *maxDistSqr;
  float *best;
  Player **result;
  Vec3 *pos;
  bool *findAnyNearPlayer;
};

</code></pre></div><h3 id="dimension-processtickingarearemoves-l2-lambda-724cf37e188c9d9c1ecc1ccf07770601"><a href="#dimension-processtickingarearemoves-l2-lambda-724cf37e188c9d9c1ecc1ccf07770601" class="header-anchor">#</a> <code>Dimension::processTickingAreaRemoves::__l2::&lt;lambda_724cf37e188c9d9c1ecc1ccf07770601&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Dimension::processTickingAreaRemoves::__l2::&lt;lambda_724cf37e188c9d9c1ecc1ccf07770601&gt;
{
  Dimension *const __this;
};

</code></pre></div><h3 id="dimension-processtickingarearemoves-l2-lambda-0b40c6c56e3e86b934e6ef5594bd0af5"><a href="#dimension-processtickingarearemoves-l2-lambda-0b40c6c56e3e86b934e6ef5594bd0af5" class="header-anchor">#</a> <code>Dimension::processTickingAreaRemoves::__l2::&lt;lambda_0b40c6c56e3e86b934e6ef5594bd0af5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Dimension::processTickingAreaRemoves::__l2::&lt;lambda_0b40c6c56e3e86b934e6ef5594bd0af5&gt;
{
  std::vector&lt;Vec3&gt; *playerPositions;
};

</code></pre></div><h3 id="dimension-tick-l29-lambda-ac349a165d3224bbbf904ca683e1527a"><a href="#dimension-tick-l29-lambda-ac349a165d3224bbbf904ca683e1527a" class="header-anchor">#</a> <code>Dimension::tick::__l29::&lt;lambda_ac349a165d3224bbbf904ca683e1527a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Dimension::tick::__l29::&lt;lambda_ac349a165d3224bbbf904ca683e1527a&gt;
{
  Json::Value *root;
};

</code></pre></div><h3 id="dimension-tick-l29-lambda-c341610514d4db5768ffe5512544611a"><a href="#dimension-tick-l29-lambda-c341610514d4db5768ffe5512544611a" class="header-anchor">#</a> <code>Dimension::tick::__l29::&lt;lambda_c341610514d4db5768ffe5512544611a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Dimension::tick::__l29::&lt;lambda_c341610514d4db5768ffe5512544611a&gt;
{
  std::pair&lt;std::string const ,EntityAOIInfo&gt; *i;
  std::unordered_set&lt;ActorUniqueID&gt; *enteredEntities;
  std::unordered_set&lt;ActorUniqueID&gt; *leftEntities;
};

</code></pre></div><h3 id="dimension-trygarbagecollectstructures-l8-lambda-955c9274fedbba38053fa519564aad45"><a href="#dimension-trygarbagecollectstructures-l8-lambda-955c9274fedbba38053fa519564aad45" class="header-anchor">#</a> <code>Dimension::tryGarbageCollectStructures::__l8::&lt;lambda_955c9274fedbba38053fa519564aad45&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Dimension::tryGarbageCollectStructures::__l8::&lt;lambda_955c9274fedbba38053fa519564aad45&gt;
{
  WorldGenerator *generator;
  std::vector&lt;ChunkPos&gt; activeChunks;
};

</code></pre></div><h3 id="distanceactorsorter"><a href="#distanceactorsorter" class="header-anchor">#</a> <code>DistanceActorSorter</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DistanceActorSorter
{
  Vec3 c;
};

</code></pre></div><h3 id="dbstorage-schedulenextautocompaction-l11-lambda-a9bf4790d98a6f8751944fe9d1ad3293"><a href="#dbstorage-schedulenextautocompaction-l11-lambda-a9bf4790d98a6f8751944fe9d1ad3293" class="header-anchor">#</a> <code>DBStorage::_scheduleNextAutoCompaction::__l11::&lt;lambda_a9bf4790d98a6f8751944fe9d1ad3293&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DBStorage::_scheduleNextAutoCompaction::__l11::&lt;lambda_a9bf4790d98a6f8751944fe9d1ad3293&gt;
{
  DBStorage *const __this;
};

</code></pre></div><h3 id="dbstorage-flushtopermanentstorage-l24-lambda-27502401e673031e39c4dbb1d1031d4f"><a href="#dbstorage-flushtopermanentstorage-l24-lambda-27502401e673031e39c4dbb1d1031d4f" class="header-anchor">#</a> <code>DBStorage::flushToPermanentStorage::__l24::&lt;lambda_27502401e673031e39c4dbb1d1031d4f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DBStorage::flushToPermanentStorage::__l24::&lt;lambda_27502401e673031e39c4dbb1d1031d4f&gt;
{
  DBStorage *const __this;
};

</code></pre></div><h3 id="dbstorage-flushtopermanentstorage-l24-lambda-2a07dc52328bfcdd63ff1a1cf36a5caf"><a href="#dbstorage-flushtopermanentstorage-l24-lambda-2a07dc52328bfcdd63ff1a1cf36a5caf" class="header-anchor">#</a> <code>DBStorage::flushToPermanentStorage::__l24::&lt;lambda_2a07dc52328bfcdd63ff1a1cf36a5caf&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DBStorage::flushToPermanentStorage::__l24::&lt;lambda_2a07dc52328bfcdd63ff1a1cf36a5caf&gt;
{
  DBStorage *const __this;
};

</code></pre></div><h3 id="dbstorage-ctor-l2-lambda-c6dbb92266e14d7aef6b0fa7a481069e"><a href="#dbstorage-ctor-l2-lambda-c6dbb92266e14d7aef6b0fa7a481069e" class="header-anchor">#</a> <code>DBStorage::{ctor}::__l2::&lt;lambda_c6dbb92266e14d7aef6b0fa7a481069e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DBStorage::{ctor}::__l2::&lt;lambda_c6dbb92266e14d7aef6b0fa7a481069e&gt;
{
  DBStorage *const __this;
};

</code></pre></div><h3 id="dbstorage-ctor-l14-lambda-37dd41990f7fa328bba60860af145226"><a href="#dbstorage-ctor-l14-lambda-37dd41990f7fa328bba60860af145226" class="header-anchor">#</a> <code>DBStorage::{ctor}::__l14::&lt;lambda_37dd41990f7fa328bba60860af145226&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DBStorage::{ctor}::__l14::&lt;lambda_37dd41990f7fa328bba60860af145226&gt;
{
  DBStorage *const __this;
};

</code></pre></div><h3 id="dbchunkstorage-removedimensiondata-l2-lambda-4c2a8f246ce4260ae0dcb0f392dc6760"><a href="#dbchunkstorage-removedimensiondata-l2-lambda-4c2a8f246ce4260ae0dcb0f392dc6760" class="header-anchor">#</a> <code>DBChunkStorage::removeDimensionData::__l2::&lt;lambda_4c2a8f246ce4260ae0dcb0f392dc6760&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DBChunkStorage::removeDimensionData::__l2::&lt;lambda_4c2a8f246ce4260ae0dcb0f392dc6760&gt;
{
  const std::unordered_set&lt;AutomaticID&lt;Dimension,int&gt;&gt; *dimensionIds;
};

</code></pre></div><h3 id="dbchunkstorage-savelivechunk-l13-lambda-75180e3b4999301e3a39cdc727de41f0"><a href="#dbchunkstorage-savelivechunk-l13-lambda-75180e3b4999301e3a39cdc727de41f0" class="header-anchor">#</a> <code>DBChunkStorage::saveLiveChunk::__l13::&lt;lambda_75180e3b4999301e3a39cdc727de41f0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DBChunkStorage::saveLiveChunk::__l13::&lt;lambda_75180e3b4999301e3a39cdc727de41f0&gt;
{
  DBChunkStorage *const __this;
  std::shared_ptr&lt;LevelStorageWriteBatch&gt; batch;
  ChunkPos id;
};

</code></pre></div><h3 id="dbchunkstorage-savelivechunk-l13-lambda-6dd2e0982947e9c0d5b2876227ec26e9"><a href="#dbchunkstorage-savelivechunk-l13-lambda-6dd2e0982947e9c0d5b2876227ec26e9" class="header-anchor">#</a> <code>DBChunkStorage::saveLiveChunk::__l13::&lt;lambda_6dd2e0982947e9c0d5b2876227ec26e9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DBChunkStorage::saveLiveChunk::__l13::&lt;lambda_6dd2e0982947e9c0d5b2876227ec26e9&gt;
{
  std::shared_ptr&lt;LevelStorageWriteBatch&gt; batch;
  DBChunkStorage *const __this;
};

</code></pre></div><h3 id="dbchunkstorage-writebatch-l2-lambda-de90ad45c173d095d118f660dfc436d5"><a href="#dbchunkstorage-writebatch-l2-lambda-de90ad45c173d095d118f660dfc436d5" class="header-anchor">#</a> <code>DBChunkStorage::_writeBatch::__l2::&lt;lambda_de90ad45c173d095d118f660dfc436d5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DBChunkStorage::_writeBatch::__l2::&lt;lambda_de90ad45c173d095d118f660dfc436d5&gt;
{
  DBChunkStorage *const __this;
  std::shared_ptr&lt;std::vector&lt;std::unique_ptr&lt;LevelChunk,LevelChunkFinalDeleter&gt;&gt; &gt; list;
};

</code></pre></div><h3 id="dbchunkstorage-serializechunk-l50-lambda-79b934b69e619e99a994ab95ede5b9bd"><a href="#dbchunkstorage-serializechunk-l50-lambda-79b934b69e619e99a994ab95ede5b9bd" class="header-anchor">#</a> <code>DBChunkStorage::_serializeChunk::__l50::&lt;lambda_79b934b69e619e99a994ab95ede5b9bd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DBChunkStorage::_serializeChunk::__l50::&lt;lambda_79b934b69e619e99a994ab95ede5b9bd&gt;
{
  DBChunkStorage *const __this;
  DBChunkStorageKey lcKey;
};

</code></pre></div><h3 id="dbchunkstorage-loadchunkfromdb-l2-lambda-e5fc82d40337e65216fc50d947aab069"><a href="#dbchunkstorage-loadchunkfromdb-l2-lambda-e5fc82d40337e65216fc50d947aab069" class="header-anchor">#</a> <code>DBChunkStorage::_loadChunkFromDB::__l2::&lt;lambda_e5fc82d40337e65216fc50d947aab069&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DBChunkStorage::_loadChunkFromDB::__l2::&lt;lambda_e5fc82d40337e65216fc50d947aab069&gt;
{
  DBChunkStorage *const __this;
  bool *exists;
  LevelChunk *lc;
  std::unordered_map&lt;LevelChunkHashMapKey,unsigned __int64&gt; *deserializedHashMap;
};

</code></pre></div><h3 id="devicebuttons"><a href="#devicebuttons" class="header-anchor">#</a> <code>DeviceButtons</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DeviceButtons
{
};

</code></pre></div><h3 id="downloadcallback"><a href="#downloadcallback" class="header-anchor">#</a> <code>DownloadCallback</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DownloadCallback
{
  DownloadCallback_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="downloadcallback-vtbl"><a href="#downloadcallback-vtbl" class="header-anchor">#</a> <code>DownloadCallback_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DownloadCallback_vtbl
{
  void (__fastcall *onSuccCallback)(DownloadCallback *this, tDownloadInfo *);
  void (__fastcall *onFailCallback)(DownloadCallback *this, tDownloadInfo *);
  void (__fastcall *onProgCallback)(DownloadCallback *this, tDownloadInfo *);
  void (__fastcall *~DownloadCallback)(DownloadCallback *this);
};

</code></pre></div><h3 id="downloader-error"><a href="#downloader-error" class="header-anchor">#</a> <code>Downloader::Error</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj Downloader::Error
{
  Downloader::ErrorCode code;
  int curlm_code;
  int curle_code;
  std::string message;
  std::string customId;
  std::string url;
};

</code></pre></div><h3 id="downloader"><a href="#downloader" class="header-anchor">#</a> <code>Downloader</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Downloader : std::enable_shared_from_this&lt;Downloader&gt;
{
  int _connectionTimeout;
  std::function&lt;void __cdecl(std::string const &amp;,Downloader::Error const &amp;)&gt; _onError;
  std::function&lt;void __cdecl(double,double,std::string const &amp;,std::string const &amp;)&gt; _onProgress;
  std::function&lt;void __cdecl(std::string const &amp;)&gt; _onSuccess;
  std::function&lt;void __cdecl(std::vector&lt;std::string&gt; const &amp;,std::string,int)&gt; _onBatchError;
  std::function&lt;void __cdecl(std::vector&lt;std::string&gt; const &amp;)&gt; _onBatchSuccess;
  bool _supportResuming;
};

</code></pre></div><h3 id="downloader-downloadunit"><a href="#downloader-downloadunit" class="header-anchor">#</a> <code>Downloader::DownloadUnit</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Downloader::DownloadUnit
{
  std::string srcUrl;
  std::string storagePath;
  std::string customId;
  std::string tmpStoragePath;
  int size;
  std::string md5;
  std::string md5Check;
  bool isCompressed_;
  bool resumeDownload;
  int downloaded_size;
  int retry_time;
  int max_retry_time;
};

</code></pre></div><h3 id="detail-getrecipesbyinput-l7-lambda-ad02f3291b5c4781efaba99a027fba61"><a href="#detail-getrecipesbyinput-l7-lambda-ad02f3291b5c4781efaba99a027fba61" class="header-anchor">#</a> <code>detail::getRecipesByInput::__l7::&lt;lambda_ad02f3291b5c4781efaba99a027fba61&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj detail::getRecipesByInput::__l7::&lt;lambda_ad02f3291b5c4781efaba99a027fba61&gt;
{
  std::vector&lt;Recipe *&gt; *recipeList;
};

</code></pre></div><h3 id="detail-getrecipesbyresult-l7-lambda-ac68db9521f360fc1211687865086f67"><a href="#detail-getrecipesbyresult-l7-lambda-ac68db9521f360fc1211687865086f67" class="header-anchor">#</a> <code>detail::getRecipesByResult::__l7::&lt;lambda_ac68db9521f360fc1211687865086f67&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj detail::getRecipesByResult::__l7::&lt;lambda_ac68db9521f360fc1211687865086f67&gt;
{
  std::vector&lt;Recipe *&gt; *recipeList;
};

</code></pre></div><h3 id="directoryentrycomparer"><a href="#directoryentrycomparer" class="header-anchor">#</a> <code>DirectoryEntryComparer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DirectoryEntryComparer
{
};

</code></pre></div><h3 id="debugsettings"><a href="#debugsettings" class="header-anchor">#</a> <code>DebugSettings</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DebugSettings
{
};

</code></pre></div><h3 id="debuglogincontroller"><a href="#debuglogincontroller" class="header-anchor">#</a> <code>DebugLoginController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DebugLoginController : MinecraftScreenController
{
  std::shared_ptr&lt;LoginScreenModel&gt; mModel;
  std::string mDebugUserName;
  std::string mDebugPassword;
};

</code></pre></div><h3 id="debuglogincontroller-vtbl"><a href="#debuglogincontroller-vtbl" class="header-anchor">#</a> <code>DebugLoginController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DebugLoginController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="downloadprogressfunc-l8-lambda-faf5f4f1c41e04eadd131e11ca6a1250"><a href="#downloadprogressfunc-l8-lambda-faf5f4f1c41e04eadd131e11ca6a1250" class="header-anchor">#</a> <code>downloadProgressFunc::__l8::&lt;lambda_faf5f4f1c41e04eadd131e11ca6a1250&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj downloadProgressFunc::__l8::&lt;lambda_faf5f4f1c41e04eadd131e11ca6a1250&gt;
{
  Downloader::ProgressData data;
  long double totalToDownload;
  long double nowDownloaded;
};

</code></pre></div><h3 id="dump-snapshot-l2-combotrace"><a href="#dump-snapshot-l2-combotrace" class="header-anchor">#</a> <code>dump_snapshot::__l2::ComboTrace</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dump_snapshot::__l2::ComboTrace
{
  unsigned __int64 size;
  unsigned __int64 count;
};

</code></pre></div><h3 id="diggertypemapping"><a href="#diggertypemapping" class="header-anchor">#</a> <code>DiggerTypeMapping</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DiggerTypeMapping
{
};

</code></pre></div><h3 id="dragon-frameobject-computedispatchcontext"><a href="#dragon-frameobject-computedispatchcontext" class="header-anchor">#</a> <code>dragon::frameobject::ComputeDispatchContext</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct dragon::frameobject::ComputeDispatchContext
{
  dragon::mesh::VertexBufferResourceManager *vbManager;
  dragon::mesh::IndexBufferResourceManager *ibManager;
  dragon::rendering::CommandContext *commands;
  const dragon::frameobject::PreparedComputeDispatchCollection *dispatches;
  dragon::res::ResolvedTextureResource *const missingTexture;
};

</code></pre></div><h3 id="dragon-rendering-bgfxuniformhelpers"><a href="#dragon-rendering-bgfxuniformhelpers" class="header-anchor">#</a> <code>dragon::rendering::BgfxUniformHelpers</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BgfxUniformHelpers
{
};

</code></pre></div><h3 id="dragon-rendering-bgfxstatehelpers"><a href="#dragon-rendering-bgfxstatehelpers" class="header-anchor">#</a> <code>dragon::rendering::BgfxStateHelpers</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BgfxStateHelpers
{
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-ae2517dea6a52563ebf06e893bafaa1b-lambda-140c085b464193e54345a34ce7c4d135-lambda-3a4c268a3373c608c9cf19eea305b10f-lambda-ac6cad7418409f0d329dbf09122230ec-lambda-74985a6bbed240ab20d16ad2e43af3cb-lambda-1872cc4fd08d4a81875e786915d05a4b"><a href="#dragon-platform-helpers-visitoverloaded-lambda-ae2517dea6a52563ebf06e893bafaa1b-lambda-140c085b464193e54345a34ce7c4d135-lambda-3a4c268a3373c608c9cf19eea305b10f-lambda-ac6cad7418409f0d329dbf09122230ec-lambda-74985a6bbed240ab20d16ad2e43af3cb-lambda-1872cc4fd08d4a81875e786915d05a4b" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_ae2517dea6a52563ebf06e893bafaa1b&gt;,&lt;lambda_140c085b464193e54345a34ce7c4d135&gt;,&lt;lambda_3a4c268a3373c608c9cf19eea305b10f&gt;,&lt;lambda_ac6cad7418409f0d329dbf09122230ec&gt;,&lt;lambda_74985a6bbed240ab20d16ad2e43af3cb&gt;,&lt;lambda_1872cc4fd08d4a81875e786915d05a4b&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_ae2517dea6a52563ebf06e893bafaa1b&gt;,&lt;lambda_140c085b464193e54345a34ce7c4d135&gt;,&lt;lambda_3a4c268a3373c608c9cf19eea305b10f&gt;,&lt;lambda_ac6cad7418409f0d329dbf09122230ec&gt;,&lt;lambda_74985a6bbed240ab20d16ad2e43af3cb&gt;,&lt;lambda_1872cc4fd08d4a81875e786915d05a4b&gt; &gt; : _BYTE[], _BYTE[], _BYTE[], _BYTE[], _BYTE[], _BYTE[]
{
  _BYTE gap0[8];
  _BYTE gap10[8];
  _BYTE gap18[24];
  _BYTE gap30[8];
  _BYTE gap38[24];
};

</code></pre></div><h3 id="dragon-materials-definition-propertiesbase-dragon-materials-definition-samplerdefinition"><a href="#dragon-materials-definition-propertiesbase-dragon-materials-definition-samplerdefinition" class="header-anchor">#</a> <code>dragon::materials::definition::PropertiesBase&lt;dragon::materials::definition::SamplerDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::materials::definition::PropertiesBase&lt;dragon::materials::definition::SamplerDefinition&gt;
{
  std::unordered_map&lt;std::string,std::variant&lt;dragon::materials::definition::PropertyField&lt;dragon::materials::definition::ExternalUniformDeclaration,std::optional&lt;dragon::materials::definition::ExternalUniformDeclaration&gt; &gt;,dragon::materials::definition::PropertyField&lt;glm::tvec4&lt;float,0&gt;,std::optional&lt;glm::tvec4&lt;float,0&gt; &gt; &gt;,dragon::materials::definition::PropertyField&lt;float,std::optional&lt;float&gt; &gt;,dragon::materials::definition::PropertyField&lt;glm::tmat3x3&lt;float,0&gt;,std::optional&lt;glm::tmat3x3&lt;float,0&gt; &gt; &gt;,dragon::materials::definition::PropertyField&lt;glm::tmat4x4&lt;float,0&gt;,std::optional&lt;glm::tmat4x4&lt;float,0&gt; &gt; &gt;,dragon::materials::definition::SamplerDefinition&gt;&gt; mValues;
};

</code></pre></div><h3 id="dragon-materials-definition-materialdefinitionproperties"><a href="#dragon-materials-definition-materialdefinitionproperties" class="header-anchor">#</a> <code>dragon::materials::definition::MaterialDefinitionProperties</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::materials::definition::MaterialDefinitionProperties : dragon::materials::definition::PropertiesBase&lt;dragon::materials::definition::SamplerDefinition&gt;
{
};

</code></pre></div><h3 id="dragon-materials-definition-materialsharedsections"><a href="#dragon-materials-definition-materialsharedsections" class="header-anchor">#</a> <code>dragon::materials::definition::MaterialSharedSections</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::materials::definition::MaterialSharedSections
{
  dragon::materials::definition::StageInputDefinition mInputDefinition;
  dragon::materials::definition::MaterialPassDeclaration mDeclarations;
  std::vector&lt;dragon::materials::definition::SharedCodeSection&gt; mCodeSections;
};

</code></pre></div><h3 id="dragon-materials-definition-materialdefinition"><a href="#dragon-materials-definition-materialdefinition" class="header-anchor">#</a> <code>dragon::materials::definition::MaterialDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::materials::definition::MaterialDefinition
{
  std::string mName;
  std::optional&lt;std::string &gt; mParentName;
  dragon::materials::definition::MaterialDefinitionProperties mProperties;
  std::unordered_map&lt;std::string,dragon::materials::definition::CustomTypeDeclaration&gt; mCustomTypes;
  std::unordered_map&lt;std::string,dragon::materials::definition::MaterialPass&gt; mDefinedPasses;
  std::unordered_map&lt;std::string,dragon::materials::definition::MaterialUsedPass&gt; mUsedPasses;
  dragon::materials::definition::MaterialSharedSections mSharedSections;
};

</code></pre></div><h3 id="dragon-materials-materialresourcemanager-trycreatematerialasync-l19-lambda-938045b63551f3018a978b16ad33ef93"><a href="#dragon-materials-materialresourcemanager-trycreatematerialasync-l19-lambda-938045b63551f3018a978b16ad33ef93" class="header-anchor">#</a> <code>dragon::materials::MaterialResourceManager::_tryCreateMaterialAsync::__l19::&lt;lambda_938045b63551f3018a978b16ad33ef93&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::materials::MaterialResourceManager::_tryCreateMaterialAsync::__l19::&lt;lambda_938045b63551f3018a978b16ad33ef93&gt;
{
  dragon::materials::MaterialResourceManager *const __this;
  unsigned __int64 locationHash;
  std::shared_ptr&lt;dragon::materials::MaterialResourceManager::MaterialLoadResult&gt; workResult;
};

</code></pre></div><h3 id="dragon-result-result-void-enum-dragon-res-textureerror"><a href="#dragon-result-result-void-enum-dragon-res-textureerror" class="header-anchor">#</a> <code>dragon::result::Result&lt;void,enum dragon::res::TextureError&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct dragon::result::Result&lt;void,enum dragon::res::TextureError&gt;
{
  std::variant&lt;dragon::result::SuccessTag,enum dragon::res::TextureError&gt; mValue;
};

</code></pre></div><h3 id="dragon-materials-details-materialentry-entrycreator-glm-tvec4-float-0-dragon-materials-materialuniform-uniformparameter"><a href="#dragon-materials-details-materialentry-entrycreator-glm-tvec4-float-0-dragon-materials-materialuniform-uniformparameter" class="header-anchor">#</a> <code>dragon::materials::details::materialentry::EntryCreator&lt;glm::tvec4&lt;float,0&gt;,dragon::materials::MaterialUniform::UniformParameter&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::materials::details::materialentry::EntryCreator&lt;glm::tvec4&lt;float,0&gt;,dragon::materials::MaterialUniform::UniformParameter&gt;
{
};

</code></pre></div><h3 id="dragon-materials-details-materialentry-entrycreator-glm-tmat3x3-float-0-dragon-materials-materialuniform-uniformparameter"><a href="#dragon-materials-details-materialentry-entrycreator-glm-tmat3x3-float-0-dragon-materials-materialuniform-uniformparameter" class="header-anchor">#</a> <code>dragon::materials::details::materialentry::EntryCreator&lt;glm::tmat3x3&lt;float,0&gt;,dragon::materials::MaterialUniform::UniformParameter&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::materials::details::materialentry::EntryCreator&lt;glm::tmat3x3&lt;float,0&gt;,dragon::materials::MaterialUniform::UniformParameter&gt;
{
};

</code></pre></div><h3 id="dragon-materials-details-materialentry-entrycreator-glm-tmat4x4-float-0-dragon-materials-materialuniform-uniformparameter"><a href="#dragon-materials-details-materialentry-entrycreator-glm-tmat4x4-float-0-dragon-materials-materialuniform-uniformparameter" class="header-anchor">#</a> <code>dragon::materials::details::materialentry::EntryCreator&lt;glm::tmat4x4&lt;float,0&gt;,dragon::materials::MaterialUniform::UniformParameter&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::materials::details::materialentry::EntryCreator&lt;glm::tmat4x4&lt;float,0&gt;,dragon::materials::MaterialUniform::UniformParameter&gt;
{
};

</code></pre></div><h3 id="dragon-materials-details-materialentry-entrycreator-int-dragon-materials-materialuniform-bufferparameter"><a href="#dragon-materials-details-materialentry-entrycreator-int-dragon-materials-materialuniform-bufferparameter" class="header-anchor">#</a> <code>dragon::materials::details::materialentry::EntryCreator&lt;int,dragon::materials::MaterialUniform::BufferParameter&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::materials::details::materialentry::EntryCreator&lt;int,dragon::materials::MaterialUniform::BufferParameter&gt;
{
};

</code></pre></div><h3 id="dragon-materials-materialuniformoverrides-getuniformdata-l6-lambda-1decc1348a6b98aad40e18f0508027f9"><a href="#dragon-materials-materialuniformoverrides-getuniformdata-l6-lambda-1decc1348a6b98aad40e18f0508027f9" class="header-anchor">#</a> <code>dragon::materials::MaterialUniformOverrides::getUniformData::__l6::&lt;lambda_1decc1348a6b98aad40e18f0508027f9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::materials::MaterialUniformOverrides::getUniformData::__l6::&lt;lambda_1decc1348a6b98aad40e18f0508027f9&gt;
{
};

</code></pre></div><h3 id="dragon-materials-materialuniformoverrides-getuniformdata-l6-lambda-e6743f942619bee0f4263db114cda5a5"><a href="#dragon-materials-materialuniformoverrides-getuniformdata-l6-lambda-e6743f942619bee0f4263db114cda5a5" class="header-anchor">#</a> <code>dragon::materials::MaterialUniformOverrides::getUniformData::__l6::&lt;lambda_e6743f942619bee0f4263db114cda5a5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::materials::MaterialUniformOverrides::getUniformData::__l6::&lt;lambda_e6743f942619bee0f4263db114cda5a5&gt;
{
};

</code></pre></div><h3 id="dragon-materials-materialuniformoverrides-getuniformdata-l6-lambda-6332ce45d5b3dc3e663e0b768d288148"><a href="#dragon-materials-materialuniformoverrides-getuniformdata-l6-lambda-6332ce45d5b3dc3e663e0b768d288148" class="header-anchor">#</a> <code>dragon::materials::MaterialUniformOverrides::getUniformData::__l6::&lt;lambda_6332ce45d5b3dc3e663e0b768d288148&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::materials::MaterialUniformOverrides::getUniformData::__l6::&lt;lambda_6332ce45d5b3dc3e663e0b768d288148&gt;
{
};

</code></pre></div><h3 id="dragon-materials-materialuniformoverrides-getuniformdata-l6-lambda-739851022b3115bfca82d865f26d3110"><a href="#dragon-materials-materialuniformoverrides-getuniformdata-l6-lambda-739851022b3115bfca82d865f26d3110" class="header-anchor">#</a> <code>dragon::materials::MaterialUniformOverrides::getUniformData::__l6::&lt;lambda_739851022b3115bfca82d865f26d3110&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::materials::MaterialUniformOverrides::getUniformData::__l6::&lt;lambda_739851022b3115bfca82d865f26d3110&gt;
{
};

</code></pre></div><h3 id="dragon-materials-materialuniformoverrides-getuniformdata-l6-lambda-fc98ac70cf8b118a78728e20f63c3cb6"><a href="#dragon-materials-materialuniformoverrides-getuniformdata-l6-lambda-fc98ac70cf8b118a78728e20f63c3cb6" class="header-anchor">#</a> <code>dragon::materials::MaterialUniformOverrides::getUniformData::__l6::&lt;lambda_fc98ac70cf8b118a78728e20f63c3cb6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::materials::MaterialUniformOverrides::getUniformData::__l6::&lt;lambda_fc98ac70cf8b118a78728e20f63c3cb6&gt;
{
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-1decc1348a6b98aad40e18f0508027f9-lambda-e6743f942619bee0f4263db114cda5a5-lambda-6332ce45d5b3dc3e663e0b768d288148-lambda-739851022b3115bfca82d865f26d3110-lambda-fc98ac70cf8b118a78728e20f63c3cb6"><a href="#dragon-platform-helpers-visitoverloaded-lambda-1decc1348a6b98aad40e18f0508027f9-lambda-e6743f942619bee0f4263db114cda5a5-lambda-6332ce45d5b3dc3e663e0b768d288148-lambda-739851022b3115bfca82d865f26d3110-lambda-fc98ac70cf8b118a78728e20f63c3cb6" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_1decc1348a6b98aad40e18f0508027f9&gt;,&lt;lambda_e6743f942619bee0f4263db114cda5a5&gt;,&lt;lambda_6332ce45d5b3dc3e663e0b768d288148&gt;,&lt;lambda_739851022b3115bfca82d865f26d3110&gt;,&lt;lambda_fc98ac70cf8b118a78728e20f63c3cb6&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_1decc1348a6b98aad40e18f0508027f9&gt;,&lt;lambda_e6743f942619bee0f4263db114cda5a5&gt;,&lt;lambda_6332ce45d5b3dc3e663e0b768d288148&gt;,&lt;lambda_739851022b3115bfca82d865f26d3110&gt;,&lt;lambda_fc98ac70cf8b118a78728e20f63c3cb6&gt; &gt; : dragon::materials::MaterialUniformOverrides::getUniformData::__l6::&lt;lambda_1decc1348a6b98aad40e18f0508027f9&gt;, dragon::materials::MaterialUniformOverrides::getUniformData::__l6::&lt;lambda_e6743f942619bee0f4263db114cda5a5&gt;, dragon::materials::MaterialUniformOverrides::getUniformData::__l6::&lt;lambda_6332ce45d5b3dc3e663e0b768d288148&gt;, dragon::materials::MaterialUniformOverrides::getUniformData::__l6::&lt;lambda_739851022b3115bfca82d865f26d3110&gt;, dragon::materials::MaterialUniformOverrides::getUniformData::__l6::&lt;lambda_fc98ac70cf8b118a78728e20f63c3cb6&gt;
{
  _BYTE gap0;
  _BYTE gap2;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-11c97bb4601acd4a010d09ba30890692-lambda-911e18ebfe7c3775069adcf0afb8ea72-lambda-3ac8d0be528e15713f44e7f572e92f92-lambda-47fbc99d5e8eafb657c1a159441f48b5-lambda-df8a3f9c158f9732a9c15954ec84b167"><a href="#dragon-platform-helpers-visitoverloaded-lambda-11c97bb4601acd4a010d09ba30890692-lambda-911e18ebfe7c3775069adcf0afb8ea72-lambda-3ac8d0be528e15713f44e7f572e92f92-lambda-47fbc99d5e8eafb657c1a159441f48b5-lambda-df8a3f9c158f9732a9c15954ec84b167" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_11c97bb4601acd4a010d09ba30890692&gt;,&lt;lambda_911e18ebfe7c3775069adcf0afb8ea72&gt;,&lt;lambda_3ac8d0be528e15713f44e7f572e92f92&gt;,&lt;lambda_47fbc99d5e8eafb657c1a159441f48b5&gt;,&lt;lambda_df8a3f9c158f9732a9c15954ec84b167&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_11c97bb4601acd4a010d09ba30890692&gt;,&lt;lambda_911e18ebfe7c3775069adcf0afb8ea72&gt;,&lt;lambda_3ac8d0be528e15713f44e7f572e92f92&gt;,&lt;lambda_47fbc99d5e8eafb657c1a159441f48b5&gt;,&lt;lambda_df8a3f9c158f9732a9c15954ec84b167&gt; &gt; : _BYTE[], _BYTE[], _BYTE[], _BYTE[], _BYTE[]
{
  _BYTE gap0;
  _BYTE gap2;
};

</code></pre></div><h3 id="dragon-memory-bgfxdatawrapper-dragon-memory-buffersource-usetracker"><a href="#dragon-memory-bgfxdatawrapper-dragon-memory-buffersource-usetracker" class="header-anchor">#</a> <code>dragon::memory::BgfxDataWrapper&lt;dragon::memory::BufferSource::UseTracker&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::memory::BgfxDataWrapper&lt;dragon::memory::BufferSource::UseTracker&gt;
{
  const std::shared_ptr&lt;dragon::memory::BufferSource::UseTracker&gt; mData;
};

</code></pre></div><h3 id="dragon-memory-bgfxdatawrapper-std-vector-unsigned-char-const"><a href="#dragon-memory-bgfxdatawrapper-std-vector-unsigned-char-const" class="header-anchor">#</a> <code>dragon::memory::BgfxDataWrapper&lt;std::vector&lt;unsigned char&gt; const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::memory::BgfxDataWrapper&lt;std::vector&lt;unsigned char&gt; const &gt;
{
  const std::shared_ptr&lt;std::vector&lt;unsigned char&gt; const &gt; mData;
};

</code></pre></div><h3 id="dragon-mesh-details-indexbufferhandletypekey"><a href="#dragon-mesh-details-indexbufferhandletypekey" class="header-anchor">#</a> <code>dragon::mesh::details::IndexBufferHandleTypeKey</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::mesh::details::IndexBufferHandleTypeKey
{
};

</code></pre></div><h3 id="dragon-mesh-indexbuffertype"><a href="#dragon-mesh-indexbuffertype" class="header-anchor">#</a> <code>dragon::mesh::IndexBufferType</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::mesh::IndexBufferType
{
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-bufferresource-accessor"><a href="#dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-bufferresource-accessor" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::BufferResource::Accessor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::BufferResource::Accessor
{
  dragon::rendering::BufferState *mState;
  bool *mWasEverCreated;
  bool *mWasEverUsed;
  std::variant&lt;bgfx::IndexBufferHandle,bgfx::DynamicIndexBufferHandle&gt; *mResource;
  dragon::mesh::IndexBufferType::ResourceDescription *mDescription;
  dragon::mesh::IndexBufferDescription *mPublicDescription;
  std::optional&lt;dragon::mesh::IndexBufferType::ResourceCreationParameters&gt; *mCreationParameters;
  std::vector&lt;dragon::mesh::IndexBufferType::ResourceUpdateParameters&gt; *mDeferredOrderedUpdateSequence;
  std::mutex *mAccessLock;
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-flush-l5-delayeddestroy"><a href="#dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-flush-l5-delayeddestroy" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::flush::__l5::DelayedDestroy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::flush::__l5::DelayedDestroy
{
  std::function&lt;void __cdecl(void)&gt; mCallback;
};

</code></pre></div><h3 id="dragon-rendering-bufferresourceinstancetraits-dragon-mesh-indexbuffertype"><a href="#dragon-rendering-bufferresourceinstancetraits-dragon-mesh-indexbuffertype" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceInstanceTraits&lt;dragon::mesh::IndexBufferType&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceInstanceTraits&lt;dragon::mesh::IndexBufferType&gt;
{
};

</code></pre></div><h3 id="dragon-memory-buffersource-resolve-l2-lambda-d3c53adb5163b2dc6cb38e1389232b1d"><a href="#dragon-memory-buffersource-resolve-l2-lambda-d3c53adb5163b2dc6cb38e1389232b1d" class="header-anchor">#</a> <code>dragon::memory::BufferSource::resolve::__l2::&lt;lambda_d3c53adb5163b2dc6cb38e1389232b1d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::memory::BufferSource::resolve::__l2::&lt;lambda_d3c53adb5163b2dc6cb38e1389232b1d&gt;
{
};

</code></pre></div><h3 id="dragon-mesh-indexbuffertype-create-l8-lambda-e47c005c7d6b9976d725fa3856b3c219"><a href="#dragon-mesh-indexbuffertype-create-l8-lambda-e47c005c7d6b9976d725fa3856b3c219" class="header-anchor">#</a> <code>dragon::mesh::IndexBufferType::create::__l8::&lt;lambda_e47c005c7d6b9976d725fa3856b3c219&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::mesh::IndexBufferType::create::__l8::&lt;lambda_e47c005c7d6b9976d725fa3856b3c219&gt;
{
  std::variant&lt;bgfx::IndexBufferHandle,bgfx::DynamicIndexBufferHandle&gt; *result;
  unsigned __int16 *flags;
};

</code></pre></div><h3 id="dragon-memory-buffersource-resolve-l2-lambda-fbf8f11091c1cfcec0d531bce112a61e"><a href="#dragon-memory-buffersource-resolve-l2-lambda-fbf8f11091c1cfcec0d531bce112a61e" class="header-anchor">#</a> <code>dragon::memory::BufferSource::resolve::__l2::&lt;lambda_fbf8f11091c1cfcec0d531bce112a61e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::memory::BufferSource::resolve::__l2::&lt;lambda_fbf8f11091c1cfcec0d531bce112a61e&gt;
{
};

</code></pre></div><h3 id="dragon-mesh-indexbuffertype-create-l12-lambda-b7dfe6184cc14514f6c43d7b49641c2d"><a href="#dragon-mesh-indexbuffertype-create-l12-lambda-b7dfe6184cc14514f6c43d7b49641c2d" class="header-anchor">#</a> <code>dragon::mesh::IndexBufferType::create::__l12::&lt;lambda_b7dfe6184cc14514f6c43d7b49641c2d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::mesh::IndexBufferType::create::__l12::&lt;lambda_b7dfe6184cc14514f6c43d7b49641c2d&gt;
{
  std::variant&lt;bgfx::IndexBufferHandle,bgfx::DynamicIndexBufferHandle&gt; *result;
  unsigned __int16 *flags;
};

</code></pre></div><h3 id="dragon-memory-buffersource-resolve-l2-lambda-ed99f4815b8499836d50f291d0152fa5"><a href="#dragon-memory-buffersource-resolve-l2-lambda-ed99f4815b8499836d50f291d0152fa5" class="header-anchor">#</a> <code>dragon::memory::BufferSource::resolve::__l2::&lt;lambda_ed99f4815b8499836d50f291d0152fa5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::memory::BufferSource::resolve::__l2::&lt;lambda_ed99f4815b8499836d50f291d0152fa5&gt;
{
};

</code></pre></div><h3 id="dragon-mesh-indexbuffertype-update-l2-lambda-08cf54ea2da37cd267dd894e7acde7af-l2-lambda-a8d6c4b5e0e75fa7cec1c0297591184b"><a href="#dragon-mesh-indexbuffertype-update-l2-lambda-08cf54ea2da37cd267dd894e7acde7af-l2-lambda-a8d6c4b5e0e75fa7cec1c0297591184b" class="header-anchor">#</a> <code>dragon::mesh::IndexBufferType::update::__l2::&lt;lambda_08cf54ea2da37cd267dd894e7acde7af&gt;::()::__l2::&lt;lambda_a8d6c4b5e0e75fa7cec1c0297591184b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::mesh::IndexBufferType::update::__l2::&lt;lambda_08cf54ea2da37cd267dd894e7acde7af&gt;::()::__l2::&lt;lambda_a8d6c4b5e0e75fa7cec1c0297591184b&gt;
{
  bgfx::DynamicIndexBufferHandle *buffer;
  const dragon::mesh::IndexBufferType::ResourceUpdateParameters *updateParameters;
};

</code></pre></div><h3 id="dragon-memory-buffersource-resolve-l2-lambda-6cd7bdef28880426738d8ed9093e0c44"><a href="#dragon-memory-buffersource-resolve-l2-lambda-6cd7bdef28880426738d8ed9093e0c44" class="header-anchor">#</a> <code>dragon::memory::BufferSource::resolve::__l2::&lt;lambda_6cd7bdef28880426738d8ed9093e0c44&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::memory::BufferSource::resolve::__l2::&lt;lambda_6cd7bdef28880426738d8ed9093e0c44&gt;
{
  dragon::mesh::IndexBufferType::update::__l2::&lt;lambda_08cf54ea2da37cd267dd894e7acde7af&gt;::()::__l2::&lt;lambda_a8d6c4b5e0e75fa7cec1c0297591184b&gt; *callback;
};

</code></pre></div><h3 id="dragon-memory-buffersource-resolve-l2-lambda-972838756510f9ca3676f4a62d582a6c"><a href="#dragon-memory-buffersource-resolve-l2-lambda-972838756510f9ca3676f4a62d582a6c" class="header-anchor">#</a> <code>dragon::memory::BufferSource::resolve::__l2::&lt;lambda_972838756510f9ca3676f4a62d582a6c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::memory::BufferSource::resolve::__l2::&lt;lambda_972838756510f9ca3676f4a62d582a6c&gt;
{
  dragon::mesh::IndexBufferType::update::__l2::&lt;lambda_08cf54ea2da37cd267dd894e7acde7af&gt;::()::__l2::&lt;lambda_a8d6c4b5e0e75fa7cec1c0297591184b&gt; *callback;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-ed99f4815b8499836d50f291d0152fa5-lambda-6cd7bdef28880426738d8ed9093e0c44-lambda-972838756510f9ca3676f4a62d582a6c"><a href="#dragon-platform-helpers-visitoverloaded-lambda-ed99f4815b8499836d50f291d0152fa5-lambda-6cd7bdef28880426738d8ed9093e0c44-lambda-972838756510f9ca3676f4a62d582a6c" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_ed99f4815b8499836d50f291d0152fa5&gt;,&lt;lambda_6cd7bdef28880426738d8ed9093e0c44&gt;,&lt;lambda_972838756510f9ca3676f4a62d582a6c&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_ed99f4815b8499836d50f291d0152fa5&gt;,&lt;lambda_6cd7bdef28880426738d8ed9093e0c44&gt;,&lt;lambda_972838756510f9ca3676f4a62d582a6c&gt; &gt; : dragon::memory::BufferSource::resolve::__l2::&lt;lambda_ed99f4815b8499836d50f291d0152fa5&gt;, dragon::memory::BufferSource::resolve::__l2::&lt;lambda_6cd7bdef28880426738d8ed9093e0c44&gt;, dragon::memory::BufferSource::resolve::__l2::&lt;lambda_972838756510f9ca3676f4a62d582a6c&gt;
{
};

</code></pre></div><h3 id="dragon-mesh-indexbuffertype-isvalid-l2-lambda-53e79ad09a321e11a3bed5dcb43e872f"><a href="#dragon-mesh-indexbuffertype-isvalid-l2-lambda-53e79ad09a321e11a3bed5dcb43e872f" class="header-anchor">#</a> <code>dragon::mesh::IndexBufferType::isValid::__l2::&lt;lambda_53e79ad09a321e11a3bed5dcb43e872f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::mesh::IndexBufferType::isValid::__l2::&lt;lambda_53e79ad09a321e11a3bed5dcb43e872f&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-tryresolve-l22-lambda-1123d9f2a4657fcfeb32d1fe7719e711"><a href="#dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-tryresolve-l22-lambda-1123d9f2a4657fcfeb32d1fe7719e711" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::tryResolve::__l22::&lt;lambda_1123d9f2a4657fcfeb32d1fe7719e711&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::tryResolve::__l22::&lt;lambda_1123d9f2a4657fcfeb32d1fe7719e711&gt;
{
  dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt; *const __this;
  std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::BufferResource&gt; target;
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-update-l33-lambda-1db1a9c3e0d949d969f73bd75669861f"><a href="#dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-update-l33-lambda-1db1a9c3e0d949d969f73bd75669861f" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::update::__l33::&lt;lambda_1db1a9c3e0d949d969f73bd75669861f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::update::__l33::&lt;lambda_1db1a9c3e0d949d969f73bd75669861f&gt;
{
  std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::BufferResource&gt; target;
  std::shared_ptr&lt;dragon::mesh::IndexBufferType::ResourceUpdateParameters&gt; updateArgs;
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-create-l5-lambda-fc7ebdbc801e9355ab1fe34a00d731ef"><a href="#dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-create-l5-lambda-fc7ebdbc801e9355ab1fe34a00d731ef" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::create::__l5::&lt;lambda_fc7ebdbc801e9355ab1fe34a00d731ef&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::create::__l5::&lt;lambda_fc7ebdbc801e9355ab1fe34a00d731ef&gt;
{
  dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt; *const __this;
  std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::BufferResource&gt; target;
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-create-l5-lambda-7a92b802fd333bc51acc068c70f5a25e"><a href="#dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-create-l5-lambda-7a92b802fd333bc51acc068c70f5a25e" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::create::__l5::&lt;lambda_7a92b802fd333bc51acc068c70f5a25e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::create::__l5::&lt;lambda_7a92b802fd333bc51acc068c70f5a25e&gt;
{
  dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt; *const __this;
  std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::BufferResource&gt; target;
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-create-l5-lambda-52d819c29a468da680fb9348225b85c3"><a href="#dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-create-l5-lambda-52d819c29a468da680fb9348225b85c3" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::create::__l5::&lt;lambda_52d819c29a468da680fb9348225b85c3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::create::__l5::&lt;lambda_52d819c29a468da680fb9348225b85c3&gt;
{
  dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt; *const __this;
  std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::BufferResource&gt; target;
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-flush-l5-lambda-54c1c396051d4b003046b116655049a1"><a href="#dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-flush-l5-lambda-54c1c396051d4b003046b116655049a1" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::flush::__l5::&lt;lambda_54c1c396051d4b003046b116655049a1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::flush::__l5::&lt;lambda_54c1c396051d4b003046b116655049a1&gt;
{
  dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt; *const __this;
  std::shared_ptr&lt;std::vector&lt;std::optional&lt;dragon::rendering::details::BufferHandleTypeWrapper&lt;dragon::mesh::details::IndexBufferHandleTypeKey,unsigned __int64&gt; &gt;&gt; &gt; buffersToDelete;
};

</code></pre></div><h3 id="dragon-guarded-guardedaccess-dragon-memory-partitionedallocator-dragon-mesh-indexbufferallocator-unsigned-int-std-mutex-std-unique-lock"><a href="#dragon-guarded-guardedaccess-dragon-memory-partitionedallocator-dragon-mesh-indexbufferallocator-unsigned-int-std-mutex-std-unique-lock" class="header-anchor">#</a> <code>dragon::guarded::GuardedAccess&lt;dragon::memory::PartitionedAllocator&lt;dragon::mesh::IndexBufferAllocator,unsigned int&gt;,std::mutex,std::unique_lock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::guarded::GuardedAccess&lt;dragon::memory::PartitionedAllocator&lt;dragon::mesh::IndexBufferAllocator,unsigned int&gt;,std::mutex,std::unique_lock&gt;
{
  dragon::memory::PartitionedAllocator&lt;dragon::mesh::IndexBufferAllocator,unsigned int&gt; *mAccess;
  std::unique_lock&lt;std::mutex&gt; mGuard;
};

</code></pre></div><h3 id="dragon-guarded-guardedaccess-dragon-memory-partitionedallocator-dragon-mesh-vertexbufferallocator-unsigned-int-std-mutex-std-unique-lock"><a href="#dragon-guarded-guardedaccess-dragon-memory-partitionedallocator-dragon-mesh-vertexbufferallocator-unsigned-int-std-mutex-std-unique-lock" class="header-anchor">#</a> <code>dragon::guarded::GuardedAccess&lt;dragon::memory::PartitionedAllocator&lt;dragon::mesh::VertexBufferAllocator,unsigned int&gt;,std::mutex,std::unique_lock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::guarded::GuardedAccess&lt;dragon::memory::PartitionedAllocator&lt;dragon::mesh::VertexBufferAllocator,unsigned int&gt;,std::mutex,std::unique_lock&gt;
{
  dragon::memory::PartitionedAllocator&lt;dragon::mesh::VertexBufferAllocator,unsigned int&gt; *mAccess;
  std::unique_lock&lt;std::mutex&gt; mGuard;
};

</code></pre></div><h3 id="dragon-mesh-details-vertexbufferhandletypekey"><a href="#dragon-mesh-details-vertexbufferhandletypekey" class="header-anchor">#</a> <code>dragon::mesh::details::VertexBufferHandleTypeKey</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::mesh::details::VertexBufferHandleTypeKey
{
};

</code></pre></div><h3 id="dragon-mesh-vertexbuffertype"><a href="#dragon-mesh-vertexbuffertype" class="header-anchor">#</a> <code>dragon::mesh::VertexBufferType</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::mesh::VertexBufferType
{
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-bufferresource-accessor"><a href="#dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-bufferresource-accessor" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::BufferResource::Accessor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::BufferResource::Accessor
{
  dragon::rendering::BufferState *mState;
  bool *mWasEverCreated;
  bool *mWasEverUsed;
  std::variant&lt;bgfx::VertexBufferHandle,bgfx::DynamicVertexBufferHandle&gt; *mResource;
  dragon::mesh::VertexBufferType::ResourceDescription *mDescription;
  dragon::mesh::VertexBufferDescription *mPublicDescription;
  std::optional&lt;dragon::mesh::VertexBufferType::ResourceCreationParameters&gt; *mCreationParameters;
  std::vector&lt;std::variant&lt;dragon::mesh::VertexBufferType::ItemResourceUpdateParameters,dragon::mesh::A0xd4a888ee::VertexBufferType::OffsetResourceUpdateParameters&gt;&gt; *mDeferredOrderedUpdateSequence;
  std::mutex *mAccessLock;
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-flush-l5-delayeddestroy"><a href="#dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-flush-l5-delayeddestroy" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::flush::__l5::DelayedDestroy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::flush::__l5::DelayedDestroy
{
  std::function&lt;void __cdecl(void)&gt; mCallback;
};

</code></pre></div><h3 id="dragon-rendering-bufferresourceinstancetraits-dragon-mesh-vertexbuffertype"><a href="#dragon-rendering-bufferresourceinstancetraits-dragon-mesh-vertexbuffertype" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceInstanceTraits&lt;dragon::mesh::VertexBufferType&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceInstanceTraits&lt;dragon::mesh::VertexBufferType&gt;
{
};

</code></pre></div><h3 id="dragon-memory-buffersource-resolve-l2-lambda-838ec8792ec8f28cdf0b6e20dc2dccfb"><a href="#dragon-memory-buffersource-resolve-l2-lambda-838ec8792ec8f28cdf0b6e20dc2dccfb" class="header-anchor">#</a> <code>dragon::memory::BufferSource::resolve::__l2::&lt;lambda_838ec8792ec8f28cdf0b6e20dc2dccfb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::memory::BufferSource::resolve::__l2::&lt;lambda_838ec8792ec8f28cdf0b6e20dc2dccfb&gt;
{
};

</code></pre></div><h3 id="dragon-mesh-vertexbuffertype-create-l8-lambda-98fb0b014d7bc1522a65b9d9e52e128c"><a href="#dragon-mesh-vertexbuffertype-create-l8-lambda-98fb0b014d7bc1522a65b9d9e52e128c" class="header-anchor">#</a> <code>dragon::mesh::VertexBufferType::create::__l8::&lt;lambda_98fb0b014d7bc1522a65b9d9e52e128c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::mesh::VertexBufferType::create::__l8::&lt;lambda_98fb0b014d7bc1522a65b9d9e52e128c&gt;
{
  std::variant&lt;bgfx::VertexBufferHandle,bgfx::DynamicVertexBufferHandle&gt; *result;
  const dragon::mesh::VertexBufferType::ResourceCreationParameters *creationParameters;
};

</code></pre></div><h3 id="dragon-memory-buffersource-resolve-l2-lambda-97d926c5e853868c401c51db34c77980"><a href="#dragon-memory-buffersource-resolve-l2-lambda-97d926c5e853868c401c51db34c77980" class="header-anchor">#</a> <code>dragon::memory::BufferSource::resolve::__l2::&lt;lambda_97d926c5e853868c401c51db34c77980&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::memory::BufferSource::resolve::__l2::&lt;lambda_97d926c5e853868c401c51db34c77980&gt;
{
};

</code></pre></div><h3 id="dragon-mesh-vertexbuffertype-create-l12-lambda-fc397e945a4de1d8f2f7561c51f6c5f5"><a href="#dragon-mesh-vertexbuffertype-create-l12-lambda-fc397e945a4de1d8f2f7561c51f6c5f5" class="header-anchor">#</a> <code>dragon::mesh::VertexBufferType::create::__l12::&lt;lambda_fc397e945a4de1d8f2f7561c51f6c5f5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::mesh::VertexBufferType::create::__l12::&lt;lambda_fc397e945a4de1d8f2f7561c51f6c5f5&gt;
{
  std::variant&lt;bgfx::VertexBufferHandle,bgfx::DynamicVertexBufferHandle&gt; *result;
  const dragon::mesh::VertexBufferType::ResourceCreationParameters *creationParameters;
};

</code></pre></div><h3 id="dragon-memory-buffersource-resolve-l2-lambda-8edc536ac967a6cc8403b61411f5980b"><a href="#dragon-memory-buffersource-resolve-l2-lambda-8edc536ac967a6cc8403b61411f5980b" class="header-anchor">#</a> <code>dragon::memory::BufferSource::resolve::__l2::&lt;lambda_8edc536ac967a6cc8403b61411f5980b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::memory::BufferSource::resolve::__l2::&lt;lambda_8edc536ac967a6cc8403b61411f5980b&gt;
{
};

</code></pre></div><h3 id="dragon-mesh-vertexbuffertype-update-l2-lambda-40fff7d480dea1c0478fd3f43504e31a-l2-lambda-959750e4c9ef93d18ac58f647170ba0c-l2-lambda-68816c14b011578f28feb10e9febd74e"><a href="#dragon-mesh-vertexbuffertype-update-l2-lambda-40fff7d480dea1c0478fd3f43504e31a-l2-lambda-959750e4c9ef93d18ac58f647170ba0c-l2-lambda-68816c14b011578f28feb10e9febd74e" class="header-anchor">#</a> <code>dragon::mesh::VertexBufferType::update::__l2::&lt;lambda_40fff7d480dea1c0478fd3f43504e31a&gt;::()::__l2::&lt;lambda_959750e4c9ef93d18ac58f647170ba0c&gt;::()::__l2::&lt;lambda_68816c14b011578f28feb10e9febd74e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::mesh::VertexBufferType::update::__l2::&lt;lambda_40fff7d480dea1c0478fd3f43504e31a&gt;::()::__l2::&lt;lambda_959750e4c9ef93d18ac58f647170ba0c&gt;::()::__l2::&lt;lambda_68816c14b011578f28feb10e9febd74e&gt;
{
  bgfx::DynamicVertexBufferHandle *buffer;
  const dragon::mesh::VertexBufferType::ItemResourceUpdateParameters *update;
};

</code></pre></div><h3 id="dragon-memory-buffersource-resolve-l2-lambda-b0d0607edd0eba6840a5b24f1333a20c"><a href="#dragon-memory-buffersource-resolve-l2-lambda-b0d0607edd0eba6840a5b24f1333a20c" class="header-anchor">#</a> <code>dragon::memory::BufferSource::resolve::__l2::&lt;lambda_b0d0607edd0eba6840a5b24f1333a20c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::memory::BufferSource::resolve::__l2::&lt;lambda_b0d0607edd0eba6840a5b24f1333a20c&gt;
{
  dragon::mesh::VertexBufferType::update::__l2::&lt;lambda_40fff7d480dea1c0478fd3f43504e31a&gt;::()::__l2::&lt;lambda_959750e4c9ef93d18ac58f647170ba0c&gt;::()::__l2::&lt;lambda_68816c14b011578f28feb10e9febd74e&gt; *callback;
};

</code></pre></div><h3 id="dragon-memory-buffersource-resolve-l2-lambda-55f5e5e8431511eed148866350b4018e"><a href="#dragon-memory-buffersource-resolve-l2-lambda-55f5e5e8431511eed148866350b4018e" class="header-anchor">#</a> <code>dragon::memory::BufferSource::resolve::__l2::&lt;lambda_55f5e5e8431511eed148866350b4018e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::memory::BufferSource::resolve::__l2::&lt;lambda_55f5e5e8431511eed148866350b4018e&gt;
{
  dragon::mesh::VertexBufferType::update::__l2::&lt;lambda_40fff7d480dea1c0478fd3f43504e31a&gt;::()::__l2::&lt;lambda_959750e4c9ef93d18ac58f647170ba0c&gt;::()::__l2::&lt;lambda_68816c14b011578f28feb10e9febd74e&gt; *callback;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-8edc536ac967a6cc8403b61411f5980b-lambda-b0d0607edd0eba6840a5b24f1333a20c-lambda-55f5e5e8431511eed148866350b4018e"><a href="#dragon-platform-helpers-visitoverloaded-lambda-8edc536ac967a6cc8403b61411f5980b-lambda-b0d0607edd0eba6840a5b24f1333a20c-lambda-55f5e5e8431511eed148866350b4018e" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_8edc536ac967a6cc8403b61411f5980b&gt;,&lt;lambda_b0d0607edd0eba6840a5b24f1333a20c&gt;,&lt;lambda_55f5e5e8431511eed148866350b4018e&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_8edc536ac967a6cc8403b61411f5980b&gt;,&lt;lambda_b0d0607edd0eba6840a5b24f1333a20c&gt;,&lt;lambda_55f5e5e8431511eed148866350b4018e&gt; &gt; : dragon::memory::BufferSource::resolve::__l2::&lt;lambda_8edc536ac967a6cc8403b61411f5980b&gt;, dragon::memory::BufferSource::resolve::__l2::&lt;lambda_b0d0607edd0eba6840a5b24f1333a20c&gt;, dragon::memory::BufferSource::resolve::__l2::&lt;lambda_55f5e5e8431511eed148866350b4018e&gt;
{
};

</code></pre></div><h3 id="dragon-memory-buffersource-resolve-l2-lambda-d476a4c0fe46b80781ed2c0b6efc5311"><a href="#dragon-memory-buffersource-resolve-l2-lambda-d476a4c0fe46b80781ed2c0b6efc5311" class="header-anchor">#</a> <code>dragon::memory::BufferSource::resolve::__l2::&lt;lambda_d476a4c0fe46b80781ed2c0b6efc5311&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::memory::BufferSource::resolve::__l2::&lt;lambda_d476a4c0fe46b80781ed2c0b6efc5311&gt;
{
};

</code></pre></div><h3 id="dragon-mesh-vertexbuffertype-update-l2-lambda-40fff7d480dea1c0478fd3f43504e31a-l2-lambda-056c755a608f3fa91ffb88d1fe572769-l2-lambda-d00d24b5edc695afa9087d59daa5c1f7"><a href="#dragon-mesh-vertexbuffertype-update-l2-lambda-40fff7d480dea1c0478fd3f43504e31a-l2-lambda-056c755a608f3fa91ffb88d1fe572769-l2-lambda-d00d24b5edc695afa9087d59daa5c1f7" class="header-anchor">#</a> <code>dragon::mesh::VertexBufferType::update::__l2::&lt;lambda_40fff7d480dea1c0478fd3f43504e31a&gt;::()::__l2::&lt;lambda_056c755a608f3fa91ffb88d1fe572769&gt;::()::__l2::&lt;lambda_d00d24b5edc695afa9087d59daa5c1f7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::mesh::VertexBufferType::update::__l2::&lt;lambda_40fff7d480dea1c0478fd3f43504e31a&gt;::()::__l2::&lt;lambda_056c755a608f3fa91ffb88d1fe572769&gt;::()::__l2::&lt;lambda_d00d24b5edc695afa9087d59daa5c1f7&gt;
{
  bgfx::DynamicVertexBufferHandle *buffer;
  const dragon::mesh::VertexBufferType::OffsetResourceUpdateParameters *update;
};

</code></pre></div><h3 id="dragon-memory-buffersource-resolve-l2-lambda-b894f1bdc6442f43f52be69056a0f4b3"><a href="#dragon-memory-buffersource-resolve-l2-lambda-b894f1bdc6442f43f52be69056a0f4b3" class="header-anchor">#</a> <code>dragon::memory::BufferSource::resolve::__l2::&lt;lambda_b894f1bdc6442f43f52be69056a0f4b3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::memory::BufferSource::resolve::__l2::&lt;lambda_b894f1bdc6442f43f52be69056a0f4b3&gt;
{
  dragon::mesh::VertexBufferType::update::__l2::&lt;lambda_40fff7d480dea1c0478fd3f43504e31a&gt;::()::__l2::&lt;lambda_056c755a608f3fa91ffb88d1fe572769&gt;::()::__l2::&lt;lambda_d00d24b5edc695afa9087d59daa5c1f7&gt; *callback;
};

</code></pre></div><h3 id="dragon-memory-buffersource-resolve-l2-lambda-5fd1f2ea8d475504cc97b500a9582418"><a href="#dragon-memory-buffersource-resolve-l2-lambda-5fd1f2ea8d475504cc97b500a9582418" class="header-anchor">#</a> <code>dragon::memory::BufferSource::resolve::__l2::&lt;lambda_5fd1f2ea8d475504cc97b500a9582418&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::memory::BufferSource::resolve::__l2::&lt;lambda_5fd1f2ea8d475504cc97b500a9582418&gt;
{
  dragon::mesh::VertexBufferType::update::__l2::&lt;lambda_40fff7d480dea1c0478fd3f43504e31a&gt;::()::__l2::&lt;lambda_056c755a608f3fa91ffb88d1fe572769&gt;::()::__l2::&lt;lambda_d00d24b5edc695afa9087d59daa5c1f7&gt; *callback;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-d476a4c0fe46b80781ed2c0b6efc5311-lambda-b894f1bdc6442f43f52be69056a0f4b3-lambda-5fd1f2ea8d475504cc97b500a9582418"><a href="#dragon-platform-helpers-visitoverloaded-lambda-d476a4c0fe46b80781ed2c0b6efc5311-lambda-b894f1bdc6442f43f52be69056a0f4b3-lambda-5fd1f2ea8d475504cc97b500a9582418" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_d476a4c0fe46b80781ed2c0b6efc5311&gt;,&lt;lambda_b894f1bdc6442f43f52be69056a0f4b3&gt;,&lt;lambda_5fd1f2ea8d475504cc97b500a9582418&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_d476a4c0fe46b80781ed2c0b6efc5311&gt;,&lt;lambda_b894f1bdc6442f43f52be69056a0f4b3&gt;,&lt;lambda_5fd1f2ea8d475504cc97b500a9582418&gt; &gt; : dragon::memory::BufferSource::resolve::__l2::&lt;lambda_d476a4c0fe46b80781ed2c0b6efc5311&gt;, dragon::memory::BufferSource::resolve::__l2::&lt;lambda_b894f1bdc6442f43f52be69056a0f4b3&gt;, dragon::memory::BufferSource::resolve::__l2::&lt;lambda_5fd1f2ea8d475504cc97b500a9582418&gt;
{
};

</code></pre></div><h3 id="dragon-mesh-vertexbuffertype-isvalid-l2-lambda-f39eaa608e24edf60fb4ca9839ef1e2d"><a href="#dragon-mesh-vertexbuffertype-isvalid-l2-lambda-f39eaa608e24edf60fb4ca9839ef1e2d" class="header-anchor">#</a> <code>dragon::mesh::VertexBufferType::isValid::__l2::&lt;lambda_f39eaa608e24edf60fb4ca9839ef1e2d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::mesh::VertexBufferType::isValid::__l2::&lt;lambda_f39eaa608e24edf60fb4ca9839ef1e2d&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-tryresolve-l22-lambda-ea07797ae0991078f478eb958b35d8c5"><a href="#dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-tryresolve-l22-lambda-ea07797ae0991078f478eb958b35d8c5" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::tryResolve::__l22::&lt;lambda_ea07797ae0991078f478eb958b35d8c5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::tryResolve::__l22::&lt;lambda_ea07797ae0991078f478eb958b35d8c5&gt;
{
  dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt; *const __this;
  std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::BufferResource&gt; target;
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-update-l33-lambda-14c51d3e5b277b8455f80d1082e4327f"><a href="#dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-update-l33-lambda-14c51d3e5b277b8455f80d1082e4327f" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::update::__l33::&lt;lambda_14c51d3e5b277b8455f80d1082e4327f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::update::__l33::&lt;lambda_14c51d3e5b277b8455f80d1082e4327f&gt;
{
  std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::BufferResource&gt; target;
  std::shared_ptr&lt;std::variant&lt;dragon::mesh::VertexBufferType::ItemResourceUpdateParameters,dragon::mesh::A0xd4a888ee::VertexBufferType::OffsetResourceUpdateParameters&gt; &gt; updateArgs;
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-create-l5-lambda-dabbf7cedc89c32f11d3266758e58541"><a href="#dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-create-l5-lambda-dabbf7cedc89c32f11d3266758e58541" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::create::__l5::&lt;lambda_dabbf7cedc89c32f11d3266758e58541&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::create::__l5::&lt;lambda_dabbf7cedc89c32f11d3266758e58541&gt;
{
  dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt; *const __this;
  std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::BufferResource&gt; target;
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-create-l5-lambda-45457dacd318d8119fadd3fcbfeee320"><a href="#dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-create-l5-lambda-45457dacd318d8119fadd3fcbfeee320" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::create::__l5::&lt;lambda_45457dacd318d8119fadd3fcbfeee320&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::create::__l5::&lt;lambda_45457dacd318d8119fadd3fcbfeee320&gt;
{
  dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt; *const __this;
  std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::BufferResource&gt; target;
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-flush-l5-lambda-75e7f7263c8b82f0f3103054786d37f9"><a href="#dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-flush-l5-lambda-75e7f7263c8b82f0f3103054786d37f9" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::flush::__l5::&lt;lambda_75e7f7263c8b82f0f3103054786d37f9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::flush::__l5::&lt;lambda_75e7f7263c8b82f0f3103054786d37f9&gt;
{
  dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt; *const __this;
  std::shared_ptr&lt;std::vector&lt;std::optional&lt;dragon::rendering::details::BufferHandleTypeWrapper&lt;dragon::mesh::details::VertexBufferHandleTypeKey,unsigned __int64&gt; &gt;&gt; &gt; buffersToDelete;
};

</code></pre></div><h3 id="dragon-guarded-guardedaccess-std-unordered-map-unsigned-int-dragon-mesh-vertexdeclmanager-impl-decllayout-std-shared-mutex-std-unique-lock"><a href="#dragon-guarded-guardedaccess-std-unordered-map-unsigned-int-dragon-mesh-vertexdeclmanager-impl-decllayout-std-shared-mutex-std-unique-lock" class="header-anchor">#</a> <code>dragon::guarded::GuardedAccess&lt;std::unordered_map&lt;unsigned int,dragon::mesh::VertexDeclManager::Impl::DeclLayout&gt;,std::shared_mutex,std::unique_lock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::guarded::GuardedAccess&lt;std::unordered_map&lt;unsigned int,dragon::mesh::VertexDeclManager::Impl::DeclLayout&gt;,std::shared_mutex,std::unique_lock&gt;
{
  std::unordered_map&lt;unsigned int,dragon::mesh::VertexDeclManager::Impl::DeclLayout&gt; *mAccess;
  std::unique_lock&lt;std::shared_mutex&gt; mGuard;
};

</code></pre></div><h3 id="dragon-guarded-guardedaccess-std-unordered-map-unsigned-short-dragon-mesh-vertexdeclmanager-impl-decllayout-const-std-shared-mutex-std-unique-lock"><a href="#dragon-guarded-guardedaccess-std-unordered-map-unsigned-short-dragon-mesh-vertexdeclmanager-impl-decllayout-const-std-shared-mutex-std-unique-lock" class="header-anchor">#</a> <code>dragon::guarded::GuardedAccess&lt;std::unordered_map&lt;unsigned short,dragon::mesh::VertexDeclManager::Impl::DeclLayout const *&gt;,std::shared_mutex,std::unique_lock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::guarded::GuardedAccess&lt;std::unordered_map&lt;unsigned short,dragon::mesh::VertexDeclManager::Impl::DeclLayout const *&gt;,std::shared_mutex,std::unique_lock&gt;
{
  std::unordered_map&lt;unsigned short,dragon::mesh::VertexDeclManager::Impl::DeclLayout const *&gt; *mAccess;
  std::unique_lock&lt;std::shared_mutex&gt; mGuard;
};

</code></pre></div><h3 id="dragon-associativetraits-dragon-guarded-guardedaccess-std-unordered-map-unsigned-short-dragon-mesh-vertexdeclmanager-impl-decllayout-const-std-shared-mutex-std-shared-lock"><a href="#dragon-associativetraits-dragon-guarded-guardedaccess-std-unordered-map-unsigned-short-dragon-mesh-vertexdeclmanager-impl-decllayout-const-std-shared-mutex-std-shared-lock" class="header-anchor">#</a> <code>dragon::AssociativeTraits&lt;dragon::guarded::GuardedAccess&lt;std::unordered_map&lt;unsigned short,dragon::mesh::VertexDeclManager::Impl::DeclLayout const *&gt;,std::shared_mutex,std::shared_lock&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::AssociativeTraits&lt;dragon::guarded::GuardedAccess&lt;std::unordered_map&lt;unsigned short,dragon::mesh::VertexDeclManager::Impl::DeclLayout const *&gt;,std::shared_mutex,std::shared_lock&gt; &gt;
{
};

</code></pre></div><h3 id="dragon-guarded-guardedaccess-std-unordered-map-unsigned-short-dragon-mesh-vertexdeclmanager-impl-decllayout-const-std-shared-mutex-std-shared-lock"><a href="#dragon-guarded-guardedaccess-std-unordered-map-unsigned-short-dragon-mesh-vertexdeclmanager-impl-decllayout-const-std-shared-mutex-std-shared-lock" class="header-anchor">#</a> <code>dragon::guarded::GuardedAccess&lt;std::unordered_map&lt;unsigned short,dragon::mesh::VertexDeclManager::Impl::DeclLayout const *&gt;,std::shared_mutex,std::shared_lock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::guarded::GuardedAccess&lt;std::unordered_map&lt;unsigned short,dragon::mesh::VertexDeclManager::Impl::DeclLayout const *&gt;,std::shared_mutex,std::shared_lock&gt;
{
  const std::unordered_map&lt;unsigned short,dragon::mesh::VertexDeclManager::Impl::DeclLayout const *&gt; *mAccess;
  std::shared_lock&lt;std::shared_mutex&gt; mGuard;
};

</code></pre></div><h3 id="dragon-associativetraits-dragon-guarded-guardedaccess-std-unordered-map-unsigned-int-dragon-mesh-vertexdeclmanager-impl-decllayout-std-shared-mutex-std-shared-lock"><a href="#dragon-associativetraits-dragon-guarded-guardedaccess-std-unordered-map-unsigned-int-dragon-mesh-vertexdeclmanager-impl-decllayout-std-shared-mutex-std-shared-lock" class="header-anchor">#</a> <code>dragon::AssociativeTraits&lt;dragon::guarded::GuardedAccess&lt;std::unordered_map&lt;unsigned int,dragon::mesh::VertexDeclManager::Impl::DeclLayout&gt;,std::shared_mutex,std::shared_lock&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::AssociativeTraits&lt;dragon::guarded::GuardedAccess&lt;std::unordered_map&lt;unsigned int,dragon::mesh::VertexDeclManager::Impl::DeclLayout&gt;,std::shared_mutex,std::shared_lock&gt; &gt;
{
};

</code></pre></div><h3 id="dragon-guarded-guardedaccess-std-unordered-map-unsigned-int-dragon-mesh-vertexdeclmanager-impl-decllayout-std-shared-mutex-std-shared-lock"><a href="#dragon-guarded-guardedaccess-std-unordered-map-unsigned-int-dragon-mesh-vertexdeclmanager-impl-decllayout-std-shared-mutex-std-shared-lock" class="header-anchor">#</a> <code>dragon::guarded::GuardedAccess&lt;std::unordered_map&lt;unsigned int,dragon::mesh::VertexDeclManager::Impl::DeclLayout&gt;,std::shared_mutex,std::shared_lock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::guarded::GuardedAccess&lt;std::unordered_map&lt;unsigned int,dragon::mesh::VertexDeclManager::Impl::DeclLayout&gt;,std::shared_mutex,std::shared_lock&gt;
{
  const std::unordered_map&lt;unsigned int,dragon::mesh::VertexDeclManager::Impl::DeclLayout&gt; *mAccess;
  std::shared_lock&lt;std::shared_mutex&gt; mGuard;
};

</code></pre></div><h3 id="dragon-associativetraits-dragon-guarded-guardedaccess-std-unordered-map-unsigned-int-dragon-mesh-vertexdeclmanager-impl-decllayout-std-shared-mutex-std-unique-lock"><a href="#dragon-associativetraits-dragon-guarded-guardedaccess-std-unordered-map-unsigned-int-dragon-mesh-vertexdeclmanager-impl-decllayout-std-shared-mutex-std-unique-lock" class="header-anchor">#</a> <code>dragon::AssociativeTraits&lt;dragon::guarded::GuardedAccess&lt;std::unordered_map&lt;unsigned int,dragon::mesh::VertexDeclManager::Impl::DeclLayout&gt;,std::shared_mutex,std::unique_lock&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::AssociativeTraits&lt;dragon::guarded::GuardedAccess&lt;std::unordered_map&lt;unsigned int,dragon::mesh::VertexDeclManager::Impl::DeclLayout&gt;,std::shared_mutex,std::unique_lock&gt; &gt;
{
};

</code></pre></div><h3 id="dragon-platform-bgfxcallbacks"><a href="#dragon-platform-bgfxcallbacks" class="header-anchor">#</a> <code>dragon::platform::BgfxCallbacks</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::BgfxCallbacks : bgfx::CallbackI
{
  Bedrock::Threading::InstancedThreadLocal&lt;std::vector&lt;Core::Profile::CPUProfileTokenMicroProfile&gt;,std::allocator&lt;std::vector&lt;Core::Profile::CPUProfileTokenMicroProfile&gt; &gt; &gt; mProfileTokenStack;
  dragon::rendering::GraphicsTasks *mGraphicsTasks;
  dragon::platform::BgfxContext *mContext;
};

</code></pre></div><h3 id="dragon-framegraph-detail-linkedpass-dragon-rendering-rendercontext"><a href="#dragon-framegraph-detail-linkedpass-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>dragon::framegraph::detail::LinkedPass&lt;dragon::rendering::RenderContext&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::framegraph::detail::LinkedPass&lt;dragon::rendering::RenderContext&gt;
{
  std::unique_ptr&lt;dragon::framegraph::detail::AbstractPass&lt;dragon::rendering::RenderContext&gt;&gt; pass;
  dragon::framegraph::detail::ResolveContext&lt;dragon::rendering::RenderContext&gt; linkContext;
};

</code></pre></div><h3 id="dragon-framegraph-dispatcherframecontext"><a href="#dragon-framegraph-dispatcherframecontext" class="header-anchor">#</a> <code>dragon::framegraph::DispatcherFrameContext</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct dragon::framegraph::DispatcherFrameContext
{
  Core::CpuRingBufferAllocator&lt;unsigned char,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt; *mAllocator;
  cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt; *mDispatcher;
  dragon::rendering::BgfxEncoderPool *mEncoderPool;
  dragon::platform::ResourcesManager *mResourcesManager;
  dragon::res::ResolvedTextureResource *const mMissingTexture;
};

</code></pre></div><h3 id="dragon-platform-bgfxcontext-updatevsync-l8-lambda-764a87c0eaf3482de06bcaf39f3678bd"><a href="#dragon-platform-bgfxcontext-updatevsync-l8-lambda-764a87c0eaf3482de06bcaf39f3678bd" class="header-anchor">#</a> <code>dragon::platform::BgfxContext::updateVSync::__l8::&lt;lambda_764a87c0eaf3482de06bcaf39f3678bd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::BgfxContext::updateVSync::__l8::&lt;lambda_764a87c0eaf3482de06bcaf39f3678bd&gt;
{
  dragon::platform::BgfxContext *const __this;
};

</code></pre></div><h3 id="dragon-platform-bgfxcontext-updatemsaalevel-l5-lambda-a8eeabbf44df1b129e628a89dd84c9f0"><a href="#dragon-platform-bgfxcontext-updatemsaalevel-l5-lambda-a8eeabbf44df1b129e628a89dd84c9f0" class="header-anchor">#</a> <code>dragon::platform::BgfxContext::updateMsaaLevel::__l5::&lt;lambda_a8eeabbf44df1b129e628a89dd84c9f0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::BgfxContext::updateMsaaLevel::__l5::&lt;lambda_a8eeabbf44df1b129e628a89dd84c9f0&gt;
{
  dragon::platform::BgfxContext *const __this;
};

</code></pre></div><h3 id="dragon-platform-bgfxcontext-updateresolution-l2-lambda-0f0591cc5a384e8319c0edb33e15d2a8"><a href="#dragon-platform-bgfxcontext-updateresolution-l2-lambda-0f0591cc5a384e8319c0edb33e15d2a8" class="header-anchor">#</a> <code>dragon::platform::BgfxContext::updateResolution::__l2::&lt;lambda_0f0591cc5a384e8319c0edb33e15d2a8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::BgfxContext::updateResolution::__l2::&lt;lambda_0f0591cc5a384e8319c0edb33e15d2a8&gt;
{
  dragon::platform::BgfxContext *const __this;
  const unsigned int width;
  const unsigned int height;
};

</code></pre></div><h3 id="dragon-framegraph-linker-dragon-rendering-rendercontext-dragon-framegraph-nolinkertrace-l2-desccomparator"><a href="#dragon-framegraph-linker-dragon-rendering-rendercontext-dragon-framegraph-nolinkertrace-l2-desccomparator" class="header-anchor">#</a> <code>dragon::framegraph::Linker&lt;dragon::rendering::RenderContext,dragon::framegraph::NoLinkerTrace&gt;::()::__l2::DescComparator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::framegraph::Linker&lt;dragon::rendering::RenderContext,dragon::framegraph::NoLinkerTrace&gt;::()::__l2::DescComparator
{
};

</code></pre></div><h3 id="dragon-platform-bgfxcallbacks-parallelforeach-l2-lambda-c5b29f0045c211cdae0854f24c11943a"><a href="#dragon-platform-bgfxcallbacks-parallelforeach-l2-lambda-c5b29f0045c211cdae0854f24c11943a" class="header-anchor">#</a> <code>dragon::platform::BgfxCallbacks::parallelForeach::__l2::&lt;lambda_c5b29f0045c211cdae0854f24c11943a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::BgfxCallbacks::parallelForeach::__l2::&lt;lambda_c5b29f0045c211cdae0854f24c11943a&gt;
{
  void (__fastcall **_workCallback)(void *, const unsigned int);
  void **_context;
};

</code></pre></div><h3 id="dragon-rendering-graphicstasks-forcounter-l10-lambda-6742c2668b399ab4e6e158503fd0428d"><a href="#dragon-rendering-graphicstasks-forcounter-l10-lambda-6742c2668b399ab4e6e158503fd0428d" class="header-anchor">#</a> <code>dragon::rendering::GraphicsTasks::forCounter::__l10::&lt;lambda_6742c2668b399ab4e6e158503fd0428d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::GraphicsTasks::forCounter::__l10::&lt;lambda_6742c2668b399ab4e6e158503fd0428d&gt;
{
  dragon::platform::BgfxCallbacks::parallelForeach::__l2::&lt;lambda_c5b29f0045c211cdae0854f24c11943a&gt; *callback;
};

</code></pre></div><h3 id="dragon-rendering-graphicstasks-forcounter-l8-lambda-9e8a04d8d15f668592b8fe526de94bee"><a href="#dragon-rendering-graphicstasks-forcounter-l8-lambda-9e8a04d8d15f668592b8fe526de94bee" class="header-anchor">#</a> <code>dragon::rendering::GraphicsTasks::forCounter::__l8::&lt;lambda_9e8a04d8d15f668592b8fe526de94bee&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::GraphicsTasks::forCounter::__l8::&lt;lambda_9e8a04d8d15f668592b8fe526de94bee&gt;
{
  const std::function&lt;void __cdecl(unsigned int)&gt; *resolve;
};

</code></pre></div><h3 id="dragon-rendering-graphicstasks-forcounter-l8-lambda-09a05b1c483888446fb68d850ffc7086"><a href="#dragon-rendering-graphicstasks-forcounter-l8-lambda-09a05b1c483888446fb68d850ffc7086" class="header-anchor">#</a> <code>dragon::rendering::GraphicsTasks::forCounter::__l8::&lt;lambda_09a05b1c483888446fb68d850ffc7086&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::GraphicsTasks::forCounter::__l8::&lt;lambda_09a05b1c483888446fb68d850ffc7086&gt;
{
  dragon::platform::BgfxCallbacks::parallelForeach::__l2::&lt;lambda_c5b29f0045c211cdae0854f24c11943a&gt; *callback;
};

</code></pre></div><h3 id="dragon-platform-createquad-l2-lambda-7a30cfcb04208d5fc2a27b20b2e1bc05"><a href="#dragon-platform-createquad-l2-lambda-7a30cfcb04208d5fc2a27b20b2e1bc05" class="header-anchor">#</a> <code>dragon::platform::_createQuad::__l2::&lt;lambda_7a30cfcb04208d5fc2a27b20b2e1bc05&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::_createQuad::__l2::&lt;lambda_7a30cfcb04208d5fc2a27b20b2e1bc05&gt;
{
};

</code></pre></div><h3 id="dragon-platform-shaderprogram"><a href="#dragon-platform-shaderprogram" class="header-anchor">#</a> <code>dragon::platform::ShaderProgram</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::ShaderProgram
{
  dragon::platform::ShaderProgram::ShaderType mShaderType;
  bgfx::ProgramHandle mShaderProgram;
  std::vector&lt;bgfx::ShaderHandle&gt; mShaders;
};

</code></pre></div><h3 id="dragon-framegraph-detail-resolvingtraits-dragon-rendering-rendercontext"><a href="#dragon-framegraph-detail-resolvingtraits-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>dragon::framegraph::detail::ResolvingTraits&lt;dragon::rendering::RenderContext&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::framegraph::detail::ResolvingTraits&lt;dragon::rendering::RenderContext&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-applyuniformsandtextures-l30-lambda-1704d25b6cc8d786cf29264f064185c5"><a href="#dragon-rendering-applyuniformsandtextures-l30-lambda-1704d25b6cc8d786cf29264f064185c5" class="header-anchor">#</a> <code>dragon::rendering::_applyUniformsAndTextures::__l30::&lt;lambda_1704d25b6cc8d786cf29264f064185c5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::_applyUniformsAndTextures::__l30::&lt;lambda_1704d25b6cc8d786cf29264f064185c5&gt;
{
  dragon::materials::MaterialUniformName *parameterName;
  bool *valueMustComeFromOverride;
};

</code></pre></div><h3 id="dragon-rendering-applyuniformsandtextures-l30-lambda-a99b85b88cd6cf6e89ad7036a456b843"><a href="#dragon-rendering-applyuniformsandtextures-l30-lambda-a99b85b88cd6cf6e89ad7036a456b843" class="header-anchor">#</a> <code>dragon::rendering::_applyUniformsAndTextures::__l30::&lt;lambda_a99b85b88cd6cf6e89ad7036a456b843&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::_applyUniformsAndTextures::__l30::&lt;lambda_a99b85b88cd6cf6e89ad7036a456b843&gt;
{
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-1704d25b6cc8d786cf29264f064185c5-lambda-a99b85b88cd6cf6e89ad7036a456b843"><a href="#dragon-platform-helpers-visitoverloaded-lambda-1704d25b6cc8d786cf29264f064185c5-lambda-a99b85b88cd6cf6e89ad7036a456b843" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_1704d25b6cc8d786cf29264f064185c5&gt;,&lt;lambda_a99b85b88cd6cf6e89ad7036a456b843&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_1704d25b6cc8d786cf29264f064185c5&gt;,&lt;lambda_a99b85b88cd6cf6e89ad7036a456b843&gt; &gt; : dragon::rendering::_applyUniformsAndTextures::__l30::&lt;lambda_1704d25b6cc8d786cf29264f064185c5&gt;, dragon::rendering::_applyUniformsAndTextures::__l30::&lt;lambda_a99b85b88cd6cf6e89ad7036a456b843&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-applyuniformsandtextures-l43-lambda-6b7fab46896fa255efc95c2fbafc2ae2"><a href="#dragon-rendering-applyuniformsandtextures-l43-lambda-6b7fab46896fa255efc95c2fbafc2ae2" class="header-anchor">#</a> <code>dragon::rendering::_applyUniformsAndTextures::__l43::&lt;lambda_6b7fab46896fa255efc95c2fbafc2ae2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::_applyUniformsAndTextures::__l43::&lt;lambda_6b7fab46896fa255efc95c2fbafc2ae2&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-applyuniformsandtextures-l47-lambda-d47516446d760cd48e0888bd2eb90dfe"><a href="#dragon-rendering-applyuniformsandtextures-l47-lambda-d47516446d760cd48e0888bd2eb90dfe" class="header-anchor">#</a> <code>dragon::rendering::_applyUniformsAndTextures::__l47::&lt;lambda_d47516446d760cd48e0888bd2eb90dfe&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::_applyUniformsAndTextures::__l47::&lt;lambda_d47516446d760cd48e0888bd2eb90dfe&gt;
{
  dragon::rendering::drawcommands::GraphicsCommandContext *target;
  const unsigned __int8 *slot;
  const dragon::materials::MaterialUniform *const *parameter;
};

</code></pre></div><h3 id="dragon-rendering-applyuniformsandtextures-l47-lambda-3d2bab5ce60b25cd54e7ca455a9d4cdc"><a href="#dragon-rendering-applyuniformsandtextures-l47-lambda-3d2bab5ce60b25cd54e7ca455a9d4cdc" class="header-anchor">#</a> <code>dragon::rendering::_applyUniformsAndTextures::__l47::&lt;lambda_3d2bab5ce60b25cd54e7ca455a9d4cdc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::_applyUniformsAndTextures::__l47::&lt;lambda_3d2bab5ce60b25cd54e7ca455a9d4cdc&gt;
{
  const dragon::materials::definition::ShaderPipeline *pipeline;
  dragon::rendering::drawcommands::GraphicsCommandContext *target;
  dragon::mesh::VertexBufferResourceManager *vbManager;
  const unsigned __int8 *slot;
  const dragon::materials::definition::SamplerAccess *access;
};

</code></pre></div><h3 id="dragon-rendering-applyuniformsandtextures-l47-lambda-d0a0ad24ae306ddb7fa133535f6a8ca9"><a href="#dragon-rendering-applyuniformsandtextures-l47-lambda-d0a0ad24ae306ddb7fa133535f6a8ca9" class="header-anchor">#</a> <code>dragon::rendering::_applyUniformsAndTextures::__l47::&lt;lambda_d0a0ad24ae306ddb7fa133535f6a8ca9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::_applyUniformsAndTextures::__l47::&lt;lambda_d0a0ad24ae306ddb7fa133535f6a8ca9&gt;
{
  const dragon::materials::definition::ShaderPipeline *pipeline;
  dragon::rendering::drawcommands::GraphicsCommandContext *target;
  dragon::mesh::IndexBufferResourceManager *ibManager;
  const unsigned __int8 *slot;
  const dragon::materials::definition::SamplerAccess *access;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-d47516446d760cd48e0888bd2eb90dfe-lambda-3d2bab5ce60b25cd54e7ca455a9d4cdc-lambda-d0a0ad24ae306ddb7fa133535f6a8ca9"><a href="#dragon-platform-helpers-visitoverloaded-lambda-d47516446d760cd48e0888bd2eb90dfe-lambda-3d2bab5ce60b25cd54e7ca455a9d4cdc-lambda-d0a0ad24ae306ddb7fa133535f6a8ca9" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_d47516446d760cd48e0888bd2eb90dfe&gt;,&lt;lambda_3d2bab5ce60b25cd54e7ca455a9d4cdc&gt;,&lt;lambda_d0a0ad24ae306ddb7fa133535f6a8ca9&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_d47516446d760cd48e0888bd2eb90dfe&gt;,&lt;lambda_3d2bab5ce60b25cd54e7ca455a9d4cdc&gt;,&lt;lambda_d0a0ad24ae306ddb7fa133535f6a8ca9&gt; &gt; : dragon::rendering::_applyUniformsAndTextures::__l47::&lt;lambda_d47516446d760cd48e0888bd2eb90dfe&gt;, dragon::rendering::_applyUniformsAndTextures::__l47::&lt;lambda_3d2bab5ce60b25cd54e7ca455a9d4cdc&gt;, dragon::rendering::_applyUniformsAndTextures::__l47::&lt;lambda_d0a0ad24ae306ddb7fa133535f6a8ca9&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-applyuniformsandtextures-l30-lambda-7277a5edf1561b278cbb0acb1a0e072a"><a href="#dragon-rendering-applyuniformsandtextures-l30-lambda-7277a5edf1561b278cbb0acb1a0e072a" class="header-anchor">#</a> <code>dragon::rendering::_applyUniformsAndTextures::__l30::&lt;lambda_7277a5edf1561b278cbb0acb1a0e072a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::_applyUniformsAndTextures::__l30::&lt;lambda_7277a5edf1561b278cbb0acb1a0e072a&gt;
{
  dragon::materials::MaterialUniformName *parameterName;
  bool *valueMustComeFromOverride;
};

</code></pre></div><h3 id="dragon-rendering-applyuniformsandtextures-l30-lambda-48a2c54785fc918f684984be41e58521"><a href="#dragon-rendering-applyuniformsandtextures-l30-lambda-48a2c54785fc918f684984be41e58521" class="header-anchor">#</a> <code>dragon::rendering::_applyUniformsAndTextures::__l30::&lt;lambda_48a2c54785fc918f684984be41e58521&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::_applyUniformsAndTextures::__l30::&lt;lambda_48a2c54785fc918f684984be41e58521&gt;
{
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-7277a5edf1561b278cbb0acb1a0e072a-lambda-48a2c54785fc918f684984be41e58521"><a href="#dragon-platform-helpers-visitoverloaded-lambda-7277a5edf1561b278cbb0acb1a0e072a-lambda-48a2c54785fc918f684984be41e58521" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_7277a5edf1561b278cbb0acb1a0e072a&gt;,&lt;lambda_48a2c54785fc918f684984be41e58521&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_7277a5edf1561b278cbb0acb1a0e072a&gt;,&lt;lambda_48a2c54785fc918f684984be41e58521&gt; &gt; : dragon::rendering::_applyUniformsAndTextures::__l30::&lt;lambda_7277a5edf1561b278cbb0acb1a0e072a&gt;, dragon::rendering::_applyUniformsAndTextures::__l30::&lt;lambda_48a2c54785fc918f684984be41e58521&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-applyuniformsandtextures-l43-lambda-d19837e8ae0c2b3bd8e1d106ac7d5ff4"><a href="#dragon-rendering-applyuniformsandtextures-l43-lambda-d19837e8ae0c2b3bd8e1d106ac7d5ff4" class="header-anchor">#</a> <code>dragon::rendering::_applyUniformsAndTextures::__l43::&lt;lambda_d19837e8ae0c2b3bd8e1d106ac7d5ff4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::_applyUniformsAndTextures::__l43::&lt;lambda_d19837e8ae0c2b3bd8e1d106ac7d5ff4&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-applyuniformsandtextures-l43-lambda-2038b89864331e997dac0998908fbef8"><a href="#dragon-rendering-applyuniformsandtextures-l43-lambda-2038b89864331e997dac0998908fbef8" class="header-anchor">#</a> <code>dragon::rendering::_applyUniformsAndTextures::__l43::&lt;lambda_2038b89864331e997dac0998908fbef8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::_applyUniformsAndTextures::__l43::&lt;lambda_2038b89864331e997dac0998908fbef8&gt;
{
  bool *valueMustComeFromOverride;
  dragon::materials::MaterialUniformName *parameterName;
  const dragon::materials::definition::ShaderPipeline *pipeline;
  dragon::rendering::drawcommands::GraphicsCommandContext *target;
  const dragon::materials::MaterialUniform::TextureParameter *textureParameter;
  bool *isValidState;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-d19837e8ae0c2b3bd8e1d106ac7d5ff4-lambda-2038b89864331e997dac0998908fbef8"><a href="#dragon-platform-helpers-visitoverloaded-lambda-d19837e8ae0c2b3bd8e1d106ac7d5ff4-lambda-2038b89864331e997dac0998908fbef8" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_d19837e8ae0c2b3bd8e1d106ac7d5ff4&gt;,&lt;lambda_2038b89864331e997dac0998908fbef8&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_d19837e8ae0c2b3bd8e1d106ac7d5ff4&gt;,&lt;lambda_2038b89864331e997dac0998908fbef8&gt; &gt; : dragon::rendering::_applyUniformsAndTextures::__l43::&lt;lambda_d19837e8ae0c2b3bd8e1d106ac7d5ff4&gt;, dragon::rendering::_applyUniformsAndTextures::__l43::&lt;lambda_2038b89864331e997dac0998908fbef8&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-drawcommands-resolvevertexbuffer-l2-lambda-12b1a0ae33466fe2a2564a97983e407c"><a href="#dragon-rendering-drawcommands-resolvevertexbuffer-l2-lambda-12b1a0ae33466fe2a2564a97983e407c" class="header-anchor">#</a> <code>dragon::rendering::drawcommands::_resolveVertexBuffer::__l2::&lt;lambda_12b1a0ae33466fe2a2564a97983e407c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::drawcommands::_resolveVertexBuffer::__l2::&lt;lambda_12b1a0ae33466fe2a2564a97983e407c&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-drawcommands-resolveindexbuffer-l2-lambda-040c469f11856dccdc394d032338fec6"><a href="#dragon-rendering-drawcommands-resolveindexbuffer-l2-lambda-040c469f11856dccdc394d032338fec6" class="header-anchor">#</a> <code>dragon::rendering::drawcommands::_resolveIndexBuffer::__l2::&lt;lambda_040c469f11856dccdc394d032338fec6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::drawcommands::_resolveIndexBuffer::__l2::&lt;lambda_040c469f11856dccdc394d032338fec6&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-drawcommands-computecommandcontext"><a href="#dragon-rendering-drawcommands-computecommandcontext" class="header-anchor">#</a> <code>dragon::rendering::drawcommands::ComputeCommandContext</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::drawcommands::ComputeCommandContext : dragon::rendering::drawcommands::GraphicsCommandContext
{
};

</code></pre></div><h3 id="dragon-rendering-drawcommands-binduniforms-l9-lambda-980fd089874be37b5b32e9bedba6dffa"><a href="#dragon-rendering-drawcommands-binduniforms-l9-lambda-980fd089874be37b5b32e9bedba6dffa" class="header-anchor">#</a> <code>dragon::rendering::drawcommands::bindUniforms::__l9::&lt;lambda_980fd089874be37b5b32e9bedba6dffa&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::drawcommands::bindUniforms::__l9::&lt;lambda_980fd089874be37b5b32e9bedba6dffa&gt;
{
  bgfx::Encoder *encoder;
  unsigned __int8 *textureUnit;
  const std::optional&lt;dragon::rendering::drawcommands::TextureBinding&gt; *optionalTexture;
};

</code></pre></div><h3 id="dragon-rendering-drawcommands-binduniforms-l9-lambda-4c449e30615802e73e5409d309bfe37a"><a href="#dragon-rendering-drawcommands-binduniforms-l9-lambda-4c449e30615802e73e5409d309bfe37a" class="header-anchor">#</a> <code>dragon::rendering::drawcommands::bindUniforms::__l9::&lt;lambda_4c449e30615802e73e5409d309bfe37a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::drawcommands::bindUniforms::__l9::&lt;lambda_4c449e30615802e73e5409d309bfe37a&gt;
{
  bgfx::Encoder *encoder;
  unsigned __int8 *textureUnit;
  const std::optional&lt;dragon::rendering::drawcommands::TextureBinding&gt; *optionalTexture;
};

</code></pre></div><h3 id="dragon-rendering-drawcommands-binduniforms-l9-lambda-c013d7da2eae639c3e1d79222ed700da"><a href="#dragon-rendering-drawcommands-binduniforms-l9-lambda-c013d7da2eae639c3e1d79222ed700da" class="header-anchor">#</a> <code>dragon::rendering::drawcommands::bindUniforms::__l9::&lt;lambda_c013d7da2eae639c3e1d79222ed700da&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::drawcommands::bindUniforms::__l9::&lt;lambda_c013d7da2eae639c3e1d79222ed700da&gt;
{
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-980fd089874be37b5b32e9bedba6dffa-lambda-4c449e30615802e73e5409d309bfe37a-lambda-c013d7da2eae639c3e1d79222ed700da"><a href="#dragon-platform-helpers-visitoverloaded-lambda-980fd089874be37b5b32e9bedba6dffa-lambda-4c449e30615802e73e5409d309bfe37a-lambda-c013d7da2eae639c3e1d79222ed700da" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_980fd089874be37b5b32e9bedba6dffa&gt;,&lt;lambda_4c449e30615802e73e5409d309bfe37a&gt;,&lt;lambda_c013d7da2eae639c3e1d79222ed700da&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_980fd089874be37b5b32e9bedba6dffa&gt;,&lt;lambda_4c449e30615802e73e5409d309bfe37a&gt;,&lt;lambda_c013d7da2eae639c3e1d79222ed700da&gt; &gt; : dragon::rendering::drawcommands::bindUniforms::__l9::&lt;lambda_980fd089874be37b5b32e9bedba6dffa&gt;, dragon::rendering::drawcommands::bindUniforms::__l9::&lt;lambda_4c449e30615802e73e5409d309bfe37a&gt;, dragon::rendering::drawcommands::bindUniforms::__l9::&lt;lambda_c013d7da2eae639c3e1d79222ed700da&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-processpendingcputasks-l8-lambda-448c4b3230988ab3fda8df397a79df9a"><a href="#dragon-rendering-processpendingcputasks-l8-lambda-448c4b3230988ab3fda8df397a79df9a" class="header-anchor">#</a> <code>dragon::rendering::_processPendingCpuTasks::__l8::&lt;lambda_448c4b3230988ab3fda8df397a79df9a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::_processPendingCpuTasks::__l8::&lt;lambda_448c4b3230988ab3fda8df397a79df9a&gt;
{
  std::function&lt;void __cdecl(std::shared_ptr&lt;dragon::rendering::ProcessingPassReference&gt;)&gt; *taskRunner;
  std::shared_ptr&lt;dragon::rendering::ProcessingPassReference&gt; task;
};

</code></pre></div><h3 id="dragon-rendering-processpendingcputasks-l2-lambda-a49022d37b2992ca9337e17e58dd6417"><a href="#dragon-rendering-processpendingcputasks-l2-lambda-a49022d37b2992ca9337e17e58dd6417" class="header-anchor">#</a> <code>dragon::rendering::_processPendingCpuTasks::__l2::&lt;lambda_a49022d37b2992ca9337e17e58dd6417&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::_processPendingCpuTasks::__l2::&lt;lambda_a49022d37b2992ca9337e17e58dd6417&gt;
{
  std::mutex *actionMutex;
  std::map&lt;void const *,std::shared_ptr&lt;dragon::rendering::ProcessingPassReference&gt;&gt; *pendingCpuPasses;
  std::vector&lt;std::shared_ptr&lt;cg::details::DispatchToken&lt;std::shared_ptr&lt;cg::details::WorkToken const &gt;,std::shared_ptr&lt;std::function&lt;void __cdecl(dragon::rendering::RenderContext &amp;)&gt; &gt; &gt; const &gt;&gt; *pendingTokensBeingBuilt;
  cg::details::SpecializedScopedFrame&lt;cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution,void&gt; *dispFrame;
  std::function&lt;void __cdecl(std::shared_ptr&lt;dragon::rendering::ProcessingPassReference&gt;)&gt; *taskRunner;
};

</code></pre></div><h3 id="dragon-rendering-processpendingcputasks-l2-lambda-a49022d37b2992ca9337e17e58dd6417-l8-lambda-283f970f6eea003ba75cbea4ab8e6818"><a href="#dragon-rendering-processpendingcputasks-l2-lambda-a49022d37b2992ca9337e17e58dd6417-l8-lambda-283f970f6eea003ba75cbea4ab8e6818" class="header-anchor">#</a> <code>dragon::rendering::_processPendingCpuTasks::__l2::&lt;lambda_a49022d37b2992ca9337e17e58dd6417&gt;::()::__l8::&lt;lambda_283f970f6eea003ba75cbea4ab8e6818&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::_processPendingCpuTasks::__l2::&lt;lambda_a49022d37b2992ca9337e17e58dd6417&gt;::()::__l8::&lt;lambda_283f970f6eea003ba75cbea4ab8e6818&gt;
{
  std::function&lt;void __cdecl(std::shared_ptr&lt;dragon::rendering::ProcessingPassReference&gt;)&gt; *taskRunner;
  std::shared_ptr&lt;dragon::rendering::ProcessingPassReference&gt; task;
};

</code></pre></div><h3 id="dragon-rendering-processpendingcputasks-l8-lambda-448c4b3230988ab3fda8df397a79df9a-l2-lambda-1d6e7202e79cb330602c9fa0320586e0"><a href="#dragon-rendering-processpendingcputasks-l8-lambda-448c4b3230988ab3fda8df397a79df9a-l2-lambda-1d6e7202e79cb330602c9fa0320586e0" class="header-anchor">#</a> <code>dragon::rendering::_processPendingCpuTasks::__l8::&lt;lambda_448c4b3230988ab3fda8df397a79df9a&gt;::()::__l2::&lt;lambda_1d6e7202e79cb330602c9fa0320586e0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::_processPendingCpuTasks::__l8::&lt;lambda_448c4b3230988ab3fda8df397a79df9a&gt;::()::__l2::&lt;lambda_1d6e7202e79cb330602c9fa0320586e0&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-processpendingcputasks-l2-lambda-a49022d37b2992ca9337e17e58dd6417-l8-lambda-283f970f6eea003ba75cbea4ab8e6818-l2-lambda-ece766a7c2ff5b0bb61a1d869df9a721"><a href="#dragon-rendering-processpendingcputasks-l2-lambda-a49022d37b2992ca9337e17e58dd6417-l8-lambda-283f970f6eea003ba75cbea4ab8e6818-l2-lambda-ece766a7c2ff5b0bb61a1d869df9a721" class="header-anchor">#</a> <code>dragon::rendering::_processPendingCpuTasks::__l2::&lt;lambda_a49022d37b2992ca9337e17e58dd6417&gt;::()::__l8::&lt;lambda_283f970f6eea003ba75cbea4ab8e6818&gt;::()::__l2::&lt;lambda_ece766a7c2ff5b0bb61a1d869df9a721&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::_processPendingCpuTasks::__l2::&lt;lambda_a49022d37b2992ca9337e17e58dd6417&gt;::()::__l8::&lt;lambda_283f970f6eea003ba75cbea4ab8e6818&gt;::()::__l2::&lt;lambda_ece766a7c2ff5b0bb61a1d869df9a721&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-graphicstasks-frame-l36-lambda-55ed0e2edbf27362bca1fa42ad637ebf"><a href="#dragon-rendering-graphicstasks-frame-l36-lambda-55ed0e2edbf27362bca1fa42ad637ebf" class="header-anchor">#</a> <code>dragon::rendering::GraphicsTasks::frame::__l36::&lt;lambda_55ed0e2edbf27362bca1fa42ad637ebf&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::GraphicsTasks::frame::__l36::&lt;lambda_55ed0e2edbf27362bca1fa42ad637ebf&gt;
{
  std::shared_ptr&lt;Core::DeferredTask&gt; callback;
};

</code></pre></div><h3 id="dragon-rendering-graphicstasks-frame-l2-lambda-ce01dea6a319546938933c0ba3ab32c3-l26-lambda-5c9fff34ec9def2773296cbe30df6075"><a href="#dragon-rendering-graphicstasks-frame-l2-lambda-ce01dea6a319546938933c0ba3ab32c3-l26-lambda-5c9fff34ec9def2773296cbe30df6075" class="header-anchor">#</a> <code>dragon::rendering::GraphicsTasks::frame::__l2::&lt;lambda_ce01dea6a319546938933c0ba3ab32c3&gt;::()::__l26::&lt;lambda_5c9fff34ec9def2773296cbe30df6075&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::GraphicsTasks::frame::__l2::&lt;lambda_ce01dea6a319546938933c0ba3ab32c3&gt;::()::__l26::&lt;lambda_5c9fff34ec9def2773296cbe30df6075&gt;
{
  std::shared_ptr&lt;Core::DeferredTask&gt; frameTask;
};

</code></pre></div><h3 id="dragon-rendering-graphicstasks-waituntilcompleted-l15-lambda-deba415402013b72ecca0c113cd988a6"><a href="#dragon-rendering-graphicstasks-waituntilcompleted-l15-lambda-deba415402013b72ecca0c113cd988a6" class="header-anchor">#</a> <code>dragon::rendering::GraphicsTasks::_waitUntilCompleted::__l15::&lt;lambda_deba415402013b72ecca0c113cd988a6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::GraphicsTasks::_waitUntilCompleted::__l15::&lt;lambda_deba415402013b72ecca0c113cd988a6&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-graphicstasks-forcounter-l16-lambda-b10b57bba4e646ff8335bd6049678819"><a href="#dragon-rendering-graphicstasks-forcounter-l16-lambda-b10b57bba4e646ff8335bd6049678819" class="header-anchor">#</a> <code>dragon::rendering::GraphicsTasks::_forCounter::__l16::&lt;lambda_b10b57bba4e646ff8335bd6049678819&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::GraphicsTasks::_forCounter::__l16::&lt;lambda_b10b57bba4e646ff8335bd6049678819&gt;
{
  const std::function&lt;void __cdecl(unsigned __int64)&gt; *workerCallback;
  unsigned __int64 i;
};

</code></pre></div><h3 id="dragon-rendering-graphicstasks-foreach-l9-lambda-969734749d613c568b9705b7f9e0199d"><a href="#dragon-rendering-graphicstasks-foreach-l9-lambda-969734749d613c568b9705b7f9e0199d" class="header-anchor">#</a> <code>dragon::rendering::GraphicsTasks::_forEach::__l9::&lt;lambda_969734749d613c568b9705b7f9e0199d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::GraphicsTasks::_forEach::__l9::&lt;lambda_969734749d613c568b9705b7f9e0199d&gt;
{
  const std::function&lt;std::function&lt;void __cdecl(dragon::rendering::RenderContext const &amp;)&gt; __cdecl(dragon::rendering::RenderContext const &amp;)&gt; *cb;
  dragon::rendering::RenderContext *context;
};

</code></pre></div><h3 id="dragon-rendering-graphicstasks-init-l20-lambda-7a56e14fcc487c3fed5f34b1847f3019"><a href="#dragon-rendering-graphicstasks-init-l20-lambda-7a56e14fcc487c3fed5f34b1847f3019" class="header-anchor">#</a> <code>dragon::rendering::GraphicsTasks::init::__l20::&lt;lambda_7a56e14fcc487c3fed5f34b1847f3019&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::GraphicsTasks::init::__l20::&lt;lambda_7a56e14fcc487c3fed5f34b1847f3019&gt;
{
  const bgfx::Init *initParameters;
};

</code></pre></div><h3 id="dragon-rendering-graphicstasks-executesynchronousrenderoperation-l9-lambda-0cde9b5be5a4ecb138a5b690a066ddc5"><a href="#dragon-rendering-graphicstasks-executesynchronousrenderoperation-l9-lambda-0cde9b5be5a4ecb138a5b690a066ddc5" class="header-anchor">#</a> <code>dragon::rendering::GraphicsTasks::_executeSynchronousRenderOperation::__l9::&lt;lambda_0cde9b5be5a4ecb138a5b690a066ddc5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::GraphicsTasks::_executeSynchronousRenderOperation::__l9::&lt;lambda_0cde9b5be5a4ecb138a5b690a066ddc5&gt;
{
  std::shared_ptr&lt;Core::DeferredTask&gt; *task;
};

</code></pre></div><h3 id="dragon-rendering-graphicstasks-deinit-l6-lambda-abb12397cea64cca44710996cd5243c7"><a href="#dragon-rendering-graphicstasks-deinit-l6-lambda-abb12397cea64cca44710996cd5243c7" class="header-anchor">#</a> <code>dragon::rendering::GraphicsTasks::deinit::__l6::&lt;lambda_abb12397cea64cca44710996cd5243c7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::GraphicsTasks::deinit::__l6::&lt;lambda_abb12397cea64cca44710996cd5243c7&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-graphicstasks-init-l2-lambda-f3b201ae555b08716be763728923aa12"><a href="#dragon-rendering-graphicstasks-init-l2-lambda-f3b201ae555b08716be763728923aa12" class="header-anchor">#</a> <code>dragon::rendering::GraphicsTasks::init::__l2::&lt;lambda_f3b201ae555b08716be763728923aa12&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::GraphicsTasks::init::__l2::&lt;lambda_f3b201ae555b08716be763728923aa12&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-graphicstasks-ctor-l15-lambda-a27074dfa039b0dfbd56b980842d50e1"><a href="#dragon-rendering-graphicstasks-ctor-l15-lambda-a27074dfa039b0dfbd56b980842d50e1" class="header-anchor">#</a> <code>dragon::rendering::GraphicsTasks::{ctor}::__l15::&lt;lambda_a27074dfa039b0dfbd56b980842d50e1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::GraphicsTasks::{ctor}::__l15::&lt;lambda_a27074dfa039b0dfbd56b980842d50e1&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-graphicstasks-frame-l2-lambda-ce01dea6a319546938933c0ba3ab32c3-l13-lambda-9b8a56bd7321156b3887584e3cd17161"><a href="#dragon-rendering-graphicstasks-frame-l2-lambda-ce01dea6a319546938933c0ba3ab32c3-l13-lambda-9b8a56bd7321156b3887584e3cd17161" class="header-anchor">#</a> <code>dragon::rendering::GraphicsTasks::frame::__l2::&lt;lambda_ce01dea6a319546938933c0ba3ab32c3&gt;::()::__l13::&lt;lambda_9b8a56bd7321156b3887584e3cd17161&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::GraphicsTasks::frame::__l2::&lt;lambda_ce01dea6a319546938933c0ba3ab32c3&gt;::()::__l13::&lt;lambda_9b8a56bd7321156b3887584e3cd17161&gt;
{
  dragon::rendering::GraphicsTasks *const __this;
};

</code></pre></div><h3 id="dragon-rendering-graphicstasks-waituntilcompleted-l15-lambda-deba415402013b72ecca0c113cd988a6-l2-lambda-2b08aade7d02f1a433f90b058841c098"><a href="#dragon-rendering-graphicstasks-waituntilcompleted-l15-lambda-deba415402013b72ecca0c113cd988a6-l2-lambda-2b08aade7d02f1a433f90b058841c098" class="header-anchor">#</a> <code>dragon::rendering::GraphicsTasks::_waitUntilCompleted::__l15::&lt;lambda_deba415402013b72ecca0c113cd988a6&gt;::()::__l2::&lt;lambda_2b08aade7d02f1a433f90b058841c098&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::GraphicsTasks::_waitUntilCompleted::__l15::&lt;lambda_deba415402013b72ecca0c113cd988a6&gt;::()::__l2::&lt;lambda_2b08aade7d02f1a433f90b058841c098&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-asynctasksscope-queue-l2-lambda-0b22387ff27ab7e2a15cceac869fb8ee-l2-lambda-d7f97153e466fac0867844a242d6fc92"><a href="#dragon-rendering-asynctasksscope-queue-l2-lambda-0b22387ff27ab7e2a15cceac869fb8ee-l2-lambda-d7f97153e466fac0867844a242d6fc92" class="header-anchor">#</a> <code>dragon::rendering::AsyncTasksScope::queue::__l2::&lt;lambda_0b22387ff27ab7e2a15cceac869fb8ee&gt;::()::__l2::&lt;lambda_d7f97153e466fac0867844a242d6fc92&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::AsyncTasksScope::queue::__l2::&lt;lambda_0b22387ff27ab7e2a15cceac869fb8ee&gt;::()::__l2::&lt;lambda_d7f97153e466fac0867844a242d6fc92&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-asynctasksscope-queue-l2-lambda-7773efb6b4df7d5c9396f16d18635c5f-l2-lambda-3ffed232d6737c37987f2a0b7aaf28f4"><a href="#dragon-rendering-asynctasksscope-queue-l2-lambda-7773efb6b4df7d5c9396f16d18635c5f-l2-lambda-3ffed232d6737c37987f2a0b7aaf28f4" class="header-anchor">#</a> <code>dragon::rendering::AsyncTasksScope::queue::__l2::&lt;lambda_7773efb6b4df7d5c9396f16d18635c5f&gt;::()::__l2::&lt;lambda_3ffed232d6737c37987f2a0b7aaf28f4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::AsyncTasksScope::queue::__l2::&lt;lambda_7773efb6b4df7d5c9396f16d18635c5f&gt;::()::__l2::&lt;lambda_3ffed232d6737c37987f2a0b7aaf28f4&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-drawutils-direct-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind"><a href="#dragon-rendering-drawutils-direct-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind" class="header-anchor">#</a> <code>dragon::rendering::drawutils::Direct&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::drawutils::Direct&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-details-dependencyresolvedtypes-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-dependenciesinvoker-std-shared-ptr-dragon-rendering-details-renderpassimpl-0-0"><a href="#dragon-rendering-details-dependencyresolvedtypes-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-dependenciesinvoker-std-shared-ptr-dragon-rendering-details-renderpassimpl-0-0" class="header-anchor">#</a> <code>dragon::rendering::details::DependencyResolvedTypes&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;::DependenciesInvoker&lt;std::shared_ptr&lt;dragon::rendering::details::RenderPassImpl&lt;0,0&gt; &gt; &amp;&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::DependencyResolvedTypes&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;::DependenciesInvoker&lt;std::shared_ptr&lt;dragon::rendering::details::RenderPassImpl&lt;0,0&gt; &gt; &amp;&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-details-dependencyresolvedtypes-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind"><a href="#dragon-rendering-details-dependencyresolvedtypes-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind" class="header-anchor">#</a> <code>dragon::rendering::details::DependencyResolvedTypes&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::DependencyResolvedTypes&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-details-dependencyresolvedtypes-dragon-rendering-details-colorbind-dependenciesinvoker-std-shared-ptr-dragon-rendering-details-renderpassimpl-0-0"><a href="#dragon-rendering-details-dependencyresolvedtypes-dragon-rendering-details-colorbind-dependenciesinvoker-std-shared-ptr-dragon-rendering-details-renderpassimpl-0-0" class="header-anchor">#</a> <code>dragon::rendering::details::DependencyResolvedTypes&lt;dragon::rendering::details::ColorBind&gt;::DependenciesInvoker&lt;std::shared_ptr&lt;dragon::rendering::details::RenderPassImpl&lt;0,0&gt; &gt; &amp;&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::DependencyResolvedTypes&lt;dragon::rendering::details::ColorBind&gt;::DependenciesInvoker&lt;std::shared_ptr&lt;dragon::rendering::details::RenderPassImpl&lt;0,0&gt; &gt; &amp;&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-details-dependencyresolvedtypes-dragon-rendering-details-colorbind"><a href="#dragon-rendering-details-dependencyresolvedtypes-dragon-rendering-details-colorbind" class="header-anchor">#</a> <code>dragon::rendering::details::DependencyResolvedTypes&lt;dragon::rendering::details::ColorBind&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::DependencyResolvedTypes&lt;dragon::rendering::details::ColorBind&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-drawutils-direct-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-draw-l2-lambda-2c201bdeb1d56c01dfa79720746b7f57"><a href="#dragon-rendering-drawutils-direct-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-draw-l2-lambda-2c201bdeb1d56c01dfa79720746b7f57" class="header-anchor">#</a> <code>dragon::rendering::drawutils::Direct&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;::draw::__l2::&lt;lambda_2c201bdeb1d56c01dfa79720746b7f57&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::drawutils::Direct&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;::draw::__l2::&lt;lambda_2c201bdeb1d56c01dfa79720746b7f57&gt;
{
  dragon::frameobject::components::MeshFilter meshFilter;
  const dragon::materials::Pass *materialPass;
  const std::shared_ptr&lt;dragon::frameobject::components::MaterialFilter&gt; innerFilter;
  const std::string fullName;
  dragon::frameobject::components::PassState passState;
  const dragon::frameobject::components::Transform transform;
};

</code></pre></div><h3 id="dragon-rendering-drawutils-direct-dragon-rendering-details-colorbind-draw-l2-lambda-7665afc645e163e5c297af321cdc2f3f"><a href="#dragon-rendering-drawutils-direct-dragon-rendering-details-colorbind-draw-l2-lambda-7665afc645e163e5c297af321cdc2f3f" class="header-anchor">#</a> <code>dragon::rendering::drawutils::Direct&lt;dragon::rendering::details::ColorBind&gt;::draw::__l2::&lt;lambda_7665afc645e163e5c297af321cdc2f3f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::drawutils::Direct&lt;dragon::rendering::details::ColorBind&gt;::draw::__l2::&lt;lambda_7665afc645e163e5c297af321cdc2f3f&gt;
{
  dragon::frameobject::components::MeshFilter meshFilter;
  const dragon::materials::Pass *materialPass;
  const std::shared_ptr&lt;dragon::frameobject::components::MaterialFilter&gt; innerFilter;
  const std::string fullName;
  dragon::frameobject::components::PassState passState;
  const dragon::frameobject::components::Transform transform;
};

</code></pre></div><h3 id="dragon-rendering-details-foldwithmaterialresourcedependenciesrequire-cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext"><a href="#dragon-rendering-details-foldwithmaterialresourcedependenciesrequire-cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>dragon::rendering::details::FoldWithMaterialResourceDependenciesRequire&lt;cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::FoldWithMaterialResourceDependenciesRequire&lt;cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt; &gt;
{
};

</code></pre></div><h3 id="dragon-rendering-details-taskcreator-dragon-rendering-graphicsframe-dragon-rendering-details-colorbind-createrenderpass-l2-lambda-681f695fa63b148e81874a7e0260f9e6"><a href="#dragon-rendering-details-taskcreator-dragon-rendering-graphicsframe-dragon-rendering-details-colorbind-createrenderpass-l2-lambda-681f695fa63b148e81874a7e0260f9e6" class="header-anchor">#</a> <code>dragon::rendering::details::TaskCreator&lt;dragon::rendering::GraphicsFrame,dragon::rendering::details::ColorBind&gt;::createRenderPass::__l2::&lt;lambda_681f695fa63b148e81874a7e0260f9e6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::TaskCreator&lt;dragon::rendering::GraphicsFrame,dragon::rendering::details::ColorBind&gt;::createRenderPass::__l2::&lt;lambda_681f695fa63b148e81874a7e0260f9e6&gt;
{
  const std::string name;
  std::tuple&lt;dragon::rendering::details::ColorBind&gt; deps;
  const std::function&lt;void __cdecl(dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt; const &amp;,dragon::rendering::ViewDescription const &amp;,dragon::rendering::details::ColorBind const &amp;)&gt; callback;
};

</code></pre></div><h3 id="dragon-rendering-details-taskcreator-dragon-rendering-graphicsframe-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-createrenderpass-l2-lambda-0ade20cb6f58f0bbb9f78eb07e9cdb68"><a href="#dragon-rendering-details-taskcreator-dragon-rendering-graphicsframe-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-createrenderpass-l2-lambda-0ade20cb6f58f0bbb9f78eb07e9cdb68" class="header-anchor">#</a> <code>dragon::rendering::details::TaskCreator&lt;dragon::rendering::GraphicsFrame,dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;::createRenderPass::__l2::&lt;lambda_0ade20cb6f58f0bbb9f78eb07e9cdb68&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::TaskCreator&lt;dragon::rendering::GraphicsFrame,dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;::createRenderPass::__l2::&lt;lambda_0ade20cb6f58f0bbb9f78eb07e9cdb68&gt;
{
  const std::string name;
  std::tuple&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt; deps;
  const std::function&lt;void __cdecl(dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt; const &amp;,dragon::rendering::ViewDescription const &amp;,dragon::rendering::details::ColorBind const &amp;,dragon::rendering::details::MaterialBind const &amp;,dragon::rendering::details::MaterialBind const &amp;)&gt; callback;
};

</code></pre></div><h3 id="dragon-rendering-details-taskcreator-dragon-rendering-graphicsframe-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-createsinglerenderpass-l2-lambda-86092073bd6acc70fa7dfd51cef7b831"><a href="#dragon-rendering-details-taskcreator-dragon-rendering-graphicsframe-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-createsinglerenderpass-l2-lambda-86092073bd6acc70fa7dfd51cef7b831" class="header-anchor">#</a> <code>dragon::rendering::details::TaskCreator&lt;dragon::rendering::GraphicsFrame,dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;::_createSingleRenderPass::__l2::&lt;lambda_86092073bd6acc70fa7dfd51cef7b831&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::TaskCreator&lt;dragon::rendering::GraphicsFrame,dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;::_createSingleRenderPass::__l2::&lt;lambda_86092073bd6acc70fa7dfd51cef7b831&gt;
{
  const dragon::rendering::ViewDescription viewDesc;
  std::function&lt;void __cdecl(dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt; const &amp;,dragon::rendering::ViewDescription const &amp;,dragon::rendering::details::ColorBind const &amp;,dragon::rendering::details::MaterialBind const &amp;,dragon::rendering::details::MaterialBind const &amp;)&gt; callback;
  std::tuple&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt; deps;
  const std::string name;
};

</code></pre></div><h3 id="dragon-framegraph-declarator-dragon-rendering-rendercontext-declaretask-l11-lambda-27869ef3f1e58005b31ea92dc557b3c0"><a href="#dragon-framegraph-declarator-dragon-rendering-rendercontext-declaretask-l11-lambda-27869ef3f1e58005b31ea92dc557b3c0" class="header-anchor">#</a> <code>dragon::framegraph::Declarator&lt;dragon::rendering::RenderContext&gt;::declareTask::__l11::&lt;lambda_27869ef3f1e58005b31ea92dc557b3c0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::framegraph::Declarator&lt;dragon::rendering::RenderContext&gt;::declareTask::__l11::&lt;lambda_27869ef3f1e58005b31ea92dc557b3c0&gt;
{
  dragon::framegraph::Declarator&lt;dragon::rendering::RenderContext&gt; *const __this;
};

</code></pre></div><h3 id="dragon-framegraph-detail-concretepass-dragon-rendering-rendercontext-dragon-frameobject-preparedcomputedispatchcollection"><a href="#dragon-framegraph-detail-concretepass-dragon-rendering-rendercontext-dragon-frameobject-preparedcomputedispatchcollection" class="header-anchor">#</a> <code>dragon::framegraph::detail::ConcretePass&lt;dragon::rendering::RenderContext,dragon::frameobject::PreparedComputeDispatchCollection&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::framegraph::detail::ConcretePass&lt;dragon::rendering::RenderContext,dragon::frameobject::PreparedComputeDispatchCollection&gt; : dragon::framegraph::detail::AbstractPass&lt;dragon::rendering::RenderContext&gt;
{
  std::function&lt;void __cdecl(dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt; const &amp;,dragon::frameobject::PreparedComputeDispatchCollection const &amp;)&gt; mAction;
  const dragon::frameobject::PreparedComputeDispatchCollection mTaskContext;
  std::string mPassName;
};

</code></pre></div><h3 id="dragon-framegraph-detail-concretepass-dragon-rendering-rendercontext-dragon-frameobject-preparedcomputedispatchcollection-vtbl"><a href="#dragon-framegraph-detail-concretepass-dragon-rendering-rendercontext-dragon-frameobject-preparedcomputedispatchcollection-vtbl" class="header-anchor">#</a> <code>dragon::framegraph::detail::ConcretePass&lt;dragon::rendering::RenderContext,dragon::frameobject::PreparedComputeDispatchCollection&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ dragon::framegraph::detail::ConcretePass&lt;dragon::rendering::RenderContext,dragon::frameobject::PreparedComputeDispatchCollection&gt;_vtbl
{
  void (__fastcall *~AbstractPass&lt;dragon::rendering::RenderContext&gt;)(dragon::framegraph::detail::AbstractPass&lt;dragon::rendering::RenderContext&gt; *this);
  void (__fastcall *execute)(dragon::framegraph::detail::AbstractPass&lt;dragon::rendering::RenderContext&gt; *this, const dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt; *);
  gsl::basic_string_span&lt;char const ,-1&gt; *(__fastcall *name)(dragon::framegraph::detail::AbstractPass&lt;dragon::rendering::RenderContext&gt; *this, gsl::basic_string_span&lt;char const ,-1&gt; *result);
};

</code></pre></div><h3 id="dragon-rendering-drawutils-direct-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind"><a href="#dragon-rendering-drawutils-direct-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind" class="header-anchor">#</a> <code>dragon::rendering::drawutils::Direct&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::drawutils::Direct&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-details-dependencyresolvedtypes-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dependenciesinvoker-std-shared-ptr-dragon-rendering-details-renderpassimpl-0-0"><a href="#dragon-rendering-details-dependencyresolvedtypes-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dependenciesinvoker-std-shared-ptr-dragon-rendering-details-renderpassimpl-0-0" class="header-anchor">#</a> <code>dragon::rendering::details::DependencyResolvedTypes&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind&gt;::DependenciesInvoker&lt;std::shared_ptr&lt;dragon::rendering::details::RenderPassImpl&lt;0,0&gt; &gt; &amp;&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::DependencyResolvedTypes&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind&gt;::DependenciesInvoker&lt;std::shared_ptr&lt;dragon::rendering::details::RenderPassImpl&lt;0,0&gt; &gt; &amp;&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-details-dependencyresolvedtypes-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind"><a href="#dragon-rendering-details-dependencyresolvedtypes-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind" class="header-anchor">#</a> <code>dragon::rendering::details::DependencyResolvedTypes&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::DependencyResolvedTypes&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-drawutils-direct-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-draw-l2-lambda-f2e4086b1c2eaa9dc15e69cc5e2e1b02"><a href="#dragon-rendering-drawutils-direct-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-draw-l2-lambda-f2e4086b1c2eaa9dc15e69cc5e2e1b02" class="header-anchor">#</a> <code>dragon::rendering::drawutils::Direct&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind&gt;::draw::__l2::&lt;lambda_f2e4086b1c2eaa9dc15e69cc5e2e1b02&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::drawutils::Direct&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind&gt;::draw::__l2::&lt;lambda_f2e4086b1c2eaa9dc15e69cc5e2e1b02&gt;
{
  dragon::frameobject::components::MeshFilter meshFilter;
  const dragon::materials::Pass *materialPass;
  const std::shared_ptr&lt;dragon::frameobject::components::MaterialFilter&gt; innerFilter;
  const std::string fullName;
  dragon::frameobject::components::PassState passState;
  const dragon::frameobject::components::Transform transform;
};

</code></pre></div><h3 id="dragon-rendering-details-taskcreator-dragon-rendering-graphicsframe-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-createrenderpass-l2-lambda-58787bc526953a7a5140bcccf22a9cbd"><a href="#dragon-rendering-details-taskcreator-dragon-rendering-graphicsframe-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-createrenderpass-l2-lambda-58787bc526953a7a5140bcccf22a9cbd" class="header-anchor">#</a> <code>dragon::rendering::details::TaskCreator&lt;dragon::rendering::GraphicsFrame,dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind&gt;::createRenderPass::__l2::&lt;lambda_58787bc526953a7a5140bcccf22a9cbd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::TaskCreator&lt;dragon::rendering::GraphicsFrame,dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind&gt;::createRenderPass::__l2::&lt;lambda_58787bc526953a7a5140bcccf22a9cbd&gt;
{
  const std::string name;
  std::tuple&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind&gt; deps;
  const std::function&lt;void __cdecl(dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt; const &amp;,dragon::rendering::ViewDescription const &amp;,dragon::rendering::details::ColorBind const &amp;,dragon::rendering::details::MaterialBind const &amp;)&gt; callback;
};

</code></pre></div><h3 id="dragon-rendering-drawutils-direct-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind"><a href="#dragon-rendering-drawutils-direct-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind" class="header-anchor">#</a> <code>dragon::rendering::drawutils::Direct&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::drawutils::Direct&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-details-dependencyresolvedtypes-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-dependenciesinvoker-std-shared-ptr-dragon-rendering-details-renderpassimpl-0-0"><a href="#dragon-rendering-details-dependencyresolvedtypes-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-dependenciesinvoker-std-shared-ptr-dragon-rendering-details-renderpassimpl-0-0" class="header-anchor">#</a> <code>dragon::rendering::details::DependencyResolvedTypes&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;::DependenciesInvoker&lt;std::shared_ptr&lt;dragon::rendering::details::RenderPassImpl&lt;0,0&gt; &gt; &amp;&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::DependencyResolvedTypes&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;::DependenciesInvoker&lt;std::shared_ptr&lt;dragon::rendering::details::RenderPassImpl&lt;0,0&gt; &gt; &amp;&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-details-dependencyresolvedtypes-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind"><a href="#dragon-rendering-details-dependencyresolvedtypes-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind" class="header-anchor">#</a> <code>dragon::rendering::details::DependencyResolvedTypes&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::DependencyResolvedTypes&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-drawutils-direct-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-draw-l2-lambda-a08b2be1e901d92fdd6da27142a99c04"><a href="#dragon-rendering-drawutils-direct-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-draw-l2-lambda-a08b2be1e901d92fdd6da27142a99c04" class="header-anchor">#</a> <code>dragon::rendering::drawutils::Direct&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;::draw::__l2::&lt;lambda_a08b2be1e901d92fdd6da27142a99c04&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::drawutils::Direct&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;::draw::__l2::&lt;lambda_a08b2be1e901d92fdd6da27142a99c04&gt;
{
  dragon::frameobject::components::MeshFilter meshFilter;
  const dragon::materials::Pass *materialPass;
  const std::shared_ptr&lt;dragon::frameobject::components::MaterialFilter&gt; innerFilter;
  const std::string fullName;
  dragon::frameobject::components::PassState passState;
  const dragon::frameobject::components::Transform transform;
};

</code></pre></div><h3 id="dragon-rendering-details-foldwithmaterialresourcedependenciesrequire-cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext"><a href="#dragon-rendering-details-foldwithmaterialresourcedependenciesrequire-cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>dragon::rendering::details::FoldWithMaterialResourceDependenciesRequire&lt;cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::FoldWithMaterialResourceDependenciesRequire&lt;cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt; &gt;
{
};

</code></pre></div><h3 id="dragon-rendering-details-taskcreator-dragon-rendering-graphicsframe-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-createrenderpass-l2-lambda-f2515dd87d60d1ccac991d8ad0055031"><a href="#dragon-rendering-details-taskcreator-dragon-rendering-graphicsframe-dragon-rendering-details-colorbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-dragon-rendering-details-materialbind-createrenderpass-l2-lambda-f2515dd87d60d1ccac991d8ad0055031" class="header-anchor">#</a> <code>dragon::rendering::details::TaskCreator&lt;dragon::rendering::GraphicsFrame,dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;::createRenderPass::__l2::&lt;lambda_f2515dd87d60d1ccac991d8ad0055031&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::TaskCreator&lt;dragon::rendering::GraphicsFrame,dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt;::createRenderPass::__l2::&lt;lambda_f2515dd87d60d1ccac991d8ad0055031&gt;
{
  const std::string name;
  std::tuple&lt;dragon::rendering::details::ColorBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind,dragon::rendering::details::MaterialBind&gt; deps;
  const std::function&lt;void __cdecl(dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt; const &amp;,dragon::rendering::ViewDescription const &amp;,dragon::rendering::details::ColorBind const &amp;,dragon::rendering::details::MaterialBind const &amp;,dragon::rendering::details::MaterialBind const &amp;,dragon::rendering::details::MaterialBind const &amp;)&gt; callback;
};

</code></pre></div><h3 id="dragon-framegraph-declarator-dragon-rendering-rendercontext-declaretask-l11-lambda-53f59f2fdc1e0e396dc2482c20c4e3be"><a href="#dragon-framegraph-declarator-dragon-rendering-rendercontext-declaretask-l11-lambda-53f59f2fdc1e0e396dc2482c20c4e3be" class="header-anchor">#</a> <code>dragon::framegraph::Declarator&lt;dragon::rendering::RenderContext&gt;::declareTask::__l11::&lt;lambda_53f59f2fdc1e0e396dc2482c20c4e3be&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::framegraph::Declarator&lt;dragon::rendering::RenderContext&gt;::declareTask::__l11::&lt;lambda_53f59f2fdc1e0e396dc2482c20c4e3be&gt;
{
  dragon::framegraph::Declarator&lt;dragon::rendering::RenderContext&gt; *const __this;
};

</code></pre></div><h3 id="dragon-rendering-details-texturehandletypekey"><a href="#dragon-rendering-details-texturehandletypekey" class="header-anchor">#</a> <code>dragon::rendering::details::TextureHandleTypeKey</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::TextureHandleTypeKey
{
};

</code></pre></div><h3 id="dragon-rendering-textureresourcetype"><a href="#dragon-rendering-textureresourcetype" class="header-anchor">#</a> <code>dragon::rendering::TextureResourceType</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::TextureResourceType
{
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-bufferresource-accessor"><a href="#dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-bufferresource-accessor" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::BufferResource::Accessor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::BufferResource::Accessor
{
  dragon::rendering::BufferState *mState;
  bool *mWasEverCreated;
  bool *mWasEverUsed;
  bgfx::TextureHandle *mResource;
  dragon::rendering::TextureResourceDescInternal *mDescription;
  dragon::rendering::TextureResourceDesc *mPublicDescription;
  std::optional&lt;dragon::rendering::TextureResourceType::ResourceCreationParameters&gt; *mCreationParameters;
  std::vector&lt;dragon::rendering::TextureResourceType::ResourceUpdateParameters&gt; *mDeferredOrderedUpdateSequence;
  std::mutex *mAccessLock;
};

</code></pre></div><h3 id="dragon-rendering-deferredhandlestate"><a href="#dragon-rendering-deferredhandlestate" class="header-anchor">#</a> <code>dragon::rendering::DeferredHandleState</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::DeferredHandleState
{
  const std::optional&lt;dragon::rendering::details::BufferHandleTypeWrapper&lt;dragon::rendering::details::TextureHandleTypeKey,unsigned __int64&gt; &gt; mHandle;
  const std::function&lt;enum dragon::rendering::DeferredActionResult __cdecl(std::optional&lt;dragon::rendering::details::BufferHandleTypeWrapper&lt;dragon::rendering::details::TextureHandleTypeKey,unsigned __int64&gt; &gt;,dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::BufferResource::Accessor &amp;)&gt; mDeferredAction;
};

</code></pre></div><h3 id="dragon-rendering-textureresourcemanager-impl-pendingtask"><a href="#dragon-rendering-textureresourcemanager-impl-pendingtask" class="header-anchor">#</a> <code>dragon::rendering::TextureResourceManager::Impl::PendingTask</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::TextureResourceManager::Impl::PendingTask
{
  const std::optional&lt;dragon::rendering::details::BufferHandleTypeWrapper&lt;dragon::rendering::details::TextureHandleTypeKey,unsigned __int64&gt; &gt; mHandle;
  std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::BufferResource&gt; mResource;
  const std::function&lt;enum dragon::rendering::DeferredActionResult __cdecl(std::optional&lt;dragon::rendering::details::BufferHandleTypeWrapper&lt;dragon::rendering::details::TextureHandleTypeKey,unsigned __int64&gt; &gt;,dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::BufferResource::Accessor &amp;)&gt; mAction;
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-flush-l5-delayeddestroy"><a href="#dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-flush-l5-delayeddestroy" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::flush::__l5::DelayedDestroy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::flush::__l5::DelayedDestroy
{
  std::function&lt;void __cdecl(void)&gt; mCallback;
};

</code></pre></div><h3 id="dragon-rendering-bufferresourceinstancetraits-dragon-rendering-textureresourcetype"><a href="#dragon-rendering-bufferresourceinstancetraits-dragon-rendering-textureresourcetype" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceInstanceTraits&lt;dragon::rendering::TextureResourceType&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceInstanceTraits&lt;dragon::rendering::TextureResourceType&gt;
{
};

</code></pre></div><h3 id="dragon-memory-buffersource-resolve-l2-lambda-15e28bd6d8adc8970663389fbec0ea91"><a href="#dragon-memory-buffersource-resolve-l2-lambda-15e28bd6d8adc8970663389fbec0ea91" class="header-anchor">#</a> <code>dragon::memory::BufferSource::resolve::__l2::&lt;lambda_15e28bd6d8adc8970663389fbec0ea91&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::memory::BufferSource::resolve::__l2::&lt;lambda_15e28bd6d8adc8970663389fbec0ea91&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-textureresourcetype-create-l32-lambda-1a1126684490dea2688199c650391340"><a href="#dragon-rendering-textureresourcetype-create-l32-lambda-1a1126684490dea2688199c650391340" class="header-anchor">#</a> <code>dragon::rendering::TextureResourceType::create::__l32::&lt;lambda_1a1126684490dea2688199c650391340&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::TextureResourceType::create::__l32::&lt;lambda_1a1126684490dea2688199c650391340&gt;
{
  bgfx::TextureHandle *result;
  dragon::rendering::BgfxTextureDesc *bgfxDesc;
  const cg::TextureDescription *desc;
};

</code></pre></div><h3 id="dragon-memory-buffersource-resolve-l2-lambda-5e2cafae2a141aba0edbd603236f9af1"><a href="#dragon-memory-buffersource-resolve-l2-lambda-5e2cafae2a141aba0edbd603236f9af1" class="header-anchor">#</a> <code>dragon::memory::BufferSource::resolve::__l2::&lt;lambda_5e2cafae2a141aba0edbd603236f9af1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::memory::BufferSource::resolve::__l2::&lt;lambda_5e2cafae2a141aba0edbd603236f9af1&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-textureresourcetype-update-l2-lambda-aeb698e76d03013a75a21854b6e155b4"><a href="#dragon-rendering-textureresourcetype-update-l2-lambda-aeb698e76d03013a75a21854b6e155b4" class="header-anchor">#</a> <code>dragon::rendering::TextureResourceType::update::__l2::&lt;lambda_aeb698e76d03013a75a21854b6e155b4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::TextureResourceType::update::__l2::&lt;lambda_aeb698e76d03013a75a21854b6e155b4&gt;
{
  bgfx::TextureHandle *buffer;
  const dragon::rendering::TextureResourceType::ResourceUpdateParameters *updateParameters;
};

</code></pre></div><h3 id="dragon-rendering-deferredresult-bool-tryget-l2-lambda-d6de28eadf07421413302508219c9a51"><a href="#dragon-rendering-deferredresult-bool-tryget-l2-lambda-d6de28eadf07421413302508219c9a51" class="header-anchor">#</a> <code>dragon::rendering::DeferredResult&lt;bool&gt;::tryGet::__l2::&lt;lambda_d6de28eadf07421413302508219c9a51&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::DeferredResult&lt;bool&gt;::tryGet::__l2::&lt;lambda_d6de28eadf07421413302508219c9a51&gt;
{
  bool *hasValue;
};

</code></pre></div><h3 id="dragon-rendering-deferredresult-bool-tryget-l2-lambda-4f695ec9d24944df82080e8405298285"><a href="#dragon-rendering-deferredresult-bool-tryget-l2-lambda-4f695ec9d24944df82080e8405298285" class="header-anchor">#</a> <code>dragon::rendering::DeferredResult&lt;bool&gt;::tryGet::__l2::&lt;lambda_4f695ec9d24944df82080e8405298285&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::DeferredResult&lt;bool&gt;::tryGet::__l2::&lt;lambda_4f695ec9d24944df82080e8405298285&gt;
{
  bool *hasValue;
  bool *result;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-d6de28eadf07421413302508219c9a51-lambda-4f695ec9d24944df82080e8405298285"><a href="#dragon-platform-helpers-visitoverloaded-lambda-d6de28eadf07421413302508219c9a51-lambda-4f695ec9d24944df82080e8405298285" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_d6de28eadf07421413302508219c9a51&gt;,&lt;lambda_4f695ec9d24944df82080e8405298285&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_d6de28eadf07421413302508219c9a51&gt;,&lt;lambda_4f695ec9d24944df82080e8405298285&gt; &gt; : dragon::rendering::DeferredResult&lt;bool&gt;::tryGet::__l2::&lt;lambda_d6de28eadf07421413302508219c9a51&gt;, dragon::rendering::DeferredResult&lt;bool&gt;::tryGet::__l2::&lt;lambda_4f695ec9d24944df82080e8405298285&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-deferredresult-unsigned-int64-tryget-l2-lambda-874f16540db02b06724caa83fa505ee7"><a href="#dragon-rendering-deferredresult-unsigned-int64-tryget-l2-lambda-874f16540db02b06724caa83fa505ee7" class="header-anchor">#</a> <code>dragon::rendering::DeferredResult&lt;unsigned __int64&gt;::tryGet::__l2::&lt;lambda_874f16540db02b06724caa83fa505ee7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::DeferredResult&lt;unsigned __int64&gt;::tryGet::__l2::&lt;lambda_874f16540db02b06724caa83fa505ee7&gt;
{
  bool *hasValue;
};

</code></pre></div><h3 id="dragon-rendering-deferredresult-unsigned-int64-tryget-l2-lambda-431efd0944ca6c373b2f9ddf83690b1f"><a href="#dragon-rendering-deferredresult-unsigned-int64-tryget-l2-lambda-431efd0944ca6c373b2f9ddf83690b1f" class="header-anchor">#</a> <code>dragon::rendering::DeferredResult&lt;unsigned __int64&gt;::tryGet::__l2::&lt;lambda_431efd0944ca6c373b2f9ddf83690b1f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::DeferredResult&lt;unsigned __int64&gt;::tryGet::__l2::&lt;lambda_431efd0944ca6c373b2f9ddf83690b1f&gt;
{
  bool *hasValue;
  std::variant&lt;unsigned __int64&gt; *result;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-874f16540db02b06724caa83fa505ee7-lambda-431efd0944ca6c373b2f9ddf83690b1f"><a href="#dragon-platform-helpers-visitoverloaded-lambda-874f16540db02b06724caa83fa505ee7-lambda-431efd0944ca6c373b2f9ddf83690b1f" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_874f16540db02b06724caa83fa505ee7&gt;,&lt;lambda_431efd0944ca6c373b2f9ddf83690b1f&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_874f16540db02b06724caa83fa505ee7&gt;,&lt;lambda_431efd0944ca6c373b2f9ddf83690b1f&gt; &gt; : dragon::rendering::DeferredResult&lt;unsigned __int64&gt;::tryGet::__l2::&lt;lambda_874f16540db02b06724caa83fa505ee7&gt;, dragon::rendering::DeferredResult&lt;unsigned __int64&gt;::tryGet::__l2::&lt;lambda_431efd0944ca6c373b2f9ddf83690b1f&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-deferredresult-bool-tryget-l2-lambda-0b7bc903a37556cee4cfa7c3b1a89326"><a href="#dragon-rendering-deferredresult-bool-tryget-l2-lambda-0b7bc903a37556cee4cfa7c3b1a89326" class="header-anchor">#</a> <code>dragon::rendering::DeferredResult&lt;bool&gt;::tryGet::__l2::&lt;lambda_0b7bc903a37556cee4cfa7c3b1a89326&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::DeferredResult&lt;bool&gt;::tryGet::__l2::&lt;lambda_0b7bc903a37556cee4cfa7c3b1a89326&gt;
{
  bool *hasValue;
};

</code></pre></div><h3 id="dragon-rendering-deferredresult-bool-tryget-l2-lambda-cfba1d17f5626e9555f01136aad9081e"><a href="#dragon-rendering-deferredresult-bool-tryget-l2-lambda-cfba1d17f5626e9555f01136aad9081e" class="header-anchor">#</a> <code>dragon::rendering::DeferredResult&lt;bool&gt;::tryGet::__l2::&lt;lambda_cfba1d17f5626e9555f01136aad9081e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::DeferredResult&lt;bool&gt;::tryGet::__l2::&lt;lambda_cfba1d17f5626e9555f01136aad9081e&gt;
{
  bool *hasValue;
  std::variant&lt;bool&gt; *result;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-0b7bc903a37556cee4cfa7c3b1a89326-lambda-cfba1d17f5626e9555f01136aad9081e"><a href="#dragon-platform-helpers-visitoverloaded-lambda-0b7bc903a37556cee4cfa7c3b1a89326-lambda-cfba1d17f5626e9555f01136aad9081e" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_0b7bc903a37556cee4cfa7c3b1a89326&gt;,&lt;lambda_cfba1d17f5626e9555f01136aad9081e&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_0b7bc903a37556cee4cfa7c3b1a89326&gt;,&lt;lambda_cfba1d17f5626e9555f01136aad9081e&gt; &gt; : dragon::rendering::DeferredResult&lt;bool&gt;::tryGet::__l2::&lt;lambda_0b7bc903a37556cee4cfa7c3b1a89326&gt;, dragon::rendering::DeferredResult&lt;bool&gt;::tryGet::__l2::&lt;lambda_cfba1d17f5626e9555f01136aad9081e&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-00429de7dd09878e4a3668b23c94d5c6"><a href="#dragon-rendering-details-runstep-l2-lambda-00429de7dd09878e4a3668b23c94d5c6" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_00429de7dd09878e4a3668b23c94d5c6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_00429de7dd09878e4a3668b23c94d5c6&gt;
{
  dragon::rendering::coroutine::DispatchTarget *currentTarget;
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; *stateHolder;
  const struct dragon::rendering::TextureResourceManager::Impl::copyAsync::__l2::&lt;lambda_a6349755da7110c122d82e5a120d69a2&gt; *coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-e10cfcc8bd96dc76aa2724a3faa1de0a"><a href="#dragon-rendering-details-runstep-l2-lambda-e10cfcc8bd96dc76aa2724a3faa1de0a" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_e10cfcc8bd96dc76aa2724a3faa1de0a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_e10cfcc8bd96dc76aa2724a3faa1de0a&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; *stateHolder;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-c74a313402be08b7adeb7d3263b0ea38"><a href="#dragon-rendering-details-runstep-l2-lambda-c74a313402be08b7adeb7d3263b0ea38" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_c74a313402be08b7adeb7d3263b0ea38&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_c74a313402be08b7adeb7d3263b0ea38&gt;
{
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; *stateHolder;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-00429de7dd09878e4a3668b23c94d5c6-lambda-e10cfcc8bd96dc76aa2724a3faa1de0a-lambda-c74a313402be08b7adeb7d3263b0ea38"><a href="#dragon-platform-helpers-visitoverloaded-lambda-00429de7dd09878e4a3668b23c94d5c6-lambda-e10cfcc8bd96dc76aa2724a3faa1de0a-lambda-c74a313402be08b7adeb7d3263b0ea38" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_00429de7dd09878e4a3668b23c94d5c6&gt;,&lt;lambda_e10cfcc8bd96dc76aa2724a3faa1de0a&gt;,&lt;lambda_c74a313402be08b7adeb7d3263b0ea38&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_00429de7dd09878e4a3668b23c94d5c6&gt;,&lt;lambda_e10cfcc8bd96dc76aa2724a3faa1de0a&gt;,&lt;lambda_c74a313402be08b7adeb7d3263b0ea38&gt; &gt; : dragon::rendering::details::runStep::__l2::&lt;lambda_00429de7dd09878e4a3668b23c94d5c6&gt;, dragon::rendering::details::runStep::__l2::&lt;lambda_e10cfcc8bd96dc76aa2724a3faa1de0a&gt;, dragon::rendering::details::runStep::__l2::&lt;lambda_c74a313402be08b7adeb7d3263b0ea38&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-f200acfc803d93621704f593d8ae7717"><a href="#dragon-rendering-details-runstep-l2-lambda-f200acfc803d93621704f593d8ae7717" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_f200acfc803d93621704f593d8ae7717&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_f200acfc803d93621704f593d8ae7717&gt;
{
  dragon::rendering::coroutine::DispatchTarget *currentTarget;
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; *stateHolder;
  const struct dragon::rendering::TextureResourceManager::Impl::readAsync::__l2::&lt;lambda_661b6c1d40bfda803ee4881643ecfcc0&gt; *coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-df5525a80596be2e2ff78d9490af6f0e"><a href="#dragon-rendering-details-runstep-l2-lambda-df5525a80596be2e2ff78d9490af6f0e" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_df5525a80596be2e2ff78d9490af6f0e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_df5525a80596be2e2ff78d9490af6f0e&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; *stateHolder;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-61b822541d2601907db01dfedeff616d"><a href="#dragon-rendering-details-runstep-l2-lambda-61b822541d2601907db01dfedeff616d" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_61b822541d2601907db01dfedeff616d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_61b822541d2601907db01dfedeff616d&gt;
{
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; *stateHolder;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-f200acfc803d93621704f593d8ae7717-lambda-df5525a80596be2e2ff78d9490af6f0e-lambda-61b822541d2601907db01dfedeff616d"><a href="#dragon-platform-helpers-visitoverloaded-lambda-f200acfc803d93621704f593d8ae7717-lambda-df5525a80596be2e2ff78d9490af6f0e-lambda-61b822541d2601907db01dfedeff616d" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_f200acfc803d93621704f593d8ae7717&gt;,&lt;lambda_df5525a80596be2e2ff78d9490af6f0e&gt;,&lt;lambda_61b822541d2601907db01dfedeff616d&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_f200acfc803d93621704f593d8ae7717&gt;,&lt;lambda_df5525a80596be2e2ff78d9490af6f0e&gt;,&lt;lambda_61b822541d2601907db01dfedeff616d&gt; &gt; : dragon::rendering::details::runStep::__l2::&lt;lambda_f200acfc803d93621704f593d8ae7717&gt;, dragon::rendering::details::runStep::__l2::&lt;lambda_df5525a80596be2e2ff78d9490af6f0e&gt;, dragon::rendering::details::runStep::__l2::&lt;lambda_61b822541d2601907db01dfedeff616d&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-tryresolve-l22-lambda-c4a429c257c1bc0d2dc1a8b4822f0fd9"><a href="#dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-tryresolve-l22-lambda-c4a429c257c1bc0d2dc1a8b4822f0fd9" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::tryResolve::__l22::&lt;lambda_c4a429c257c1bc0d2dc1a8b4822f0fd9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::tryResolve::__l22::&lt;lambda_c4a429c257c1bc0d2dc1a8b4822f0fd9&gt;
{
  dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt; *const __this;
  std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::BufferResource&gt; target;
};

</code></pre></div><h3 id="dragon-rendering-textureresourcemanager-createasexternal-l12-lambda-b09ac5df02a6a00a8bfe64931c430cce-l18-lambda-73d510a550d1a71057ed7def60a67dd4"><a href="#dragon-rendering-textureresourcemanager-createasexternal-l12-lambda-b09ac5df02a6a00a8bfe64931c430cce-l18-lambda-73d510a550d1a71057ed7def60a67dd4" class="header-anchor">#</a> <code>dragon::rendering::TextureResourceManager::createAsExternal::__l12::&lt;lambda_b09ac5df02a6a00a8bfe64931c430cce&gt;::()::__l18::&lt;lambda_73d510a550d1a71057ed7def60a67dd4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::TextureResourceManager::createAsExternal::__l12::&lt;lambda_b09ac5df02a6a00a8bfe64931c430cce&gt;::()::__l18::&lt;lambda_73d510a550d1a71057ed7def60a67dd4&gt;
{
  dragon::rendering::TextureResourceManager *const __this;
  dragon::rendering::DeferredResult&lt;bool&gt; overrideAsyncResult;
  std::optional&lt;dragon::rendering::details::BufferHandleTypeWrapper&lt;dragon::rendering::details::TextureHandleTypeKey,unsigned __int64&gt; &gt; baseTexture;
  unsigned __int64 newNativeTexture;
};

</code></pre></div><h3 id="dragon-rendering-textureresourcemanager-impl-readasync-l2-lambda-661b6c1d40bfda803ee4881643ecfcc0-l2-lambda-9effa90042a655dc8bd720bfc0235711"><a href="#dragon-rendering-textureresourcemanager-impl-readasync-l2-lambda-661b6c1d40bfda803ee4881643ecfcc0-l2-lambda-9effa90042a655dc8bd720bfc0235711" class="header-anchor">#</a> <code>dragon::rendering::TextureResourceManager::Impl::readAsync::__l2::&lt;lambda_661b6c1d40bfda803ee4881643ecfcc0&gt;::()::__l2::&lt;lambda_9effa90042a655dc8bd720bfc0235711&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) dragon::rendering::TextureResourceManager::Impl::readAsync::__l2::&lt;lambda_661b6c1d40bfda803ee4881643ecfcc0&gt;::()::__l2::&lt;lambda_9effa90042a655dc8bd720bfc0235711&gt;
{
  dragon::rendering::TextureResourceManager::Impl *const __this;
  const unsigned int finishFrameNumber;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-a4713c0cfe5a3b6c52ea9ddde732e47d"><a href="#dragon-rendering-details-runstep-l2-lambda-a4713c0cfe5a3b6c52ea9ddde732e47d" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_a4713c0cfe5a3b6c52ea9ddde732e47d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_a4713c0cfe5a3b6c52ea9ddde732e47d&gt;
{
  dragon::rendering::coroutine::DispatchTarget *currentTarget;
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; *stateHolder;
  const std::function&lt;std::variant&lt;dragon::rendering::coroutine::TryAgain,dragon::rendering::coroutine::Run&lt;bool&gt;,bool&gt; __cdecl(void)&gt; *coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-66a3e410687ef6af83c0d08d2f7c8a05"><a href="#dragon-rendering-details-runstep-l2-lambda-66a3e410687ef6af83c0d08d2f7c8a05" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_66a3e410687ef6af83c0d08d2f7c8a05&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_66a3e410687ef6af83c0d08d2f7c8a05&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; *stateHolder;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-20bf40bb9b5bd6a8f1d855db236d7b16"><a href="#dragon-rendering-details-runstep-l2-lambda-20bf40bb9b5bd6a8f1d855db236d7b16" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_20bf40bb9b5bd6a8f1d855db236d7b16&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_20bf40bb9b5bd6a8f1d855db236d7b16&gt;
{
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; *stateHolder;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-a4713c0cfe5a3b6c52ea9ddde732e47d-lambda-66a3e410687ef6af83c0d08d2f7c8a05-lambda-20bf40bb9b5bd6a8f1d855db236d7b16"><a href="#dragon-platform-helpers-visitoverloaded-lambda-a4713c0cfe5a3b6c52ea9ddde732e47d-lambda-66a3e410687ef6af83c0d08d2f7c8a05-lambda-20bf40bb9b5bd6a8f1d855db236d7b16" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_a4713c0cfe5a3b6c52ea9ddde732e47d&gt;,&lt;lambda_66a3e410687ef6af83c0d08d2f7c8a05&gt;,&lt;lambda_20bf40bb9b5bd6a8f1d855db236d7b16&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_a4713c0cfe5a3b6c52ea9ddde732e47d&gt;,&lt;lambda_66a3e410687ef6af83c0d08d2f7c8a05&gt;,&lt;lambda_20bf40bb9b5bd6a8f1d855db236d7b16&gt; &gt; : dragon::rendering::details::runStep::__l2::&lt;lambda_a4713c0cfe5a3b6c52ea9ddde732e47d&gt;, dragon::rendering::details::runStep::__l2::&lt;lambda_66a3e410687ef6af83c0d08d2f7c8a05&gt;, dragon::rendering::details::runStep::__l2::&lt;lambda_20bf40bb9b5bd6a8f1d855db236d7b16&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-bc347f2c11c4f4acbd4f8abb87b036b1"><a href="#dragon-rendering-details-runstep-l2-lambda-bc347f2c11c4f4acbd4f8abb87b036b1" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_bc347f2c11c4f4acbd4f8abb87b036b1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_bc347f2c11c4f4acbd4f8abb87b036b1&gt;
{
  dragon::rendering::coroutine::DispatchTarget *currentTarget;
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,dragon::rendering::SharedTextureHandle&gt; &gt; *stateHolder;
  const dragon::rendering::DeferredResult&lt;bool&gt;::then::__l2::&lt;lambda_c3545776d4a1357cc987df9697644608&gt; *coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-8c9f3269710ce9476149804229953a1e"><a href="#dragon-rendering-details-runstep-l2-lambda-8c9f3269710ce9476149804229953a1e" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_8c9f3269710ce9476149804229953a1e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_8c9f3269710ce9476149804229953a1e&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,dragon::rendering::SharedTextureHandle&gt; &gt; *stateHolder;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-8312f1077e84881f7fcbfb5385b787af"><a href="#dragon-rendering-details-runstep-l2-lambda-8312f1077e84881f7fcbfb5385b787af" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_8312f1077e84881f7fcbfb5385b787af&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_8312f1077e84881f7fcbfb5385b787af&gt;
{
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,dragon::rendering::SharedTextureHandle&gt; &gt; *stateHolder;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-bc347f2c11c4f4acbd4f8abb87b036b1-lambda-8c9f3269710ce9476149804229953a1e-lambda-8312f1077e84881f7fcbfb5385b787af"><a href="#dragon-platform-helpers-visitoverloaded-lambda-bc347f2c11c4f4acbd4f8abb87b036b1-lambda-8c9f3269710ce9476149804229953a1e-lambda-8312f1077e84881f7fcbfb5385b787af" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_bc347f2c11c4f4acbd4f8abb87b036b1&gt;,&lt;lambda_8c9f3269710ce9476149804229953a1e&gt;,&lt;lambda_8312f1077e84881f7fcbfb5385b787af&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_bc347f2c11c4f4acbd4f8abb87b036b1&gt;,&lt;lambda_8c9f3269710ce9476149804229953a1e&gt;,&lt;lambda_8312f1077e84881f7fcbfb5385b787af&gt; &gt; : dragon::rendering::details::runStep::__l2::&lt;lambda_bc347f2c11c4f4acbd4f8abb87b036b1&gt;, dragon::rendering::details::runStep::__l2::&lt;lambda_8c9f3269710ce9476149804229953a1e&gt;, dragon::rendering::details::runStep::__l2::&lt;lambda_8312f1077e84881f7fcbfb5385b787af&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-61ef815dfe04875bdb4f9819a637ba35"><a href="#dragon-rendering-details-runstep-l2-lambda-61ef815dfe04875bdb4f9819a637ba35" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_61ef815dfe04875bdb4f9819a637ba35&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_61ef815dfe04875bdb4f9819a637ba35&gt;
{
  dragon::rendering::coroutine::DispatchTarget *currentTarget;
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,dragon::rendering::SharedTextureHandle&gt; &gt; *stateHolder;
  const struct dragon::rendering::DeferredResult&lt;unsigned __int64&gt;::then::__l2::&lt;lambda_8b27e51beabb27cbb611d54cf4caa5b9&gt; *coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-e748f7c1651b3c2605040e30cd0026d1"><a href="#dragon-rendering-details-runstep-l2-lambda-e748f7c1651b3c2605040e30cd0026d1" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_e748f7c1651b3c2605040e30cd0026d1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_e748f7c1651b3c2605040e30cd0026d1&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,dragon::rendering::SharedTextureHandle&gt; &gt; *stateHolder;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-58c10b021011d7de0219795f1f17daad"><a href="#dragon-rendering-details-runstep-l2-lambda-58c10b021011d7de0219795f1f17daad" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_58c10b021011d7de0219795f1f17daad&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_58c10b021011d7de0219795f1f17daad&gt;
{
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,dragon::rendering::SharedTextureHandle&gt; &gt; *stateHolder;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-61ef815dfe04875bdb4f9819a637ba35-lambda-e748f7c1651b3c2605040e30cd0026d1-lambda-58c10b021011d7de0219795f1f17daad"><a href="#dragon-platform-helpers-visitoverloaded-lambda-61ef815dfe04875bdb4f9819a637ba35-lambda-e748f7c1651b3c2605040e30cd0026d1-lambda-58c10b021011d7de0219795f1f17daad" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_61ef815dfe04875bdb4f9819a637ba35&gt;,&lt;lambda_e748f7c1651b3c2605040e30cd0026d1&gt;,&lt;lambda_58c10b021011d7de0219795f1f17daad&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_61ef815dfe04875bdb4f9819a637ba35&gt;,&lt;lambda_e748f7c1651b3c2605040e30cd0026d1&gt;,&lt;lambda_58c10b021011d7de0219795f1f17daad&gt; &gt; : dragon::rendering::details::runStep::__l2::&lt;lambda_61ef815dfe04875bdb4f9819a637ba35&gt;, dragon::rendering::details::runStep::__l2::&lt;lambda_e748f7c1651b3c2605040e30cd0026d1&gt;, dragon::rendering::details::runStep::__l2::&lt;lambda_58c10b021011d7de0219795f1f17daad&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-56131c259497b6ec942552da7c21d76f"><a href="#dragon-rendering-details-runstep-l2-lambda-56131c259497b6ec942552da7c21d76f" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_56131c259497b6ec942552da7c21d76f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_56131c259497b6ec942552da7c21d76f&gt;
{
  dragon::rendering::coroutine::DispatchTarget *currentTarget;
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,dragon::rendering::SharedTextureHandle&gt; &gt; *stateHolder;
  const std::function&lt;std::variant&lt;dragon::rendering::coroutine::TryAgain,dragon::rendering::coroutine::Run&lt;dragon::rendering::SharedTextureHandle&gt;,dragon::rendering::SharedTextureHandle&gt; __cdecl(void)&gt; *coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-f6d401144df93177f677010af549061f"><a href="#dragon-rendering-details-runstep-l2-lambda-f6d401144df93177f677010af549061f" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_f6d401144df93177f677010af549061f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_f6d401144df93177f677010af549061f&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,dragon::rendering::SharedTextureHandle&gt; &gt; *stateHolder;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-d1887979d014c5c700c893676632811d"><a href="#dragon-rendering-details-runstep-l2-lambda-d1887979d014c5c700c893676632811d" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_d1887979d014c5c700c893676632811d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_d1887979d014c5c700c893676632811d&gt;
{
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,dragon::rendering::SharedTextureHandle&gt; &gt; *stateHolder;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-56131c259497b6ec942552da7c21d76f-lambda-f6d401144df93177f677010af549061f-lambda-d1887979d014c5c700c893676632811d"><a href="#dragon-platform-helpers-visitoverloaded-lambda-56131c259497b6ec942552da7c21d76f-lambda-f6d401144df93177f677010af549061f-lambda-d1887979d014c5c700c893676632811d" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_56131c259497b6ec942552da7c21d76f&gt;,&lt;lambda_f6d401144df93177f677010af549061f&gt;,&lt;lambda_d1887979d014c5c700c893676632811d&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_56131c259497b6ec942552da7c21d76f&gt;,&lt;lambda_f6d401144df93177f677010af549061f&gt;,&lt;lambda_d1887979d014c5c700c893676632811d&gt; &gt; : dragon::rendering::details::runStep::__l2::&lt;lambda_56131c259497b6ec942552da7c21d76f&gt;, dragon::rendering::details::runStep::__l2::&lt;lambda_f6d401144df93177f677010af549061f&gt;, dragon::rendering::details::runStep::__l2::&lt;lambda_d1887979d014c5c700c893676632811d&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-a1b2a7e0f3d6af6c5b58879eada7c855"><a href="#dragon-rendering-details-runstep-l2-lambda-a1b2a7e0f3d6af6c5b58879eada7c855" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_a1b2a7e0f3d6af6c5b58879eada7c855&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_a1b2a7e0f3d6af6c5b58879eada7c855&gt;
{
  dragon::rendering::coroutine::DispatchTarget *currentTarget;
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; *stateHolder;
  const struct dragon::rendering::DeferredResult&lt;bool&gt;::then::__l2::&lt;lambda_b36912425dc1a21ee23179b794f7fa70&gt; *coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-7993acc3c8eb0047818e9d50cdee1abd"><a href="#dragon-rendering-details-runstep-l2-lambda-7993acc3c8eb0047818e9d50cdee1abd" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_7993acc3c8eb0047818e9d50cdee1abd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_7993acc3c8eb0047818e9d50cdee1abd&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; *stateHolder;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-22b116b7cbf894fad86dc64ae6df4c1f"><a href="#dragon-rendering-details-runstep-l2-lambda-22b116b7cbf894fad86dc64ae6df4c1f" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_22b116b7cbf894fad86dc64ae6df4c1f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_22b116b7cbf894fad86dc64ae6df4c1f&gt;
{
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; *stateHolder;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-a1b2a7e0f3d6af6c5b58879eada7c855-lambda-7993acc3c8eb0047818e9d50cdee1abd-lambda-22b116b7cbf894fad86dc64ae6df4c1f"><a href="#dragon-platform-helpers-visitoverloaded-lambda-a1b2a7e0f3d6af6c5b58879eada7c855-lambda-7993acc3c8eb0047818e9d50cdee1abd-lambda-22b116b7cbf894fad86dc64ae6df4c1f" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_a1b2a7e0f3d6af6c5b58879eada7c855&gt;,&lt;lambda_7993acc3c8eb0047818e9d50cdee1abd&gt;,&lt;lambda_22b116b7cbf894fad86dc64ae6df4c1f&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_a1b2a7e0f3d6af6c5b58879eada7c855&gt;,&lt;lambda_7993acc3c8eb0047818e9d50cdee1abd&gt;,&lt;lambda_22b116b7cbf894fad86dc64ae6df4c1f&gt; &gt; : dragon::rendering::details::runStep::__l2::&lt;lambda_a1b2a7e0f3d6af6c5b58879eada7c855&gt;, dragon::rendering::details::runStep::__l2::&lt;lambda_7993acc3c8eb0047818e9d50cdee1abd&gt;, dragon::rendering::details::runStep::__l2::&lt;lambda_22b116b7cbf894fad86dc64ae6df4c1f&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-9e9b351cf491e6fbbcbd224f44748919"><a href="#dragon-rendering-details-runstep-l2-lambda-9e9b351cf491e6fbbcbd224f44748919" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_9e9b351cf491e6fbbcbd224f44748919&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_9e9b351cf491e6fbbcbd224f44748919&gt;
{
  dragon::rendering::coroutine::DispatchTarget *currentTarget;
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; *stateHolder;
  const struct dragon::rendering::DeferredResult&lt;bool&gt;::then::__l2::&lt;lambda_69c394c075e7947ecf6de6e23a7a00d3&gt; *coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-c4f55adc6fc3bd9650f292b46e07f10d"><a href="#dragon-rendering-details-runstep-l2-lambda-c4f55adc6fc3bd9650f292b46e07f10d" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_c4f55adc6fc3bd9650f292b46e07f10d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_c4f55adc6fc3bd9650f292b46e07f10d&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; *stateHolder;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-6aa0680ec266c8fdc971c0b007e2fb1c"><a href="#dragon-rendering-details-runstep-l2-lambda-6aa0680ec266c8fdc971c0b007e2fb1c" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_6aa0680ec266c8fdc971c0b007e2fb1c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_6aa0680ec266c8fdc971c0b007e2fb1c&gt;
{
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; *stateHolder;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-9e9b351cf491e6fbbcbd224f44748919-lambda-c4f55adc6fc3bd9650f292b46e07f10d-lambda-6aa0680ec266c8fdc971c0b007e2fb1c"><a href="#dragon-platform-helpers-visitoverloaded-lambda-9e9b351cf491e6fbbcbd224f44748919-lambda-c4f55adc6fc3bd9650f292b46e07f10d-lambda-6aa0680ec266c8fdc971c0b007e2fb1c" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_9e9b351cf491e6fbbcbd224f44748919&gt;,&lt;lambda_c4f55adc6fc3bd9650f292b46e07f10d&gt;,&lt;lambda_6aa0680ec266c8fdc971c0b007e2fb1c&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_9e9b351cf491e6fbbcbd224f44748919&gt;,&lt;lambda_c4f55adc6fc3bd9650f292b46e07f10d&gt;,&lt;lambda_6aa0680ec266c8fdc971c0b007e2fb1c&gt; &gt; : dragon::rendering::details::runStep::__l2::&lt;lambda_9e9b351cf491e6fbbcbd224f44748919&gt;, dragon::rendering::details::runStep::__l2::&lt;lambda_c4f55adc6fc3bd9650f292b46e07f10d&gt;, dragon::rendering::details::runStep::__l2::&lt;lambda_6aa0680ec266c8fdc971c0b007e2fb1c&gt;
{
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-update-l33-lambda-458b16ee16903832b42a44567235bda7"><a href="#dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-update-l33-lambda-458b16ee16903832b42a44567235bda7" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::update::__l33::&lt;lambda_458b16ee16903832b42a44567235bda7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::update::__l33::&lt;lambda_458b16ee16903832b42a44567235bda7&gt;
{
  std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::BufferResource&gt; target;
  std::shared_ptr&lt;dragon::rendering::TextureResourceType::ResourceUpdateParameters&gt; updateArgs;
};

</code></pre></div><h3 id="dragon-rendering-coroutine-dispatch-l6-lambda-a1c2d30c4013903b5aec4fa185d2cdc4"><a href="#dragon-rendering-coroutine-dispatch-l6-lambda-a1c2d30c4013903b5aec4fa185d2cdc4" class="header-anchor">#</a> <code>dragon::rendering::coroutine::dispatch::__l6::&lt;lambda_a1c2d30c4013903b5aec4fa185d2cdc4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::coroutine::dispatch::__l6::&lt;lambda_a1c2d30c4013903b5aec4fa185d2cdc4&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,dragon::rendering::SharedTextureHandle&gt; &gt; stateHolder;
  const dragon::rendering::TextureResourceManager::createAsExternal::__l12::&lt;lambda_b09ac5df02a6a00a8bfe64931c430cce&gt; coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-create-l5-lambda-7429854351f78834836fb87ef94ecddb"><a href="#dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-create-l5-lambda-7429854351f78834836fb87ef94ecddb" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::create::__l5::&lt;lambda_7429854351f78834836fb87ef94ecddb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::create::__l5::&lt;lambda_7429854351f78834836fb87ef94ecddb&gt;
{
  dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt; *const __this;
  std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::BufferResource&gt; target;
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-create-l5-lambda-d8d78cde96f6ae0c209904e24ae369f7"><a href="#dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-create-l5-lambda-d8d78cde96f6ae0c209904e24ae369f7" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::create::__l5::&lt;lambda_d8d78cde96f6ae0c209904e24ae369f7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::create::__l5::&lt;lambda_d8d78cde96f6ae0c209904e24ae369f7&gt;
{
  dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt; *const __this;
  std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::BufferResource&gt; target;
};

</code></pre></div><h3 id="dragon-rendering-coroutine-dispatch-l6-lambda-f30324bc8d40a6c0d5e4401c96f79fb9"><a href="#dragon-rendering-coroutine-dispatch-l6-lambda-f30324bc8d40a6c0d5e4401c96f79fb9" class="header-anchor">#</a> <code>dragon::rendering::coroutine::dispatch::__l6::&lt;lambda_f30324bc8d40a6c0d5e4401c96f79fb9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::coroutine::dispatch::__l6::&lt;lambda_f30324bc8d40a6c0d5e4401c96f79fb9&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::TextureResourceManager::Impl::overrideInternalAsync::__l2::&lt;lambda_f6804d13e6c1f399c569beed1d3a6cb8&gt; coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-coroutine-dispatch-l5-lambda-c602feaaae81dd2253c3cb291027307a"><a href="#dragon-rendering-coroutine-dispatch-l5-lambda-c602feaaae81dd2253c3cb291027307a" class="header-anchor">#</a> <code>dragon::rendering::coroutine::dispatch::__l5::&lt;lambda_c602feaaae81dd2253c3cb291027307a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::coroutine::dispatch::__l5::&lt;lambda_c602feaaae81dd2253c3cb291027307a&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::TextureResourceManager::Impl::overrideInternalAsync::__l2::&lt;lambda_f6804d13e6c1f399c569beed1d3a6cb8&gt; coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-coroutine-dispatch-l6-lambda-76852469a24b588dffed7499cbd54af8"><a href="#dragon-rendering-coroutine-dispatch-l6-lambda-76852469a24b588dffed7499cbd54af8" class="header-anchor">#</a> <code>dragon::rendering::coroutine::dispatch::__l6::&lt;lambda_76852469a24b588dffed7499cbd54af8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::coroutine::dispatch::__l6::&lt;lambda_76852469a24b588dffed7499cbd54af8&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,unsigned __int64&gt; &gt; stateHolder;
  const dragon::rendering::TextureResourceManager::Impl::getInternalAsync::__l2::&lt;lambda_c2f36c41a6f8b939cf03ff8a0cc2efce&gt; coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-flush-l5-lambda-e5ad9426d677070c2fdef4038fc0294b"><a href="#dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-flush-l5-lambda-e5ad9426d677070c2fdef4038fc0294b" class="header-anchor">#</a> <code>dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::flush::__l5::&lt;lambda_e5ad9426d677070c2fdef4038fc0294b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::flush::__l5::&lt;lambda_e5ad9426d677070c2fdef4038fc0294b&gt;
{
  dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt; *const __this;
  std::shared_ptr&lt;std::vector&lt;std::optional&lt;dragon::rendering::details::BufferHandleTypeWrapper&lt;dragon::rendering::details::TextureHandleTypeKey,unsigned __int64&gt; &gt;&gt; &gt; buffersToDelete;
};

</code></pre></div><h3 id="dragon-rendering-coroutine-dispatch-l5-lambda-69b722bc7359d47c64df04b8afc3a891"><a href="#dragon-rendering-coroutine-dispatch-l5-lambda-69b722bc7359d47c64df04b8afc3a891" class="header-anchor">#</a> <code>dragon::rendering::coroutine::dispatch::__l5::&lt;lambda_69b722bc7359d47c64df04b8afc3a891&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::coroutine::dispatch::__l5::&lt;lambda_69b722bc7359d47c64df04b8afc3a891&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,dragon::rendering::SharedTextureHandle&gt; &gt; stateHolder;
  const dragon::rendering::DeferredResult&lt;unsigned __int64&gt;::then::__l2::&lt;lambda_e7b38f5f36d64d4501f5714de64d6730&gt; coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-0d771b36c68787c1e72511b5fa13c6d0-l2-lambda-092210d0254d409187ac1f8d6f07185d"><a href="#dragon-rendering-details-runstep-l2-lambda-0d771b36c68787c1e72511b5fa13c6d0-l2-lambda-092210d0254d409187ac1f8d6f07185d" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_0d771b36c68787c1e72511b5fa13c6d0&gt;::()::__l2::&lt;lambda_092210d0254d409187ac1f8d6f07185d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_0d771b36c68787c1e72511b5fa13c6d0&gt;::()::__l2::&lt;lambda_092210d0254d409187ac1f8d6f07185d&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,dragon::rendering::SharedTextureHandle&gt; &gt; stateHolder;
  const dragon::rendering::coroutine::Run&lt;dragon::rendering::SharedTextureHandle&gt; run;
};

</code></pre></div><h3 id="dragon-rendering-coroutine-dispatch-l5-lambda-11a1d5ae472a027cb6632881bcbca6c5"><a href="#dragon-rendering-coroutine-dispatch-l5-lambda-11a1d5ae472a027cb6632881bcbca6c5" class="header-anchor">#</a> <code>dragon::rendering::coroutine::dispatch::__l5::&lt;lambda_11a1d5ae472a027cb6632881bcbca6c5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::coroutine::dispatch::__l5::&lt;lambda_11a1d5ae472a027cb6632881bcbca6c5&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::coroutine::when::__l2::&lt;lambda_43bb4ffe9e3a22cb4498ae83c4961d8c&gt; coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-coroutine-dispatch-l5-lambda-c4661421668a05dd66275e614d2c913d"><a href="#dragon-rendering-coroutine-dispatch-l5-lambda-c4661421668a05dd66275e614d2c913d" class="header-anchor">#</a> <code>dragon::rendering::coroutine::dispatch::__l5::&lt;lambda_c4661421668a05dd66275e614d2c913d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::coroutine::dispatch::__l5::&lt;lambda_c4661421668a05dd66275e614d2c913d&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,dragon::rendering::SharedTextureHandle&gt; &gt; stateHolder;
  const dragon::rendering::DeferredResult&lt;bool&gt;::then::__l2::&lt;lambda_c3545776d4a1357cc987df9697644608&gt; coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-c39af1b785cfd9fef232bb63f8916fde-l2-lambda-13f3d7855e4af07a3c276e9986c506b2"><a href="#dragon-rendering-details-runstep-l2-lambda-c39af1b785cfd9fef232bb63f8916fde-l2-lambda-13f3d7855e4af07a3c276e9986c506b2" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_c39af1b785cfd9fef232bb63f8916fde&gt;::()::__l2::&lt;lambda_13f3d7855e4af07a3c276e9986c506b2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_c39af1b785cfd9fef232bb63f8916fde&gt;::()::__l2::&lt;lambda_13f3d7855e4af07a3c276e9986c506b2&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::coroutine::Run&lt;bool&gt; run;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-a569cced27cf5a1cf209a41b43f8456a-l6-lambda-1b68472403d595797829ecc57129966e"><a href="#dragon-rendering-details-runstep-l2-lambda-a569cced27cf5a1cf209a41b43f8456a-l6-lambda-1b68472403d595797829ecc57129966e" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_a569cced27cf5a1cf209a41b43f8456a&gt;::()::__l6::&lt;lambda_1b68472403d595797829ecc57129966e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_a569cced27cf5a1cf209a41b43f8456a&gt;::()::__l6::&lt;lambda_1b68472403d595797829ecc57129966e&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::TextureResourceManager::Impl::overrideInternalAsync::__l2::&lt;lambda_f6804d13e6c1f399c569beed1d3a6cb8&gt; coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-a569cced27cf5a1cf209a41b43f8456a-l5-lambda-84e065d48bed39571ec09499ccc3d49a"><a href="#dragon-rendering-details-runstep-l2-lambda-a569cced27cf5a1cf209a41b43f8456a-l5-lambda-84e065d48bed39571ec09499ccc3d49a" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_a569cced27cf5a1cf209a41b43f8456a&gt;::()::__l5::&lt;lambda_84e065d48bed39571ec09499ccc3d49a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_a569cced27cf5a1cf209a41b43f8456a&gt;::()::__l5::&lt;lambda_84e065d48bed39571ec09499ccc3d49a&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::TextureResourceManager::Impl::overrideInternalAsync::__l2::&lt;lambda_f6804d13e6c1f399c569beed1d3a6cb8&gt; coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-56a057a413dadfdd162cdce03e706fb2-l2-lambda-d381cb58fc7779d7b1a7400c6ba63a6b"><a href="#dragon-rendering-details-runstep-l2-lambda-56a057a413dadfdd162cdce03e706fb2-l2-lambda-d381cb58fc7779d7b1a7400c6ba63a6b" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_56a057a413dadfdd162cdce03e706fb2&gt;::()::__l2::&lt;lambda_d381cb58fc7779d7b1a7400c6ba63a6b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_56a057a413dadfdd162cdce03e706fb2&gt;::()::__l2::&lt;lambda_d381cb58fc7779d7b1a7400c6ba63a6b&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,unsigned __int64&gt; &gt; stateHolder;
  const dragon::rendering::coroutine::Run&lt;unsigned __int64&gt; run;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-df5525a80596be2e2ff78d9490af6f0e-l2-lambda-d96772231ef00d7358ecf86c49fd7f57"><a href="#dragon-rendering-details-runstep-l2-lambda-df5525a80596be2e2ff78d9490af6f0e-l2-lambda-d96772231ef00d7358ecf86c49fd7f57" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_df5525a80596be2e2ff78d9490af6f0e&gt;::()::__l2::&lt;lambda_d96772231ef00d7358ecf86c49fd7f57&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_df5525a80596be2e2ff78d9490af6f0e&gt;::()::__l2::&lt;lambda_d96772231ef00d7358ecf86c49fd7f57&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::coroutine::Run&lt;bool&gt; run;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-f200acfc803d93621704f593d8ae7717-l6-lambda-c201794e9569b397d4574556637b0a8c"><a href="#dragon-rendering-details-runstep-l2-lambda-f200acfc803d93621704f593d8ae7717-l6-lambda-c201794e9569b397d4574556637b0a8c" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_f200acfc803d93621704f593d8ae7717&gt;::()::__l6::&lt;lambda_c201794e9569b397d4574556637b0a8c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(64)) dragon::rendering::details::runStep::__l2::&lt;lambda_f200acfc803d93621704f593d8ae7717&gt;::()::__l6::&lt;lambda_c201794e9569b397d4574556637b0a8c&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::TextureResourceManager::Impl::readAsync::__l2::&lt;lambda_661b6c1d40bfda803ee4881643ecfcc0&gt; coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-f200acfc803d93621704f593d8ae7717-l5-lambda-f161ca190794011fd8c399182391bc7e"><a href="#dragon-rendering-details-runstep-l2-lambda-f200acfc803d93621704f593d8ae7717-l5-lambda-f161ca190794011fd8c399182391bc7e" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_f200acfc803d93621704f593d8ae7717&gt;::()::__l5::&lt;lambda_f161ca190794011fd8c399182391bc7e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(64)) dragon::rendering::details::runStep::__l2::&lt;lambda_f200acfc803d93621704f593d8ae7717&gt;::()::__l5::&lt;lambda_f161ca190794011fd8c399182391bc7e&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::TextureResourceManager::Impl::readAsync::__l2::&lt;lambda_661b6c1d40bfda803ee4881643ecfcc0&gt; coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-e10cfcc8bd96dc76aa2724a3faa1de0a-l2-lambda-8fde154722b8182b3040c7b4e0d20e1a"><a href="#dragon-rendering-details-runstep-l2-lambda-e10cfcc8bd96dc76aa2724a3faa1de0a-l2-lambda-8fde154722b8182b3040c7b4e0d20e1a" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_e10cfcc8bd96dc76aa2724a3faa1de0a&gt;::()::__l2::&lt;lambda_8fde154722b8182b3040c7b4e0d20e1a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_e10cfcc8bd96dc76aa2724a3faa1de0a&gt;::()::__l2::&lt;lambda_8fde154722b8182b3040c7b4e0d20e1a&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::coroutine::Run&lt;bool&gt; run;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-00429de7dd09878e4a3668b23c94d5c6-l6-lambda-f36c08dd3cb8b019023aa1579e15a3cc"><a href="#dragon-rendering-details-runstep-l2-lambda-00429de7dd09878e4a3668b23c94d5c6-l6-lambda-f36c08dd3cb8b019023aa1579e15a3cc" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_00429de7dd09878e4a3668b23c94d5c6&gt;::()::__l6::&lt;lambda_f36c08dd3cb8b019023aa1579e15a3cc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) dragon::rendering::details::runStep::__l2::&lt;lambda_00429de7dd09878e4a3668b23c94d5c6&gt;::()::__l6::&lt;lambda_f36c08dd3cb8b019023aa1579e15a3cc&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::TextureResourceManager::Impl::copyAsync::__l2::&lt;lambda_a6349755da7110c122d82e5a120d69a2&gt; coroutineCallback;
  _BYTE gap18[64];
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-00429de7dd09878e4a3668b23c94d5c6-l5-lambda-61a91c263a9f826421fecc11c824e563"><a href="#dragon-rendering-details-runstep-l2-lambda-00429de7dd09878e4a3668b23c94d5c6-l5-lambda-61a91c263a9f826421fecc11c824e563" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_00429de7dd09878e4a3668b23c94d5c6&gt;::()::__l5::&lt;lambda_61a91c263a9f826421fecc11c824e563&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) dragon::rendering::details::runStep::__l2::&lt;lambda_00429de7dd09878e4a3668b23c94d5c6&gt;::()::__l5::&lt;lambda_61a91c263a9f826421fecc11c824e563&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::TextureResourceManager::Impl::copyAsync::__l2::&lt;lambda_a6349755da7110c122d82e5a120d69a2&gt; coroutineCallback;
  _BYTE gap18[64];
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-c4f55adc6fc3bd9650f292b46e07f10d-l2-lambda-4ffc2df15ba54d80d4a68a47656f5b0c"><a href="#dragon-rendering-details-runstep-l2-lambda-c4f55adc6fc3bd9650f292b46e07f10d-l2-lambda-4ffc2df15ba54d80d4a68a47656f5b0c" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_c4f55adc6fc3bd9650f292b46e07f10d&gt;::()::__l2::&lt;lambda_4ffc2df15ba54d80d4a68a47656f5b0c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_c4f55adc6fc3bd9650f292b46e07f10d&gt;::()::__l2::&lt;lambda_4ffc2df15ba54d80d4a68a47656f5b0c&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::coroutine::Run&lt;bool&gt; run;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-9e9b351cf491e6fbbcbd224f44748919-l6-lambda-a799483fea850e5e7b740f8f8b259dd2"><a href="#dragon-rendering-details-runstep-l2-lambda-9e9b351cf491e6fbbcbd224f44748919-l6-lambda-a799483fea850e5e7b740f8f8b259dd2" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_9e9b351cf491e6fbbcbd224f44748919&gt;::()::__l6::&lt;lambda_a799483fea850e5e7b740f8f8b259dd2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) dragon::rendering::details::runStep::__l2::&lt;lambda_9e9b351cf491e6fbbcbd224f44748919&gt;::()::__l6::&lt;lambda_a799483fea850e5e7b740f8f8b259dd2&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::DeferredResult&lt;bool&gt;::then::__l2::&lt;lambda_69c394c075e7947ecf6de6e23a7a00d3&gt; coroutineCallback;
  _BYTE gap18[32];
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-9e9b351cf491e6fbbcbd224f44748919-l5-lambda-ce33225d20eac731c3c5d3af79018974"><a href="#dragon-rendering-details-runstep-l2-lambda-9e9b351cf491e6fbbcbd224f44748919-l5-lambda-ce33225d20eac731c3c5d3af79018974" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_9e9b351cf491e6fbbcbd224f44748919&gt;::()::__l5::&lt;lambda_ce33225d20eac731c3c5d3af79018974&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) dragon::rendering::details::runStep::__l2::&lt;lambda_9e9b351cf491e6fbbcbd224f44748919&gt;::()::__l5::&lt;lambda_ce33225d20eac731c3c5d3af79018974&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::DeferredResult&lt;bool&gt;::then::__l2::&lt;lambda_69c394c075e7947ecf6de6e23a7a00d3&gt; coroutineCallback;
  _BYTE gap18[32];
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-7993acc3c8eb0047818e9d50cdee1abd-l2-lambda-e8536be739904b349810d2196988cf6e"><a href="#dragon-rendering-details-runstep-l2-lambda-7993acc3c8eb0047818e9d50cdee1abd-l2-lambda-e8536be739904b349810d2196988cf6e" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_7993acc3c8eb0047818e9d50cdee1abd&gt;::()::__l2::&lt;lambda_e8536be739904b349810d2196988cf6e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_7993acc3c8eb0047818e9d50cdee1abd&gt;::()::__l2::&lt;lambda_e8536be739904b349810d2196988cf6e&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::coroutine::Run&lt;bool&gt; run;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-a1b2a7e0f3d6af6c5b58879eada7c855-l6-lambda-89a176c9f04a1fbb53c7bf68c08f9c09"><a href="#dragon-rendering-details-runstep-l2-lambda-a1b2a7e0f3d6af6c5b58879eada7c855-l6-lambda-89a176c9f04a1fbb53c7bf68c08f9c09" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_a1b2a7e0f3d6af6c5b58879eada7c855&gt;::()::__l6::&lt;lambda_89a176c9f04a1fbb53c7bf68c08f9c09&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) dragon::rendering::details::runStep::__l2::&lt;lambda_a1b2a7e0f3d6af6c5b58879eada7c855&gt;::()::__l6::&lt;lambda_89a176c9f04a1fbb53c7bf68c08f9c09&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::DeferredResult&lt;bool&gt;::then::__l2::&lt;lambda_b36912425dc1a21ee23179b794f7fa70&gt; coroutineCallback;
  _BYTE gap18[32];
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-a1b2a7e0f3d6af6c5b58879eada7c855-l5-lambda-cb722233db968e5f59240fb8589f559c"><a href="#dragon-rendering-details-runstep-l2-lambda-a1b2a7e0f3d6af6c5b58879eada7c855-l5-lambda-cb722233db968e5f59240fb8589f559c" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_a1b2a7e0f3d6af6c5b58879eada7c855&gt;::()::__l5::&lt;lambda_cb722233db968e5f59240fb8589f559c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) dragon::rendering::details::runStep::__l2::&lt;lambda_a1b2a7e0f3d6af6c5b58879eada7c855&gt;::()::__l5::&lt;lambda_cb722233db968e5f59240fb8589f559c&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::DeferredResult&lt;bool&gt;::then::__l2::&lt;lambda_b36912425dc1a21ee23179b794f7fa70&gt; coroutineCallback;
  _BYTE gap18[32];
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-432cf39907ff9873ee4e999290412742-l2-lambda-d4ad2026ebbdcf5a3d5e6a0c5150cfc6"><a href="#dragon-rendering-details-runstep-l2-lambda-432cf39907ff9873ee4e999290412742-l2-lambda-d4ad2026ebbdcf5a3d5e6a0c5150cfc6" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_432cf39907ff9873ee4e999290412742&gt;::()::__l2::&lt;lambda_d4ad2026ebbdcf5a3d5e6a0c5150cfc6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_432cf39907ff9873ee4e999290412742&gt;::()::__l2::&lt;lambda_d4ad2026ebbdcf5a3d5e6a0c5150cfc6&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,dragon::rendering::SharedTextureHandle&gt; &gt; stateHolder;
  const dragon::rendering::coroutine::Run&lt;dragon::rendering::SharedTextureHandle&gt; run;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-f6d401144df93177f677010af549061f-l2-lambda-5d14e8a7d4aa62a6124ce6bb12f4b788"><a href="#dragon-rendering-details-runstep-l2-lambda-f6d401144df93177f677010af549061f-l2-lambda-5d14e8a7d4aa62a6124ce6bb12f4b788" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_f6d401144df93177f677010af549061f&gt;::()::__l2::&lt;lambda_5d14e8a7d4aa62a6124ce6bb12f4b788&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_f6d401144df93177f677010af549061f&gt;::()::__l2::&lt;lambda_5d14e8a7d4aa62a6124ce6bb12f4b788&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,dragon::rendering::SharedTextureHandle&gt; &gt; stateHolder;
  const dragon::rendering::coroutine::Run&lt;dragon::rendering::SharedTextureHandle&gt; run;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-b05b51eb72137a21c2cf1048902f2e5e-l2-lambda-1613ea905ce01cf62e8c52812631a7c0"><a href="#dragon-rendering-details-runstep-l2-lambda-b05b51eb72137a21c2cf1048902f2e5e-l2-lambda-1613ea905ce01cf62e8c52812631a7c0" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_b05b51eb72137a21c2cf1048902f2e5e&gt;::()::__l2::&lt;lambda_1613ea905ce01cf62e8c52812631a7c0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_b05b51eb72137a21c2cf1048902f2e5e&gt;::()::__l2::&lt;lambda_1613ea905ce01cf62e8c52812631a7c0&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::coroutine::Run&lt;bool&gt; run;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-e748f7c1651b3c2605040e30cd0026d1-l2-lambda-4789fb643bb4830fc45696c9194f4566"><a href="#dragon-rendering-details-runstep-l2-lambda-e748f7c1651b3c2605040e30cd0026d1-l2-lambda-4789fb643bb4830fc45696c9194f4566" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_e748f7c1651b3c2605040e30cd0026d1&gt;::()::__l2::&lt;lambda_4789fb643bb4830fc45696c9194f4566&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_e748f7c1651b3c2605040e30cd0026d1&gt;::()::__l2::&lt;lambda_4789fb643bb4830fc45696c9194f4566&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,dragon::rendering::SharedTextureHandle&gt; &gt; stateHolder;
  const dragon::rendering::coroutine::Run&lt;dragon::rendering::SharedTextureHandle&gt; run;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-61ef815dfe04875bdb4f9819a637ba35-l6-lambda-e24b39e3a7c6f8729d91b3f580c2dc97"><a href="#dragon-rendering-details-runstep-l2-lambda-61ef815dfe04875bdb4f9819a637ba35-l6-lambda-e24b39e3a7c6f8729d91b3f580c2dc97" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_61ef815dfe04875bdb4f9819a637ba35&gt;::()::__l6::&lt;lambda_e24b39e3a7c6f8729d91b3f580c2dc97&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(64)) dragon::rendering::details::runStep::__l2::&lt;lambda_61ef815dfe04875bdb4f9819a637ba35&gt;::()::__l6::&lt;lambda_e24b39e3a7c6f8729d91b3f580c2dc97&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,dragon::rendering::SharedTextureHandle&gt; &gt; stateHolder;
  const dragon::rendering::DeferredResult&lt;unsigned __int64&gt;::then::__l2::&lt;lambda_8b27e51beabb27cbb611d54cf4caa5b9&gt; coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-61ef815dfe04875bdb4f9819a637ba35-l5-lambda-fb7cafac9c0cdd995dfb619d50ecfedb"><a href="#dragon-rendering-details-runstep-l2-lambda-61ef815dfe04875bdb4f9819a637ba35-l5-lambda-fb7cafac9c0cdd995dfb619d50ecfedb" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_61ef815dfe04875bdb4f9819a637ba35&gt;::()::__l5::&lt;lambda_fb7cafac9c0cdd995dfb619d50ecfedb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(64)) dragon::rendering::details::runStep::__l2::&lt;lambda_61ef815dfe04875bdb4f9819a637ba35&gt;::()::__l5::&lt;lambda_fb7cafac9c0cdd995dfb619d50ecfedb&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,dragon::rendering::SharedTextureHandle&gt; &gt; stateHolder;
  const dragon::rendering::DeferredResult&lt;unsigned __int64&gt;::then::__l2::&lt;lambda_8b27e51beabb27cbb611d54cf4caa5b9&gt; coroutineCallback;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-8c9f3269710ce9476149804229953a1e-l2-lambda-2802f83d76530a35048e269653041662"><a href="#dragon-rendering-details-runstep-l2-lambda-8c9f3269710ce9476149804229953a1e-l2-lambda-2802f83d76530a35048e269653041662" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_8c9f3269710ce9476149804229953a1e&gt;::()::__l2::&lt;lambda_2802f83d76530a35048e269653041662&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_8c9f3269710ce9476149804229953a1e&gt;::()::__l2::&lt;lambda_2802f83d76530a35048e269653041662&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,dragon::rendering::SharedTextureHandle&gt; &gt; stateHolder;
  const dragon::rendering::coroutine::Run&lt;dragon::rendering::SharedTextureHandle&gt; run;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-011674cc6bf6055202422059f93cb0b6-l2-lambda-946c52530d637afd7db21fcf161be18c"><a href="#dragon-rendering-details-runstep-l2-lambda-011674cc6bf6055202422059f93cb0b6-l2-lambda-946c52530d637afd7db21fcf161be18c" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_011674cc6bf6055202422059f93cb0b6&gt;::()::__l2::&lt;lambda_946c52530d637afd7db21fcf161be18c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_011674cc6bf6055202422059f93cb0b6&gt;::()::__l2::&lt;lambda_946c52530d637afd7db21fcf161be18c&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,unsigned __int64&gt; &gt; stateHolder;
  const dragon::rendering::coroutine::Run&lt;unsigned __int64&gt; run;
};

</code></pre></div><h3 id="dragon-rendering-details-runstep-l2-lambda-66a3e410687ef6af83c0d08d2f7c8a05-l2-lambda-6d7945c89d3c8f0e5ddea32179639038"><a href="#dragon-rendering-details-runstep-l2-lambda-66a3e410687ef6af83c0d08d2f7c8a05-l2-lambda-6d7945c89d3c8f0e5ddea32179639038" class="header-anchor">#</a> <code>dragon::rendering::details::runStep::__l2::&lt;lambda_66a3e410687ef6af83c0d08d2f7c8a05&gt;::()::__l2::&lt;lambda_6d7945c89d3c8f0e5ddea32179639038&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::rendering::details::runStep::__l2::&lt;lambda_66a3e410687ef6af83c0d08d2f7c8a05&gt;::()::__l2::&lt;lambda_6d7945c89d3c8f0e5ddea32179639038&gt;
{
  dragon::rendering::GraphicsTasks *gfxTasks;
  std::shared_ptr&lt;std::variant&lt;dragon::rendering::details::Empty,bool&gt; &gt; stateHolder;
  const dragon::rendering::coroutine::Run&lt;bool&gt; run;
};

</code></pre></div><h3 id="dragon-pagedbufferview-dragon-mesh-vertexbufferview-dragon-mesh-vertexspanregistry"><a href="#dragon-pagedbufferview-dragon-mesh-vertexbufferview-dragon-mesh-vertexspanregistry" class="header-anchor">#</a> <code>dragon::PagedBufferView&lt;dragon::mesh::VertexBufferView,dragon::mesh::VertexSpanRegistry&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::PagedBufferView&lt;dragon::mesh::VertexBufferView,dragon::mesh::VertexSpanRegistry&gt; : dragon::mesh::VertexBufferView
{
  dragon::mesh::SplitMergeBasedSpanRegistry&lt;dragon::mesh::VertexSpanType,dragon::memory::BufferSource &amp;&amp;&gt;::Span mStorageSpan;
  gsl::not_null&lt;dragon::mesh::VertexSpanRegistry *&gt; mStorageSource;
};

</code></pre></div><h3 id="dragon-pagedbufferview-dragon-mesh-vertexbufferview-dragon-mesh-vertexspanregistry-vtbl"><a href="#dragon-pagedbufferview-dragon-mesh-vertexbufferview-dragon-mesh-vertexspanregistry-vtbl" class="header-anchor">#</a> <code>dragon::PagedBufferView&lt;dragon::mesh::VertexBufferView,dragon::mesh::VertexSpanRegistry&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ dragon::PagedBufferView&lt;dragon::mesh::VertexBufferView,dragon::mesh::VertexSpanRegistry&gt;_vtbl
{
  void (__fastcall *~VertexBufferView)(dragon::mesh::VertexBufferView *this);
};

</code></pre></div><h3 id="dragon-updatevertexbuffertransaction-apply-l5-lambda-a0a64e1c7867513b871690dbd0dac5db"><a href="#dragon-updatevertexbuffertransaction-apply-l5-lambda-a0a64e1c7867513b871690dbd0dac5db" class="header-anchor">#</a> <code>dragon::UpdateVertexBufferTransaction::apply::__l5::&lt;lambda_a0a64e1c7867513b871690dbd0dac5db&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::UpdateVertexBufferTransaction::apply::__l5::&lt;lambda_a0a64e1c7867513b871690dbd0dac5db&gt;
{
  dragon::UpdateVertexBufferTransaction *const __this;
  const unsigned int *offset;
};

</code></pre></div><h3 id="dragon-updatevertexbuffertransaction-apply-l5-lambda-dfd5f0409683ab748d9a99769867473c"><a href="#dragon-updatevertexbuffertransaction-apply-l5-lambda-dfd5f0409683ab748d9a99769867473c" class="header-anchor">#</a> <code>dragon::UpdateVertexBufferTransaction::apply::__l5::&lt;lambda_dfd5f0409683ab748d9a99769867473c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::UpdateVertexBufferTransaction::apply::__l5::&lt;lambda_dfd5f0409683ab748d9a99769867473c&gt;
{
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-a0a64e1c7867513b871690dbd0dac5db-lambda-dfd5f0409683ab748d9a99769867473c"><a href="#dragon-platform-helpers-visitoverloaded-lambda-a0a64e1c7867513b871690dbd0dac5db-lambda-dfd5f0409683ab748d9a99769867473c" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_a0a64e1c7867513b871690dbd0dac5db&gt;,&lt;lambda_dfd5f0409683ab748d9a99769867473c&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_a0a64e1c7867513b871690dbd0dac5db&gt;,&lt;lambda_dfd5f0409683ab748d9a99769867473c&gt; &gt; : dragon::UpdateVertexBufferTransaction::apply::__l5::&lt;lambda_a0a64e1c7867513b871690dbd0dac5db&gt;, dragon::UpdateVertexBufferTransaction::apply::__l5::&lt;lambda_dfd5f0409683ab748d9a99769867473c&gt;
{
};

</code></pre></div><h3 id="dragon-pagedbufferview-dragon-mesh-indexbufferview-dragon-mesh-indexspanregistry"><a href="#dragon-pagedbufferview-dragon-mesh-indexbufferview-dragon-mesh-indexspanregistry" class="header-anchor">#</a> <code>dragon::PagedBufferView&lt;dragon::mesh::IndexBufferView,dragon::mesh::IndexSpanRegistry&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::PagedBufferView&lt;dragon::mesh::IndexBufferView,dragon::mesh::IndexSpanRegistry&gt; : dragon::mesh::IndexBufferView
{
  dragon::mesh::SplitMergeBasedSpanRegistry&lt;dragon::mesh::IndexSpanType,dragon::memory::BufferSource &amp;&amp;&gt;::Span mStorageSpan;
  gsl::not_null&lt;dragon::mesh::IndexSpanRegistry *&gt; mStorageSource;
};

</code></pre></div><h3 id="dragon-pagedbufferview-dragon-mesh-indexbufferview-dragon-mesh-indexspanregistry-vtbl"><a href="#dragon-pagedbufferview-dragon-mesh-indexbufferview-dragon-mesh-indexspanregistry-vtbl" class="header-anchor">#</a> <code>dragon::PagedBufferView&lt;dragon::mesh::IndexBufferView,dragon::mesh::IndexSpanRegistry&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ dragon::PagedBufferView&lt;dragon::mesh::IndexBufferView,dragon::mesh::IndexSpanRegistry&gt;_vtbl
{
  void (__fastcall *~IndexBufferView)(dragon::mesh::IndexBufferView *this);
};

</code></pre></div><h3 id="dragon-updateindexbuffertransaction"><a href="#dragon-updateindexbuffertransaction" class="header-anchor">#</a> <code>dragon::UpdateIndexBufferTransaction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::UpdateIndexBufferTransaction
{
  std::vector&lt;unsigned char&gt; mBufferData;
  unsigned int mBufferStride;
  unsigned int mCount;
  std::string mDebugName;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-bf8217875efd4734fc345b4ef63f6648-lambda-752c0c19f3f0232d69a7dbbec83b0069"><a href="#dragon-platform-helpers-visitoverloaded-lambda-bf8217875efd4734fc345b4ef63f6648-lambda-752c0c19f3f0232d69a7dbbec83b0069" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_bf8217875efd4734fc345b4ef63f6648&gt;,&lt;lambda_752c0c19f3f0232d69a7dbbec83b0069&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_bf8217875efd4734fc345b4ef63f6648&gt;,&lt;lambda_752c0c19f3f0232d69a7dbbec83b0069&gt; &gt; : _BYTE[], _BYTE[]
{
  _BYTE gap0[16];
};

</code></pre></div><h3 id="dragon-createshaderbuffertransaction"><a href="#dragon-createshaderbuffertransaction" class="header-anchor">#</a> <code>dragon::CreateShaderBufferTransaction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::CreateShaderBufferTransaction
{
  std::vector&lt;unsigned char&gt; mBufferData;
  std::string mDebugName;
  unsigned int mBufferStride;
  unsigned int mCount;
};

</code></pre></div><h3 id="dragon-updateshaderbuffertransaction"><a href="#dragon-updateshaderbuffertransaction" class="header-anchor">#</a> <code>dragon::UpdateShaderBufferTransaction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::UpdateShaderBufferTransaction
{
  mce::ServerResourcePointer&lt;mce::ResourcePointer&lt;dragon::res::ResolvedShaderBufferResource,mce::ResourceBlockTemplate&lt;dragon::res::ResolvedShaderBufferResource,mce::UncheckedHandleTracker,dragon::BufferDescription&gt;,std::shared_ptr&gt;,mce::AssertResourceServiceErrorHandler&gt; mExistingBuffer;
  std::vector&lt;unsigned char&gt; mBufferData;
  std::string mDebugName;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-8574d24f6ba3260e6512bd19c23332cb"><a href="#dragon-platform-helpers-visitoverloaded-lambda-8574d24f6ba3260e6512bd19c23332cb" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_8574d24f6ba3260e6512bd19c23332cb&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_8574d24f6ba3260e6512bd19c23332cb&gt; &gt; : _BYTE[]
{
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-ef04bbbe9db0627491ed8a68d2971e49-lambda-cb2b4c4012b8f92c166615c0ab0943ba-lambda-eef8078e1bccecd3e2b3cf439b9fe412-lambda-ccc5cedc205676584038f50995c97560"><a href="#dragon-platform-helpers-visitoverloaded-lambda-ef04bbbe9db0627491ed8a68d2971e49-lambda-cb2b4c4012b8f92c166615c0ab0943ba-lambda-eef8078e1bccecd3e2b3cf439b9fe412-lambda-ccc5cedc205676584038f50995c97560" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_ef04bbbe9db0627491ed8a68d2971e49&gt;,&lt;lambda_cb2b4c4012b8f92c166615c0ab0943ba&gt;,&lt;lambda_eef8078e1bccecd3e2b3cf439b9fe412&gt;,&lt;lambda_ccc5cedc205676584038f50995c97560&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_ef04bbbe9db0627491ed8a68d2971e49&gt;,&lt;lambda_cb2b4c4012b8f92c166615c0ab0943ba&gt;,&lt;lambda_eef8078e1bccecd3e2b3cf439b9fe412&gt;,&lt;lambda_ccc5cedc205676584038f50995c97560&gt; &gt; : _BYTE[], _BYTE[], _BYTE[], _BYTE[]
{
  _BYTE gap0[32];
  _BYTE gap20[32];
  _BYTE gap40[32];
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-8b396866c5fe75c5542c62259c6a9bb1"><a href="#dragon-platform-helpers-visitoverloaded-lambda-8b396866c5fe75c5542c62259c6a9bb1" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_8b396866c5fe75c5542c62259c6a9bb1&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_8b396866c5fe75c5542c62259c6a9bb1&gt; &gt; : _BYTE[]
{
};

</code></pre></div><h3 id="dragon-createaccelerationstructurewithquadindexbuffertransaction"><a href="#dragon-createaccelerationstructurewithquadindexbuffertransaction" class="header-anchor">#</a> <code>dragon::CreateAccelerationStructureWithQuadIndexBufferTransaction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::CreateAccelerationStructureWithQuadIndexBufferTransaction
{
  mce::ServerResourcePointer&lt;mce::ResourcePointer&lt;dragon::mesh::ResolvedVertexBufferResource,mce::ResourceBlockTemplate&lt;dragon::mesh::ResolvedVertexBufferResource,mce::UncheckedHandleTracker,dragon::BufferDescription&gt;,std::shared_ptr&gt;,mce::AssertResourceServiceErrorHandler&gt; mVertexBuffer;
  unsigned int mVertexCount;
  dragon::rendering::BgfxPrimitiveIndexBuffer *mIndexBuffer;
  _BYTE mBuildFlags[2];
  std::string mDebugName;
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-6fcb2d35f34fb2797d3759006d77a339-lambda-06aa723ec6d816dc5b681cceedbd6330-lambda-4967c4eaee6be9a101ef51498e7e7e5c-lambda-f344babe6311f80830aad2f4fe42b3d0"><a href="#dragon-platform-helpers-visitoverloaded-lambda-6fcb2d35f34fb2797d3759006d77a339-lambda-06aa723ec6d816dc5b681cceedbd6330-lambda-4967c4eaee6be9a101ef51498e7e7e5c-lambda-f344babe6311f80830aad2f4fe42b3d0" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_6fcb2d35f34fb2797d3759006d77a339&gt;,&lt;lambda_06aa723ec6d816dc5b681cceedbd6330&gt;,&lt;lambda_4967c4eaee6be9a101ef51498e7e7e5c&gt;,&lt;lambda_f344babe6311f80830aad2f4fe42b3d0&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_6fcb2d35f34fb2797d3759006d77a339&gt;,&lt;lambda_06aa723ec6d816dc5b681cceedbd6330&gt;,&lt;lambda_4967c4eaee6be9a101ef51498e7e7e5c&gt;,&lt;lambda_f344babe6311f80830aad2f4fe42b3d0&gt; &gt; : _BYTE[], _BYTE[], _BYTE[], _BYTE[]
{
  _BYTE gap0[40];
  _BYTE gap28[32];
  _BYTE gap48[32];
  _BYTE gap68[32];
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-3b3a38ca1c5399c6f597f779098ccd90"><a href="#dragon-platform-helpers-visitoverloaded-lambda-3b3a38ca1c5399c6f597f779098ccd90" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_3b3a38ca1c5399c6f597f779098ccd90&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_3b3a38ca1c5399c6f597f779098ccd90&gt; &gt; : _BYTE[]
{
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-63759548f050931abeef0f4e2fd24f88-lambda-d56d4d2f7249e72c13e0d36d290eebff-lambda-a9c0175f63b744e2348f358ed6bca670-lambda-bbb4de575de97cbc76dc6ef9a84919c4"><a href="#dragon-platform-helpers-visitoverloaded-lambda-63759548f050931abeef0f4e2fd24f88-lambda-d56d4d2f7249e72c13e0d36d290eebff-lambda-a9c0175f63b744e2348f358ed6bca670-lambda-bbb4de575de97cbc76dc6ef9a84919c4" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_63759548f050931abeef0f4e2fd24f88&gt;,&lt;lambda_d56d4d2f7249e72c13e0d36d290eebff&gt;,&lt;lambda_a9c0175f63b744e2348f358ed6bca670&gt;,&lt;lambda_bbb4de575de97cbc76dc6ef9a84919c4&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_63759548f050931abeef0f4e2fd24f88&gt;,&lt;lambda_d56d4d2f7249e72c13e0d36d290eebff&gt;,&lt;lambda_a9c0175f63b744e2348f358ed6bca670&gt;,&lt;lambda_bbb4de575de97cbc76dc6ef9a84919c4&gt; &gt; : _BYTE[], _BYTE[], _BYTE[], _BYTE[]
{
  _BYTE gap0[40];
  _BYTE gap28[40];
  _BYTE gap50[40];
};

</code></pre></div><h3 id="dragon-updatevertexonlyaccelerationstructuretransaction-apply-l11-lambda-0243b5dcd3a99e8661e057624a474c96"><a href="#dragon-updatevertexonlyaccelerationstructuretransaction-apply-l11-lambda-0243b5dcd3a99e8661e057624a474c96" class="header-anchor">#</a> <code>dragon::UpdateVertexOnlyAccelerationStructureTransaction::apply::__l11::&lt;lambda_0243b5dcd3a99e8661e057624a474c96&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::UpdateVertexOnlyAccelerationStructureTransaction::apply::__l11::&lt;lambda_0243b5dcd3a99e8661e057624a474c96&gt;
{
};

</code></pre></div><h3 id="dragon-platform-helpers-visitoverloaded-lambda-0243b5dcd3a99e8661e057624a474c96"><a href="#dragon-platform-helpers-visitoverloaded-lambda-0243b5dcd3a99e8661e057624a474c96" class="header-anchor">#</a> <code>dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_0243b5dcd3a99e8661e057624a474c96&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::platform::helpers::VisitOverloaded&lt;&lt;lambda_0243b5dcd3a99e8661e057624a474c96&gt; &gt; : dragon::UpdateVertexOnlyAccelerationStructureTransaction::apply::__l11::&lt;lambda_0243b5dcd3a99e8661e057624a474c96&gt;
{
};

</code></pre></div><h3 id="dragon-result-result-std-optional-dragon-res-texturedescription-enum-dragon-res-textureerror"><a href="#dragon-result-result-std-optional-dragon-res-texturedescription-enum-dragon-res-textureerror" class="header-anchor">#</a> <code>dragon::result::Result&lt;std::optional&lt;dragon::res::TextureDescription&gt;,enum dragon::res::TextureError&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::result::Result&lt;std::optional&lt;dragon::res::TextureDescription&gt;,enum dragon::res::TextureError&gt;
{
  std::variant&lt;std::optional&lt;dragon::res::TextureDescription&gt;,enum dragon::res::TextureError&gt; mValue;
};

</code></pre></div><h3 id="dragon-res-updatetextureregiontransaction"><a href="#dragon-res-updatetextureregiontransaction" class="header-anchor">#</a> <code>dragon::res::UpdateTextureRegionTransaction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::res::UpdateTextureRegionTransaction
{
  unsigned int mX;
  unsigned int mY;
  cg::ImageBuffer mImageBuffer;
};

</code></pre></div><h3 id="dragon-res-copytexturetransaction"><a href="#dragon-res-copytexturetransaction" class="header-anchor">#</a> <code>dragon::res::CopyTextureTransaction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::res::CopyTextureTransaction
{
  dragon::res::ClientTexture mSrc;
};

</code></pre></div><h3 id="dragon-res-textureread-wait-l4-lambda-01a2631989fab186b0742e2fff9bfaed"><a href="#dragon-res-textureread-wait-l4-lambda-01a2631989fab186b0742e2fff9bfaed" class="header-anchor">#</a> <code>dragon::res::TextureRead::wait::__l4::&lt;lambda_01a2631989fab186b0742e2fff9bfaed&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::res::TextureRead::wait::__l4::&lt;lambda_01a2631989fab186b0742e2fff9bfaed&gt;
{
};

</code></pre></div><h3 id="dragon-res-resolvedtextureresource-dtor-l5-lambda-28b687352226c6311cbeb9099133fe66"><a href="#dragon-res-resolvedtextureresource-dtor-l5-lambda-28b687352226c6311cbeb9099133fe66" class="header-anchor">#</a> <code>dragon::res::ResolvedTextureResource::{dtor}::__l5::&lt;lambda_28b687352226c6311cbeb9099133fe66&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj dragon::res::ResolvedTextureResource::{dtor}::__l5::&lt;lambda_28b687352226c6311cbeb9099133fe66&gt;
{
  bgfx::TextureHandle handle;
};

</code></pre></div><h3 id="droppercontainermanagermodel"><a href="#droppercontainermanagermodel" class="header-anchor">#</a> <code>DropperContainerManagerModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DropperContainerManagerModel : LevelContainerManagerModel
{
};

</code></pre></div><h3 id="droppercontainermanagermodel-vtbl"><a href="#droppercontainermanagermodel-vtbl" class="header-anchor">#</a> <code>DropperContainerManagerModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DropperContainerManagerModel_vtbl
{
  void (__fastcall *~IContainerManager)(IContainerManager *this);
  ContainerID (__fastcall *getContainerId)(IContainerManager *this);
  void (__fastcall *setContainerId)(IContainerManager *this, ContainerID);
  ContainerType (__fastcall *getContainerType)(IContainerManager *this);
  void (__fastcall *setContainerType)(IContainerManager *this, ContainerType);
  void (__fastcall *serverInitItemStackIds)(IContainerManager *this);
  std::vector&lt;ItemStack&gt; *(__fastcall *getItemCopies)(IContainerManager *this, std::vector&lt;ItemStack&gt; *result);
  void (__fastcall *setSlot)(IContainerManager *this, int, const ItemStack *, bool);
  const ItemStack *(__fastcall *getSlot)(IContainerManager *this, int);
  void (__fastcall *setData)(IContainerManager *this, int, int);
  void (__fastcall *broadcastChanges)(IContainerManager *this);
  bool (__fastcall *validateContainer)(IContainerManager *this);
  bool (__fastcall *isValid)(ContainerManagerModel *this, float);
  ContainerScreenContext *(__fastcall *_postInit)(ContainerManagerModel *this, ContainerScreenContext *result);
};

</code></pre></div><h3 id="dispensercontainermanagermodel"><a href="#dispensercontainermanagermodel" class="header-anchor">#</a> <code>DispenserContainerManagerModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DispenserContainerManagerModel : LevelContainerManagerModel
{
};

</code></pre></div><h3 id="dispensercontainermanagermodel-vtbl"><a href="#dispensercontainermanagermodel-vtbl" class="header-anchor">#</a> <code>DispenserContainerManagerModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DispenserContainerManagerModel_vtbl
{
  void (__fastcall *~IContainerManager)(IContainerManager *this);
  ContainerID (__fastcall *getContainerId)(IContainerManager *this);
  void (__fastcall *setContainerId)(IContainerManager *this, ContainerID);
  ContainerType (__fastcall *getContainerType)(IContainerManager *this);
  void (__fastcall *setContainerType)(IContainerManager *this, ContainerType);
  void (__fastcall *serverInitItemStackIds)(IContainerManager *this);
  std::vector&lt;ItemStack&gt; *(__fastcall *getItemCopies)(IContainerManager *this, std::vector&lt;ItemStack&gt; *result);
  void (__fastcall *setSlot)(IContainerManager *this, int, const ItemStack *, bool);
  const ItemStack *(__fastcall *getSlot)(IContainerManager *this, int);
  void (__fastcall *setData)(IContainerManager *this, int, int);
  void (__fastcall *broadcastChanges)(IContainerManager *this);
  bool (__fastcall *validateContainer)(IContainerManager *this);
  bool (__fastcall *isValid)(ContainerManagerModel *this, float);
  ContainerScreenContext *(__fastcall *_postInit)(ContainerManagerModel *this, ContainerScreenContext *result);
};

</code></pre></div><h3 id="dancesystem"><a href="#dancesystem" class="header-anchor">#</a> <code>DanceSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DanceSystem : ITickingSystem
{
};

</code></pre></div><h3 id="dancesystem-vtbl"><a href="#dancesystem-vtbl" class="header-anchor">#</a> <code>DanceSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DanceSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="dwellersystem"><a href="#dwellersystem" class="header-anchor">#</a> <code>DwellerSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DwellerSystem : ITickingSystem
{
};

</code></pre></div><h3 id="dwellersystem-vtbl"><a href="#dwellersystem-vtbl" class="header-anchor">#</a> <code>DwellerSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DwellerSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="doorinteractgoal"><a href="#doorinteractgoal" class="header-anchor">#</a> <code>DoorInteractGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DoorInteractGoal : Goal
{
  BlockPos mDoorPos;
  const DoorBlock *mDoorBlock;
  bool mInitialToggledState;
  bool mMobOversized;
  bool mExited;
  float mDoorOpenDirX;
  float mDoorOpenDirZ;
  Direction::Type mEnterDirection;
  Direction::Type mExitDirection;
  Mob *mMob;
};

</code></pre></div><h3 id="doorinteractgoal-vtbl"><a href="#doorinteractgoal-vtbl" class="header-anchor">#</a> <code>DoorInteractGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DoorInteractGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="defendvillagetargetdefinition"><a href="#defendvillagetargetdefinition" class="header-anchor">#</a> <code>DefendVillageTargetDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) DefendVillageTargetDefinition : TargetGoalDefinition
{
  float mAttackChance;
};

</code></pre></div><h3 id="defendvillagetargetdefinition-vtbl"><a href="#defendvillagetargetdefinition-vtbl" class="header-anchor">#</a> <code>DefendVillageTargetDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefendVillageTargetDefinition_vtbl
{
  void (__fastcall *~BaseGoalDefinition)(BaseGoalDefinition *this);
  bool (__fastcall *validateMobType)(BaseGoalDefinition *this, Mob *);
  bool (__fastcall *validate)(BaseGoalDefinition *this, Mob *);
};

</code></pre></div><h3 id="defendvillagetargetgoal"><a href="#defendvillagetargetgoal" class="header-anchor">#</a> <code>DefendVillageTargetGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) DefendVillageTargetGoal : TargetGoal
{
  Mob *mPotentialTarget;
  float mAttackChance;
};

</code></pre></div><h3 id="defendvillagetargetgoal-vtbl"><a href="#defendvillagetargetgoal-vtbl" class="header-anchor">#</a> <code>DefendVillageTargetGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefendVillageTargetGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
  bool (__fastcall *_canAttack)(TargetGoal *this, Mob *, Actor *, bool, bool, const MobDescriptor **);
};

</code></pre></div><h3 id="delayedattackdefinition"><a href="#delayedattackdefinition" class="header-anchor">#</a> <code>DelayedAttackDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) DelayedAttackDefinition : MeleeAttackDefinition
{
  float mAttackDuration;
  float mHitDelayPercent;
  LevelSoundEvent mSound;
};

</code></pre></div><h3 id="delayedattackdefinition-vtbl"><a href="#delayedattackdefinition-vtbl" class="header-anchor">#</a> <code>DelayedAttackDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DelayedAttackDefinition_vtbl
{
  void (__fastcall *~BaseGoalDefinition)(BaseGoalDefinition *this);
  bool (__fastcall *validateMobType)(BaseGoalDefinition *this, Mob *);
  bool (__fastcall *validate)(BaseGoalDefinition *this, Mob *);
};

</code></pre></div><h3 id="delayedattackgoal"><a href="#delayedattackgoal" class="header-anchor">#</a> <code>DelayedAttackGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) DelayedAttackGoal : MeleeAttackGoal
{
  int mAttackDurationTicks;
  int mPostPathingTicks;
  int mHitDelayTicks;
  _BYTE mAttackFlag[4];
  LevelSoundEvent mSound;
};

</code></pre></div><h3 id="delayedattackgoal-vtbl"><a href="#delayedattackgoal-vtbl" class="header-anchor">#</a> <code>DelayedAttackGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DelayedAttackGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
  void (__fastcall *_attemptMoveToTarget)(MeleeAttackGoal *this, Actor *);
  void (__fastcall *_attemptAttackTarget)(MeleeAttackGoal *this, Actor *, float, float, float);
};

</code></pre></div><h3 id="dragonbasegoaldefinition"><a href="#dragonbasegoaldefinition" class="header-anchor">#</a> <code>DragonBaseGoalDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) DragonBaseGoalDefinition : BaseGoalDefinition
{
  float mActiveSpeed;
  float mFlightSpeed;
  float mTurnSpeed;
  FloatRange mTargetZone;
};

</code></pre></div><h3 id="dragonbasegoaldefinition-vtbl"><a href="#dragonbasegoaldefinition-vtbl" class="header-anchor">#</a> <code>DragonBaseGoalDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DragonBaseGoalDefinition_vtbl
{
  void (__fastcall *~BaseGoalDefinition)(BaseGoalDefinition *this);
  bool (__fastcall *validateMobType)(BaseGoalDefinition *this, Mob *);
  bool (__fastcall *validate)(BaseGoalDefinition *this, Mob *);
};

</code></pre></div><h3 id="dragonbasegoal"><a href="#dragonbasegoal" class="header-anchor">#</a> <code>DragonBaseGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) DragonBaseGoal : Goal
{
  EnderDragon *mDragon;
  float mActiveSpeed;
  float mFlightSpeed;
  float mTurnSpeed;
  FloatRange mTargetZone;
};

</code></pre></div><h3 id="dragonbasegoal-vtbl"><a href="#dragonbasegoal-vtbl" class="header-anchor">#</a> <code>DragonBaseGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DragonBaseGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="dragonchargeplayerdefinition"><a href="#dragonchargeplayerdefinition" class="header-anchor">#</a> <code>DragonChargePlayerDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) DragonChargePlayerDefinition : DragonBaseGoalDefinition
{
  float mContinueChargeThresholdTime;
};

</code></pre></div><h3 id="dragonchargeplayerdefinition-vtbl"><a href="#dragonchargeplayerdefinition-vtbl" class="header-anchor">#</a> <code>DragonChargePlayerDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DragonChargePlayerDefinition_vtbl
{
  void (__fastcall *~BaseGoalDefinition)(BaseGoalDefinition *this);
  bool (__fastcall *validateMobType)(BaseGoalDefinition *this, Mob *);
  bool (__fastcall *validate)(BaseGoalDefinition *this, Mob *);
};

</code></pre></div><h3 id="dragonchargeplayergoal"><a href="#dragonchargeplayergoal" class="header-anchor">#</a> <code>DragonChargePlayerGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DragonChargePlayerGoal : DragonBaseGoal
{
  int mOutsideChargeZoneTicks;
  int mContinueChargeThresholdTicks;
};

</code></pre></div><h3 id="dragonchargeplayergoal-vtbl"><a href="#dragonchargeplayergoal-vtbl" class="header-anchor">#</a> <code>DragonChargePlayerGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DragonChargePlayerGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="dragonbasegoaldefinition-builddragonbaseschema-l2-lambda-ac3b56ffc0f5393751f1704d25cc5371"><a href="#dragonbasegoaldefinition-builddragonbaseschema-l2-lambda-ac3b56ffc0f5393751f1704d25cc5371" class="header-anchor">#</a> <code>DragonBaseGoalDefinition::buildDragonBaseSchema::__l2::&lt;lambda_ac3b56ffc0f5393751f1704d25cc5371&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DragonBaseGoalDefinition::buildDragonBaseSchema::__l2::&lt;lambda_ac3b56ffc0f5393751f1704d25cc5371&gt;
{
  bool targetZoneJsonRequired;
  std::string targetZoneField;
};

</code></pre></div><h3 id="dragonbasegoaldefinition-builddragonbaseschema-l2-lambda-1938c658b5a686de9d54375c62570bb0"><a href="#dragonbasegoaldefinition-builddragonbaseschema-l2-lambda-1938c658b5a686de9d54375c62570bb0" class="header-anchor">#</a> <code>DragonBaseGoalDefinition::buildDragonBaseSchema::__l2::&lt;lambda_1938c658b5a686de9d54375c62570bb0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DragonBaseGoalDefinition::buildDragonBaseSchema::__l2::&lt;lambda_1938c658b5a686de9d54375c62570bb0&gt;
{
};

</code></pre></div><h3 id="dragondeathgoal"><a href="#dragondeathgoal" class="header-anchor">#</a> <code>DragonDeathGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) DragonDeathGoal : Goal
{
  EnderDragon *mDragon;
  int mTime;
};

</code></pre></div><h3 id="dragondeathgoal-vtbl"><a href="#dragondeathgoal-vtbl" class="header-anchor">#</a> <code>DragonDeathGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DragonDeathGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="dragonflamingdefinition"><a href="#dragonflamingdefinition" class="header-anchor">#</a> <code>DragonFlamingDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DragonFlamingDefinition : BaseGoalDefinition
{
  int mGroundFlameAttackCount;
  float mCooldownTime;
  float mFlameTime;
  float mRoarTime;
  float mSmokeRadius;
  float mSmokeTime;
  std::string mSmokeColor;
};

</code></pre></div><h3 id="dragonflamingdefinition-vtbl"><a href="#dragonflamingdefinition-vtbl" class="header-anchor">#</a> <code>DragonFlamingDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DragonFlamingDefinition_vtbl
{
  void (__fastcall *~BaseGoalDefinition)(BaseGoalDefinition *this);
  bool (__fastcall *validateMobType)(BaseGoalDefinition *this, Mob *);
  bool (__fastcall *validate)(BaseGoalDefinition *this, Mob *);
};

</code></pre></div><h3 id="dragonflaminggoal"><a href="#dragonflaminggoal" class="header-anchor">#</a> <code>DragonFlamingGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DragonFlamingGoal : Goal
{
  EnderDragon *mDragon;
  int mGroundFlameAttackCount;
  int mCooldownTicks;
  int mFlameTicks;
  int mFlameDurationTicks;
  int mRoarTicks;
  int mRoarDurationTicks;
  int mSmokeDurationTicks;
  float mSmokeRadius;
  mce::Color mSmokeColor;
};

</code></pre></div><h3 id="dragonflaminggoal-vtbl"><a href="#dragonflaminggoal-vtbl" class="header-anchor">#</a> <code>DragonFlamingGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DragonFlamingGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="dragonholdingpatterngoal"><a href="#dragonholdingpatterngoal" class="header-anchor">#</a> <code>DragonHoldingPatternGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DragonHoldingPatternGoal : Goal
{
  std::unique_ptr&lt;Path&gt; mCurrentPath;
  bool mClockwise;
  EnderDragon *mDragon;
};

</code></pre></div><h3 id="dragonholdingpatterngoal-vtbl"><a href="#dragonholdingpatterngoal-vtbl" class="header-anchor">#</a> <code>DragonHoldingPatternGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DragonHoldingPatternGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="dragonlandinggoal"><a href="#dragonlandinggoal" class="header-anchor">#</a> <code>DragonLandingGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) DragonLandingGoal : Goal
{
  EnderDragon *mDragon;
  std::unique_ptr&lt;Path&gt; mCurrentPath;
  bool mDone;
};

</code></pre></div><h3 id="dragonlandinggoal-vtbl"><a href="#dragonlandinggoal-vtbl" class="header-anchor">#</a> <code>DragonLandingGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DragonLandingGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="dragonscanninggoal"><a href="#dragonscanninggoal" class="header-anchor">#</a> <code>DragonScanningGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) DragonScanningGoal : Goal
{
  EnderDragon *mDragon;
  float mScanTime;
};

</code></pre></div><h3 id="dragonscanninggoal-vtbl"><a href="#dragonscanninggoal-vtbl" class="header-anchor">#</a> <code>DragonScanningGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DragonScanningGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="dragonstrafeplayerdefinition"><a href="#dragonstrafeplayerdefinition" class="header-anchor">#</a> <code>DragonStrafePlayerDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DragonStrafePlayerDefinition : DragonBaseGoalDefinition
{
  float mSwitchDirectionProbability;
  float mRangeAndViewTime;
  float mFireballRange;
  float mViewAngle;
};

</code></pre></div><h3 id="dragonstrafeplayerdefinition-vtbl"><a href="#dragonstrafeplayerdefinition-vtbl" class="header-anchor">#</a> <code>DragonStrafePlayerDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DragonStrafePlayerDefinition_vtbl
{
  void (__fastcall *~BaseGoalDefinition)(BaseGoalDefinition *this);
  bool (__fastcall *validateMobType)(BaseGoalDefinition *this, Mob *);
  bool (__fastcall *validate)(BaseGoalDefinition *this, Mob *);
};

</code></pre></div><h3 id="dragonstrafeplayergoal"><a href="#dragonstrafeplayergoal" class="header-anchor">#</a> <code>DragonStrafePlayerGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) DragonStrafePlayerGoal : DragonBaseGoal
{
  Actor *mAttackTarget;
  std::unique_ptr&lt;Path&gt; mCurrentPath;
  bool mClockwise;
  bool mDone;
  int mHasTargetTicks;
  int mRangeAndViewTicks;
  float mFireballPower;
  float mFireballRange;
  float mSwitchDirectionProbability;
  float mViewAngle;
};

</code></pre></div><h3 id="dragonstrafeplayergoal-vtbl"><a href="#dragonstrafeplayergoal-vtbl" class="header-anchor">#</a> <code>DragonStrafePlayerGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DragonStrafePlayerGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="dragonbasegoaldefinition-builddragonbaseschema-l2-lambda-b1aa74c093f58ccb20c883e4bd30ac6c"><a href="#dragonbasegoaldefinition-builddragonbaseschema-l2-lambda-b1aa74c093f58ccb20c883e4bd30ac6c" class="header-anchor">#</a> <code>DragonBaseGoalDefinition::buildDragonBaseSchema::__l2::&lt;lambda_b1aa74c093f58ccb20c883e4bd30ac6c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DragonBaseGoalDefinition::buildDragonBaseSchema::__l2::&lt;lambda_b1aa74c093f58ccb20c883e4bd30ac6c&gt;
{
  bool targetZoneJsonRequired;
  std::string targetZoneField;
};

</code></pre></div><h3 id="dragonbasegoaldefinition-builddragonbaseschema-l2-lambda-539b8604f9adc26e401b11765918b94f"><a href="#dragonbasegoaldefinition-builddragonbaseschema-l2-lambda-539b8604f9adc26e401b11765918b94f" class="header-anchor">#</a> <code>DragonBaseGoalDefinition::buildDragonBaseSchema::__l2::&lt;lambda_539b8604f9adc26e401b11765918b94f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DragonBaseGoalDefinition::buildDragonBaseSchema::__l2::&lt;lambda_539b8604f9adc26e401b11765918b94f&gt;
{
};

</code></pre></div><h3 id="dragontakeoffgoal"><a href="#dragontakeoffgoal" class="header-anchor">#</a> <code>DragonTakeoffGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DragonTakeoffGoal : Goal
{
  bool mFirstTick;
  std::unique_ptr&lt;Path&gt; mCurrentPath;
  EnderDragon *mDragon;
};

</code></pre></div><h3 id="dragontakeoffgoal-vtbl"><a href="#dragontakeoffgoal-vtbl" class="header-anchor">#</a> <code>DragonTakeoffGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DragonTakeoffGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="dropitemfordefinition"><a href="#dropitemfordefinition" class="header-anchor">#</a> <code>DropItemForDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) DropItemForDefinition : BaseGoalDefinition
{
  float mSecondsBeforePickup;
  float mTotalCoolDownSeconds;
  float mDropItemChance;
  float mOfferingDistance;
  float mMinimumTeleportDistance;
  float mLookAtTargetMaxHeadHeight;
  std::string mLootTable;
  DefinitionTrigger mOnDropAttempt;
  FloatRange mTimeOfDayRange;
  Vec3 mTargetRange;
  Vec3 mTeleportDistanceFromTarget;
  std::vector&lt;MobDescriptor&gt; mTargetFilter;
  int mSearchCount;
  int mSearchHeight;
  int mSearchRange;
  float mGoalRadius;
  float mSpeedModifier;
};

</code></pre></div><h3 id="dropitemfordefinition-vtbl"><a href="#dropitemfordefinition-vtbl" class="header-anchor">#</a> <code>DropItemForDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DropItemForDefinition_vtbl
{
  void (__fastcall *~BaseGoalDefinition)(BaseGoalDefinition *this);
  bool (__fastcall *validateMobType)(BaseGoalDefinition *this, Mob *);
  bool (__fastcall *validate)(BaseGoalDefinition *this, Mob *);
};

</code></pre></div><h3 id="dropitemforgoal"><a href="#dropitemforgoal" class="header-anchor">#</a> <code>DropItemForGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DropItemForGoal : BaseMoveToBlockGoal
{
  bool mHasDroppedItem;
  int mCooldownRemaining;
  int mTicksBeforePickup;
  int mTotalCooldownTicks;
  float mDropItemChance;
  float mPreferredSquareDistance;
  float mMinimumTeleportDistance;
  float mLookAtTargetMaxHeadHeight;
  std::string mLootTable;
  ActorUniqueID mDropForID;
  DefinitionTrigger mOnDropAttempt;
  FloatRange mTimeOfDayRange;
  Vec3 mTargetRange;
  Vec3 mTeleportDistanceFromTarget;
  std::vector&lt;MobDescriptor&gt; mTargetFilter;
};

</code></pre></div><h3 id="dropitemforgoal-vtbl"><a href="#dropitemforgoal-vtbl" class="header-anchor">#</a> <code>DropItemForGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DropItemForGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
  bool (__fastcall *hasReachedTarget)(BaseMoveToGoal *this);
  bool (__fastcall *isValidTarget)(BaseMoveToGoal *this, BlockSource *, const BlockPos *);
  int (__fastcall *_nextStartTick)(BaseMoveToGoal *this);
  bool (__fastcall *_canReach)(BaseMoveToGoal *this, const BlockPos *);
  void (__fastcall *_moveToBlock)(BaseMoveToGoal *this);
  Vec3 *(__fastcall *_getTargetPosition)(BaseMoveToGoal *this, Vec3 *result);
  unsigned __int64 (__fastcall *_getRepathTime)(BaseMoveToGoal *this);
  bool (__fastcall *findTargetBlock)(BaseMoveToBlockGoal *this);
};

</code></pre></div><h3 id="dropitemfordefinition-buildschema-l2-lambda-ba3f88ce38b474a7f7f5b2392b30d3e4"><a href="#dropitemfordefinition-buildschema-l2-lambda-ba3f88ce38b474a7f7f5b2392b30d3e4" class="header-anchor">#</a> <code>DropItemForDefinition::buildSchema::__l2::&lt;lambda_ba3f88ce38b474a7f7f5b2392b30d3e4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DropItemForDefinition::buildSchema::__l2::&lt;lambda_ba3f88ce38b474a7f7f5b2392b30d3e4&gt;
{
  bool timeOfDayRangeJsonRequired;
  std::string timeOfDayRangeField;
};

</code></pre></div><h3 id="dropitemfordefinition-buildschema-l2-lambda-2a97a3f1a23358a985ef13bb8cdac69a"><a href="#dropitemfordefinition-buildschema-l2-lambda-2a97a3f1a23358a985ef13bb8cdac69a" class="header-anchor">#</a> <code>DropItemForDefinition::buildSchema::__l2::&lt;lambda_2a97a3f1a23358a985ef13bb8cdac69a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DropItemForDefinition::buildSchema::__l2::&lt;lambda_2a97a3f1a23358a985ef13bb8cdac69a&gt;
{
};

</code></pre></div><h3 id="definitioninstancetyped-avoidblockgoal-definition"><a href="#definitioninstancetyped-avoidblockgoal-definition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;AvoidBlockGoal::Definition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;AvoidBlockGoal::Definition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;AvoidBlockGoal::Definition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-avoidblockgoal-definition-vtbl"><a href="#definitioninstancetyped-avoidblockgoal-definition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;AvoidBlockGoal::Definition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;AvoidBlockGoal::Definition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-avoidblockgoal-definition-avoidblockgoal"><a href="#definitioninstance-entitycontext-avoidblockgoal-definition-avoidblockgoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,AvoidBlockGoal::Definition,AvoidBlockGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,AvoidBlockGoal::Definition,AvoidBlockGoal&gt; : DefinitionInstanceTyped&lt;AvoidBlockGoal::Definition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-avoidblockgoal-definition-avoidblockgoal-vtbl"><a href="#definitioninstance-entitycontext-avoidblockgoal-definition-avoidblockgoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,AvoidBlockGoal::Definition,AvoidBlockGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,AvoidBlockGoal::Definition,AvoidBlockGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,AvoidBlockGoal::Definition,AvoidBlockGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,AvoidBlockGoal::Definition,AvoidBlockGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,AvoidBlockGoal::Definition,AvoidBlockGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,AvoidBlockGoal::Definition,AvoidBlockGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-avoidblockgoal-definition"><a href="#definitionserializer-avoidblockgoal-definition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;AvoidBlockGoal::Definition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;AvoidBlockGoal::Definition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;AvoidBlockGoal::Definition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,AvoidBlockGoal::Definition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-avoidblockgoal-definition-vtbl"><a href="#definitionserializer-avoidblockgoal-definition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;AvoidBlockGoal::Definition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;AvoidBlockGoal::Definition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-avoidmobtypedefinition"><a href="#definitioninstancetyped-avoidmobtypedefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;AvoidMobTypeDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;AvoidMobTypeDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;AvoidMobTypeDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-avoidmobtypedefinition-vtbl"><a href="#definitioninstancetyped-avoidmobtypedefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;AvoidMobTypeDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;AvoidMobTypeDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-avoidmobtypedefinition-avoidmobtypegoal"><a href="#definitioninstance-entitycontext-avoidmobtypedefinition-avoidmobtypegoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,AvoidMobTypeDefinition,AvoidMobTypeGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,AvoidMobTypeDefinition,AvoidMobTypeGoal&gt; : DefinitionInstanceTyped&lt;AvoidMobTypeDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-avoidmobtypedefinition-avoidmobtypegoal-vtbl"><a href="#definitioninstance-entitycontext-avoidmobtypedefinition-avoidmobtypegoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,AvoidMobTypeDefinition,AvoidMobTypeGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,AvoidMobTypeDefinition,AvoidMobTypeGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,AvoidMobTypeDefinition,AvoidMobTypeGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,AvoidMobTypeDefinition,AvoidMobTypeGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,AvoidMobTypeDefinition,AvoidMobTypeGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,AvoidMobTypeDefinition,AvoidMobTypeGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-avoidmobtypedefinition"><a href="#definitionserializer-avoidmobtypedefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;AvoidMobTypeDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;AvoidMobTypeDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;AvoidMobTypeDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,AvoidMobTypeDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-avoidmobtypedefinition-vtbl"><a href="#definitionserializer-avoidmobtypedefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;AvoidMobTypeDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;AvoidMobTypeDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-chargeattackdefinition"><a href="#definitioninstancetyped-chargeattackdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;ChargeAttackDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;ChargeAttackDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;ChargeAttackDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-chargeattackdefinition-vtbl"><a href="#definitioninstancetyped-chargeattackdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;ChargeAttackDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;ChargeAttackDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-chargeattackdefinition-chargeattackgoal"><a href="#definitioninstance-entitycontext-chargeattackdefinition-chargeattackgoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ChargeAttackDefinition,ChargeAttackGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,ChargeAttackDefinition,ChargeAttackGoal&gt; : DefinitionInstanceTyped&lt;ChargeAttackDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-chargeattackdefinition-chargeattackgoal-vtbl"><a href="#definitioninstance-entitycontext-chargeattackdefinition-chargeattackgoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ChargeAttackDefinition,ChargeAttackGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,ChargeAttackDefinition,ChargeAttackGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,ChargeAttackDefinition,ChargeAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,ChargeAttackDefinition,ChargeAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,ChargeAttackDefinition,ChargeAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,ChargeAttackDefinition,ChargeAttackGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-chargeattackdefinition"><a href="#definitionserializer-chargeattackdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ChargeAttackDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;ChargeAttackDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;ChargeAttackDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,ChargeAttackDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-chargeattackdefinition-vtbl"><a href="#definitionserializer-chargeattackdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ChargeAttackDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;ChargeAttackDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-chargehelditemdefinition"><a href="#definitioninstancetyped-chargehelditemdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;ChargeHeldItemDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;ChargeHeldItemDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;ChargeHeldItemDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-chargehelditemdefinition-vtbl"><a href="#definitioninstancetyped-chargehelditemdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;ChargeHeldItemDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;ChargeHeldItemDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-chargehelditemdefinition-chargehelditemgoal"><a href="#definitioninstance-entitycontext-chargehelditemdefinition-chargehelditemgoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ChargeHeldItemDefinition,ChargeHeldItemGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,ChargeHeldItemDefinition,ChargeHeldItemGoal&gt; : DefinitionInstanceTyped&lt;ChargeHeldItemDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-chargehelditemdefinition-chargehelditemgoal-vtbl"><a href="#definitioninstance-entitycontext-chargehelditemdefinition-chargehelditemgoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ChargeHeldItemDefinition,ChargeHeldItemGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,ChargeHeldItemDefinition,ChargeHeldItemGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,ChargeHeldItemDefinition,ChargeHeldItemGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,ChargeHeldItemDefinition,ChargeHeldItemGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,ChargeHeldItemDefinition,ChargeHeldItemGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,ChargeHeldItemDefinition,ChargeHeldItemGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-chargehelditemdefinition"><a href="#definitionserializer-chargehelditemdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ChargeHeldItemDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;ChargeHeldItemDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;ChargeHeldItemDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,ChargeHeldItemDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-chargehelditemdefinition-vtbl"><a href="#definitionserializer-chargehelditemdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ChargeHeldItemDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;ChargeHeldItemDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-circlearoundanchordefinition"><a href="#definitioninstancetyped-circlearoundanchordefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;CircleAroundAnchorDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;CircleAroundAnchorDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;CircleAroundAnchorDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-circlearoundanchordefinition-vtbl"><a href="#definitioninstancetyped-circlearoundanchordefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;CircleAroundAnchorDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;CircleAroundAnchorDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-circlearoundanchordefinition-circlearoundanchorgoal"><a href="#definitioninstance-entitycontext-circlearoundanchordefinition-circlearoundanchorgoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,CircleAroundAnchorDefinition,CircleAroundAnchorGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,CircleAroundAnchorDefinition,CircleAroundAnchorGoal&gt; : DefinitionInstanceTyped&lt;CircleAroundAnchorDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-circlearoundanchordefinition-circlearoundanchorgoal-vtbl"><a href="#definitioninstance-entitycontext-circlearoundanchordefinition-circlearoundanchorgoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,CircleAroundAnchorDefinition,CircleAroundAnchorGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,CircleAroundAnchorDefinition,CircleAroundAnchorGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,CircleAroundAnchorDefinition,CircleAroundAnchorGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,CircleAroundAnchorDefinition,CircleAroundAnchorGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,CircleAroundAnchorDefinition,CircleAroundAnchorGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,CircleAroundAnchorDefinition,CircleAroundAnchorGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-circlearoundanchordefinition"><a href="#definitionserializer-circlearoundanchordefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;CircleAroundAnchorDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;CircleAroundAnchorDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;CircleAroundAnchorDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,CircleAroundAnchorDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-circlearoundanchordefinition-vtbl"><a href="#definitionserializer-circlearoundanchordefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;CircleAroundAnchorDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;CircleAroundAnchorDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-controlledbyplayerdefinition"><a href="#definitioninstancetyped-controlledbyplayerdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;ControlledByPlayerDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;ControlledByPlayerDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;ControlledByPlayerDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-controlledbyplayerdefinition-vtbl"><a href="#definitioninstancetyped-controlledbyplayerdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;ControlledByPlayerDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;ControlledByPlayerDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-controlledbyplayerdefinition-controlledbyplayergoal"><a href="#definitioninstance-entitycontext-controlledbyplayerdefinition-controlledbyplayergoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ControlledByPlayerDefinition,ControlledByPlayerGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,ControlledByPlayerDefinition,ControlledByPlayerGoal&gt; : DefinitionInstanceTyped&lt;ControlledByPlayerDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-controlledbyplayerdefinition-controlledbyplayergoal-vtbl"><a href="#definitioninstance-entitycontext-controlledbyplayerdefinition-controlledbyplayergoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ControlledByPlayerDefinition,ControlledByPlayerGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,ControlledByPlayerDefinition,ControlledByPlayerGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,ControlledByPlayerDefinition,ControlledByPlayerGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,ControlledByPlayerDefinition,ControlledByPlayerGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,ControlledByPlayerDefinition,ControlledByPlayerGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,ControlledByPlayerDefinition,ControlledByPlayerGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-controlledbyplayerdefinition"><a href="#definitionserializer-controlledbyplayerdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ControlledByPlayerDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;ControlledByPlayerDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;ControlledByPlayerDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,ControlledByPlayerDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-controlledbyplayerdefinition-vtbl"><a href="#definitionserializer-controlledbyplayerdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ControlledByPlayerDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;ControlledByPlayerDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-defendvillagetargetdefinition"><a href="#definitioninstancetyped-defendvillagetargetdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;DefendVillageTargetDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;DefendVillageTargetDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;DefendVillageTargetDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-defendvillagetargetdefinition-vtbl"><a href="#definitioninstancetyped-defendvillagetargetdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;DefendVillageTargetDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;DefendVillageTargetDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-defendvillagetargetdefinition-defendvillagetargetgoal"><a href="#definitioninstance-entitycontext-defendvillagetargetdefinition-defendvillagetargetgoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,DefendVillageTargetDefinition,DefendVillageTargetGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,DefendVillageTargetDefinition,DefendVillageTargetGoal&gt; : DefinitionInstanceTyped&lt;DefendVillageTargetDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-defendvillagetargetdefinition-defendvillagetargetgoal-vtbl"><a href="#definitioninstance-entitycontext-defendvillagetargetdefinition-defendvillagetargetgoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,DefendVillageTargetDefinition,DefendVillageTargetGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,DefendVillageTargetDefinition,DefendVillageTargetGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,DefendVillageTargetDefinition,DefendVillageTargetGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,DefendVillageTargetDefinition,DefendVillageTargetGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,DefendVillageTargetDefinition,DefendVillageTargetGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,DefendVillageTargetDefinition,DefendVillageTargetGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-defendvillagetargetdefinition"><a href="#definitionserializer-defendvillagetargetdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;DefendVillageTargetDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;DefendVillageTargetDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;DefendVillageTargetDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,DefendVillageTargetDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-defendvillagetargetdefinition-vtbl"><a href="#definitionserializer-defendvillagetargetdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;DefendVillageTargetDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;DefendVillageTargetDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-delayedattackdefinition"><a href="#definitioninstancetyped-delayedattackdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;DelayedAttackDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;DelayedAttackDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;DelayedAttackDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-delayedattackdefinition-vtbl"><a href="#definitioninstancetyped-delayedattackdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;DelayedAttackDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;DelayedAttackDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-delayedattackdefinition-delayedattackgoal"><a href="#definitioninstance-entitycontext-delayedattackdefinition-delayedattackgoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,DelayedAttackDefinition,DelayedAttackGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,DelayedAttackDefinition,DelayedAttackGoal&gt; : DefinitionInstanceTyped&lt;DelayedAttackDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-delayedattackdefinition-delayedattackgoal-vtbl"><a href="#definitioninstance-entitycontext-delayedattackdefinition-delayedattackgoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,DelayedAttackDefinition,DelayedAttackGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,DelayedAttackDefinition,DelayedAttackGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,DelayedAttackDefinition,DelayedAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,DelayedAttackDefinition,DelayedAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,DelayedAttackDefinition,DelayedAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,DelayedAttackDefinition,DelayedAttackGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-delayedattackdefinition"><a href="#definitionserializer-delayedattackdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;DelayedAttackDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;DelayedAttackDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;DelayedAttackDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,DelayedAttackDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-delayedattackdefinition-vtbl"><a href="#definitionserializer-delayedattackdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;DelayedAttackDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;DelayedAttackDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-dragonchargeplayerdefinition"><a href="#definitioninstancetyped-dragonchargeplayerdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;DragonChargePlayerDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;DragonChargePlayerDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;DragonChargePlayerDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-dragonchargeplayerdefinition-vtbl"><a href="#definitioninstancetyped-dragonchargeplayerdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;DragonChargePlayerDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;DragonChargePlayerDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-dragonchargeplayerdefinition-dragonchargeplayergoal"><a href="#definitioninstance-entitycontext-dragonchargeplayerdefinition-dragonchargeplayergoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,DragonChargePlayerDefinition,DragonChargePlayerGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,DragonChargePlayerDefinition,DragonChargePlayerGoal&gt; : DefinitionInstanceTyped&lt;DragonChargePlayerDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-dragonchargeplayerdefinition-dragonchargeplayergoal-vtbl"><a href="#definitioninstance-entitycontext-dragonchargeplayerdefinition-dragonchargeplayergoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,DragonChargePlayerDefinition,DragonChargePlayerGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,DragonChargePlayerDefinition,DragonChargePlayerGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,DragonChargePlayerDefinition,DragonChargePlayerGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,DragonChargePlayerDefinition,DragonChargePlayerGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,DragonChargePlayerDefinition,DragonChargePlayerGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,DragonChargePlayerDefinition,DragonChargePlayerGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-dragonchargeplayerdefinition"><a href="#definitionserializer-dragonchargeplayerdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;DragonChargePlayerDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;DragonChargePlayerDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;DragonChargePlayerDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,DragonChargePlayerDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-dragonchargeplayerdefinition-vtbl"><a href="#definitionserializer-dragonchargeplayerdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;DragonChargePlayerDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;DragonChargePlayerDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-dragonflamingdefinition"><a href="#definitioninstancetyped-dragonflamingdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;DragonFlamingDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;DragonFlamingDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;DragonFlamingDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-dragonflamingdefinition-vtbl"><a href="#definitioninstancetyped-dragonflamingdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;DragonFlamingDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;DragonFlamingDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-dragonflamingdefinition-dragonflaminggoal"><a href="#definitioninstance-entitycontext-dragonflamingdefinition-dragonflaminggoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,DragonFlamingDefinition,DragonFlamingGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,DragonFlamingDefinition,DragonFlamingGoal&gt; : DefinitionInstanceTyped&lt;DragonFlamingDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-dragonflamingdefinition-dragonflaminggoal-vtbl"><a href="#definitioninstance-entitycontext-dragonflamingdefinition-dragonflaminggoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,DragonFlamingDefinition,DragonFlamingGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,DragonFlamingDefinition,DragonFlamingGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,DragonFlamingDefinition,DragonFlamingGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,DragonFlamingDefinition,DragonFlamingGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,DragonFlamingDefinition,DragonFlamingGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,DragonFlamingDefinition,DragonFlamingGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-dragonflamingdefinition"><a href="#definitionserializer-dragonflamingdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;DragonFlamingDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;DragonFlamingDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;DragonFlamingDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,DragonFlamingDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-dragonflamingdefinition-vtbl"><a href="#definitionserializer-dragonflamingdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;DragonFlamingDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;DragonFlamingDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-dragonstrafeplayerdefinition"><a href="#definitioninstancetyped-dragonstrafeplayerdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;DragonStrafePlayerDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;DragonStrafePlayerDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;DragonStrafePlayerDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-dragonstrafeplayerdefinition-vtbl"><a href="#definitioninstancetyped-dragonstrafeplayerdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;DragonStrafePlayerDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;DragonStrafePlayerDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-dragonstrafeplayerdefinition-dragonstrafeplayergoal"><a href="#definitioninstance-entitycontext-dragonstrafeplayerdefinition-dragonstrafeplayergoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,DragonStrafePlayerDefinition,DragonStrafePlayerGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,DragonStrafePlayerDefinition,DragonStrafePlayerGoal&gt; : DefinitionInstanceTyped&lt;DragonStrafePlayerDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-dragonstrafeplayerdefinition-dragonstrafeplayergoal-vtbl"><a href="#definitioninstance-entitycontext-dragonstrafeplayerdefinition-dragonstrafeplayergoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,DragonStrafePlayerDefinition,DragonStrafePlayerGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,DragonStrafePlayerDefinition,DragonStrafePlayerGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,DragonStrafePlayerDefinition,DragonStrafePlayerGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,DragonStrafePlayerDefinition,DragonStrafePlayerGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,DragonStrafePlayerDefinition,DragonStrafePlayerGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,DragonStrafePlayerDefinition,DragonStrafePlayerGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-dragonstrafeplayerdefinition"><a href="#definitionserializer-dragonstrafeplayerdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;DragonStrafePlayerDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;DragonStrafePlayerDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;DragonStrafePlayerDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,DragonStrafePlayerDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-dragonstrafeplayerdefinition-vtbl"><a href="#definitionserializer-dragonstrafeplayerdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;DragonStrafePlayerDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;DragonStrafePlayerDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-dropitemfordefinition"><a href="#definitioninstancetyped-dropitemfordefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;DropItemForDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;DropItemForDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;DropItemForDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-dropitemfordefinition-vtbl"><a href="#definitioninstancetyped-dropitemfordefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;DropItemForDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;DropItemForDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-dropitemfordefinition-dropitemforgoal"><a href="#definitioninstance-entitycontext-dropitemfordefinition-dropitemforgoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,DropItemForDefinition,DropItemForGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,DropItemForDefinition,DropItemForGoal&gt; : DefinitionInstanceTyped&lt;DropItemForDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-dropitemfordefinition-dropitemforgoal-vtbl"><a href="#definitioninstance-entitycontext-dropitemfordefinition-dropitemforgoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,DropItemForDefinition,DropItemForGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,DropItemForDefinition,DropItemForGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,DropItemForDefinition,DropItemForGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,DropItemForDefinition,DropItemForGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,DropItemForDefinition,DropItemForGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,DropItemForDefinition,DropItemForGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-dropitemfordefinition"><a href="#definitionserializer-dropitemfordefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;DropItemForDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;DropItemForDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;DropItemForDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,DropItemForDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-dropitemfordefinition-vtbl"><a href="#definitionserializer-dropitemfordefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;DropItemForDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;DropItemForDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-eatblockdefinition"><a href="#definitioninstancetyped-eatblockdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;EatBlockDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;EatBlockDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;EatBlockDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-eatblockdefinition-vtbl"><a href="#definitioninstancetyped-eatblockdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;EatBlockDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;EatBlockDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-eatblockdefinition-eatblockgoal"><a href="#definitioninstance-entitycontext-eatblockdefinition-eatblockgoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,EatBlockDefinition,EatBlockGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,EatBlockDefinition,EatBlockGoal&gt; : DefinitionInstanceTyped&lt;EatBlockDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-eatblockdefinition-eatblockgoal-vtbl"><a href="#definitioninstance-entitycontext-eatblockdefinition-eatblockgoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,EatBlockDefinition,EatBlockGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,EatBlockDefinition,EatBlockGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,EatBlockDefinition,EatBlockGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,EatBlockDefinition,EatBlockGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,EatBlockDefinition,EatBlockGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,EatBlockDefinition,EatBlockGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-eatblockdefinition"><a href="#definitionserializer-eatblockdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;EatBlockDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;EatBlockDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;EatBlockDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,EatBlockDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-eatblockdefinition-vtbl"><a href="#definitionserializer-eatblockdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;EatBlockDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;EatBlockDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-equipitemgoal-definition"><a href="#definitioninstancetyped-equipitemgoal-definition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;EquipItemGoal::Definition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;EquipItemGoal::Definition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;EquipItemGoal::Definition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-equipitemgoal-definition-vtbl"><a href="#definitioninstancetyped-equipitemgoal-definition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;EquipItemGoal::Definition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;EquipItemGoal::Definition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-equipitemgoal-definition-equipitemgoal"><a href="#definitioninstance-entitycontext-equipitemgoal-definition-equipitemgoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,EquipItemGoal::Definition,EquipItemGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,EquipItemGoal::Definition,EquipItemGoal&gt; : DefinitionInstanceTyped&lt;EquipItemGoal::Definition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-equipitemgoal-definition-equipitemgoal-vtbl"><a href="#definitioninstance-entitycontext-equipitemgoal-definition-equipitemgoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,EquipItemGoal::Definition,EquipItemGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,EquipItemGoal::Definition,EquipItemGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,EquipItemGoal::Definition,EquipItemGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,EquipItemGoal::Definition,EquipItemGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,EquipItemGoal::Definition,EquipItemGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,EquipItemGoal::Definition,EquipItemGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-equipitemgoal-definition"><a href="#definitionserializer-equipitemgoal-definition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;EquipItemGoal::Definition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;EquipItemGoal::Definition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;EquipItemGoal::Definition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,EquipItemGoal::Definition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-equipitemgoal-definition-vtbl"><a href="#definitionserializer-equipitemgoal-definition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;EquipItemGoal::Definition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;EquipItemGoal::Definition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-exploreoutskirtsdefinition"><a href="#definitioninstancetyped-exploreoutskirtsdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;ExploreOutskirtsDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;ExploreOutskirtsDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;ExploreOutskirtsDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-exploreoutskirtsdefinition-vtbl"><a href="#definitioninstancetyped-exploreoutskirtsdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;ExploreOutskirtsDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;ExploreOutskirtsDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-exploreoutskirtsdefinition-exploreoutskirtsgoal"><a href="#definitioninstance-entitycontext-exploreoutskirtsdefinition-exploreoutskirtsgoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ExploreOutskirtsDefinition,ExploreOutskirtsGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,ExploreOutskirtsDefinition,ExploreOutskirtsGoal&gt; : DefinitionInstanceTyped&lt;ExploreOutskirtsDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-exploreoutskirtsdefinition-exploreoutskirtsgoal-vtbl"><a href="#definitioninstance-entitycontext-exploreoutskirtsdefinition-exploreoutskirtsgoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,ExploreOutskirtsDefinition,ExploreOutskirtsGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,ExploreOutskirtsDefinition,ExploreOutskirtsGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,ExploreOutskirtsDefinition,ExploreOutskirtsGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,ExploreOutskirtsDefinition,ExploreOutskirtsGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,ExploreOutskirtsDefinition,ExploreOutskirtsGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,ExploreOutskirtsDefinition,ExploreOutskirtsGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-exploreoutskirtsdefinition"><a href="#definitionserializer-exploreoutskirtsdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ExploreOutskirtsDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;ExploreOutskirtsDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;ExploreOutskirtsDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,ExploreOutskirtsDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-exploreoutskirtsdefinition-vtbl"><a href="#definitionserializer-exploreoutskirtsdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;ExploreOutskirtsDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;ExploreOutskirtsDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-guardianattackdefinition"><a href="#definitioninstancetyped-guardianattackdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;GuardianAttackDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;GuardianAttackDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;GuardianAttackDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-guardianattackdefinition-vtbl"><a href="#definitioninstancetyped-guardianattackdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;GuardianAttackDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;GuardianAttackDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-guardianattackdefinition-guardianattackgoal"><a href="#definitioninstance-entitycontext-guardianattackdefinition-guardianattackgoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,GuardianAttackDefinition,GuardianAttackGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,GuardianAttackDefinition,GuardianAttackGoal&gt; : DefinitionInstanceTyped&lt;GuardianAttackDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-guardianattackdefinition-guardianattackgoal-vtbl"><a href="#definitioninstance-entitycontext-guardianattackdefinition-guardianattackgoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,GuardianAttackDefinition,GuardianAttackGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,GuardianAttackDefinition,GuardianAttackGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,GuardianAttackDefinition,GuardianAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,GuardianAttackDefinition,GuardianAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,GuardianAttackDefinition,GuardianAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,GuardianAttackDefinition,GuardianAttackGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-guardianattackdefinition"><a href="#definitionserializer-guardianattackdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;GuardianAttackDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;GuardianAttackDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;GuardianAttackDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,GuardianAttackDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-guardianattackdefinition-vtbl"><a href="#definitionserializer-guardianattackdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;GuardianAttackDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;GuardianAttackDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-harvestfarmblockdefinition"><a href="#definitioninstancetyped-harvestfarmblockdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;HarvestFarmBlockDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;HarvestFarmBlockDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;HarvestFarmBlockDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-harvestfarmblockdefinition-vtbl"><a href="#definitioninstancetyped-harvestfarmblockdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;HarvestFarmBlockDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;HarvestFarmBlockDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-harvestfarmblockdefinition-harvestfarmblockgoal"><a href="#definitioninstance-entitycontext-harvestfarmblockdefinition-harvestfarmblockgoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,HarvestFarmBlockDefinition,HarvestFarmBlockGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,HarvestFarmBlockDefinition,HarvestFarmBlockGoal&gt; : DefinitionInstanceTyped&lt;HarvestFarmBlockDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-harvestfarmblockdefinition-harvestfarmblockgoal-vtbl"><a href="#definitioninstance-entitycontext-harvestfarmblockdefinition-harvestfarmblockgoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,HarvestFarmBlockDefinition,HarvestFarmBlockGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,HarvestFarmBlockDefinition,HarvestFarmBlockGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,HarvestFarmBlockDefinition,HarvestFarmBlockGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,HarvestFarmBlockDefinition,HarvestFarmBlockGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,HarvestFarmBlockDefinition,HarvestFarmBlockGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,HarvestFarmBlockDefinition,HarvestFarmBlockGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-harvestfarmblockdefinition"><a href="#definitionserializer-harvestfarmblockdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;HarvestFarmBlockDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;HarvestFarmBlockDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;HarvestFarmBlockDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,HarvestFarmBlockDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-harvestfarmblockdefinition-vtbl"><a href="#definitionserializer-harvestfarmblockdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;HarvestFarmBlockDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;HarvestFarmBlockDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-meleeattackdefinition"><a href="#definitioninstancetyped-meleeattackdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;MeleeAttackDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;MeleeAttackDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;MeleeAttackDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-meleeattackdefinition-vtbl"><a href="#definitioninstancetyped-meleeattackdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;MeleeAttackDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;MeleeAttackDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-meleeattackdefinition-meleeattackgoal"><a href="#definitioninstance-entitycontext-meleeattackdefinition-meleeattackgoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,MeleeAttackDefinition,MeleeAttackGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,MeleeAttackDefinition,MeleeAttackGoal&gt; : DefinitionInstanceTyped&lt;MeleeAttackDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-meleeattackdefinition-meleeattackgoal-vtbl"><a href="#definitioninstance-entitycontext-meleeattackdefinition-meleeattackgoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,MeleeAttackDefinition,MeleeAttackGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,MeleeAttackDefinition,MeleeAttackGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,MeleeAttackDefinition,MeleeAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,MeleeAttackDefinition,MeleeAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,MeleeAttackDefinition,MeleeAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,MeleeAttackDefinition,MeleeAttackGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-meleeattackdefinition"><a href="#definitionserializer-meleeattackdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;MeleeAttackDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;MeleeAttackDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;MeleeAttackDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,MeleeAttackDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-meleeattackdefinition-vtbl"><a href="#definitionserializer-meleeattackdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;MeleeAttackDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;MeleeAttackDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-movetowardsdwellingrestrictiondefinition"><a href="#definitioninstancetyped-movetowardsdwellingrestrictiondefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;MoveTowardsDwellingRestrictionDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;MoveTowardsDwellingRestrictionDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;MoveTowardsDwellingRestrictionDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-movetowardsdwellingrestrictiondefinition-vtbl"><a href="#definitioninstancetyped-movetowardsdwellingrestrictiondefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;MoveTowardsDwellingRestrictionDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;MoveTowardsDwellingRestrictionDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-movetowardsdwellingrestrictiondefinition-movetowardsdwellingrestrictiongoal"><a href="#definitioninstance-entitycontext-movetowardsdwellingrestrictiondefinition-movetowardsdwellingrestrictiongoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,MoveTowardsDwellingRestrictionDefinition,MoveTowardsDwellingRestrictionGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,MoveTowardsDwellingRestrictionDefinition,MoveTowardsDwellingRestrictionGoal&gt; : DefinitionInstanceTyped&lt;MoveTowardsDwellingRestrictionDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-movetowardsdwellingrestrictiondefinition-movetowardsdwellingrestrictiongoal-vtbl"><a href="#definitioninstance-entitycontext-movetowardsdwellingrestrictiondefinition-movetowardsdwellingrestrictiongoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,MoveTowardsDwellingRestrictionDefinition,MoveTowardsDwellingRestrictionGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,MoveTowardsDwellingRestrictionDefinition,MoveTowardsDwellingRestrictionGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,MoveTowardsDwellingRestrictionDefinition,MoveTowardsDwellingRestrictionGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,MoveTowardsDwellingRestrictionDefinition,MoveTowardsDwellingRestrictionGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,MoveTowardsDwellingRestrictionDefinition,MoveTowardsDwellingRestrictionGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,MoveTowardsDwellingRestrictionDefinition,MoveTowardsDwellingRestrictionGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-movetowardsdwellingrestrictiondefinition"><a href="#definitionserializer-movetowardsdwellingrestrictiondefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;MoveTowardsDwellingRestrictionDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;MoveTowardsDwellingRestrictionDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;MoveTowardsDwellingRestrictionDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,MoveTowardsDwellingRestrictionDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-movetowardsdwellingrestrictiondefinition-vtbl"><a href="#definitionserializer-movetowardsdwellingrestrictiondefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;MoveTowardsDwellingRestrictionDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;MoveTowardsDwellingRestrictionDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-movetowardshomerestrictiondefinition"><a href="#definitioninstancetyped-movetowardshomerestrictiondefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;MoveTowardsHomeRestrictionDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;MoveTowardsHomeRestrictionDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;MoveTowardsHomeRestrictionDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-movetowardshomerestrictiondefinition-vtbl"><a href="#definitioninstancetyped-movetowardshomerestrictiondefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;MoveTowardsHomeRestrictionDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;MoveTowardsHomeRestrictionDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-movetowardshomerestrictiondefinition-movetowardshomerestrictiongoal"><a href="#definitioninstance-entitycontext-movetowardshomerestrictiondefinition-movetowardshomerestrictiongoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,MoveTowardsHomeRestrictionDefinition,MoveTowardsHomeRestrictionGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,MoveTowardsHomeRestrictionDefinition,MoveTowardsHomeRestrictionGoal&gt; : DefinitionInstanceTyped&lt;MoveTowardsHomeRestrictionDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-movetowardshomerestrictiondefinition-movetowardshomerestrictiongoal-vtbl"><a href="#definitioninstance-entitycontext-movetowardshomerestrictiondefinition-movetowardshomerestrictiongoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,MoveTowardsHomeRestrictionDefinition,MoveTowardsHomeRestrictionGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,MoveTowardsHomeRestrictionDefinition,MoveTowardsHomeRestrictionGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,MoveTowardsHomeRestrictionDefinition,MoveTowardsHomeRestrictionGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,MoveTowardsHomeRestrictionDefinition,MoveTowardsHomeRestrictionGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,MoveTowardsHomeRestrictionDefinition,MoveTowardsHomeRestrictionGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,MoveTowardsHomeRestrictionDefinition,MoveTowardsHomeRestrictionGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-movetowardshomerestrictiondefinition"><a href="#definitionserializer-movetowardshomerestrictiondefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;MoveTowardsHomeRestrictionDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;MoveTowardsHomeRestrictionDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;MoveTowardsHomeRestrictionDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,MoveTowardsHomeRestrictionDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-movetowardshomerestrictiondefinition-vtbl"><a href="#definitionserializer-movetowardshomerestrictiondefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;MoveTowardsHomeRestrictionDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;MoveTowardsHomeRestrictionDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-ocelotattackdefinition"><a href="#definitioninstancetyped-ocelotattackdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;OcelotAttackDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;OcelotAttackDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;OcelotAttackDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-ocelotattackdefinition-vtbl"><a href="#definitioninstancetyped-ocelotattackdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;OcelotAttackDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;OcelotAttackDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-ocelotattackdefinition-ocelotattackgoal"><a href="#definitioninstance-entitycontext-ocelotattackdefinition-ocelotattackgoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,OcelotAttackDefinition,OcelotAttackGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,OcelotAttackDefinition,OcelotAttackGoal&gt; : DefinitionInstanceTyped&lt;OcelotAttackDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-ocelotattackdefinition-ocelotattackgoal-vtbl"><a href="#definitioninstance-entitycontext-ocelotattackdefinition-ocelotattackgoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,OcelotAttackDefinition,OcelotAttackGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,OcelotAttackDefinition,OcelotAttackGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,OcelotAttackDefinition,OcelotAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,OcelotAttackDefinition,OcelotAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,OcelotAttackDefinition,OcelotAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,OcelotAttackDefinition,OcelotAttackGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-ocelotattackdefinition"><a href="#definitionserializer-ocelotattackdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;OcelotAttackDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;OcelotAttackDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;OcelotAttackDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,OcelotAttackDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-ocelotattackdefinition-vtbl"><a href="#definitionserializer-ocelotattackdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;OcelotAttackDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;OcelotAttackDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-rangedattackdefinition"><a href="#definitioninstancetyped-rangedattackdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;RangedAttackDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;RangedAttackDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;RangedAttackDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-rangedattackdefinition-vtbl"><a href="#definitioninstancetyped-rangedattackdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;RangedAttackDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;RangedAttackDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-rangedattackdefinition-rangedattackgoal"><a href="#definitioninstance-entitycontext-rangedattackdefinition-rangedattackgoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,RangedAttackDefinition,RangedAttackGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,RangedAttackDefinition,RangedAttackGoal&gt; : DefinitionInstanceTyped&lt;RangedAttackDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-rangedattackdefinition-rangedattackgoal-vtbl"><a href="#definitioninstance-entitycontext-rangedattackdefinition-rangedattackgoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,RangedAttackDefinition,RangedAttackGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,RangedAttackDefinition,RangedAttackGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,RangedAttackDefinition,RangedAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,RangedAttackDefinition,RangedAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,RangedAttackDefinition,RangedAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,RangedAttackDefinition,RangedAttackGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-rangedattackdefinition"><a href="#definitionserializer-rangedattackdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;RangedAttackDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;RangedAttackDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;RangedAttackDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,RangedAttackDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-rangedattackdefinition-vtbl"><a href="#definitionserializer-rangedattackdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;RangedAttackDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;RangedAttackDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-slimeattackdefinition"><a href="#definitioninstancetyped-slimeattackdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;SlimeAttackDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;SlimeAttackDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;SlimeAttackDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-slimeattackdefinition-vtbl"><a href="#definitioninstancetyped-slimeattackdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;SlimeAttackDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;SlimeAttackDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div><h3 id="definitioninstance-entitycontext-slimeattackdefinition-slimeattackgoal"><a href="#definitioninstance-entitycontext-slimeattackdefinition-slimeattackgoal" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,SlimeAttackDefinition,SlimeAttackGoal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstance&lt;EntityContext &amp;,SlimeAttackDefinition,SlimeAttackGoal&gt; : DefinitionInstanceTyped&lt;SlimeAttackDefinition&gt;
{
};

</code></pre></div><h3 id="definitioninstance-entitycontext-slimeattackdefinition-slimeattackgoal-vtbl"><a href="#definitioninstance-entitycontext-slimeattackdefinition-slimeattackgoal-vtbl" class="header-anchor">#</a> <code>DefinitionInstance&lt;EntityContext &amp;,SlimeAttackDefinition,SlimeAttackGoal&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstance&lt;EntityContext &amp;,SlimeAttackDefinition,SlimeAttackGoal&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *_create)(DefinitionInstance&lt;EntityContext &amp;,SlimeAttackDefinition,SlimeAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_initialize)(DefinitionInstance&lt;EntityContext &amp;,SlimeAttackDefinition,SlimeAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_uninitialize)(DefinitionInstance&lt;EntityContext &amp;,SlimeAttackDefinition,SlimeAttackGoal&gt; *this, EntityContext *);
  void (__fastcall *_destroy)(DefinitionInstance&lt;EntityContext &amp;,SlimeAttackDefinition,SlimeAttackGoal&gt; *this, EntityContext *);
};

</code></pre></div><h3 id="definitionserializer-slimeattackdefinition"><a href="#definitionserializer-slimeattackdefinition" class="header-anchor">#</a> <code>DefinitionSerializer&lt;SlimeAttackDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionSerializer&lt;SlimeAttackDefinition&gt; : IDefinitionSerializer
{
  std::function&lt;std::shared_ptr&lt;DefinitionInstanceTyped&lt;SlimeAttackDefinition&gt; &gt; __cdecl(void)&gt; mDefinitionInitializer;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,SlimeAttackDefinition&gt; &gt; mSchema;
};

</code></pre></div><h3 id="definitionserializer-slimeattackdefinition-vtbl"><a href="#definitionserializer-slimeattackdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionSerializer&lt;SlimeAttackDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionSerializer&lt;SlimeAttackDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionSerializer)(IDefinitionSerializer *this);
  std::shared_ptr&lt;IDefinitionInstance&gt; *(__fastcall *serializeDefinitionInstance)(IDefinitionSerializer *this, std::shared_ptr&lt;IDefinitionInstance&gt; *result, const Json::Value *, bool);
};

</code></pre></div><h3 id="definitioninstancetyped-slimefloatdefinition"><a href="#definitioninstancetyped-slimefloatdefinition" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;SlimeFloatDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj DefinitionInstanceTyped&lt;SlimeFloatDefinition&gt; : IDefinitionInstance
{
  std::unique_ptr&lt;SlimeFloatDefinition&gt; mDefinition;
};

</code></pre></div><h3 id="definitioninstancetyped-slimefloatdefinition-vtbl"><a href="#definitioninstancetyped-slimefloatdefinition-vtbl" class="header-anchor">#</a> <code>DefinitionInstanceTyped&lt;SlimeFloatDefinition&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ DefinitionInstanceTyped&lt;SlimeFloatDefinition&gt;_vtbl
{
  void (__fastcall *~IDefinitionInstance)(IDefinitionInstance *this);
  unsigned __int16 (__fastcall *getRuntimeTypeId)(IDefinitionInstance *this);
  void (__fastcall *create)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *initialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *uninitialize)(IDefinitionInstance *this, const ContextAccessor *);
  void (__fastcall *destroy)(IDefinitionInstance *this, const ContextAccessor *);
};

</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      
      <a href="/mcstructure/1.16.201/structure/D~5.html" class="prev">
        D~5
      </a></span> <span class="next"><a href="/mcstructure/1.16.201/structure/D~7.html">
        D~7
      </a>
      
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/mcstructure/assets/js/app.56b0ab36.js" defer></script><script src="/mcstructure/assets/js/2.56e23786.js" defer></script><script src="/mcstructure/assets/js/104.4a4116d4.js" defer></script>
  </body>
</html>
