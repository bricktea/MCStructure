<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>B~1 | MC TIL</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Some structure and enum information for minecraft bedrock edition.">
    
    <link rel="preload" href="/mcstructure/assets/css/0.styles.5de0a167.css" as="style"><link rel="preload" href="/mcstructure/assets/js/app.56b0ab36.js" as="script"><link rel="preload" href="/mcstructure/assets/js/2.56e23786.js" as="script"><link rel="preload" href="/mcstructure/assets/js/91.85f8c578.js" as="script"><link rel="prefetch" href="/mcstructure/assets/js/10.dda8da32.js"><link rel="prefetch" href="/mcstructure/assets/js/100.d193fca3.js"><link rel="prefetch" href="/mcstructure/assets/js/101.324df8d1.js"><link rel="prefetch" href="/mcstructure/assets/js/102.81d32953.js"><link rel="prefetch" href="/mcstructure/assets/js/103.bafffe55.js"><link rel="prefetch" href="/mcstructure/assets/js/104.4a4116d4.js"><link rel="prefetch" href="/mcstructure/assets/js/105.ee5ab7c3.js"><link rel="prefetch" href="/mcstructure/assets/js/106.16520c01.js"><link rel="prefetch" href="/mcstructure/assets/js/107.e4e2fef9.js"><link rel="prefetch" href="/mcstructure/assets/js/108.9771cecd.js"><link rel="prefetch" href="/mcstructure/assets/js/109.07a059f8.js"><link rel="prefetch" href="/mcstructure/assets/js/11.84aff5f4.js"><link rel="prefetch" href="/mcstructure/assets/js/110.79e73184.js"><link rel="prefetch" href="/mcstructure/assets/js/111.735fe11b.js"><link rel="prefetch" href="/mcstructure/assets/js/112.5b8c9633.js"><link rel="prefetch" href="/mcstructure/assets/js/113.a961fd7d.js"><link rel="prefetch" href="/mcstructure/assets/js/114.f46e6ac6.js"><link rel="prefetch" href="/mcstructure/assets/js/115.29d129b9.js"><link rel="prefetch" href="/mcstructure/assets/js/116.0761604d.js"><link rel="prefetch" href="/mcstructure/assets/js/117.8fa51bbe.js"><link rel="prefetch" href="/mcstructure/assets/js/118.65b68c09.js"><link rel="prefetch" href="/mcstructure/assets/js/119.0b88b1c0.js"><link rel="prefetch" href="/mcstructure/assets/js/12.fb0b2343.js"><link rel="prefetch" href="/mcstructure/assets/js/120.6514cc60.js"><link rel="prefetch" href="/mcstructure/assets/js/121.30792057.js"><link rel="prefetch" href="/mcstructure/assets/js/122.ac6c9052.js"><link rel="prefetch" href="/mcstructure/assets/js/123.9dde14ff.js"><link rel="prefetch" href="/mcstructure/assets/js/124.1b8cd48f.js"><link rel="prefetch" href="/mcstructure/assets/js/125.ba14f223.js"><link rel="prefetch" href="/mcstructure/assets/js/126.5dd69ba6.js"><link rel="prefetch" href="/mcstructure/assets/js/127.32df8d72.js"><link rel="prefetch" href="/mcstructure/assets/js/128.aa9a14cc.js"><link rel="prefetch" href="/mcstructure/assets/js/129.d7a703a5.js"><link rel="prefetch" href="/mcstructure/assets/js/13.b8437649.js"><link rel="prefetch" href="/mcstructure/assets/js/130.d8f7ecf5.js"><link rel="prefetch" href="/mcstructure/assets/js/131.0c1d33fe.js"><link rel="prefetch" href="/mcstructure/assets/js/132.8b6e6ff3.js"><link rel="prefetch" href="/mcstructure/assets/js/133.f999118d.js"><link rel="prefetch" href="/mcstructure/assets/js/134.bc4a2893.js"><link rel="prefetch" href="/mcstructure/assets/js/135.e6e793b3.js"><link rel="prefetch" href="/mcstructure/assets/js/136.c50dcaff.js"><link rel="prefetch" href="/mcstructure/assets/js/137.209d5c8a.js"><link rel="prefetch" href="/mcstructure/assets/js/138.3eed47db.js"><link rel="prefetch" href="/mcstructure/assets/js/139.5e9afeaa.js"><link rel="prefetch" href="/mcstructure/assets/js/14.c94aa248.js"><link rel="prefetch" href="/mcstructure/assets/js/140.ac85c96f.js"><link rel="prefetch" href="/mcstructure/assets/js/141.82f0f06f.js"><link rel="prefetch" href="/mcstructure/assets/js/142.08052153.js"><link rel="prefetch" href="/mcstructure/assets/js/143.97d16176.js"><link rel="prefetch" href="/mcstructure/assets/js/144.66c74f2b.js"><link rel="prefetch" href="/mcstructure/assets/js/145.58e96ed1.js"><link rel="prefetch" href="/mcstructure/assets/js/146.4c73b3b4.js"><link rel="prefetch" href="/mcstructure/assets/js/147.0e0e09a7.js"><link rel="prefetch" href="/mcstructure/assets/js/148.a8c2c253.js"><link rel="prefetch" href="/mcstructure/assets/js/149.99f1b4f1.js"><link rel="prefetch" href="/mcstructure/assets/js/15.fd6df6e3.js"><link rel="prefetch" href="/mcstructure/assets/js/16.855c8adf.js"><link rel="prefetch" href="/mcstructure/assets/js/17.860009b0.js"><link rel="prefetch" href="/mcstructure/assets/js/18.63105a6b.js"><link rel="prefetch" href="/mcstructure/assets/js/19.fbddb16b.js"><link rel="prefetch" href="/mcstructure/assets/js/20.605578ab.js"><link rel="prefetch" href="/mcstructure/assets/js/21.1e5adf90.js"><link rel="prefetch" href="/mcstructure/assets/js/22.29bfa69a.js"><link rel="prefetch" href="/mcstructure/assets/js/23.566201a2.js"><link rel="prefetch" href="/mcstructure/assets/js/24.d912e845.js"><link rel="prefetch" href="/mcstructure/assets/js/25.8885d257.js"><link rel="prefetch" href="/mcstructure/assets/js/26.8409713f.js"><link rel="prefetch" href="/mcstructure/assets/js/27.49cb5267.js"><link rel="prefetch" href="/mcstructure/assets/js/28.2a890355.js"><link rel="prefetch" href="/mcstructure/assets/js/29.6ea7598b.js"><link rel="prefetch" href="/mcstructure/assets/js/3.50967458.js"><link rel="prefetch" href="/mcstructure/assets/js/30.1a3c3902.js"><link rel="prefetch" href="/mcstructure/assets/js/31.24ec9e8b.js"><link rel="prefetch" href="/mcstructure/assets/js/32.40831503.js"><link rel="prefetch" href="/mcstructure/assets/js/33.6602f7d9.js"><link rel="prefetch" href="/mcstructure/assets/js/34.75d333d9.js"><link rel="prefetch" href="/mcstructure/assets/js/35.84bf3e5a.js"><link rel="prefetch" href="/mcstructure/assets/js/36.fe4e7307.js"><link rel="prefetch" href="/mcstructure/assets/js/37.b2ee95ad.js"><link rel="prefetch" href="/mcstructure/assets/js/38.c03d5dee.js"><link rel="prefetch" href="/mcstructure/assets/js/39.a60df6e0.js"><link rel="prefetch" href="/mcstructure/assets/js/4.f5835878.js"><link rel="prefetch" href="/mcstructure/assets/js/40.6322a006.js"><link rel="prefetch" href="/mcstructure/assets/js/41.420acfde.js"><link rel="prefetch" href="/mcstructure/assets/js/42.a4ef9cfe.js"><link rel="prefetch" href="/mcstructure/assets/js/43.660cc3cf.js"><link rel="prefetch" href="/mcstructure/assets/js/44.683fc1e0.js"><link rel="prefetch" href="/mcstructure/assets/js/45.f27a9ad0.js"><link rel="prefetch" href="/mcstructure/assets/js/46.9f9edd2c.js"><link rel="prefetch" href="/mcstructure/assets/js/47.fd3ae547.js"><link rel="prefetch" href="/mcstructure/assets/js/48.375f8f97.js"><link rel="prefetch" href="/mcstructure/assets/js/49.e0d0f024.js"><link rel="prefetch" href="/mcstructure/assets/js/5.e0bd9261.js"><link rel="prefetch" href="/mcstructure/assets/js/50.aa126f14.js"><link rel="prefetch" href="/mcstructure/assets/js/51.e939b03e.js"><link rel="prefetch" href="/mcstructure/assets/js/52.a2d46eef.js"><link rel="prefetch" href="/mcstructure/assets/js/53.72de48c3.js"><link rel="prefetch" href="/mcstructure/assets/js/54.54675155.js"><link rel="prefetch" href="/mcstructure/assets/js/55.8b419ad8.js"><link rel="prefetch" href="/mcstructure/assets/js/56.07af8dcf.js"><link rel="prefetch" href="/mcstructure/assets/js/57.0bedaec9.js"><link rel="prefetch" href="/mcstructure/assets/js/58.37c94f2a.js"><link rel="prefetch" href="/mcstructure/assets/js/59.b0866a6a.js"><link rel="prefetch" href="/mcstructure/assets/js/6.04e2a2d2.js"><link rel="prefetch" href="/mcstructure/assets/js/60.5c5afc8c.js"><link rel="prefetch" href="/mcstructure/assets/js/61.ea56e4d6.js"><link rel="prefetch" href="/mcstructure/assets/js/62.3cb13464.js"><link rel="prefetch" href="/mcstructure/assets/js/63.83c0082d.js"><link rel="prefetch" href="/mcstructure/assets/js/64.2cd02c8b.js"><link rel="prefetch" href="/mcstructure/assets/js/65.c16cc8f2.js"><link rel="prefetch" href="/mcstructure/assets/js/66.ad2d4521.js"><link rel="prefetch" href="/mcstructure/assets/js/67.83e59ab1.js"><link rel="prefetch" href="/mcstructure/assets/js/68.beec9ddd.js"><link rel="prefetch" href="/mcstructure/assets/js/69.b4bc257c.js"><link rel="prefetch" href="/mcstructure/assets/js/7.fd995bdf.js"><link rel="prefetch" href="/mcstructure/assets/js/70.1ea3abef.js"><link rel="prefetch" href="/mcstructure/assets/js/71.3cf65839.js"><link rel="prefetch" href="/mcstructure/assets/js/72.6f64c4ab.js"><link rel="prefetch" href="/mcstructure/assets/js/73.452d7013.js"><link rel="prefetch" href="/mcstructure/assets/js/74.0660e6d9.js"><link rel="prefetch" href="/mcstructure/assets/js/75.b7b5e783.js"><link rel="prefetch" href="/mcstructure/assets/js/76.5fddaea1.js"><link rel="prefetch" href="/mcstructure/assets/js/77.be26bbc6.js"><link rel="prefetch" href="/mcstructure/assets/js/78.0e00fef4.js"><link rel="prefetch" href="/mcstructure/assets/js/79.731c37fb.js"><link rel="prefetch" href="/mcstructure/assets/js/8.1cbf1ff3.js"><link rel="prefetch" href="/mcstructure/assets/js/80.2282d655.js"><link rel="prefetch" href="/mcstructure/assets/js/81.33a53399.js"><link rel="prefetch" href="/mcstructure/assets/js/82.196f3fc3.js"><link rel="prefetch" href="/mcstructure/assets/js/83.e9cb3f05.js"><link rel="prefetch" href="/mcstructure/assets/js/84.35c05041.js"><link rel="prefetch" href="/mcstructure/assets/js/85.16e996b6.js"><link rel="prefetch" href="/mcstructure/assets/js/86.97412bd5.js"><link rel="prefetch" href="/mcstructure/assets/js/87.2244cc28.js"><link rel="prefetch" href="/mcstructure/assets/js/88.f00d5fcc.js"><link rel="prefetch" href="/mcstructure/assets/js/89.13359307.js"><link rel="prefetch" href="/mcstructure/assets/js/9.86a5a003.js"><link rel="prefetch" href="/mcstructure/assets/js/90.3b4668a2.js"><link rel="prefetch" href="/mcstructure/assets/js/92.c7bfeb53.js"><link rel="prefetch" href="/mcstructure/assets/js/93.87278538.js"><link rel="prefetch" href="/mcstructure/assets/js/94.9636adb8.js"><link rel="prefetch" href="/mcstructure/assets/js/95.49a2df5b.js"><link rel="prefetch" href="/mcstructure/assets/js/96.f84087c6.js"><link rel="prefetch" href="/mcstructure/assets/js/97.777e52ef.js"><link rel="prefetch" href="/mcstructure/assets/js/98.95f637bf.js"><link rel="prefetch" href="/mcstructure/assets/js/99.535a1eab.js">
    <link rel="stylesheet" href="/mcstructure/assets/css/0.styles.5de0a167.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/mcstructure/" class="home-link router-link-active"><!----> <span class="site-name">MC TIL</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/mcstructure/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/Redbeanw44602/mcstructure" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/mcstructure/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/Redbeanw44602/mcstructure" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Struct</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/mcstructure/1.16.201/structure/A.html" class="sidebar-link">A</a></li><li><a href="/mcstructure/1.16.201/structure/A~1.html" class="sidebar-link">A~1</a></li><li><a href="/mcstructure/1.16.201/structure/B.html" class="sidebar-link">B</a></li><li><a href="/mcstructure/1.16.201/structure/B~1.html" aria-current="page" class="active sidebar-link">B~1</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/mcstructure/1.16.201/structure/B~2.html" class="sidebar-link">B~2</a></li><li><a href="/mcstructure/1.16.201/structure/C.html" class="sidebar-link">C</a></li><li><a href="/mcstructure/1.16.201/structure/C~1.html" class="sidebar-link">C~1</a></li><li><a href="/mcstructure/1.16.201/structure/C~2.html" class="sidebar-link">C~2</a></li><li><a href="/mcstructure/1.16.201/structure/C~3.html" class="sidebar-link">C~3</a></li><li><a href="/mcstructure/1.16.201/structure/D.html" class="sidebar-link">D</a></li><li><a href="/mcstructure/1.16.201/structure/D~1.html" class="sidebar-link">D~1</a></li><li><a href="/mcstructure/1.16.201/structure/D~2.html" class="sidebar-link">D~2</a></li><li><a href="/mcstructure/1.16.201/structure/D~3.html" class="sidebar-link">D~3</a></li><li><a href="/mcstructure/1.16.201/structure/D~4.html" class="sidebar-link">D~4</a></li><li><a href="/mcstructure/1.16.201/structure/D~5.html" class="sidebar-link">D~5</a></li><li><a href="/mcstructure/1.16.201/structure/D~6.html" class="sidebar-link">D~6</a></li><li><a href="/mcstructure/1.16.201/structure/D~7.html" class="sidebar-link">D~7</a></li><li><a href="/mcstructure/1.16.201/structure/D~8.html" class="sidebar-link">D~8</a></li><li><a href="/mcstructure/1.16.201/structure/D~9.html" class="sidebar-link">D~9</a></li><li><a href="/mcstructure/1.16.201/structure/D~10.html" class="sidebar-link">D~10</a></li><li><a href="/mcstructure/1.16.201/structure/E.html" class="sidebar-link">E</a></li><li><a href="/mcstructure/1.16.201/structure/E~1.html" class="sidebar-link">E~1</a></li><li><a href="/mcstructure/1.16.201/structure/F.html" class="sidebar-link">F</a></li><li><a href="/mcstructure/1.16.201/structure/F~1.html" class="sidebar-link">F~1</a></li><li><a href="/mcstructure/1.16.201/structure/G.html" class="sidebar-link">G</a></li><li><a href="/mcstructure/1.16.201/structure/H.html" class="sidebar-link">H</a></li><li><a href="/mcstructure/1.16.201/structure/I.html" class="sidebar-link">I</a></li><li><a href="/mcstructure/1.16.201/structure/I~1.html" class="sidebar-link">I~1</a></li><li><a href="/mcstructure/1.16.201/structure/I~2.html" class="sidebar-link">I~2</a></li><li><a href="/mcstructure/1.16.201/structure/J.html" class="sidebar-link">J</a></li><li><a href="/mcstructure/1.16.201/structure/K.html" class="sidebar-link">K</a></li><li><a href="/mcstructure/1.16.201/structure/L.html" class="sidebar-link">L</a></li><li><a href="/mcstructure/1.16.201/structure/L~1.html" class="sidebar-link">L~1</a></li><li><a href="/mcstructure/1.16.201/structure/M.html" class="sidebar-link">M</a></li><li><a href="/mcstructure/1.16.201/structure/M~1.html" class="sidebar-link">M~1</a></li><li><a href="/mcstructure/1.16.201/structure/M~2.html" class="sidebar-link">M~2</a></li><li><a href="/mcstructure/1.16.201/structure/M~3.html" class="sidebar-link">M~3</a></li><li><a href="/mcstructure/1.16.201/structure/N.html" class="sidebar-link">N</a></li><li><a href="/mcstructure/1.16.201/structure/O.html" class="sidebar-link">O</a></li><li><a href="/mcstructure/1.16.201/structure/P.html" class="sidebar-link">P</a></li><li><a href="/mcstructure/1.16.201/structure/P~1.html" class="sidebar-link">P~1</a></li><li><a href="/mcstructure/1.16.201/structure/P~2.html" class="sidebar-link">P~2</a></li><li><a href="/mcstructure/1.16.201/structure/P~3.html" class="sidebar-link">P~3</a></li><li><a href="/mcstructure/1.16.201/structure/Q.html" class="sidebar-link">Q</a></li><li><a href="/mcstructure/1.16.201/structure/R.html" class="sidebar-link">R</a></li><li><a href="/mcstructure/1.16.201/structure/R~1.html" class="sidebar-link">R~1</a></li><li><a href="/mcstructure/1.16.201/structure/R~2.html" class="sidebar-link">R~2</a></li><li><a href="/mcstructure/1.16.201/structure/R~3.html" class="sidebar-link">R~3</a></li><li><a href="/mcstructure/1.16.201/structure/S.html" class="sidebar-link">S</a></li><li><a href="/mcstructure/1.16.201/structure/S~1.html" class="sidebar-link">S~1</a></li><li><a href="/mcstructure/1.16.201/structure/S~2.html" class="sidebar-link">S~2</a></li><li><a href="/mcstructure/1.16.201/structure/S~3.html" class="sidebar-link">S~3</a></li><li><a href="/mcstructure/1.16.201/structure/S~4.html" class="sidebar-link">S~4</a></li><li><a href="/mcstructure/1.16.201/structure/T.html" class="sidebar-link">T</a></li><li><a href="/mcstructure/1.16.201/structure/T~1.html" class="sidebar-link">T~1</a></li><li><a href="/mcstructure/1.16.201/structure/U.html" class="sidebar-link">U</a></li><li><a href="/mcstructure/1.16.201/structure/V.html" class="sidebar-link">V</a></li><li><a href="/mcstructure/1.16.201/structure/W.html" class="sidebar-link">W</a></li><li><a href="/mcstructure/1.16.201/structure/W~1.html" class="sidebar-link">W~1</a></li><li><a href="/mcstructure/1.16.201/structure/X.html" class="sidebar-link">X</a></li><li><a href="/mcstructure/1.16.201/structure/Z.html" class="sidebar-link">Z</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Enums</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="b-1"><a href="#b-1" class="header-anchor">#</a> B~1</h1> <h3 id="bedrock-threading-asyncdeferredresultt-bool-vtbl"><a href="#bedrock-threading-asyncdeferredresultt-bool-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::AsyncDeferredResultT&lt;bool&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::AsyncDeferredResultT&lt;bool&gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;bool&gt;)(Bedrock::Threading::IAsyncResult&lt;bool&gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;bool&gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;bool&gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;bool&gt; *this, std::exception_ptr *result);
  bool (__fastcall *getResult)(Bedrock::Threading::IAsyncResult&lt;bool&gt; *this);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;bool&gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;bool&gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;bool&gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="batchworker-packstorage-pendingtask-tryqueueworker-l9-lambda-af25b8745a49294668e7e18ef98137e4"><a href="#batchworker-packstorage-pendingtask-tryqueueworker-l9-lambda-af25b8745a49294668e7e18ef98137e4" class="header-anchor">#</a> <code>BatchWorker&lt;PackStorage::PendingTask&gt;::_tryQueueWorker::__l9::&lt;lambda_af25b8745a49294668e7e18ef98137e4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BatchWorker&lt;PackStorage::PendingTask&gt;::_tryQueueWorker::__l9::&lt;lambda_af25b8745a49294668e7e18ef98137e4&gt;
{
  BatchWorker&lt;PackStorage::PendingTask&gt; *const __this;
};

</code></pre></div><h3 id="bedrock-threading-threadlocalobjectimplementation-molangevalparams-std-allocator-molangevalparams"><a href="#bedrock-threading-threadlocalobjectimplementation-molangevalparams-std-allocator-molangevalparams" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalObjectImplementation&lt;MolangEvalParams,std::allocator&lt;MolangEvalParams&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalObjectImplementation&lt;MolangEvalParams,std::allocator&lt;MolangEvalParams&gt; &gt;
{
  MolangEvalParams *mPtr;
};

</code></pre></div><h3 id="bedrock-threading-threadlocalobject-molangevalparams-std-allocator-molangevalparams"><a href="#bedrock-threading-threadlocalobject-molangevalparams-std-allocator-molangevalparams" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalObject&lt;MolangEvalParams,std::allocator&lt;MolangEvalParams&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalObject&lt;MolangEvalParams,std::allocator&lt;MolangEvalParams&gt; &gt; : Bedrock::Threading::ThreadLocalObjectImplementation&lt;MolangEvalParams,std::allocator&lt;MolangEvalParams&gt; &gt;
{
  std::function&lt;void __cdecl(MolangEvalParams *)&gt; mConstructor;
};

</code></pre></div><h3 id="bedrock-threading-tlsdetail-defaultconstructor-molangevalparams-void"><a href="#bedrock-threading-tlsdetail-defaultconstructor-molangevalparams-void" class="header-anchor">#</a> <code>Bedrock::Threading::TLSDetail::DefaultConstructor&lt;MolangEvalParams,void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::TLSDetail::DefaultConstructor&lt;MolangEvalParams,void&gt;
{
};

</code></pre></div><h3 id="bedrock-threading-tlsdetail-defaultconstructor-molangevalparams-void-create-l2-lambda-958a58132a7af05cc0661d2aecfa4548"><a href="#bedrock-threading-tlsdetail-defaultconstructor-molangevalparams-void-create-l2-lambda-958a58132a7af05cc0661d2aecfa4548" class="header-anchor">#</a> <code>Bedrock::Threading::TLSDetail::DefaultConstructor&lt;MolangEvalParams,void&gt;::create::__l2::&lt;lambda_958a58132a7af05cc0661d2aecfa4548&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::TLSDetail::DefaultConstructor&lt;MolangEvalParams,void&gt;::create::__l2::&lt;lambda_958a58132a7af05cc0661d2aecfa4548&gt;
{
};

</code></pre></div><h3 id="bidirectionalunorderedmap-enum-itemstacknetresult-std-string"><a href="#bidirectionalunorderedmap-enum-itemstacknetresult-std-string" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum ItemStackNetResult,std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BidirectionalUnorderedMap&lt;enum ItemStackNetResult,std::string &gt;
{
  std::unordered_map&lt;enum ItemStackNetResult,std::string&gt; mRight;
  std::unordered_map&lt;std::string,enum ItemStackNetResult&gt; mLeft;
};

</code></pre></div><h3 id="bedrock-threading-threadlocalvalueaccessor-componentitem"><a href="#bedrock-threading-threadlocalvalueaccessor-componentitem" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalValueAccessor&lt;ComponentItem *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalValueAccessor&lt;ComponentItem *&gt;
{
};

</code></pre></div><h3 id="boostablecomponent"><a href="#boostablecomponent" class="header-anchor">#</a> <code>BoostableComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BoostableComponent : IEntityComponent
{
  bool mIsBoosting;
  int mBoostTime;
  int mBoostTimeTotal;
  float mFovMod;
};

</code></pre></div><h3 id="blockitem"><a href="#blockitem" class="header-anchor">#</a> <code>BlockItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockItem : Item
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-4e7611f2c774939b21bda2cfa4f46e40"><a href="#biomecomponentloading-buildschema-l2-lambda-4e7611f2c774939b21bda2cfa4f46e40" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_4e7611f2c774939b21bda2cfa4f46e40&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_4e7611f2c774939b21bda2cfa4f46e40&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-01b284e148679bd63bab12b0717db626"><a href="#biomecomponentloading-buildschema-l2-lambda-01b284e148679bd63bab12b0717db626" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_01b284e148679bd63bab12b0717db626&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_01b284e148679bd63bab12b0717db626&gt;
{
  std::function&lt;CappedSurfaceAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-0f779d43536bc104e122b0d74a889027"><a href="#biomecomponentloading-buildschema-l2-lambda-0f779d43536bc104e122b0d74a889027" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_0f779d43536bc104e122b0d74a889027&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_0f779d43536bc104e122b0d74a889027&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-b059eddd1b406bfce4b57442217ab1b3"><a href="#biomecomponentloading-buildschema-l2-lambda-b059eddd1b406bfce4b57442217ab1b3" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_b059eddd1b406bfce4b57442217ab1b3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_b059eddd1b406bfce4b57442217ab1b3&gt;
{
  std::function&lt;CappedSurfaceAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-a41f431bfd368896c55b381baacd11ba"><a href="#biomecomponentloading-buildschema-l2-lambda-a41f431bfd368896c55b381baacd11ba" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_a41f431bfd368896c55b381baacd11ba&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_a41f431bfd368896c55b381baacd11ba&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-cea596d8301ad7333b74eecd38417d3c"><a href="#biomecomponentloading-buildschema-l2-lambda-cea596d8301ad7333b74eecd38417d3c" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_cea596d8301ad7333b74eecd38417d3c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_cea596d8301ad7333b74eecd38417d3c&gt;
{
  std::function&lt;CappedSurfaceAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-e084b3da421e0a056d83c37c8ebf2c09"><a href="#biomecomponentloading-buildschema-l2-lambda-e084b3da421e0a056d83c37c8ebf2c09" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_e084b3da421e0a056d83c37c8ebf2c09&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_e084b3da421e0a056d83c37c8ebf2c09&gt;
{
  std::function&lt;CappedSurfaceAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-201c44a5279f845d9ef54bb2268fc08b"><a href="#biomecomponentloading-buildschema-l2-lambda-201c44a5279f845d9ef54bb2268fc08b" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_201c44a5279f845d9ef54bb2268fc08b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_201c44a5279f845d9ef54bb2268fc08b&gt;
{
  std::function&lt;CappedSurfaceAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-ae3f9c725f64bdda2a0fe8a5292f5adc"><a href="#biomecomponentloading-buildschema-l2-lambda-ae3f9c725f64bdda2a0fe8a5292f5adc" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_ae3f9c725f64bdda2a0fe8a5292f5adc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_ae3f9c725f64bdda2a0fe8a5292f5adc&gt;
{
};

</code></pre></div><h3 id="blockbreathabilitydescription"><a href="#blockbreathabilitydescription" class="header-anchor">#</a> <code>BlockBreathabilityDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockBreathabilityDescription : BlockComponentDescription
{
  BreathingType mType;
};

</code></pre></div><h3 id="blockbreathabilitydescription-vtbl"><a href="#blockbreathabilitydescription-vtbl" class="header-anchor">#</a> <code>BlockBreathabilityDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockBreathabilityDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockbreathabilitycomponent"><a href="#blockbreathabilitycomponent" class="header-anchor">#</a> <code>BlockBreathabilityComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockBreathabilityComponent
{
  BreathingType mType;
};

</code></pre></div><h3 id="blockbreathabilitydescription-buildschema-l2-lambda-4c61f8557da081b1c8c2a22b9346d104"><a href="#blockbreathabilitydescription-buildschema-l2-lambda-4c61f8557da081b1c8c2a22b9346d104" class="header-anchor">#</a> <code>BlockBreathabilityDescription::buildSchema::__l2::&lt;lambda_4c61f8557da081b1c8c2a22b9346d104&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockBreathabilityDescription::buildSchema::__l2::&lt;lambda_4c61f8557da081b1c8c2a22b9346d104&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockcollisioncomponentdescription"><a href="#blockcollisioncomponentdescription" class="header-anchor">#</a> <code>BlockCollisionComponentDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockCollisionComponentDescription : BlockComponentDescription
{
  bool mEnabled;
  Vec3 mOrigin;
  Vec3 mSize;
};

</code></pre></div><h3 id="blockcollisioncomponentdescription-vtbl"><a href="#blockcollisioncomponentdescription-vtbl" class="header-anchor">#</a> <code>BlockCollisionComponentDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockCollisionComponentDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockraycastcomponentdescription"><a href="#blockraycastcomponentdescription" class="header-anchor">#</a> <code>BlockRaycastComponentDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockRaycastComponentDescription : BlockComponentDescription
{
  bool mEnabled;
  Vec3 mOrigin;
  Vec3 mSize;
};

</code></pre></div><h3 id="blockraycastcomponentdescription-vtbl"><a href="#blockraycastcomponentdescription-vtbl" class="header-anchor">#</a> <code>BlockRaycastComponentDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockRaycastComponentDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockcollisioncomponent"><a href="#blockcollisioncomponent" class="header-anchor">#</a> <code>BlockCollisionComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockCollisionComponent
{
  bool mEnabled;
  bool mWorldInfoBaked;
  AABB mOriginalAABB;
  AABB mTransformedAABB;
};

</code></pre></div><h3 id="blockcollisioncomponentprocessor"><a href="#blockcollisioncomponentprocessor" class="header-anchor">#</a> <code>BlockCollisionComponentProcessor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockCollisionComponentProcessor
{
};

</code></pre></div><h3 id="blockcollisioncomponentprocessor-getprocessor-l2-lambda-d50d369ffbd5602eccd1ecd87abe7ddc"><a href="#blockcollisioncomponentprocessor-getprocessor-l2-lambda-d50d369ffbd5602eccd1ecd87abe7ddc" class="header-anchor">#</a> <code>BlockCollisionComponentProcessor::getProcessor::__l2::&lt;lambda_d50d369ffbd5602eccd1ecd87abe7ddc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockCollisionComponentProcessor::getProcessor::__l2::&lt;lambda_d50d369ffbd5602eccd1ecd87abe7ddc&gt;
{
};

</code></pre></div><h3 id="blockcollisioncomponentdescription-buildschema-l2-lambda-4b812ccf5071d0acd944581760f037ef"><a href="#blockcollisioncomponentdescription-buildschema-l2-lambda-4b812ccf5071d0acd944581760f037ef" class="header-anchor">#</a> <code>BlockCollisionComponentDescription::buildSchema::__l2::&lt;lambda_4b812ccf5071d0acd944581760f037ef&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockCollisionComponentDescription::buildSchema::__l2::&lt;lambda_4b812ccf5071d0acd944581760f037ef&gt;
{
};

</code></pre></div><h3 id="blockcollisioncomponentdescription-buildschema-l2-lambda-6878f6579073ac5e14ce6c03b3c5937f"><a href="#blockcollisioncomponentdescription-buildschema-l2-lambda-6878f6579073ac5e14ce6c03b3c5937f" class="header-anchor">#</a> <code>BlockCollisionComponentDescription::buildSchema::__l2::&lt;lambda_6878f6579073ac5e14ce6c03b3c5937f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockCollisionComponentDescription::buildSchema::__l2::&lt;lambda_6878f6579073ac5e14ce6c03b3c5937f&gt;
{
};

</code></pre></div><h3 id="blockcollisioncomponentdescription-buildschema-l2-lambda-dc89933ad8a520e005190a29280cbde2"><a href="#blockcollisioncomponentdescription-buildschema-l2-lambda-dc89933ad8a520e005190a29280cbde2" class="header-anchor">#</a> <code>BlockCollisionComponentDescription::buildSchema::__l2::&lt;lambda_dc89933ad8a520e005190a29280cbde2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockCollisionComponentDescription::buildSchema::__l2::&lt;lambda_dc89933ad8a520e005190a29280cbde2&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockcollisioncomponentdescription-buildschema-l2-lambda-c14de7537c04cb6c24d0e6d8a11adb99"><a href="#blockcollisioncomponentdescription-buildschema-l2-lambda-c14de7537c04cb6c24d0e6d8a11adb99" class="header-anchor">#</a> <code>BlockCollisionComponentDescription::buildSchema::__l2::&lt;lambda_c14de7537c04cb6c24d0e6d8a11adb99&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockCollisionComponentDescription::buildSchema::__l2::&lt;lambda_c14de7537c04cb6c24d0e6d8a11adb99&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockdestroytimedescription"><a href="#blockdestroytimedescription" class="header-anchor">#</a> <code>BlockDestroyTimeDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockDestroyTimeDescription : BlockComponentDescription
{
  float mDestroyTime;
};

</code></pre></div><h3 id="blockdestroytimedescription-vtbl"><a href="#blockdestroytimedescription-vtbl" class="header-anchor">#</a> <code>BlockDestroyTimeDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockDestroyTimeDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockdestroytimecomponent"><a href="#blockdestroytimecomponent" class="header-anchor">#</a> <code>BlockDestroyTimeComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockDestroyTimeComponent
{
  float mDestroyTime;
};

</code></pre></div><h3 id="blockdestroytimedescription-buildschema-l2-lambda-d1e3a537cd9a75624f45c10c16433a09"><a href="#blockdestroytimedescription-buildschema-l2-lambda-d1e3a537cd9a75624f45c10c16433a09" class="header-anchor">#</a> <code>BlockDestroyTimeDescription::buildSchema::__l2::&lt;lambda_d1e3a537cd9a75624f45c10c16433a09&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockDestroyTimeDescription::buildSchema::__l2::&lt;lambda_d1e3a537cd9a75624f45c10c16433a09&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockdisplaynamedescription"><a href="#blockdisplaynamedescription" class="header-anchor">#</a> <code>BlockDisplayNameDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockDisplayNameDescription : BlockComponentDescription
{
  std::string mDisplayName;
};

</code></pre></div><h3 id="blockdisplaynamedescription-vtbl"><a href="#blockdisplaynamedescription-vtbl" class="header-anchor">#</a> <code>BlockDisplayNameDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockDisplayNameDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockdisplaynamedescription-buildschema-l2-lambda-c46f60d3a9697599df883587d19d6273"><a href="#blockdisplaynamedescription-buildschema-l2-lambda-c46f60d3a9697599df883587d19d6273" class="header-anchor">#</a> <code>BlockDisplayNameDescription::buildSchema::__l2::&lt;lambda_c46f60d3a9697599df883587d19d6273&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockDisplayNameDescription::buildSchema::__l2::&lt;lambda_c46f60d3a9697599df883587d19d6273&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockexplodeabledescription"><a href="#blockexplodeabledescription" class="header-anchor">#</a> <code>BlockExplodeableDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockExplodeableDescription : BlockComponentDescription
{
  float mExplosionResistance;
};

</code></pre></div><h3 id="blockexplodeabledescription-vtbl"><a href="#blockexplodeabledescription-vtbl" class="header-anchor">#</a> <code>BlockExplodeableDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockExplodeableDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockexplodeablecomponent"><a href="#blockexplodeablecomponent" class="header-anchor">#</a> <code>BlockExplodeableComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockExplodeableComponent
{
  float mExplosionResistance;
};

</code></pre></div><h3 id="blockexplodeabledescription-buildschema-l2-lambda-daebb62fbd57786a9760bf50be0a77d9"><a href="#blockexplodeabledescription-buildschema-l2-lambda-daebb62fbd57786a9760bf50be0a77d9" class="header-anchor">#</a> <code>BlockExplodeableDescription::buildSchema::__l2::&lt;lambda_daebb62fbd57786a9760bf50be0a77d9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockExplodeableDescription::buildSchema::__l2::&lt;lambda_daebb62fbd57786a9760bf50be0a77d9&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockflammabledescription"><a href="#blockflammabledescription" class="header-anchor">#</a> <code>BlockFlammableDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockFlammableDescription : BlockComponentDescription
{
  int mFlameOdds;
  int mBurnOdds;
};

</code></pre></div><h3 id="blockflammabledescription-vtbl"><a href="#blockflammabledescription-vtbl" class="header-anchor">#</a> <code>BlockFlammableDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockFlammableDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockflammablecomponent"><a href="#blockflammablecomponent" class="header-anchor">#</a> <code>BlockFlammableComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockFlammableComponent
{
  int mFlameOdds;
  int mBurnOdds;
};

</code></pre></div><h3 id="blockflammabledescription-buildschema-l2-lambda-c59bc263b6294a6e6f39b8d0e04877f0"><a href="#blockflammabledescription-buildschema-l2-lambda-c59bc263b6294a6e6f39b8d0e04877f0" class="header-anchor">#</a> <code>BlockFlammableDescription::buildSchema::__l2::&lt;lambda_c59bc263b6294a6e6f39b8d0e04877f0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockFlammableDescription::buildSchema::__l2::&lt;lambda_c59bc263b6294a6e6f39b8d0e04877f0&gt;
{
};

</code></pre></div><h3 id="blockflammabledescription-buildschema-l2-lambda-a96b44a40c7e60e12ae13262d5bca2e7"><a href="#blockflammabledescription-buildschema-l2-lambda-a96b44a40c7e60e12ae13262d5bca2e7" class="header-anchor">#</a> <code>BlockFlammableDescription::buildSchema::__l2::&lt;lambda_a96b44a40c7e60e12ae13262d5bca2e7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockFlammableDescription::buildSchema::__l2::&lt;lambda_a96b44a40c7e60e12ae13262d5bca2e7&gt;
{
};

</code></pre></div><h3 id="blockflammabledescription-buildschema-l2-lambda-57c47e0013d9103b49b0606920551b9d"><a href="#blockflammabledescription-buildschema-l2-lambda-57c47e0013d9103b49b0606920551b9d" class="header-anchor">#</a> <code>BlockFlammableDescription::buildSchema::__l2::&lt;lambda_57c47e0013d9103b49b0606920551b9d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockFlammableDescription::buildSchema::__l2::&lt;lambda_57c47e0013d9103b49b0606920551b9d&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockfrictiondescription"><a href="#blockfrictiondescription" class="header-anchor">#</a> <code>BlockFrictionDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockFrictionDescription : BlockComponentDescription
{
  float mFriction;
};

</code></pre></div><h3 id="blockfrictiondescription-vtbl"><a href="#blockfrictiondescription-vtbl" class="header-anchor">#</a> <code>BlockFrictionDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockFrictionDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockfrictiondescription-buildschema-l2-lambda-c69e137bc810408b918b6f7d7307713f"><a href="#blockfrictiondescription-buildschema-l2-lambda-c69e137bc810408b918b6f7d7307713f" class="header-anchor">#</a> <code>BlockFrictionDescription::buildSchema::__l2::&lt;lambda_c69e137bc810408b918b6f7d7307713f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockFrictionDescription::buildSchema::__l2::&lt;lambda_c69e137bc810408b918b6f7d7307713f&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockgeometrydescription-buildschema-l2-lambda-ce6722aba34e352d0154f0dda9737a1e"><a href="#blockgeometrydescription-buildschema-l2-lambda-ce6722aba34e352d0154f0dda9737a1e" class="header-anchor">#</a> <code>BlockGeometryDescription::buildSchema::__l2::&lt;lambda_ce6722aba34e352d0154f0dda9737a1e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockGeometryDescription::buildSchema::__l2::&lt;lambda_ce6722aba34e352d0154f0dda9737a1e&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blocklegacycomponent"><a href="#blocklegacycomponent" class="header-anchor">#</a> <code>BlockLegacyComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockLegacyComponent
{
  BlockLegacy *mBlockLegacy;
  bool mAllowSame;
};

</code></pre></div><h3 id="blocklegacycomponentdescription"><a href="#blocklegacycomponentdescription" class="header-anchor">#</a> <code>BlockLegacyComponentDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockLegacyComponentDescription : BlockComponentDescription
{
};

</code></pre></div><h3 id="blocklegacycomponentdescription-vtbl"><a href="#blocklegacycomponentdescription-vtbl" class="header-anchor">#</a> <code>BlockLegacyComponentDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockLegacyComponentDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blocklegacycomponentdescription-buildschema-l2-lambda-27204d2f2a39d85660d61256896bff1b"><a href="#blocklegacycomponentdescription-buildschema-l2-lambda-27204d2f2a39d85660d61256896bff1b" class="header-anchor">#</a> <code>BlockLegacyComponentDescription::buildSchema::__l2::&lt;lambda_27204d2f2a39d85660d61256896bff1b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockLegacyComponentDescription::buildSchema::__l2::&lt;lambda_27204d2f2a39d85660d61256896bff1b&gt;
{
};

</code></pre></div><h3 id="blocklightdescription"><a href="#blocklightdescription" class="header-anchor">#</a> <code>BlockLightDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockLightDescription : BlockComponentDescription
{
  Brightness mLightLevel;
};

</code></pre></div><h3 id="blocklightdescription-vtbl"><a href="#blocklightdescription-vtbl" class="header-anchor">#</a> <code>BlockLightDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockLightDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blocklightcomponent"><a href="#blocklightcomponent" class="header-anchor">#</a> <code>BlockLightComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockLightComponent
{
  Brightness mLightLevel;
};

</code></pre></div><h3 id="blocklightdescription-buildschema-l2-lambda-d71761e05246a34376364883fdb7208e"><a href="#blocklightdescription-buildschema-l2-lambda-d71761e05246a34376364883fdb7208e" class="header-anchor">#</a> <code>BlockLightDescription::buildSchema::__l2::&lt;lambda_d71761e05246a34376364883fdb7208e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockLightDescription::buildSchema::__l2::&lt;lambda_d71761e05246a34376364883fdb7208e&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blocklightemissiondescription"><a href="#blocklightemissiondescription" class="header-anchor">#</a> <code>BlockLightEmissionDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockLightEmissionDescription : BlockComponentDescription
{
  float mLightEmission;
};

</code></pre></div><h3 id="blocklightemissiondescription-vtbl"><a href="#blocklightemissiondescription-vtbl" class="header-anchor">#</a> <code>BlockLightEmissionDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockLightEmissionDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blocklightemissiondescription-buildschema-l2-lambda-1f9e1aeaf46d2eac21fea725a5f02ba0"><a href="#blocklightemissiondescription-buildschema-l2-lambda-1f9e1aeaf46d2eac21fea725a5f02ba0" class="header-anchor">#</a> <code>BlockLightEmissionDescription::buildSchema::__l2::&lt;lambda_1f9e1aeaf46d2eac21fea725a5f02ba0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockLightEmissionDescription::buildSchema::__l2::&lt;lambda_1f9e1aeaf46d2eac21fea725a5f02ba0&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockmapcolordescription"><a href="#blockmapcolordescription" class="header-anchor">#</a> <code>BlockMapColorDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockMapColorDescription : BlockComponentDescription
{
  mce::Color mMapColor;
};

</code></pre></div><h3 id="blockmapcolordescription-vtbl"><a href="#blockmapcolordescription-vtbl" class="header-anchor">#</a> <code>BlockMapColorDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockMapColorDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockmapcolorcomponent"><a href="#blockmapcolorcomponent" class="header-anchor">#</a> <code>BlockMapColorComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockMapColorComponent
{
  mce::Color mMapColor;
};

</code></pre></div><h3 id="blockmapcolordescription-buildschema-l2-lambda-08f7f2a483b2ce2d8ae180541a033fbf"><a href="#blockmapcolordescription-buildschema-l2-lambda-08f7f2a483b2ce2d8ae180541a033fbf" class="header-anchor">#</a> <code>BlockMapColorDescription::buildSchema::__l2::&lt;lambda_08f7f2a483b2ce2d8ae180541a033fbf&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockMapColorDescription::buildSchema::__l2::&lt;lambda_08f7f2a483b2ce2d8ae180541a033fbf&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockmaterialinstancesdescription-buildschema-l2-lambda-ba98cf8c091c5275fe54b54a6fd1fa64"><a href="#blockmaterialinstancesdescription-buildschema-l2-lambda-ba98cf8c091c5275fe54b54a6fd1fa64" class="header-anchor">#</a> <code>BlockMaterialInstancesDescription::buildSchema::__l2::&lt;lambda_ba98cf8c091c5275fe54b54a6fd1fa64&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockMaterialInstancesDescription::buildSchema::__l2::&lt;lambda_ba98cf8c091c5275fe54b54a6fd1fa64&gt;
{
};

</code></pre></div><h3 id="blockmaterialinstancesdescription-buildschema-l2-lambda-06f55dbee568ee03701593fa00d64316"><a href="#blockmaterialinstancesdescription-buildschema-l2-lambda-06f55dbee568ee03701593fa00d64316" class="header-anchor">#</a> <code>BlockMaterialInstancesDescription::buildSchema::__l2::&lt;lambda_06f55dbee568ee03701593fa00d64316&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockMaterialInstancesDescription::buildSchema::__l2::&lt;lambda_06f55dbee568ee03701593fa00d64316&gt;
{
};

</code></pre></div><h3 id="blockmaterialinstancesdescription-buildschema-l2-lambda-573d2fb4ea2eda602f92a6079ece291a"><a href="#blockmaterialinstancesdescription-buildschema-l2-lambda-573d2fb4ea2eda602f92a6079ece291a" class="header-anchor">#</a> <code>BlockMaterialInstancesDescription::buildSchema::__l2::&lt;lambda_573d2fb4ea2eda602f92a6079ece291a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockMaterialInstancesDescription::buildSchema::__l2::&lt;lambda_573d2fb4ea2eda602f92a6079ece291a&gt;
{
};

</code></pre></div><h3 id="blockmaterialinstancesdescription-buildschema-l2-lambda-12efd0823a81885ff5970a7012bb91e8"><a href="#blockmaterialinstancesdescription-buildschema-l2-lambda-12efd0823a81885ff5970a7012bb91e8" class="header-anchor">#</a> <code>BlockMaterialInstancesDescription::buildSchema::__l2::&lt;lambda_12efd0823a81885ff5970a7012bb91e8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockMaterialInstancesDescription::buildSchema::__l2::&lt;lambda_12efd0823a81885ff5970a7012bb91e8&gt;
{
};

</code></pre></div><h3 id="blockmaterialinstancesdescription-buildschema-l2-lambda-db0e7cbf50b78f865c00e20c1e7ca2f2"><a href="#blockmaterialinstancesdescription-buildschema-l2-lambda-db0e7cbf50b78f865c00e20c1e7ca2f2" class="header-anchor">#</a> <code>BlockMaterialInstancesDescription::buildSchema::__l2::&lt;lambda_db0e7cbf50b78f865c00e20c1e7ca2f2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockMaterialInstancesDescription::buildSchema::__l2::&lt;lambda_db0e7cbf50b78f865c00e20c1e7ca2f2&gt;
{
};

</code></pre></div><h3 id="blockmaterialinstancesdescription-buildschema-l2-lambda-44ff594e168fc93ea3851ee9be5d388a"><a href="#blockmaterialinstancesdescription-buildschema-l2-lambda-44ff594e168fc93ea3851ee9be5d388a" class="header-anchor">#</a> <code>BlockMaterialInstancesDescription::buildSchema::__l2::&lt;lambda_44ff594e168fc93ea3851ee9be5d388a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockMaterialInstancesDescription::buildSchema::__l2::&lt;lambda_44ff594e168fc93ea3851ee9be5d388a&gt;
{
};

</code></pre></div><h3 id="blockmaterialinstancesdescription-buildschema-l2-lambda-89c1e1e1679be2065bf56004cfe846be"><a href="#blockmaterialinstancesdescription-buildschema-l2-lambda-89c1e1e1679be2065bf56004cfe846be" class="header-anchor">#</a> <code>BlockMaterialInstancesDescription::buildSchema::__l2::&lt;lambda_89c1e1e1679be2065bf56004cfe846be&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockMaterialInstancesDescription::buildSchema::__l2::&lt;lambda_89c1e1e1679be2065bf56004cfe846be&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockplacementfilterdescription"><a href="#blockplacementfilterdescription" class="header-anchor">#</a> <code>BlockPlacementFilterDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockPlacementFilterDescription : BlockComponentDescription
{
  std::vector&lt;BlockPlacementCondition&gt; conditions;
};

</code></pre></div><h3 id="blockplacementfilterdescription-vtbl"><a href="#blockplacementfilterdescription-vtbl" class="header-anchor">#</a> <code>BlockPlacementFilterDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockPlacementFilterDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockplacementfilterdescription-buildschema-l4-lambda-e8ce4e56bf378dc7388d7d765e0865c1"><a href="#blockplacementfilterdescription-buildschema-l4-lambda-e8ce4e56bf378dc7388d7d765e0865c1" class="header-anchor">#</a> <code>BlockPlacementFilterDescription::buildSchema::__l4::&lt;lambda_e8ce4e56bf378dc7388d7d765e0865c1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockPlacementFilterDescription::buildSchema::__l4::&lt;lambda_e8ce4e56bf378dc7388d7d765e0865c1&gt;
{
};

</code></pre></div><h3 id="blockplacementfilterdescription-buildschema-l3-lambda-9da8bab70b5a357e6f6558be61f31a37"><a href="#blockplacementfilterdescription-buildschema-l3-lambda-9da8bab70b5a357e6f6558be61f31a37" class="header-anchor">#</a> <code>BlockPlacementFilterDescription::buildSchema::__l3::&lt;lambda_9da8bab70b5a357e6f6558be61f31a37&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockPlacementFilterDescription::buildSchema::__l3::&lt;lambda_9da8bab70b5a357e6f6558be61f31a37&gt;
{
};

</code></pre></div><h3 id="blockplacementfilterdescription-buildschema-l3-lambda-3929d7bdc0012c1d5b5d07211a568962"><a href="#blockplacementfilterdescription-buildschema-l3-lambda-3929d7bdc0012c1d5b5d07211a568962" class="header-anchor">#</a> <code>BlockPlacementFilterDescription::buildSchema::__l3::&lt;lambda_3929d7bdc0012c1d5b5d07211a568962&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockPlacementFilterDescription::buildSchema::__l3::&lt;lambda_3929d7bdc0012c1d5b5d07211a568962&gt;
{
};

</code></pre></div><h3 id="blockplacementfilterdescription-buildschema-l3-lambda-48a2c92454dca1b1eb86708c0cb6f245"><a href="#blockplacementfilterdescription-buildschema-l3-lambda-48a2c92454dca1b1eb86708c0cb6f245" class="header-anchor">#</a> <code>BlockPlacementFilterDescription::buildSchema::__l3::&lt;lambda_48a2c92454dca1b1eb86708c0cb6f245&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockPlacementFilterDescription::buildSchema::__l3::&lt;lambda_48a2c92454dca1b1eb86708c0cb6f245&gt;
{
};

</code></pre></div><h3 id="blockplacementfilterdescription-buildschema-l2-lambda-cb0824acb19a6926bc16ae918b367222"><a href="#blockplacementfilterdescription-buildschema-l2-lambda-cb0824acb19a6926bc16ae918b367222" class="header-anchor">#</a> <code>BlockPlacementFilterDescription::buildSchema::__l2::&lt;lambda_cb0824acb19a6926bc16ae918b367222&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockPlacementFilterDescription::buildSchema::__l2::&lt;lambda_cb0824acb19a6926bc16ae918b367222&gt;
{
};

</code></pre></div><h3 id="blockunwalkabledescription"><a href="#blockunwalkabledescription" class="header-anchor">#</a> <code>BlockUnwalkableDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockUnwalkableDescription : BlockComponentDescription
{
  bool value;
};

</code></pre></div><h3 id="blockunwalkabledescription-vtbl"><a href="#blockunwalkabledescription-vtbl" class="header-anchor">#</a> <code>BlockUnwalkableDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockUnwalkableDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockpreventsjumpingdescription"><a href="#blockpreventsjumpingdescription" class="header-anchor">#</a> <code>BlockPreventsJumpingDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockPreventsJumpingDescription : BlockComponentDescription
{
  bool value;
};

</code></pre></div><h3 id="blockpreventsjumpingdescription-vtbl"><a href="#blockpreventsjumpingdescription-vtbl" class="header-anchor">#</a> <code>BlockPreventsJumpingDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockPreventsJumpingDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockimmovabledescription"><a href="#blockimmovabledescription" class="header-anchor">#</a> <code>BlockImmovableDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockImmovableDescription : BlockComponentDescription
{
  bool value;
};

</code></pre></div><h3 id="blockimmovabledescription-vtbl"><a href="#blockimmovabledescription-vtbl" class="header-anchor">#</a> <code>BlockImmovableDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockImmovableDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockbreakonpushdescription"><a href="#blockbreakonpushdescription" class="header-anchor">#</a> <code>BlockBreakOnPushDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockBreakOnPushDescription : BlockComponentDescription
{
  bool value;
};

</code></pre></div><h3 id="blockbreakonpushdescription-vtbl"><a href="#blockbreakonpushdescription-vtbl" class="header-anchor">#</a> <code>BlockBreakOnPushDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockBreakOnPushDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockonlypistonpushdescription"><a href="#blockonlypistonpushdescription" class="header-anchor">#</a> <code>BlockOnlyPistonPushDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockOnlyPistonPushDescription : BlockComponentDescription
{
  bool value;
};

</code></pre></div><h3 id="blockonlypistonpushdescription-vtbl"><a href="#blockonlypistonpushdescription-vtbl" class="header-anchor">#</a> <code>BlockOnlyPistonPushDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockOnlyPistonPushDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockbreakswhenhitbyarrowdescription"><a href="#blockbreakswhenhitbyarrowdescription" class="header-anchor">#</a> <code>BlockBreaksWhenHitByArrowDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockBreaksWhenHitByArrowDescription : BlockComponentDescription
{
  bool value;
};

</code></pre></div><h3 id="blockbreakswhenhitbyarrowdescription-vtbl"><a href="#blockbreakswhenhitbyarrowdescription-vtbl" class="header-anchor">#</a> <code>BlockBreaksWhenHitByArrowDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockBreaksWhenHitByArrowDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockpropertycomponent"><a href="#blockpropertycomponent" class="header-anchor">#</a> <code>BlockPropertyComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockPropertyComponent
{
  std::unordered_map&lt;enum BlockProperty,bool&gt; propertyMap;
};

</code></pre></div><h3 id="blockonlypistonpushdescription-buildschema-l2-lambda-c945b5662cf1eb5589293648d6eec793"><a href="#blockonlypistonpushdescription-buildschema-l2-lambda-c945b5662cf1eb5589293648d6eec793" class="header-anchor">#</a> <code>BlockOnlyPistonPushDescription::buildSchema::__l2::&lt;lambda_c945b5662cf1eb5589293648d6eec793&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockOnlyPistonPushDescription::buildSchema::__l2::&lt;lambda_c945b5662cf1eb5589293648d6eec793&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockbreakonpushdescription-buildschema-l2-lambda-85b29853f478a656648e5c7bba71cddf"><a href="#blockbreakonpushdescription-buildschema-l2-lambda-85b29853f478a656648e5c7bba71cddf" class="header-anchor">#</a> <code>BlockBreakOnPushDescription::buildSchema::__l2::&lt;lambda_85b29853f478a656648e5c7bba71cddf&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockBreakOnPushDescription::buildSchema::__l2::&lt;lambda_85b29853f478a656648e5c7bba71cddf&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockimmovabledescription-buildschema-l2-lambda-e8efcee476cac9f07672d89dca1ff150"><a href="#blockimmovabledescription-buildschema-l2-lambda-e8efcee476cac9f07672d89dca1ff150" class="header-anchor">#</a> <code>BlockImmovableDescription::buildSchema::__l2::&lt;lambda_e8efcee476cac9f07672d89dca1ff150&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockImmovableDescription::buildSchema::__l2::&lt;lambda_e8efcee476cac9f07672d89dca1ff150&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockpreventsjumpingdescription-buildschema-l2-lambda-9542622d127f343463dd4c8650a62bd0"><a href="#blockpreventsjumpingdescription-buildschema-l2-lambda-9542622d127f343463dd4c8650a62bd0" class="header-anchor">#</a> <code>BlockPreventsJumpingDescription::buildSchema::__l2::&lt;lambda_9542622d127f343463dd4c8650a62bd0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockPreventsJumpingDescription::buildSchema::__l2::&lt;lambda_9542622d127f343463dd4c8650a62bd0&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockunwalkabledescription-buildschema-l2-lambda-1a4657843158ef697741cd4b4af2d5c3"><a href="#blockunwalkabledescription-buildschema-l2-lambda-1a4657843158ef697741cd4b4af2d5c3" class="header-anchor">#</a> <code>BlockUnwalkableDescription::buildSchema::__l2::&lt;lambda_1a4657843158ef697741cd4b4af2d5c3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockUnwalkableDescription::buildSchema::__l2::&lt;lambda_1a4657843158ef697741cd4b4af2d5c3&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockqueuedtickingdescription"><a href="#blockqueuedtickingdescription" class="header-anchor">#</a> <code>BlockQueuedTickingDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockQueuedTickingDescription : BlockComponentDescription
{
  float mDelayRange[2];
  bool mLooping;
  DefinitionTrigger mOnTimeDown;
};

</code></pre></div><h3 id="blockqueuedtickingdescription-vtbl"><a href="#blockqueuedtickingdescription-vtbl" class="header-anchor">#</a> <code>BlockQueuedTickingDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockQueuedTickingDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockqueuedtickingdescription-buildschema-l2-lambda-cf213ad65c48f5af5c1a97b78c1e03cc"><a href="#blockqueuedtickingdescription-buildschema-l2-lambda-cf213ad65c48f5af5c1a97b78c1e03cc" class="header-anchor">#</a> <code>BlockQueuedTickingDescription::buildSchema::__l2::&lt;lambda_cf213ad65c48f5af5c1a97b78c1e03cc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockQueuedTickingDescription::buildSchema::__l2::&lt;lambda_cf213ad65c48f5af5c1a97b78c1e03cc&gt;
{
};

</code></pre></div><h3 id="blockqueuedtickingdescription-buildschema-l2-lambda-626e42b5f549b74b2c47ecc5065668f8"><a href="#blockqueuedtickingdescription-buildschema-l2-lambda-626e42b5f549b74b2c47ecc5065668f8" class="header-anchor">#</a> <code>BlockQueuedTickingDescription::buildSchema::__l2::&lt;lambda_626e42b5f549b74b2c47ecc5065668f8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockQueuedTickingDescription::buildSchema::__l2::&lt;lambda_626e42b5f549b74b2c47ecc5065668f8&gt;
{
};

</code></pre></div><h3 id="blockqueuedtickingdescription-buildschema-l2-lambda-3dcdcc4801ba6f06b5bd699cf19f4ae9"><a href="#blockqueuedtickingdescription-buildschema-l2-lambda-3dcdcc4801ba6f06b5bd699cf19f4ae9" class="header-anchor">#</a> <code>BlockQueuedTickingDescription::buildSchema::__l2::&lt;lambda_3dcdcc4801ba6f06b5bd699cf19f4ae9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockQueuedTickingDescription::buildSchema::__l2::&lt;lambda_3dcdcc4801ba6f06b5bd699cf19f4ae9&gt;
{
};

</code></pre></div><h3 id="blockqueuedtickingdescription-buildschema-l2-lambda-d7521e35ca8cc680c738d8c91bd339a3"><a href="#blockqueuedtickingdescription-buildschema-l2-lambda-d7521e35ca8cc680c738d8c91bd339a3" class="header-anchor">#</a> <code>BlockQueuedTickingDescription::buildSchema::__l2::&lt;lambda_d7521e35ca8cc680c738d8c91bd339a3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockQueuedTickingDescription::buildSchema::__l2::&lt;lambda_d7521e35ca8cc680c738d8c91bd339a3&gt;
{
};

</code></pre></div><h3 id="blockqueuedtickingdescription-buildschema-l2-lambda-9dd896149b2b0e048d3f4e74066c6d79"><a href="#blockqueuedtickingdescription-buildschema-l2-lambda-9dd896149b2b0e048d3f4e74066c6d79" class="header-anchor">#</a> <code>BlockQueuedTickingDescription::buildSchema::__l2::&lt;lambda_9dd896149b2b0e048d3f4e74066c6d79&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockQueuedTickingDescription::buildSchema::__l2::&lt;lambda_9dd896149b2b0e048d3f4e74066c6d79&gt;
{
};

</code></pre></div><h3 id="blockqueuedtickingdescription-buildschema-l2-lambda-aa9609fada4ce700b2792b8814cdcabf"><a href="#blockqueuedtickingdescription-buildschema-l2-lambda-aa9609fada4ce700b2792b8814cdcabf" class="header-anchor">#</a> <code>BlockQueuedTickingDescription::buildSchema::__l2::&lt;lambda_aa9609fada4ce700b2792b8814cdcabf&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockQueuedTickingDescription::buildSchema::__l2::&lt;lambda_aa9609fada4ce700b2792b8814cdcabf&gt;
{
};

</code></pre></div><h3 id="blockqueuedtickingdescription-buildschema-l2-lambda-b620b3e3f93259a2e6ac65f0433095c0"><a href="#blockqueuedtickingdescription-buildschema-l2-lambda-b620b3e3f93259a2e6ac65f0433095c0" class="header-anchor">#</a> <code>BlockQueuedTickingDescription::buildSchema::__l2::&lt;lambda_b620b3e3f93259a2e6ac65f0433095c0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockQueuedTickingDescription::buildSchema::__l2::&lt;lambda_b620b3e3f93259a2e6ac65f0433095c0&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockrandomtickingdescription"><a href="#blockrandomtickingdescription" class="header-anchor">#</a> <code>BlockRandomTickingDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockRandomTickingDescription : BlockComponentDescription
{
  DefinitionTrigger mOnTimeDown;
};

</code></pre></div><h3 id="blockrandomtickingdescription-vtbl"><a href="#blockrandomtickingdescription-vtbl" class="header-anchor">#</a> <code>BlockRandomTickingDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockRandomTickingDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockrandomtickingcomponent"><a href="#blockrandomtickingcomponent" class="header-anchor">#</a> <code>BlockRandomTickingComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockRandomTickingComponent
{
  DefinitionTrigger mOnTimeDown;
};

</code></pre></div><h3 id="blockrandomtickingdescription-buildschema-l2-lambda-07d8c21d2a1191c5ff5c50620c1730e3"><a href="#blockrandomtickingdescription-buildschema-l2-lambda-07d8c21d2a1191c5ff5c50620c1730e3" class="header-anchor">#</a> <code>BlockRandomTickingDescription::buildSchema::__l2::&lt;lambda_07d8c21d2a1191c5ff5c50620c1730e3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockRandomTickingDescription::buildSchema::__l2::&lt;lambda_07d8c21d2a1191c5ff5c50620c1730e3&gt;
{
};

</code></pre></div><h3 id="blockrandomtickingdescription-buildschema-l2-lambda-1321e859aa1dd025510131cc9e8e6225"><a href="#blockrandomtickingdescription-buildschema-l2-lambda-1321e859aa1dd025510131cc9e8e6225" class="header-anchor">#</a> <code>BlockRandomTickingDescription::buildSchema::__l2::&lt;lambda_1321e859aa1dd025510131cc9e8e6225&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockRandomTickingDescription::buildSchema::__l2::&lt;lambda_1321e859aa1dd025510131cc9e8e6225&gt;
{
};

</code></pre></div><h3 id="blockrandomtickingdescription-buildschema-l2-lambda-9c30243026aaa59f1df4244d1fee3202"><a href="#blockrandomtickingdescription-buildschema-l2-lambda-9c30243026aaa59f1df4244d1fee3202" class="header-anchor">#</a> <code>BlockRandomTickingDescription::buildSchema::__l2::&lt;lambda_9c30243026aaa59f1df4244d1fee3202&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockRandomTickingDescription::buildSchema::__l2::&lt;lambda_9c30243026aaa59f1df4244d1fee3202&gt;
{
};

</code></pre></div><h3 id="blockrandomtickingdescription-buildschema-l2-lambda-c59ae86f72fe7374104f30d451d32d65"><a href="#blockrandomtickingdescription-buildschema-l2-lambda-c59ae86f72fe7374104f30d451d32d65" class="header-anchor">#</a> <code>BlockRandomTickingDescription::buildSchema::__l2::&lt;lambda_c59ae86f72fe7374104f30d451d32d65&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockRandomTickingDescription::buildSchema::__l2::&lt;lambda_c59ae86f72fe7374104f30d451d32d65&gt;
{
};

</code></pre></div><h3 id="blockrandomtickingdescription-buildschema-l2-lambda-eb0063f1e7722fc1fd674532441eac14"><a href="#blockrandomtickingdescription-buildschema-l2-lambda-eb0063f1e7722fc1fd674532441eac14" class="header-anchor">#</a> <code>BlockRandomTickingDescription::buildSchema::__l2::&lt;lambda_eb0063f1e7722fc1fd674532441eac14&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockRandomTickingDescription::buildSchema::__l2::&lt;lambda_eb0063f1e7722fc1fd674532441eac14&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockraycastcomponentprocessor"><a href="#blockraycastcomponentprocessor" class="header-anchor">#</a> <code>BlockRaycastComponentProcessor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockRaycastComponentProcessor
{
};

</code></pre></div><h3 id="blockraycastcomponentprocessor-getprocessor-l2-lambda-10b292fb3bf93b28c6ce9e7cd4e94995"><a href="#blockraycastcomponentprocessor-getprocessor-l2-lambda-10b292fb3bf93b28c6ce9e7cd4e94995" class="header-anchor">#</a> <code>BlockRaycastComponentProcessor::getProcessor::__l2::&lt;lambda_10b292fb3bf93b28c6ce9e7cd4e94995&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockRaycastComponentProcessor::getProcessor::__l2::&lt;lambda_10b292fb3bf93b28c6ce9e7cd4e94995&gt;
{
};

</code></pre></div><h3 id="blockraycastcomponentdescription-buildschema-l2-lambda-fb014cf2776a7d8c0e9f3bbce0361b6c"><a href="#blockraycastcomponentdescription-buildschema-l2-lambda-fb014cf2776a7d8c0e9f3bbce0361b6c" class="header-anchor">#</a> <code>BlockRaycastComponentDescription::buildSchema::__l2::&lt;lambda_fb014cf2776a7d8c0e9f3bbce0361b6c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockRaycastComponentDescription::buildSchema::__l2::&lt;lambda_fb014cf2776a7d8c0e9f3bbce0361b6c&gt;
{
};

</code></pre></div><h3 id="blockraycastcomponentdescription-buildschema-l2-lambda-589fb79a6d3e2959a4a37044011844b6"><a href="#blockraycastcomponentdescription-buildschema-l2-lambda-589fb79a6d3e2959a4a37044011844b6" class="header-anchor">#</a> <code>BlockRaycastComponentDescription::buildSchema::__l2::&lt;lambda_589fb79a6d3e2959a4a37044011844b6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockRaycastComponentDescription::buildSchema::__l2::&lt;lambda_589fb79a6d3e2959a4a37044011844b6&gt;
{
};

</code></pre></div><h3 id="blockraycastcomponentdescription-buildschema-l2-lambda-8bf5a874efbe02d284420606108a25cb"><a href="#blockraycastcomponentdescription-buildschema-l2-lambda-8bf5a874efbe02d284420606108a25cb" class="header-anchor">#</a> <code>BlockRaycastComponentDescription::buildSchema::__l2::&lt;lambda_8bf5a874efbe02d284420606108a25cb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockRaycastComponentDescription::buildSchema::__l2::&lt;lambda_8bf5a874efbe02d284420606108a25cb&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockraycastcomponentdescription-buildschema-l2-lambda-5dc9edb90a48ac3aff1ad1a548af9b94"><a href="#blockraycastcomponentdescription-buildschema-l2-lambda-5dc9edb90a48ac3aff1ad1a548af9b94" class="header-anchor">#</a> <code>BlockRaycastComponentDescription::buildSchema::__l2::&lt;lambda_5dc9edb90a48ac3aff1ad1a548af9b94&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockRaycastComponentDescription::buildSchema::__l2::&lt;lambda_5dc9edb90a48ac3aff1ad1a548af9b94&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockrotationdescription-buildschema-l2-lambda-ad48c97325fe1028e35444e9e43fe6d8"><a href="#blockrotationdescription-buildschema-l2-lambda-ad48c97325fe1028e35444e9e43fe6d8" class="header-anchor">#</a> <code>BlockRotationDescription::buildSchema::__l2::&lt;lambda_ad48c97325fe1028e35444e9e43fe6d8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockRotationDescription::buildSchema::__l2::&lt;lambda_ad48c97325fe1028e35444e9e43fe6d8&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blockunitcubedescription-buildschema-l2-lambda-19fd5eb0a190a0558be6cf70036e4f47"><a href="#blockunitcubedescription-buildschema-l2-lambda-19fd5eb0a190a0558be6cf70036e4f47" class="header-anchor">#</a> <code>BlockUnitCubeDescription::buildSchema::__l2::&lt;lambda_19fd5eb0a190a0558be6cf70036e4f47&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockUnitCubeDescription::buildSchema::__l2::&lt;lambda_19fd5eb0a190a0558be6cf70036e4f47&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blocktriggerdescription-onfallontrigger"><a href="#blocktriggerdescription-onfallontrigger" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnFallOnTrigger&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockTriggerDescription&lt;OnFallOnTrigger&gt; : BlockComponentDescription
{
  std::string mType;
  std::string mCondition;
  _BYTE mTarget[2];
};

</code></pre></div><h3 id="blocktriggerdescription-onfallontrigger-vtbl"><a href="#blocktriggerdescription-onfallontrigger-vtbl" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnFallOnTrigger&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockTriggerDescription&lt;OnFallOnTrigger&gt;_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blocktriggerdescription-onfallontrigger-buildschema-l2-lambda-ef8916e3db97f444a0c05fc5425db430"><a href="#blocktriggerdescription-onfallontrigger-buildschema-l2-lambda-ef8916e3db97f444a0c05fc5425db430" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnFallOnTrigger&gt;::buildSchema::__l2::&lt;lambda_ef8916e3db97f444a0c05fc5425db430&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnFallOnTrigger&gt;::buildSchema::__l2::&lt;lambda_ef8916e3db97f444a0c05fc5425db430&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-onfallontrigger-buildschema-l2-lambda-000f4e5a520a10ac3ebaba19bf2a65e9"><a href="#blocktriggerdescription-onfallontrigger-buildschema-l2-lambda-000f4e5a520a10ac3ebaba19bf2a65e9" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnFallOnTrigger&gt;::buildSchema::__l2::&lt;lambda_000f4e5a520a10ac3ebaba19bf2a65e9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnFallOnTrigger&gt;::buildSchema::__l2::&lt;lambda_000f4e5a520a10ac3ebaba19bf2a65e9&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-onfallontrigger-buildschema-l2-lambda-fdb5fee4d3e733bbfc3db9c35163d2af"><a href="#blocktriggerdescription-onfallontrigger-buildschema-l2-lambda-fdb5fee4d3e733bbfc3db9c35163d2af" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnFallOnTrigger&gt;::buildSchema::__l2::&lt;lambda_fdb5fee4d3e733bbfc3db9c35163d2af&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnFallOnTrigger&gt;::buildSchema::__l2::&lt;lambda_fdb5fee4d3e733bbfc3db9c35163d2af&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-onfallontrigger-buildschema-l2-lambda-dc70758361f9d984c7cf95f24c605334"><a href="#blocktriggerdescription-onfallontrigger-buildschema-l2-lambda-dc70758361f9d984c7cf95f24c605334" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnFallOnTrigger&gt;::buildSchema::__l2::&lt;lambda_dc70758361f9d984c7cf95f24c605334&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnFallOnTrigger&gt;::buildSchema::__l2::&lt;lambda_dc70758361f9d984c7cf95f24c605334&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blocktriggerdescription-oninteracttrigger"><a href="#blocktriggerdescription-oninteracttrigger" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnInteractTrigger&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockTriggerDescription&lt;OnInteractTrigger&gt; : BlockComponentDescription
{
  std::string mType;
  std::string mCondition;
  _BYTE mTarget[2];
};

</code></pre></div><h3 id="blocktriggerdescription-oninteracttrigger-vtbl"><a href="#blocktriggerdescription-oninteracttrigger-vtbl" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnInteractTrigger&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockTriggerDescription&lt;OnInteractTrigger&gt;_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blocktriggerdescription-oninteracttrigger-buildschema-l2-lambda-a33df2b205b85b239e63f61267080c4a"><a href="#blocktriggerdescription-oninteracttrigger-buildschema-l2-lambda-a33df2b205b85b239e63f61267080c4a" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnInteractTrigger&gt;::buildSchema::__l2::&lt;lambda_a33df2b205b85b239e63f61267080c4a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnInteractTrigger&gt;::buildSchema::__l2::&lt;lambda_a33df2b205b85b239e63f61267080c4a&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-oninteracttrigger-buildschema-l2-lambda-076c3050c0e5f5733483d25f92b40f6a"><a href="#blocktriggerdescription-oninteracttrigger-buildschema-l2-lambda-076c3050c0e5f5733483d25f92b40f6a" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnInteractTrigger&gt;::buildSchema::__l2::&lt;lambda_076c3050c0e5f5733483d25f92b40f6a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnInteractTrigger&gt;::buildSchema::__l2::&lt;lambda_076c3050c0e5f5733483d25f92b40f6a&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-oninteracttrigger-buildschema-l2-lambda-9ced8916369862ecd1f019fbfcf13823"><a href="#blocktriggerdescription-oninteracttrigger-buildschema-l2-lambda-9ced8916369862ecd1f019fbfcf13823" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnInteractTrigger&gt;::buildSchema::__l2::&lt;lambda_9ced8916369862ecd1f019fbfcf13823&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnInteractTrigger&gt;::buildSchema::__l2::&lt;lambda_9ced8916369862ecd1f019fbfcf13823&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-oninteracttrigger-buildschema-l2-lambda-d814003a632a6cbdb9671d6311392b8f"><a href="#blocktriggerdescription-oninteracttrigger-buildschema-l2-lambda-d814003a632a6cbdb9671d6311392b8f" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnInteractTrigger&gt;::buildSchema::__l2::&lt;lambda_d814003a632a6cbdb9671d6311392b8f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnInteractTrigger&gt;::buildSchema::__l2::&lt;lambda_d814003a632a6cbdb9671d6311392b8f&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blocktriggerdescription-onplacedtrigger"><a href="#blocktriggerdescription-onplacedtrigger" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnPlacedTrigger&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockTriggerDescription&lt;OnPlacedTrigger&gt; : BlockComponentDescription
{
  std::string mType;
  std::string mCondition;
  _BYTE mTarget[2];
};

</code></pre></div><h3 id="blocktriggerdescription-onplacedtrigger-vtbl"><a href="#blocktriggerdescription-onplacedtrigger-vtbl" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnPlacedTrigger&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockTriggerDescription&lt;OnPlacedTrigger&gt;_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blocktriggerdescription-onplacedtrigger-buildschema-l2-lambda-e8215986e7b31d8dd963ccb19f24bc1c"><a href="#blocktriggerdescription-onplacedtrigger-buildschema-l2-lambda-e8215986e7b31d8dd963ccb19f24bc1c" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnPlacedTrigger&gt;::buildSchema::__l2::&lt;lambda_e8215986e7b31d8dd963ccb19f24bc1c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnPlacedTrigger&gt;::buildSchema::__l2::&lt;lambda_e8215986e7b31d8dd963ccb19f24bc1c&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-onplacedtrigger-buildschema-l2-lambda-f48aa65c4d65cdf0f0fa0766d3dcb3ad"><a href="#blocktriggerdescription-onplacedtrigger-buildschema-l2-lambda-f48aa65c4d65cdf0f0fa0766d3dcb3ad" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnPlacedTrigger&gt;::buildSchema::__l2::&lt;lambda_f48aa65c4d65cdf0f0fa0766d3dcb3ad&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnPlacedTrigger&gt;::buildSchema::__l2::&lt;lambda_f48aa65c4d65cdf0f0fa0766d3dcb3ad&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-onplacedtrigger-buildschema-l2-lambda-4a014553b7ffe83cbe45da2192597e7b"><a href="#blocktriggerdescription-onplacedtrigger-buildschema-l2-lambda-4a014553b7ffe83cbe45da2192597e7b" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnPlacedTrigger&gt;::buildSchema::__l2::&lt;lambda_4a014553b7ffe83cbe45da2192597e7b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnPlacedTrigger&gt;::buildSchema::__l2::&lt;lambda_4a014553b7ffe83cbe45da2192597e7b&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-onplacedtrigger-buildschema-l2-lambda-47afbc0fcbee03dec64a6d7f55c9abb0"><a href="#blocktriggerdescription-onplacedtrigger-buildschema-l2-lambda-47afbc0fcbee03dec64a6d7f55c9abb0" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnPlacedTrigger&gt;::buildSchema::__l2::&lt;lambda_47afbc0fcbee03dec64a6d7f55c9abb0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnPlacedTrigger&gt;::buildSchema::__l2::&lt;lambda_47afbc0fcbee03dec64a6d7f55c9abb0&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blocktriggerdescription-onplayerdestroyedtrigger"><a href="#blocktriggerdescription-onplayerdestroyedtrigger" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnPlayerDestroyedTrigger&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockTriggerDescription&lt;OnPlayerDestroyedTrigger&gt; : BlockComponentDescription
{
  std::string mType;
  std::string mCondition;
  _BYTE mTarget[2];
};

</code></pre></div><h3 id="blocktriggerdescription-onplayerdestroyedtrigger-vtbl"><a href="#blocktriggerdescription-onplayerdestroyedtrigger-vtbl" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnPlayerDestroyedTrigger&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockTriggerDescription&lt;OnPlayerDestroyedTrigger&gt;_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blocktriggerdescription-onplayerdestroyedtrigger-buildschema-l2-lambda-435ed67ca33cdf6ce3551e627dde545b"><a href="#blocktriggerdescription-onplayerdestroyedtrigger-buildschema-l2-lambda-435ed67ca33cdf6ce3551e627dde545b" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnPlayerDestroyedTrigger&gt;::buildSchema::__l2::&lt;lambda_435ed67ca33cdf6ce3551e627dde545b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnPlayerDestroyedTrigger&gt;::buildSchema::__l2::&lt;lambda_435ed67ca33cdf6ce3551e627dde545b&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-onplayerdestroyedtrigger-buildschema-l2-lambda-e78fbccb97a8276bca1647984fa77f23"><a href="#blocktriggerdescription-onplayerdestroyedtrigger-buildschema-l2-lambda-e78fbccb97a8276bca1647984fa77f23" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnPlayerDestroyedTrigger&gt;::buildSchema::__l2::&lt;lambda_e78fbccb97a8276bca1647984fa77f23&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnPlayerDestroyedTrigger&gt;::buildSchema::__l2::&lt;lambda_e78fbccb97a8276bca1647984fa77f23&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-onplayerdestroyedtrigger-buildschema-l2-lambda-1e4e182aec1b3e1d24d6fba3cdf70c50"><a href="#blocktriggerdescription-onplayerdestroyedtrigger-buildschema-l2-lambda-1e4e182aec1b3e1d24d6fba3cdf70c50" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnPlayerDestroyedTrigger&gt;::buildSchema::__l2::&lt;lambda_1e4e182aec1b3e1d24d6fba3cdf70c50&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnPlayerDestroyedTrigger&gt;::buildSchema::__l2::&lt;lambda_1e4e182aec1b3e1d24d6fba3cdf70c50&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-onplayerdestroyedtrigger-buildschema-l2-lambda-4b99d462895d28d49e43325b4a39a5dd"><a href="#blocktriggerdescription-onplayerdestroyedtrigger-buildschema-l2-lambda-4b99d462895d28d49e43325b4a39a5dd" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnPlayerDestroyedTrigger&gt;::buildSchema::__l2::&lt;lambda_4b99d462895d28d49e43325b4a39a5dd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnPlayerDestroyedTrigger&gt;::buildSchema::__l2::&lt;lambda_4b99d462895d28d49e43325b4a39a5dd&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blocktriggerdescription-onplayerplacingtrigger"><a href="#blocktriggerdescription-onplayerplacingtrigger" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnPlayerPlacingTrigger&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockTriggerDescription&lt;OnPlayerPlacingTrigger&gt; : BlockComponentDescription
{
  std::string mType;
  std::string mCondition;
  _BYTE mTarget[2];
};

</code></pre></div><h3 id="blocktriggerdescription-onplayerplacingtrigger-vtbl"><a href="#blocktriggerdescription-onplayerplacingtrigger-vtbl" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnPlayerPlacingTrigger&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockTriggerDescription&lt;OnPlayerPlacingTrigger&gt;_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blocktriggerdescription-onplayerplacingtrigger-buildschema-l2-lambda-027de81471dbda20b20e86eedbf98df7"><a href="#blocktriggerdescription-onplayerplacingtrigger-buildschema-l2-lambda-027de81471dbda20b20e86eedbf98df7" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnPlayerPlacingTrigger&gt;::buildSchema::__l2::&lt;lambda_027de81471dbda20b20e86eedbf98df7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnPlayerPlacingTrigger&gt;::buildSchema::__l2::&lt;lambda_027de81471dbda20b20e86eedbf98df7&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-onplayerplacingtrigger-buildschema-l2-lambda-f0f38f51c88a5b42b90f6d3fc2ad3143"><a href="#blocktriggerdescription-onplayerplacingtrigger-buildschema-l2-lambda-f0f38f51c88a5b42b90f6d3fc2ad3143" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnPlayerPlacingTrigger&gt;::buildSchema::__l2::&lt;lambda_f0f38f51c88a5b42b90f6d3fc2ad3143&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnPlayerPlacingTrigger&gt;::buildSchema::__l2::&lt;lambda_f0f38f51c88a5b42b90f6d3fc2ad3143&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-onplayerplacingtrigger-buildschema-l2-lambda-ebe4b9d77c2a0e21773e7548a78153ea"><a href="#blocktriggerdescription-onplayerplacingtrigger-buildschema-l2-lambda-ebe4b9d77c2a0e21773e7548a78153ea" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnPlayerPlacingTrigger&gt;::buildSchema::__l2::&lt;lambda_ebe4b9d77c2a0e21773e7548a78153ea&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnPlayerPlacingTrigger&gt;::buildSchema::__l2::&lt;lambda_ebe4b9d77c2a0e21773e7548a78153ea&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-onplayerplacingtrigger-buildschema-l2-lambda-833337504ddb4f2a526e6da5743fc5c8"><a href="#blocktriggerdescription-onplayerplacingtrigger-buildschema-l2-lambda-833337504ddb4f2a526e6da5743fc5c8" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnPlayerPlacingTrigger&gt;::buildSchema::__l2::&lt;lambda_833337504ddb4f2a526e6da5743fc5c8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnPlayerPlacingTrigger&gt;::buildSchema::__l2::&lt;lambda_833337504ddb4f2a526e6da5743fc5c8&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blocktriggerdescription-onstepontrigger"><a href="#blocktriggerdescription-onstepontrigger" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnStepOnTrigger&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockTriggerDescription&lt;OnStepOnTrigger&gt; : BlockComponentDescription
{
  std::string mType;
  std::string mCondition;
  _BYTE mTarget[2];
};

</code></pre></div><h3 id="blocktriggerdescription-onstepontrigger-vtbl"><a href="#blocktriggerdescription-onstepontrigger-vtbl" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnStepOnTrigger&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockTriggerDescription&lt;OnStepOnTrigger&gt;_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blocktriggerdescription-onstepofftrigger"><a href="#blocktriggerdescription-onstepofftrigger" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnStepOffTrigger&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockTriggerDescription&lt;OnStepOffTrigger&gt; : BlockComponentDescription
{
  std::string mType;
  std::string mCondition;
  _BYTE mTarget[2];
};

</code></pre></div><h3 id="blocktriggerdescription-onstepofftrigger-vtbl"><a href="#blocktriggerdescription-onstepofftrigger-vtbl" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnStepOffTrigger&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockTriggerDescription&lt;OnStepOffTrigger&gt;_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blocktriggerdescription-onstepontrigger-buildschema-l2-lambda-838ec938e898e7fb3a589c9f550675b7"><a href="#blocktriggerdescription-onstepontrigger-buildschema-l2-lambda-838ec938e898e7fb3a589c9f550675b7" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnStepOnTrigger&gt;::buildSchema::__l2::&lt;lambda_838ec938e898e7fb3a589c9f550675b7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnStepOnTrigger&gt;::buildSchema::__l2::&lt;lambda_838ec938e898e7fb3a589c9f550675b7&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-onstepontrigger-buildschema-l2-lambda-8b344d19ff57fad5d3756f55b27cd212"><a href="#blocktriggerdescription-onstepontrigger-buildschema-l2-lambda-8b344d19ff57fad5d3756f55b27cd212" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnStepOnTrigger&gt;::buildSchema::__l2::&lt;lambda_8b344d19ff57fad5d3756f55b27cd212&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnStepOnTrigger&gt;::buildSchema::__l2::&lt;lambda_8b344d19ff57fad5d3756f55b27cd212&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-onstepontrigger-buildschema-l2-lambda-25314afb71d3d21539214ab6b84d06e6"><a href="#blocktriggerdescription-onstepontrigger-buildschema-l2-lambda-25314afb71d3d21539214ab6b84d06e6" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnStepOnTrigger&gt;::buildSchema::__l2::&lt;lambda_25314afb71d3d21539214ab6b84d06e6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnStepOnTrigger&gt;::buildSchema::__l2::&lt;lambda_25314afb71d3d21539214ab6b84d06e6&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-onstepontrigger-buildschema-l2-lambda-b50379f0dbf3bd5c47b0a110b58ddceb"><a href="#blocktriggerdescription-onstepontrigger-buildschema-l2-lambda-b50379f0dbf3bd5c47b0a110b58ddceb" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnStepOnTrigger&gt;::buildSchema::__l2::&lt;lambda_b50379f0dbf3bd5c47b0a110b58ddceb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnStepOnTrigger&gt;::buildSchema::__l2::&lt;lambda_b50379f0dbf3bd5c47b0a110b58ddceb&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="blocktriggerdescription-onstepofftrigger-buildschema-l2-lambda-e2c75ed82a16fa8196b889610cdebfc3"><a href="#blocktriggerdescription-onstepofftrigger-buildschema-l2-lambda-e2c75ed82a16fa8196b889610cdebfc3" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnStepOffTrigger&gt;::buildSchema::__l2::&lt;lambda_e2c75ed82a16fa8196b889610cdebfc3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnStepOffTrigger&gt;::buildSchema::__l2::&lt;lambda_e2c75ed82a16fa8196b889610cdebfc3&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-onstepofftrigger-buildschema-l2-lambda-751a230ba8aa7b7ae9f90fb86eaecaa4"><a href="#blocktriggerdescription-onstepofftrigger-buildschema-l2-lambda-751a230ba8aa7b7ae9f90fb86eaecaa4" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnStepOffTrigger&gt;::buildSchema::__l2::&lt;lambda_751a230ba8aa7b7ae9f90fb86eaecaa4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnStepOffTrigger&gt;::buildSchema::__l2::&lt;lambda_751a230ba8aa7b7ae9f90fb86eaecaa4&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-onstepofftrigger-buildschema-l2-lambda-e702ff7c6ebe41cd2656da0166ab18d5"><a href="#blocktriggerdescription-onstepofftrigger-buildschema-l2-lambda-e702ff7c6ebe41cd2656da0166ab18d5" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnStepOffTrigger&gt;::buildSchema::__l2::&lt;lambda_e702ff7c6ebe41cd2656da0166ab18d5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnStepOffTrigger&gt;::buildSchema::__l2::&lt;lambda_e702ff7c6ebe41cd2656da0166ab18d5&gt;
{
};

</code></pre></div><h3 id="blocktriggerdescription-onstepofftrigger-buildschema-l2-lambda-ba303f0246cd6fbc9f8024e4d67a8b23"><a href="#blocktriggerdescription-onstepofftrigger-buildschema-l2-lambda-ba303f0246cd6fbc9f8024e4d67a8b23" class="header-anchor">#</a> <code>BlockTriggerDescription&lt;OnStepOffTrigger&gt;::buildSchema::__l2::&lt;lambda_ba303f0246cd6fbc9f8024e4d67a8b23&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTriggerDescription&lt;OnStepOffTrigger&gt;::buildSchema::__l2::&lt;lambda_ba303f0246cd6fbc9f8024e4d67a8b23&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="bedrock-nonownerpointer-dimension"><a href="#bedrock-nonownerpointer-dimension" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;Dimension&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;Dimension&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="blockselector-vtbl"><a href="#blockselector-vtbl" class="header-anchor">#</a> <code>BlockSelector_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockSelector_vtbl
{
  void (__fastcall *~BlockSelector)(BlockSelector *this);
  const Block *(__fastcall *next)(BlockSelector *this, Random *, int, int, int, bool);
};

</code></pre></div><h3 id="bastionpiece"><a href="#bastionpiece" class="header-anchor">#</a> <code>BastionPiece</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BastionPiece : PoolElementStructurePiece
{
};

</code></pre></div><h3 id="bastionpiece-addpieces-l16-lambda-c6c2cc063f3e8775940af7b1bdaadfd2"><a href="#bastionpiece-addpieces-l16-lambda-c6c2cc063f3e8775940af7b1bdaadfd2" class="header-anchor">#</a> <code>BastionPiece::addPieces::__l16::&lt;lambda_c6c2cc063f3e8775940af7b1bdaadfd2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BastionPiece::addPieces::__l16::&lt;lambda_c6c2cc063f3e8775940af7b1bdaadfd2&gt;
{
};

</code></pre></div><h3 id="bidirectionalunorderedmap-enum-particletype-std-string"><a href="#bidirectionalunorderedmap-enum-particletype-std-string" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum ParticleType,std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BidirectionalUnorderedMap&lt;enum ParticleType,std::string &gt;
{
  std::unordered_map&lt;enum ParticleType,std::string&gt; mRight;
  std::unordered_map&lt;std::string,enum ParticleType&gt; mLeft;
};

</code></pre></div><h3 id="bedrock-platformbootstrap"><a href="#bedrock-platformbootstrap" class="header-anchor">#</a> <code>Bedrock::PlatformBootstrap</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::PlatformBootstrap
{
  Bedrock::PlatformBootstrap_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-platformbootstrap-vtbl"><a href="#bedrock-platformbootstrap-vtbl" class="header-anchor">#</a> <code>Bedrock::PlatformBootstrap_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::PlatformBootstrap_vtbl
{
  void (__fastcall *~PlatformBootstrap)(Bedrock::PlatformBootstrap *this);
  void (__fastcall *initialize)(Bedrock::PlatformBootstrap *this);
  const char *(__fastcall *getDataRoot)(Bedrock::PlatformBootstrap *this, unsigned __int64 *);
  unsigned __int64 (__fastcall *rawLoadAssetFile)(Bedrock::PlatformBootstrap *this, char *, unsigned __int64, const char *, char *, unsigned __int64);
};

</code></pre></div><h3 id="balloonabledefinition"><a href="#balloonabledefinition" class="header-anchor">#</a> <code>BalloonableDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BalloonableDefinition
{
  float mSoftDistance;
  float mMaxDistance;
  float mInvMass;
  DefinitionTrigger mOnBalloon;
  DefinitionTrigger mOnUnballoon;
};

</code></pre></div><h3 id="balloonablecomponent"><a href="#balloonablecomponent" class="header-anchor">#</a> <code>BalloonableComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BalloonableComponent : IEntityComponent
{
};

</code></pre></div><h3 id="ballooncomponent"><a href="#ballooncomponent" class="header-anchor">#</a> <code>BalloonComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) BalloonComponent : IEntityComponent
{
  ActorUniqueID mAttachedID;
  float mMaxHeight;
  bool mShouldDropAttached;
};

</code></pre></div><h3 id="balloondefinition"><a href="#balloondefinition" class="header-anchor">#</a> <code>BalloonDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BalloonDefinition
{
  Vec3 mLiftForce;
};

</code></pre></div><h3 id="behaviordata-data-void"><a href="#behaviordata-data-void" class="header-anchor">#</a> <code>BehaviorData::Data&lt;void *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BehaviorData::Data&lt;void *&gt; : BehaviorData::DataProxy
{
  void *mData;
};

</code></pre></div><h3 id="behaviordata-data-void-vtbl"><a href="#behaviordata-data-void-vtbl" class="header-anchor">#</a> <code>BehaviorData::Data&lt;void *&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BehaviorData::Data&lt;void *&gt;_vtbl
{
  void (__fastcall *~DataProxy)(BehaviorData::DataProxy *this);
  std::unique_ptr&lt;BehaviorData::DataProxy&gt; *(__fastcall *copy)(BehaviorData::DataProxy *this, std::unique_ptr&lt;BehaviorData::DataProxy&gt; *result);
};

</code></pre></div><h3 id="blocklisteventmap"><a href="#blocklisteventmap" class="header-anchor">#</a> <code>BlockListEventMap</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockListEventMap
{
  std::vector&lt;BlockDescriptor&gt; mBlockDescriptors;
  std::string mEventName;
};

</code></pre></div><h3 id="blockbreaksensordefinition"><a href="#blockbreaksensordefinition" class="header-anchor">#</a> <code>BlockBreakSensorDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockBreakSensorDefinition
{
  float mSensorRadius;
  std::vector&lt;BlockListEventMap&gt; mBlockSets;
};

</code></pre></div><h3 id="boostitem"><a href="#boostitem" class="header-anchor">#</a> <code>BoostItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BoostItem
{
  ItemDescriptor mItemDescriptor;
  ItemDescriptor mReplacementItemDescriptor;
  int mDamageAmount;
};

</code></pre></div><h3 id="boostabledefinition"><a href="#boostabledefinition" class="header-anchor">#</a> <code>BoostableDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BoostableDefinition
{
  std::vector&lt;BoostItem&gt; mBoostItems;
  float mMaxBoostTime;
  float mSpeedModifier;
  float mFovMod;
};

</code></pre></div><h3 id="bossdefinition"><a href="#bossdefinition" class="header-anchor">#</a> <code>BossDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BossDefinition
{
  std::string mName;
  bool mShouldDarkenSky;
  int mHudRange;
};

</code></pre></div><h3 id="breakblockscomponent"><a href="#breakblockscomponent" class="header-anchor">#</a> <code>BreakBlocksComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BreakBlocksComponent : IEntityComponent
{
};

</code></pre></div><h3 id="breakdoorannotationcomponent"><a href="#breakdoorannotationcomponent" class="header-anchor">#</a> <code>BreakDoorAnnotationComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BreakDoorAnnotationComponent : IEntityComponent
{
  int mBreakTicks;
  Difficulty mMinDifficulty;
  ActorUniqueID mTargetID;
  int mBreakingTime;
  std::optional&lt;BlockPos&gt; mObstructionPos;
  unsigned __int64 mLastPathIndex;
};

</code></pre></div><h3 id="breathabledefinition"><a href="#breathabledefinition" class="header-anchor">#</a> <code>BreathableDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BreathableDefinition
{
  int mTotalSupply;
  int mSuffocateTime;
  float mInhaleTime;
  bool mBreathesAir;
  bool mBreathesWater;
  bool mBreathesLava;
  bool mBreathesSolids;
  bool mGeneratesBubbles;
  std::vector&lt;BlockDescriptor&gt; mBreathableBlocks;
  std::vector&lt;BlockDescriptor&gt; mNonBreathableBlocks;
};

</code></pre></div><h3 id="breedabledefinition"><a href="#breedabledefinition" class="header-anchor">#</a> <code>BreedableDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BreedableDefinition
{
  bool mTame;
  bool mBlendAttributes;
  float mExtraChance;
  float mBreedCooldownTimeSeconds;
  bool mInheritTamed;
  bool mAllowSitting;
  std::vector&lt;ItemDescriptor&gt; mBreedItems;
  std::vector&lt;EnvironmentRequirement&gt; mEnvironmentRequirements;
  ActorFilterGroup mLoveFilter;
  std::vector&lt;BreedableType&gt; mBreedTypes;
  MutationFactorData mMutationFactors;
  DenySameParentsVariantData mDenyParentsVariant;
  bool mCausesPregnancy;
  bool mRequireFullHealth;
  int mMinNumberChildren;
  int mMaxNumberChildren;
};

</code></pre></div><h3 id="breedablecomponent"><a href="#breedablecomponent" class="header-anchor">#</a> <code>BreedableComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BreedableComponent : IEntityComponent
{
  const BreedableDefinition *mStaticData;
  int mLoveTimer;
  int mBreedCooldown;
  int mBreedCooldownTime;
  bool mInheritTamed;
  bool mCausesPregnancy;
  ActorUniqueID mLoveCause;
};

</code></pre></div><h3 id="bribeabledefinition"><a href="#bribeabledefinition" class="header-anchor">#</a> <code>BribeableDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BribeableDefinition
{
  float mBribeCooldown;
  std::vector&lt;ItemDescriptor&gt; mBribeItems;
};

</code></pre></div><h3 id="bribeablecomponent"><a href="#bribeablecomponent" class="header-anchor">#</a> <code>BribeableComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BribeableComponent : IEntityComponent
{
  const BribeableDefinition *mStaticData;
  int mBribeTimer;
  int mBribeCooldown;
  int mBribeCooldownTime;
};

</code></pre></div><h3 id="bucketablecomponent"><a href="#bucketablecomponent" class="header-anchor">#</a> <code>BucketableComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BucketableComponent : IEntityComponent
{
};

</code></pre></div><h3 id="burnsindaylightdefinition"><a href="#burnsindaylightdefinition" class="header-anchor">#</a> <code>BurnsInDaylightDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BurnsInDaylightDefinition
{
};

</code></pre></div><h3 id="bucketablecomponent-getinteraction-l5-lambda-8e84a487e038ec80f3efce51137fd1cb"><a href="#bucketablecomponent-getinteraction-l5-lambda-8e84a487e038ec80f3efce51137fd1cb" class="header-anchor">#</a> <code>BucketableComponent::getInteraction::__l5::&lt;lambda_8e84a487e038ec80f3efce51137fd1cb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BucketableComponent::getInteraction::__l5::&lt;lambda_8e84a487e038ec80f3efce51137fd1cb&gt;
{
  Actor *owner;
  Player *player;
};

</code></pre></div><h3 id="bribeablecomponent-getinteraction-l14-lambda-1e8d22cdb9df4c9a9c784cbb7b6ea1eb"><a href="#bribeablecomponent-getinteraction-l14-lambda-1e8d22cdb9df4c9a9c784cbb7b6ea1eb" class="header-anchor">#</a> <code>BribeableComponent::getInteraction::__l14::&lt;lambda_1e8d22cdb9df4c9a9c784cbb7b6ea1eb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BribeableComponent::getInteraction::__l14::&lt;lambda_1e8d22cdb9df4c9a9c784cbb7b6ea1eb&gt;
{
  Actor *owner;
  Player *player;
  BribeableComponent *const __this;
};

</code></pre></div><h3 id="bribeabledefinition-buildschema-l2-lambda-3ea2844f8ccdbf4ca2d8554f79132ad2"><a href="#bribeabledefinition-buildschema-l2-lambda-3ea2844f8ccdbf4ca2d8554f79132ad2" class="header-anchor">#</a> <code>BribeableDefinition::buildSchema::__l2::&lt;lambda_3ea2844f8ccdbf4ca2d8554f79132ad2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BribeableDefinition::buildSchema::__l2::&lt;lambda_3ea2844f8ccdbf4ca2d8554f79132ad2&gt;
{
};

</code></pre></div><h3 id="breedablecomponent-getinteraction-l23-lambda-0ca09d6f42b0b2725246a39b155b6d02"><a href="#breedablecomponent-getinteraction-l23-lambda-0ca09d6f42b0b2725246a39b155b6d02" class="header-anchor">#</a> <code>BreedableComponent::getInteraction::__l23::&lt;lambda_0ca09d6f42b0b2725246a39b155b6d02&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BreedableComponent::getInteraction::__l23::&lt;lambda_0ca09d6f42b0b2725246a39b155b6d02&gt;
{
  Player *player;
  Actor *owner;
  BreedableComponent *const __this;
};

</code></pre></div><h3 id="breedabledefinition-buildschema-l2-lambda-687cb70991334864e2f4d9922259ea88"><a href="#breedabledefinition-buildschema-l2-lambda-687cb70991334864e2f4d9922259ea88" class="header-anchor">#</a> <code>BreedableDefinition::buildSchema::__l2::&lt;lambda_687cb70991334864e2f4d9922259ea88&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BreedableDefinition::buildSchema::__l2::&lt;lambda_687cb70991334864e2f4d9922259ea88&gt;
{
};

</code></pre></div><h3 id="breedabledefinition-buildschema-l2-lambda-3b992a0d9419e48052bc453e3b7aa62c"><a href="#breedabledefinition-buildschema-l2-lambda-3b992a0d9419e48052bc453e3b7aa62c" class="header-anchor">#</a> <code>BreedableDefinition::buildSchema::__l2::&lt;lambda_3b992a0d9419e48052bc453e3b7aa62c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BreedableDefinition::buildSchema::__l2::&lt;lambda_3b992a0d9419e48052bc453e3b7aa62c&gt;
{
};

</code></pre></div><h3 id="breakdoorannotationcomponent-obstructioncheck-l65-lambda-29299142ebba9cf19320f4a54667acc9"><a href="#breakdoorannotationcomponent-obstructioncheck-l65-lambda-29299142ebba9cf19320f4a54667acc9" class="header-anchor">#</a> <code>BreakDoorAnnotationComponent::obstructionCheck::__l65::&lt;lambda_29299142ebba9cf19320f4a54667acc9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BreakDoorAnnotationComponent::obstructionCheck::__l65::&lt;lambda_29299142ebba9cf19320f4a54667acc9&gt;
{
  Mob *mob;
  const Block *block;
  const BlockPos *nodePos;
};

</code></pre></div><h3 id="breakblockscomponent-breaknearbyblocks-l29-lambda-99cbf2916026c93342b5e87247c4b1b8"><a href="#breakblockscomponent-breaknearbyblocks-l29-lambda-99cbf2916026c93342b5e87247c4b1b8" class="header-anchor">#</a> <code>BreakBlocksComponent::breakNearbyBlocks::__l29::&lt;lambda_99cbf2916026c93342b5e87247c4b1b8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BreakBlocksComponent::breakNearbyBlocks::__l29::&lt;lambda_99cbf2916026c93342b5e87247c4b1b8&gt;
{
  Actor *actor;
  const Block *breakBlock;
  const int *x;
  const int *y;
  const int *z;
  BlockSource *region;
};

</code></pre></div><h3 id="blockbreaksensorcomponent-initialize-l2-lambda-1b6de276689ee3844025b88c9022f8f6"><a href="#blockbreaksensorcomponent-initialize-l2-lambda-1b6de276689ee3844025b88c9022f8f6" class="header-anchor">#</a> <code>BlockBreakSensorComponent::initialize::__l2::&lt;lambda_1b6de276689ee3844025b88c9022f8f6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockBreakSensorComponent::initialize::__l2::&lt;lambda_1b6de276689ee3844025b88c9022f8f6&gt;
{
  Actor *actor;
};

</code></pre></div><h3 id="balloonablecomponent-getinteraction-l16-lambda-4eb329858ee62965ee9c218f5145de0f"><a href="#balloonablecomponent-getinteraction-l16-lambda-4eb329858ee62965ee9c218f5145de0f" class="header-anchor">#</a> <code>BalloonableComponent::getInteraction::__l16::&lt;lambda_4eb329858ee62965ee9c218f5145de0f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BalloonableComponent::getInteraction::__l16::&lt;lambda_4eb329858ee62965ee9c218f5145de0f&gt;
{
  Player *player;
  Actor *owner;
  BalloonableComponent *const __this;
};

</code></pre></div><h3 id="balloonablecomponent-getinteraction-l8-lambda-88cf98eb28c9260dfe790cfd08438e9d"><a href="#balloonablecomponent-getinteraction-l8-lambda-88cf98eb28c9260dfe790cfd08438e9d" class="header-anchor">#</a> <code>BalloonableComponent::getInteraction::__l8::&lt;lambda_88cf98eb28c9260dfe790cfd08438e9d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BalloonableComponent::getInteraction::__l8::&lt;lambda_88cf98eb28c9260dfe790cfd08438e9d&gt;
{
  Actor *owner;
  BalloonableComponent *const __this;
  Actor *balloon;
};

</code></pre></div><h3 id="balloonabledefinition-buildschema-l2-lambda-0d60382c8be5f5bc0dca2a0f426db4a1"><a href="#balloonabledefinition-buildschema-l2-lambda-0d60382c8be5f5bc0dca2a0f426db4a1" class="header-anchor">#</a> <code>BalloonableDefinition::buildSchema::__l2::&lt;lambda_0d60382c8be5f5bc0dca2a0f426db4a1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BalloonableDefinition::buildSchema::__l2::&lt;lambda_0d60382c8be5f5bc0dca2a0f426db4a1&gt;
{
};

</code></pre></div><h3 id="balloonabledefinition-buildschema-l2-lambda-e55aca88682b256223a20f461ea159b2"><a href="#balloonabledefinition-buildschema-l2-lambda-e55aca88682b256223a20f461ea159b2" class="header-anchor">#</a> <code>BalloonableDefinition::buildSchema::__l2::&lt;lambda_e55aca88682b256223a20f461ea159b2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BalloonableDefinition::buildSchema::__l2::&lt;lambda_e55aca88682b256223a20f461ea159b2&gt;
{
};

</code></pre></div><h3 id="baserailblock"><a href="#baserailblock" class="header-anchor">#</a> <code>BaseRailBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BaseRailBlock : BlockLegacy
{
  const bool mUsesDataBit;
};

</code></pre></div><h3 id="baserailblock-vtbl"><a href="#baserailblock-vtbl" class="header-anchor">#</a> <code>BaseRailBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BaseRailBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="buildschemaspawnactorparameters-l2-lambda-f4d58fb7fa9c4857247880a11bbd432f"><a href="#buildschemaspawnactorparameters-l2-lambda-f4d58fb7fa9c4857247880a11bbd432f" class="header-anchor">#</a> <code>buildSchemaSpawnActorParameters::__l2::&lt;lambda_f4d58fb7fa9c4857247880a11bbd432f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buildSchemaSpawnActorParameters::__l2::&lt;lambda_f4d58fb7fa9c4857247880a11bbd432f&gt;
{
};

</code></pre></div><h3 id="buildschemaspawnactorparameters-l2-lambda-5f64cd3a4c891918e62801dca2a65523"><a href="#buildschemaspawnactorparameters-l2-lambda-5f64cd3a4c891918e62801dca2a65523" class="header-anchor">#</a> <code>buildSchemaSpawnActorParameters::__l2::&lt;lambda_5f64cd3a4c891918e62801dca2a65523&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buildSchemaSpawnActorParameters::__l2::&lt;lambda_5f64cd3a4c891918e62801dca2a65523&gt;
{
};

</code></pre></div><h3 id="behaviorsystem"><a href="#behaviorsystem" class="header-anchor">#</a> <code>BehaviorSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BehaviorSystem : ITickingSystem
{
};

</code></pre></div><h3 id="behaviorsystem-vtbl"><a href="#behaviorsystem-vtbl" class="header-anchor">#</a> <code>BehaviorSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BehaviorSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="blockbreaksensorsystem"><a href="#blockbreaksensorsystem" class="header-anchor">#</a> <code>BlockBreakSensorSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockBreakSensorSystem : ITickingSystem
{
};

</code></pre></div><h3 id="blockbreaksensorsystem-vtbl"><a href="#blockbreaksensorsystem-vtbl" class="header-anchor">#</a> <code>BlockBreakSensorSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockBreakSensorSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="bodycontrolcomponent"><a href="#bodycontrolcomponent" class="header-anchor">#</a> <code>BodyControlComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BodyControlComponent : IEntityComponent
{
  std::unique_ptr&lt;BodyControl&gt; mBodyControl;
};

</code></pre></div><h3 id="bodycontrolsystem"><a href="#bodycontrolsystem" class="header-anchor">#</a> <code>BodyControlSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BodyControlSystem : ITickingSystem
{
};

</code></pre></div><h3 id="bodycontrolsystem-vtbl"><a href="#bodycontrolsystem-vtbl" class="header-anchor">#</a> <code>BodyControlSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BodyControlSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="boostablesystem"><a href="#boostablesystem" class="header-anchor">#</a> <code>BoostableSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BoostableSystem : ITickingSystem
{
};

</code></pre></div><h3 id="boostablesystem-vtbl"><a href="#boostablesystem-vtbl" class="header-anchor">#</a> <code>BoostableSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BoostableSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="breakblockssystem"><a href="#breakblockssystem" class="header-anchor">#</a> <code>BreakBlocksSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BreakBlocksSystem : ITickingSystem
{
};

</code></pre></div><h3 id="breakblockssystem-vtbl"><a href="#breakblockssystem-vtbl" class="header-anchor">#</a> <code>BreakBlocksSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BreakBlocksSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="breakdoorannotationsystem"><a href="#breakdoorannotationsystem" class="header-anchor">#</a> <code>BreakDoorAnnotationSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BreakDoorAnnotationSystem : ITickingSystem
{
};

</code></pre></div><h3 id="breakdoorannotationsystem-vtbl"><a href="#breakdoorannotationsystem-vtbl" class="header-anchor">#</a> <code>BreakDoorAnnotationSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BreakDoorAnnotationSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="breathablesystem"><a href="#breathablesystem" class="header-anchor">#</a> <code>BreathableSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BreathableSystem : ITickingSystem
{
};

</code></pre></div><h3 id="breathablesystem-vtbl"><a href="#breathablesystem-vtbl" class="header-anchor">#</a> <code>BreathableSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BreathableSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="bedrock-threading-threadutil"><a href="#bedrock-threading-threadutil" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadUtil</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadUtil
{
};

</code></pre></div><h3 id="batchednetworkpeer-startsendtask-l2-lambda-bd091a0e94bce2f3d40cd13870786e14"><a href="#batchednetworkpeer-startsendtask-l2-lambda-bd091a0e94bce2f3d40cd13870786e14" class="header-anchor">#</a> <code>BatchedNetworkPeer::_startSendTask::__l2::&lt;lambda_bd091a0e94bce2f3d40cd13870786e14&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BatchedNetworkPeer::_startSendTask::__l2::&lt;lambda_bd091a0e94bce2f3d40cd13870786e14&gt;
{
  std::shared_ptr&lt;std::vector&lt;std::function&lt;void __cdecl(void)&gt;&gt; &gt; sharedCallbackList;
};

</code></pre></div><h3 id="batchednetworkpeer-startsendtask-l2-lambda-f57f9e03a6e9b4ead48e0fa8aaeaf5db"><a href="#batchednetworkpeer-startsendtask-l2-lambda-f57f9e03a6e9b4ead48e0fa8aaeaf5db" class="header-anchor">#</a> <code>BatchedNetworkPeer::_startSendTask::__l2::&lt;lambda_f57f9e03a6e9b4ead48e0fa8aaeaf5db&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BatchedNetworkPeer::_startSendTask::__l2::&lt;lambda_f57f9e03a6e9b4ead48e0fa8aaeaf5db&gt;
{
  BatchedNetworkPeer *const __this;
  std::shared_ptr&lt;std::vector&lt;std::function&lt;void __cdecl(void)&gt;&gt; &gt; sharedCallbackList;
};

</code></pre></div><h3 id="bookcloningrecipe"><a href="#bookcloningrecipe" class="header-anchor">#</a> <code>BookCloningRecipe</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookCloningRecipe : MultiRecipe
{
  std::vector&lt;ItemInstance&gt; mResults;
};

</code></pre></div><h3 id="bookcloningrecipe-vtbl"><a href="#bookcloningrecipe-vtbl" class="header-anchor">#</a> <code>BookCloningRecipe_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BookCloningRecipe_vtbl
{
  void (__fastcall *~Recipe)(Recipe *this);
  const std::vector&lt;ItemInstance&gt; *(__fastcall *assemble)(Recipe *this, CraftingContainer *);
  int (__fastcall *getCraftingSize)(Recipe *this);
  const RecipeIngredient *(__fastcall *getIngredient)(Recipe *this, int, int);
  const std::vector&lt;ItemInstance&gt; *(__fastcall *getResultItem)(Recipe *this);
  bool (__fastcall *isShapeless)(Recipe *this);
  bool (__fastcall *matches)(Recipe *this, CraftingContainer *, Level *);
  int (__fastcall *size)(Recipe *this);
  const mce::UUID *(__fastcall *getId)(Recipe *this);
  const ItemPack *(__fastcall *getItemPack)(Recipe *this);
  bool (__fastcall *isMultiRecipe)(Recipe *this);
  std::string *(__fastcall *getTypeString)(Recipe *this, std::string *result);
  bool (__fastcall *itemValidForRecipe)(Recipe *this, const ItemDescriptor *, const ItemStack *);
  bool (__fastcall *itemsMatch)(Recipe *this, const ItemDescriptor *, int, int, const CompoundTag *);
  bool (__fastcall *itemsMatch)(Recipe *this, const ItemDescriptor *, const ItemDescriptor *, const CompoundTag *);
  bool (__fastcall *itemsMatch)(Recipe *this, const ItemDescriptor *, const ItemDescriptor *);
};

</code></pre></div><h3 id="bannerduplicaterecipe"><a href="#bannerduplicaterecipe" class="header-anchor">#</a> <code>BannerDuplicateRecipe</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BannerDuplicateRecipe : MultiRecipe
{
  std::vector&lt;ItemInstance&gt; mResults;
};

</code></pre></div><h3 id="bannerduplicaterecipe-vtbl"><a href="#bannerduplicaterecipe-vtbl" class="header-anchor">#</a> <code>BannerDuplicateRecipe_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BannerDuplicateRecipe_vtbl
{
  void (__fastcall *~Recipe)(Recipe *this);
  const std::vector&lt;ItemInstance&gt; *(__fastcall *assemble)(Recipe *this, CraftingContainer *);
  int (__fastcall *getCraftingSize)(Recipe *this);
  const RecipeIngredient *(__fastcall *getIngredient)(Recipe *this, int, int);
  const std::vector&lt;ItemInstance&gt; *(__fastcall *getResultItem)(Recipe *this);
  bool (__fastcall *isShapeless)(Recipe *this);
  bool (__fastcall *matches)(Recipe *this, CraftingContainer *, Level *);
  int (__fastcall *size)(Recipe *this);
  const mce::UUID *(__fastcall *getId)(Recipe *this);
  const ItemPack *(__fastcall *getItemPack)(Recipe *this);
  bool (__fastcall *isMultiRecipe)(Recipe *this);
  std::string *(__fastcall *getTypeString)(Recipe *this, std::string *result);
  bool (__fastcall *itemValidForRecipe)(Recipe *this, const ItemDescriptor *, const ItemStack *);
  bool (__fastcall *itemsMatch)(Recipe *this, const ItemDescriptor *, int, int, const CompoundTag *);
  bool (__fastcall *itemsMatch)(Recipe *this, const ItemDescriptor *, const ItemDescriptor *, const CompoundTag *);
  bool (__fastcall *itemsMatch)(Recipe *this, const ItemDescriptor *, const ItemDescriptor *);
};

</code></pre></div><h3 id="banneraddpatternrecipe"><a href="#banneraddpatternrecipe" class="header-anchor">#</a> <code>BannerAddPatternRecipe</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BannerAddPatternRecipe : MultiRecipe
{
  std::vector&lt;ItemInstance&gt; mResults;
};

</code></pre></div><h3 id="banneraddpatternrecipe-vtbl"><a href="#banneraddpatternrecipe-vtbl" class="header-anchor">#</a> <code>BannerAddPatternRecipe_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BannerAddPatternRecipe_vtbl
{
  void (__fastcall *~Recipe)(Recipe *this);
  const std::vector&lt;ItemInstance&gt; *(__fastcall *assemble)(Recipe *this, CraftingContainer *);
  int (__fastcall *getCraftingSize)(Recipe *this);
  const RecipeIngredient *(__fastcall *getIngredient)(Recipe *this, int, int);
  const std::vector&lt;ItemInstance&gt; *(__fastcall *getResultItem)(Recipe *this);
  bool (__fastcall *isShapeless)(Recipe *this);
  bool (__fastcall *matches)(Recipe *this, CraftingContainer *, Level *);
  int (__fastcall *size)(Recipe *this);
  const mce::UUID *(__fastcall *getId)(Recipe *this);
  const ItemPack *(__fastcall *getItemPack)(Recipe *this);
  bool (__fastcall *isMultiRecipe)(Recipe *this);
  std::string *(__fastcall *getTypeString)(Recipe *this, std::string *result);
  bool (__fastcall *itemValidForRecipe)(Recipe *this, const ItemDescriptor *, const ItemStack *);
  bool (__fastcall *itemsMatch)(Recipe *this, const ItemDescriptor *, int, int, const CompoundTag *);
  bool (__fastcall *itemsMatch)(Recipe *this, const ItemDescriptor *, const ItemDescriptor *, const CompoundTag *);
  bool (__fastcall *itemsMatch)(Recipe *this, const ItemDescriptor *, const ItemDescriptor *);
};

</code></pre></div><h3 id="basegamepackslices-basegameversionpack"><a href="#basegamepackslices-basegameversionpack" class="header-anchor">#</a> <code>BaseGamePackSlices::BaseGameVersionPack</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BaseGamePackSlices::BaseGameVersionPack
{
  BaseGameVersion mBaseGameVersion;
  ResourcePack *mPack;
};

</code></pre></div><h3 id="bedrock-threading-threadlocalvalueaccessor-resourceloadmanager-resourceloadtaskgroup"><a href="#bedrock-threading-threadlocalvalueaccessor-resourceloadmanager-resourceloadtaskgroup" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalValueAccessor&lt;ResourceLoadManager::ResourceLoadTaskGroup *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalValueAccessor&lt;ResourceLoadManager::ResourceLoadTaskGroup *&gt;
{
};

</code></pre></div><h3 id="bedrock-threading-asyncresult-completeresult-std-string"><a href="#bedrock-threading-asyncresult-completeresult-std-string" class="header-anchor">#</a> <code>Bedrock::Threading::AsyncResult::CompleteResult&lt;std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::AsyncResult::CompleteResult&lt;std::string &gt; : Bedrock::Threading::IAsyncResult&lt;std::string &gt;
{
  std::string mResult;
};

</code></pre></div><h3 id="bedrock-threading-asyncresult-completeresult-std-string-vtbl"><a href="#bedrock-threading-asyncresult-completeresult-std-string-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::AsyncResult::CompleteResult&lt;std::string &gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::AsyncResult::CompleteResult&lt;std::string &gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;std::string &gt;)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this, std::exception_ptr *result);
  std::string *(__fastcall *getResult)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this, std::string *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;std::string &gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="bedrock-threading-asyncdeferredresultt-std-shared-ptr-mce-image"><a href="#bedrock-threading-asyncdeferredresultt-std-shared-ptr-mce-image" class="header-anchor">#</a> <code>Bedrock::Threading::AsyncDeferredResultT&lt;std::shared_ptr&lt;mce::Image&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::AsyncDeferredResultT&lt;std::shared_ptr&lt;mce::Image&gt; &gt; : Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt;
{
  std::mutex mLock;
  Bedrock::Threading::AsyncDeferredResultT&lt;std::shared_ptr&lt;mce::Image&gt; &gt;::DelayStatus mStatus;
  std::vector&lt;std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt; const &amp;)&gt;&gt; mComplete;
  std::optional&lt;std::shared_ptr&lt;mce::Image&gt; &gt; mResult;
};

</code></pre></div><h3 id="bedrock-threading-asyncdeferredresultt-std-shared-ptr-mce-image-vtbl"><a href="#bedrock-threading-asyncdeferredresultt-std-shared-ptr-mce-image-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::AsyncDeferredResultT&lt;std::shared_ptr&lt;mce::Image&gt; &gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::AsyncDeferredResultT&lt;std::shared_ptr&lt;mce::Image&gt; &gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt;)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt; *this, std::exception_ptr *result);
  std::shared_ptr&lt;mce::Image&gt; *(__fastcall *getResult)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt; *this, std::shared_ptr&lt;mce::Image&gt; *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="bedrock-threading-iasyncresult-std-vector-std-shared-ptr-bedrock-threading-iasyncresult-std-string"><a href="#bedrock-threading-iasyncresult-std-vector-std-shared-ptr-bedrock-threading-iasyncresult-std-string" class="header-anchor">#</a> <code>Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt; : Bedrock::Threading::AsyncBase
{
  Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt;_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-threading-iasyncresult-std-vector-std-shared-ptr-bedrock-threading-iasyncresult-std-string-vtbl"><a href="#bedrock-threading-iasyncresult-std-vector-std-shared-ptr-bedrock-threading-iasyncresult-std-string-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;,std::allocator&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::basic_string&lt;char,std::char_traits&lt;char)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt; *this, std::exception_ptr *result);
  std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; *(__fastcall *getResult)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt; *this, std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="bedrock-threading-whenall-std-string"><a href="#bedrock-threading-whenall-std-string" class="header-anchor">#</a> <code>Bedrock::Threading::WhenAll&lt;std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::WhenAll&lt;std::string &gt; : Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt;
{
  std::mutex mLock;
  Bedrock::Threading::AsyncStatus mStatus;
  unsigned __int64 mPending;
  std::vector&lt;std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt; const &amp;)&gt;&gt; mCallbacks;
  std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; mActions;
};

</code></pre></div><h3 id="bedrock-threading-whenall-std-string-vtbl"><a href="#bedrock-threading-whenall-std-string-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::WhenAll&lt;std::string &gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::WhenAll&lt;std::string &gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;,std::allocator&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::basic_string&lt;char,std::char_traits&lt;char)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt; *this, std::exception_ptr *result);
  std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; *(__fastcall *getResult)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt; *this, std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::string &gt; &gt;&gt; &gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="bedrock-threading-whenall-std-string-initialize-l6-lambda-ea6d99b805a01534f505aa92a5af28d0"><a href="#bedrock-threading-whenall-std-string-initialize-l6-lambda-ea6d99b805a01534f505aa92a5af28d0" class="header-anchor">#</a> <code>Bedrock::Threading::WhenAll&lt;std::string &gt;::initialize::__l6::&lt;lambda_ea6d99b805a01534f505aa92a5af28d0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::WhenAll&lt;std::string &gt;::initialize::__l6::&lt;lambda_ea6d99b805a01534f505aa92a5af28d0&gt;
{
  std::shared_ptr&lt;Bedrock::Threading::WhenAll&lt;std::string &gt; &gt; sharedThis;
};

</code></pre></div><h3 id="bedrockitems"><a href="#bedrockitems" class="header-anchor">#</a> <code>BedrockItems</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BedrockItems
{
};

</code></pre></div><h3 id="blocktickingqueue-hashblocktick"><a href="#blocktickingqueue-hashblocktick" class="header-anchor">#</a> <code>BlockTickingQueue::HashBlockTick</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTickingQueue::HashBlockTick
{
};

</code></pre></div><h3 id="bossbarcommand"><a href="#bossbarcommand" class="header-anchor">#</a> <code>BossbarCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) BossbarCommand : Command
{
  BossbarCommand::BossbarAction mAction;
  BossbarCommand::BossbarGetOption mGetOption;
  _BYTE mSetOption[4];
  std::string mId;
  Json::Value mName;
  BossBarColor mColor;
  int mMax;
  CommandSelector&lt;Player&gt; mTargets;
  int mValue;
  bool mVisible;
};

</code></pre></div><h3 id="bossbarcommand-vtbl"><a href="#bossbarcommand-vtbl" class="header-anchor">#</a> <code>BossbarCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BossbarCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="bidirectionalunorderedmap-enum-itemacquisitionmethod-std-string"><a href="#bidirectionalunorderedmap-enum-itemacquisitionmethod-std-string" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum ItemAcquisitionMethod,std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BidirectionalUnorderedMap&lt;enum ItemAcquisitionMethod,std::string &gt;
{
  std::unordered_map&lt;enum ItemAcquisitionMethod,std::string&gt; mRight;
  std::unordered_map&lt;std::string,enum ItemAcquisitionMethod&gt; mLeft;
};

</code></pre></div><h3 id="bidirectionalunorderedmap-enum-itemusemethod-std-string"><a href="#bidirectionalunorderedmap-enum-itemusemethod-std-string" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum ItemUseMethod,std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BidirectionalUnorderedMap&lt;enum ItemUseMethod,std::string &gt;
{
  std::unordered_map&lt;enum ItemUseMethod,std::string&gt; mRight;
  std::unordered_map&lt;std::string,enum ItemUseMethod&gt; mLeft;
};

</code></pre></div><h3 id="blocklistserializer"><a href="#blocklistserializer" class="header-anchor">#</a> <code>BlockListSerializer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockListSerializer
{
};

</code></pre></div><h3 id="backing-store-struct"><a href="#backing-store-struct" class="header-anchor">#</a> <code>backing_store_struct</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct backing_store_struct
{
  void (__fastcall *read_backing_store)(jpeg_common_struct *, backing_store_struct *, void *, int, int);
  void (__fastcall *write_backing_store)(jpeg_common_struct *, backing_store_struct *, void *, int, int);
  void (__fastcall *close_backing_store)(jpeg_common_struct *, backing_store_struct *);
  _iobuf *temp_file;
  char temp_name[64];
};

</code></pre></div><h3 id="bedrock-threading-tlsdetail-defaultconstructor-random-void"><a href="#bedrock-threading-tlsdetail-defaultconstructor-random-void" class="header-anchor">#</a> <code>Bedrock::Threading::TLSDetail::DefaultConstructor&lt;Random,void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::TLSDetail::DefaultConstructor&lt;Random,void&gt;
{
};

</code></pre></div><h3 id="bedrock-threading-tlsdetail-defaultconstructor-random-void-create-l2-lambda-c5e437940b24146f2fb7ba5b5af46ca8"><a href="#bedrock-threading-tlsdetail-defaultconstructor-random-void-create-l2-lambda-c5e437940b24146f2fb7ba5b5af46ca8" class="header-anchor">#</a> <code>Bedrock::Threading::TLSDetail::DefaultConstructor&lt;Random,void&gt;::create::__l2::&lt;lambda_c5e437940b24146f2fb7ba5b5af46ca8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::TLSDetail::DefaultConstructor&lt;Random,void&gt;::create::__l2::&lt;lambda_c5e437940b24146f2fb7ba5b5af46ca8&gt;
{
};

</code></pre></div><h3 id="bidirectionalunorderedmap-std-string-enum-actordamagecause"><a href="#bidirectionalunorderedmap-std-string-enum-actordamagecause" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;std::string,enum ActorDamageCause&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BidirectionalUnorderedMap&lt;std::string,enum ActorDamageCause&gt;
{
  std::unordered_map&lt;std::string,enum ActorDamageCause&gt; mRight;
  std::unordered_map&lt;enum ActorDamageCause,std::string&gt; mLeft;
};

</code></pre></div><h3 id="bedrock-threading-iasyncresult-std-pair-json-value-core-pathbuffer-std-string"><a href="#bedrock-threading-iasyncresult-std-pair-json-value-core-pathbuffer-std-string" class="header-anchor">#</a> <code>Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; : Bedrock::Threading::AsyncBase
{
  Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt;_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-threading-iasyncresult-std-pair-json-value-core-pathbuffer-std-string-vtbl"><a href="#bedrock-threading-iasyncresult-std-pair-json-value-core-pathbuffer-std-string-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt;)(Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; *this, std::exception_ptr *result);
  std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; *(__fastcall *getResult)(Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; *this, std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="bedrock-threading-asyncdeferredresultt-std-pair-json-value-core-pathbuffer-std-string"><a href="#bedrock-threading-asyncdeferredresultt-std-pair-json-value-core-pathbuffer-std-string" class="header-anchor">#</a> <code>Bedrock::Threading::AsyncDeferredResultT&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::AsyncDeferredResultT&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; : Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt;
{
  std::mutex mLock;
  Bedrock::Threading::AsyncDeferredResultT&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt;::DelayStatus mStatus;
  std::vector&lt;std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; const &amp;)&gt;&gt; mComplete;
  std::optional&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; mResult;
};

</code></pre></div><h3 id="bedrock-threading-asyncdeferredresultt-std-pair-json-value-core-pathbuffer-std-string-vtbl"><a href="#bedrock-threading-asyncdeferredresultt-std-pair-json-value-core-pathbuffer-std-string-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::AsyncDeferredResultT&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::AsyncDeferredResultT&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt;)(Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; *this, std::exception_ptr *result);
  std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; *(__fastcall *getResult)(Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; *this, std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="basegoaldefinition"><a href="#basegoaldefinition" class="header-anchor">#</a> <code>BaseGoalDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BaseGoalDefinition
{
  BaseGoalDefinition_vtbl *__vftable /*VFT*/;
  int mPriority;
  int mControlFlags;
  std::string mName;
};

</code></pre></div><h3 id="basegoaldefinition-vtbl"><a href="#basegoaldefinition-vtbl" class="header-anchor">#</a> <code>BaseGoalDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BaseGoalDefinition_vtbl
{
  void (__fastcall *~BaseGoalDefinition)(BaseGoalDefinition *this);
  bool (__fastcall *validateMobType)(BaseGoalDefinition *this, Mob *);
  bool (__fastcall *validate)(BaseGoalDefinition *this, Mob *);
};

</code></pre></div><h3 id="breatheairgoal"><a href="#breatheairgoal" class="header-anchor">#</a> <code>BreatheAirGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BreatheAirGoal : Goal
{
  Mob *mMob;
  Vec3 mWanted;
  float mSpeedMod;
  int mRadius;
  int mStartBreath;
  bool mEndsInAir;
};

</code></pre></div><h3 id="breatheairgoal-vtbl"><a href="#breatheairgoal-vtbl" class="header-anchor">#</a> <code>BreatheAirGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BreatheAirGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="basegoaldefinition-buildschemabase-l2-lambda-d8612f873e3b81f52251871d1b9a99f9"><a href="#basegoaldefinition-buildschemabase-l2-lambda-d8612f873e3b81f52251871d1b9a99f9" class="header-anchor">#</a> <code>BaseGoalDefinition::buildSchemaBase::__l2::&lt;lambda_d8612f873e3b81f52251871d1b9a99f9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BaseGoalDefinition::buildSchemaBase::__l2::&lt;lambda_d8612f873e3b81f52251871d1b9a99f9&gt;
{
};

</code></pre></div><h3 id="basegoaldefinition-buildschemabase-l2-lambda-5f47e7c4535a8e8b6eb9aa52e1794f25"><a href="#basegoaldefinition-buildschemabase-l2-lambda-5f47e7c4535a8e8b6eb9aa52e1794f25" class="header-anchor">#</a> <code>BaseGoalDefinition::buildSchemaBase::__l2::&lt;lambda_5f47e7c4535a8e8b6eb9aa52e1794f25&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BaseGoalDefinition::buildSchemaBase::__l2::&lt;lambda_5f47e7c4535a8e8b6eb9aa52e1794f25&gt;
{
};

</code></pre></div><h3 id="basegoaldefinition-buildschemabase-l2-lambda-10b1270a68118e20f7f1d196815febb1"><a href="#basegoaldefinition-buildschemabase-l2-lambda-10b1270a68118e20f7f1d196815febb1" class="header-anchor">#</a> <code>BaseGoalDefinition::buildSchemaBase::__l2::&lt;lambda_10b1270a68118e20f7f1d196815febb1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BaseGoalDefinition::buildSchemaBase::__l2::&lt;lambda_10b1270a68118e20f7f1d196815febb1&gt;
{
};

</code></pre></div><h3 id="basegoaldefinition-buildschemabase-l2-lambda-e7713cd94131b6e804ff7baff09e844c"><a href="#basegoaldefinition-buildschemabase-l2-lambda-e7713cd94131b6e804ff7baff09e844c" class="header-anchor">#</a> <code>BaseGoalDefinition::buildSchemaBase::__l2::&lt;lambda_e7713cd94131b6e804ff7baff09e844c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BaseGoalDefinition::buildSchemaBase::__l2::&lt;lambda_e7713cd94131b6e804ff7baff09e844c&gt;
{
};

</code></pre></div><h3 id="basegoaldefinition-buildschemabase-l2-lambda-9fe4dd819da38dc1eae3af426a0fcc90"><a href="#basegoaldefinition-buildschemabase-l2-lambda-9fe4dd819da38dc1eae3af426a0fcc90" class="header-anchor">#</a> <code>BaseGoalDefinition::buildSchemaBase::__l2::&lt;lambda_9fe4dd819da38dc1eae3af426a0fcc90&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BaseGoalDefinition::buildSchemaBase::__l2::&lt;lambda_9fe4dd819da38dc1eae3af426a0fcc90&gt;
{
};

</code></pre></div><h3 id="basegoaldefinition-buildschemabase-l2-lambda-78da3d7fc4f3f9c053018dec9b623030"><a href="#basegoaldefinition-buildschemabase-l2-lambda-78da3d7fc4f3f9c053018dec9b623030" class="header-anchor">#</a> <code>BaseGoalDefinition::buildSchemaBase::__l2::&lt;lambda_78da3d7fc4f3f9c053018dec9b623030&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BaseGoalDefinition::buildSchemaBase::__l2::&lt;lambda_78da3d7fc4f3f9c053018dec9b623030&gt;
{
};

</code></pre></div><h3 id="bat"><a href="#bat" class="header-anchor">#</a> <code>Bat</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bat : Mob
{
  bool mWasResting;
  Vec3 mTargetPosition;
};

</code></pre></div><h3 id="bee"><a href="#bee" class="header-anchor">#</a> <code>Bee</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Bee : Animal
{
  unsigned __int64 mNormalLoop;
  unsigned __int64 mAggressiveLoop;
  float mLoopSoundSpeed;
};

</code></pre></div><h3 id="bee-registerloopingsounds-l2-lambda-8b16ca835b74e115732146567a1e7f3b"><a href="#bee-registerloopingsounds-l2-lambda-8b16ca835b74e115732146567a1e7f3b" class="header-anchor">#</a> <code>Bee::_registerLoopingSounds::__l2::&lt;lambda_8b16ca835b74e115732146567a1e7f3b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bee::_registerLoopingSounds::__l2::&lt;lambda_8b16ca835b74e115732146567a1e7f3b&gt;
{
  Bee *const __this;
};

</code></pre></div><h3 id="bee-registerloopingsounds-l2-lambda-fe84468281a4fb95c579b7348cca4739"><a href="#bee-registerloopingsounds-l2-lambda-fe84468281a4fb95c579b7348cca4739" class="header-anchor">#</a> <code>Bee::_registerLoopingSounds::__l2::&lt;lambda_fe84468281a4fb95c579b7348cca4739&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bee::_registerLoopingSounds::__l2::&lt;lambda_fe84468281a4fb95c579b7348cca4739&gt;
{
  Bee *const __this;
};

</code></pre></div><h3 id="behaviordata-data-int"><a href="#behaviordata-data-int" class="header-anchor">#</a> <code>BehaviorData::Data&lt;int&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BehaviorData::Data&lt;int&gt; : BehaviorData::DataProxy
{
  int mData;
};

</code></pre></div><h3 id="behaviordata-data-int-vtbl"><a href="#behaviordata-data-int-vtbl" class="header-anchor">#</a> <code>BehaviorData::Data&lt;int&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BehaviorData::Data&lt;int&gt;_vtbl
{
  void (__fastcall *~DataProxy)(BehaviorData::DataProxy *this);
  std::unique_ptr&lt;BehaviorData::DataProxy&gt; *(__fastcall *copy)(BehaviorData::DataProxy *this, std::unique_ptr&lt;BehaviorData::DataProxy&gt; *result);
};

</code></pre></div><h3 id="behaviordata-data-float"><a href="#behaviordata-data-float" class="header-anchor">#</a> <code>BehaviorData::Data&lt;float&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BehaviorData::Data&lt;float&gt; : BehaviorData::DataProxy
{
  float mData;
};

</code></pre></div><h3 id="behaviordata-data-float-vtbl"><a href="#behaviordata-data-float-vtbl" class="header-anchor">#</a> <code>BehaviorData::Data&lt;float&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BehaviorData::Data&lt;float&gt;_vtbl
{
  void (__fastcall *~DataProxy)(BehaviorData::DataProxy *this);
  std::unique_ptr&lt;BehaviorData::DataProxy&gt; *(__fastcall *copy)(BehaviorData::DataProxy *this, std::unique_ptr&lt;BehaviorData::DataProxy&gt; *result);
};

</code></pre></div><h3 id="behaviordata-data-bool"><a href="#behaviordata-data-bool" class="header-anchor">#</a> <code>BehaviorData::Data&lt;bool&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BehaviorData::Data&lt;bool&gt; : BehaviorData::DataProxy
{
  bool mData;
};

</code></pre></div><h3 id="behaviordata-data-bool-vtbl"><a href="#behaviordata-data-bool-vtbl" class="header-anchor">#</a> <code>BehaviorData::Data&lt;bool&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BehaviorData::Data&lt;bool&gt;_vtbl
{
  void (__fastcall *~DataProxy)(BehaviorData::DataProxy *this);
  std::unique_ptr&lt;BehaviorData::DataProxy&gt; *(__fastcall *copy)(BehaviorData::DataProxy *this, std::unique_ptr&lt;BehaviorData::DataProxy&gt; *result);
};

</code></pre></div><h3 id="behaviordata-data-blockpos"><a href="#behaviordata-data-blockpos" class="header-anchor">#</a> <code>BehaviorData::Data&lt;BlockPos&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BehaviorData::Data&lt;BlockPos&gt; : BehaviorData::DataProxy
{
  BlockPos mData;
};

</code></pre></div><h3 id="behaviordata-data-blockpos-vtbl"><a href="#behaviordata-data-blockpos-vtbl" class="header-anchor">#</a> <code>BehaviorData::Data&lt;BlockPos&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BehaviorData::Data&lt;BlockPos&gt;_vtbl
{
  void (__fastcall *~DataProxy)(BehaviorData::DataProxy *this);
  std::unique_ptr&lt;BehaviorData::DataProxy&gt; *(__fastcall *copy)(BehaviorData::DataProxy *this, std::unique_ptr&lt;BehaviorData::DataProxy&gt; *result);
};

</code></pre></div><h3 id="behaviordata-data-vec3"><a href="#behaviordata-data-vec3" class="header-anchor">#</a> <code>BehaviorData::Data&lt;Vec3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BehaviorData::Data&lt;Vec3&gt; : BehaviorData::DataProxy
{
  Vec3 mData;
};

</code></pre></div><h3 id="behaviordata-data-vec3-vtbl"><a href="#behaviordata-data-vec3-vtbl" class="header-anchor">#</a> <code>BehaviorData::Data&lt;Vec3&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BehaviorData::Data&lt;Vec3&gt;_vtbl
{
  void (__fastcall *~DataProxy)(BehaviorData::DataProxy *this);
  std::unique_ptr&lt;BehaviorData::DataProxy&gt; *(__fastcall *copy)(BehaviorData::DataProxy *this, std::unique_ptr&lt;BehaviorData::DataProxy&gt; *result);
};

</code></pre></div><h3 id="behaviordata-data-std-string"><a href="#behaviordata-data-std-string" class="header-anchor">#</a> <code>BehaviorData::Data&lt;std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BehaviorData::Data&lt;std::string &gt; : BehaviorData::DataProxy
{
  std::string mData;
};

</code></pre></div><h3 id="behaviordata-data-std-string-vtbl"><a href="#behaviordata-data-std-string-vtbl" class="header-anchor">#</a> <code>BehaviorData::Data&lt;std::string &gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BehaviorData::Data&lt;std::string &gt;_vtbl
{
  void (__fastcall *~DataProxy)(BehaviorData::DataProxy *this);
  std::unique_ptr&lt;BehaviorData::DataProxy&gt; *(__fastcall *copy)(BehaviorData::DataProxy *this, std::unique_ptr&lt;BehaviorData::DataProxy&gt; *result);
};

</code></pre></div><h3 id="breakblocknode"><a href="#breakblocknode" class="header-anchor">#</a> <code>BreakBlockNode</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) BreakBlockNode : BehaviorNode
{
  BlockPos mBlockPos;
  int mNumTicksToBreak;
  gsl::not_null&lt;Block const *&gt; mStartingBlock;
  int mNumTicksBreaking;
  bool mPreActionDone;
};

</code></pre></div><h3 id="breakblocknode-vtbl"><a href="#breakblocknode-vtbl" class="header-anchor">#</a> <code>BreakBlockNode_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BreakBlockNode_vtbl
{
  void (__fastcall *~BehaviorNode)(BehaviorNode *this);
  BehaviorStatus (__fastcall *tick)(BehaviorNode *this, Actor *);
  void (__fastcall *initializeFromDefinition)(BehaviorNode *this, Actor *);
};

</code></pre></div><h3 id="breakblockdefinition"><a href="#breakblockdefinition" class="header-anchor">#</a> <code>BreakBlockDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BreakBlockDefinition : BehaviorDefinition
{
  BlockPos mBlockPos;
  std::string mBlockPosId;
  int mNumTicksToBreak;
  std::string mNumTicksToBreakId;
};

</code></pre></div><h3 id="breakblockdefinition-vtbl"><a href="#breakblockdefinition-vtbl" class="header-anchor">#</a> <code>BreakBlockDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BreakBlockDefinition_vtbl
{
  void (__fastcall *~BehaviorDefinition)(BehaviorDefinition *this);
  void (__fastcall *load)(BehaviorDefinition *this, Json::Value, const BehaviorFactory *);
  std::unique_ptr&lt;BehaviorNode&gt; *(__fastcall *createNode)(BehaviorDefinition *this, std::unique_ptr&lt;BehaviorNode&gt; *result, Actor *, const BehaviorFactory *, BehaviorNode *, BehaviorData *);
};

</code></pre></div><h3 id="buildsoundeventschema-l2-lambda-83c1561f5f5169c4af75436371373e5f"><a href="#buildsoundeventschema-l2-lambda-83c1561f5f5169c4af75436371373e5f" class="header-anchor">#</a> <code>buildSoundEventSchema::__l2::&lt;lambda_83c1561f5f5169c4af75436371373e5f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buildSoundEventSchema::__l2::&lt;lambda_83c1561f5f5169c4af75436371373e5f&gt;
{
};

</code></pre></div><h3 id="buildsoundeventschema-l2-lambda-dbade74c4a1f92bbca03768828a59559"><a href="#buildsoundeventschema-l2-lambda-dbade74c4a1f92bbca03768828a59559" class="header-anchor">#</a> <code>buildSoundEventSchema::__l2::&lt;lambda_dbade74c4a1f92bbca03768828a59559&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buildSoundEventSchema::__l2::&lt;lambda_dbade74c4a1f92bbca03768828a59559&gt;
{
};

</code></pre></div><h3 id="buildparticleeventschema-l2-lambda-bf90f814d09023d3d86bbabfc91b2f2d"><a href="#buildparticleeventschema-l2-lambda-bf90f814d09023d3d86bbabfc91b2f2d" class="header-anchor">#</a> <code>buildParticleEventSchema::__l2::&lt;lambda_bf90f814d09023d3d86bbabfc91b2f2d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buildParticleEventSchema::__l2::&lt;lambda_bf90f814d09023d3d86bbabfc91b2f2d&gt;
{
};

</code></pre></div><h3 id="buildparticleeventschema-l2-lambda-c0a41c51a54f56fb665624f94a8c68a4"><a href="#buildparticleeventschema-l2-lambda-c0a41c51a54f56fb665624f94a8c68a4" class="header-anchor">#</a> <code>buildParticleEventSchema::__l2::&lt;lambda_c0a41c51a54f56fb665624f94a8c68a4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buildParticleEventSchema::__l2::&lt;lambda_c0a41c51a54f56fb665624f94a8c68a4&gt;
{
};

</code></pre></div><h3 id="buildparticleeventschema-l2-lambda-9d0a5b44103b9a4cd09a0f79bdc9c298"><a href="#buildparticleeventschema-l2-lambda-9d0a5b44103b9a4cd09a0f79bdc9c298" class="header-anchor">#</a> <code>buildParticleEventSchema::__l2::&lt;lambda_9d0a5b44103b9a4cd09a0f79bdc9c298&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buildParticleEventSchema::__l2::&lt;lambda_9d0a5b44103b9a4cd09a0f79bdc9c298&gt;
{
};

</code></pre></div><h3 id="buildparticleeventschema-l2-lambda-2d6eded26c009ade9068294c18061152"><a href="#buildparticleeventschema-l2-lambda-2d6eded26c009ade9068294c18061152" class="header-anchor">#</a> <code>buildParticleEventSchema::__l2::&lt;lambda_2d6eded26c009ade9068294c18061152&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buildParticleEventSchema::__l2::&lt;lambda_2d6eded26c009ade9068294c18061152&gt;
{
};

</code></pre></div><h3 id="buildparticleeventschema-l2-lambda-1f3caa22e3ae22f1f1994ba5630aee65"><a href="#buildparticleeventschema-l2-lambda-1f3caa22e3ae22f1f1994ba5630aee65" class="header-anchor">#</a> <code>buildParticleEventSchema::__l2::&lt;lambda_1f3caa22e3ae22f1f1994ba5630aee65&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buildParticleEventSchema::__l2::&lt;lambda_1f3caa22e3ae22f1f1994ba5630aee65&gt;
{
};

</code></pre></div><h3 id="buildparticleeventschema-l2-lambda-d68979437fb540ff520a765fa7266f39"><a href="#buildparticleeventschema-l2-lambda-d68979437fb540ff520a765fa7266f39" class="header-anchor">#</a> <code>buildParticleEventSchema::__l2::&lt;lambda_d68979437fb540ff520a765fa7266f39&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buildParticleEventSchema::__l2::&lt;lambda_d68979437fb540ff520a765fa7266f39&gt;
{
};

</code></pre></div><h3 id="buildparticleeventschema-l2-lambda-8fe8b599339fd8148421a1fadfa1fb50"><a href="#buildparticleeventschema-l2-lambda-8fe8b599339fd8148421a1fadfa1fb50" class="header-anchor">#</a> <code>buildParticleEventSchema::__l2::&lt;lambda_8fe8b599339fd8148421a1fadfa1fb50&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buildParticleEventSchema::__l2::&lt;lambda_8fe8b599339fd8148421a1fadfa1fb50&gt;
{
};

</code></pre></div><h3 id="buildparticleeventschema-l2-lambda-09e2c5ded9e20b86bf2f8fed4ad9c667"><a href="#buildparticleeventschema-l2-lambda-09e2c5ded9e20b86bf2f8fed4ad9c667" class="header-anchor">#</a> <code>buildParticleEventSchema::__l2::&lt;lambda_09e2c5ded9e20b86bf2f8fed4ad9c667&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buildParticleEventSchema::__l2::&lt;lambda_09e2c5ded9e20b86bf2f8fed4ad9c667&gt;
{
};

</code></pre></div><h3 id="blockpatternbuilder"><a href="#blockpatternbuilder" class="header-anchor">#</a> <code>BlockPatternBuilder</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockPatternBuilder
{
  BlockSource *mRegion;
  std::vector&lt;std::string&gt; mPattern;
  std::map&lt;char,std::function&lt;bool __cdecl(BlockSource &amp;,BlockPos const &amp;,Block const &amp;)&gt;&gt; mLookup;
  bool mReadyForMatch;
  int mNumPatterns;
  int mPatternLength;
};

</code></pre></div><h3 id="brewingstandblockactor"><a href="#brewingstandblockactor" class="header-anchor">#</a> <code>BrewingStandBlockActor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BrewingStandBlockActor : BlockActor, Container
{
  int mBrewTime;
  int mFuelAmount;
  int mFuelTotal;
  bool mFinished;
  const Item *mIngredient;
  ItemStack mItems[5];
  bool mNotifyPlayersOnChange;
};

</code></pre></div><h3 id="brewingstandblockactor-vtbl"><a href="#brewingstandblockactor-vtbl" class="header-anchor">#</a> <code>BrewingStandBlockActor_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BrewingStandBlockActor_vtbl
{
  void (__fastcall *~BlockActor)(BlockActor *this);
  void (__fastcall *load)(BlockActor *this, Level *, const CompoundTag *, DataLoadHelper *);
  bool (__fastcall *save)(BlockActor *this, CompoundTag *);
  bool (__fastcall *saveItemInstanceData)(BlockActor *this, CompoundTag *);
  void (__fastcall *saveBlockData)(BlockActor *this, CompoundTag *, BlockSource *);
  void (__fastcall *loadBlockData)(BlockActor *this, const CompoundTag *, BlockSource *, DataLoadHelper *);
  void (__fastcall *onCustomTagLoadDone)(BlockActor *this, BlockSource *);
  void (__fastcall *tick)(BlockActor *this, BlockSource *);
  bool (__fastcall *isFinished)(BlockActor *this);
  void (__fastcall *onChanged)(BlockActor *this, BlockSource *);
  bool (__fastcall *isMovable)(BlockActor *this, BlockSource *);
  bool (__fastcall *isCustomNameSaved)(BlockActor *this);
  bool (__fastcall *onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *, const Player *);
  void (__fastcall *onPlace)(BlockActor *this, BlockSource *);
  void (__fastcall *onMove)(BlockActor *this);
  void (__fastcall *onRemoved)(BlockActor *this, BlockSource *);
  void (__fastcall *triggerEvent)(BlockActor *this, int, int);
  void (__fastcall *clearCache)(BlockActor *this);
  void (__fastcall *onNeighborChanged)(BlockActor *this, BlockSource *, const BlockPos *);
  float (__fastcall *getShadowRadius)(BlockActor *this, BlockSource *);
  bool (__fastcall *hasAlphaLayer)(BlockActor *this);
  BlockActor *(__fastcall *getCrackEntity)(BlockActor *this, BlockSource *, const BlockPos *);
  void (__fastcall *getDebugText)(BlockActor *this, std::vector&lt;std::string&gt; *, const BlockPos *);
  const std::string *(__fastcall *getCustomName)(BlockActor *this);
  const std::string *(__fastcall *getFilteredCustomName)(BlockActor *this, const UIProfanityContext *);
  std::string *(__fastcall *getName)(BlockActor *this, std::string *result);
  void (__fastcall *setCustomName)(BlockActor *this, const std::string *);
  std::string *(__fastcall *getImmersiveReaderText)(BlockActor *this, std::string *result, BlockSource *);
  int (__fastcall *getRepairCost)(BlockActor *this);
  PistonBlockActor *(__fastcall *getOwningPiston)(BlockActor *this, BlockSource *);
  const Container *(__fastcall *getContainer)(BlockActor *this);
  Container *(__fastcall *getContainer)(BlockActor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(BlockActor *this);
  void (__fastcall *checkWordsOnChunkLoad)(BlockActor *this, LevelChunk *);
  void (__fastcall *checkWordsOnUpdate)(BlockActor *this, Player *);
  void (__fastcall *onChunkLoaded)(BlockActor *this, LevelChunk *);
  void (__fastcall *onChunkUnloaded)(BlockActor *this, LevelChunk *);
  std::unique_ptr&lt;BlockActorDataPacket&gt; *(__fastcall *_getUpdatePacket)(BlockActor *this, std::unique_ptr&lt;BlockActorDataPacket&gt; *result, BlockSource *);
  void (__fastcall *_onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *);
  bool (__fastcall *_playerCanUpdate)(BlockActor *this, const Player *);
};

</code></pre></div><h3 id="barrelblockactor"><a href="#barrelblockactor" class="header-anchor">#</a> <code>BarrelBlockActor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BarrelBlockActor : ChestBlockActor
{
};

</code></pre></div><h3 id="balloon"><a href="#balloon" class="header-anchor">#</a> <code>Balloon</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Balloon : PredictableProjectile
{
  std::unique_ptr&lt;MovementInterpolator&gt; mInterpolator;
};

</code></pre></div><h3 id="balloon-vtbl"><a href="#balloon-vtbl" class="header-anchor">#</a> <code>Balloon_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Balloon_vtbl
{
  bool (__fastcall *hasComponent)(Actor *this, const HashedString *);
  void (__fastcall *reloadHardcoded)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadHardcodedClient)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *initializeComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *_serverInitItemStackIds)(Actor *this);
  void (__fastcall *_doInitialMove)(Actor *this);
  bool (__fastcall *checkAllSensitiveWords)(Actor *this);
  bool (__fastcall *checkNameTag)(Actor *this);
  void (__fastcall *~Actor)(Actor *this);
  void (__fastcall *reset)(Actor *this);
  int (__fastcall *getOnDeathExperience)(Actor *this);
  ActorType (__fastcall *getOwnerEntityType)(Actor *this);
  void (__fastcall *remove)(Actor *this);
  void (__fastcall *setPos)(Actor *this, const Vec3 *);
  const PredictedMovementValues *(__fastcall *getPredictedMovementValues)(Actor *this);
  const Vec3 *(__fastcall *getPos)(Actor *this);
  const Vec3 *(__fastcall *getPosOld)(Actor *this);
  const Vec3 *(__fastcall *getPosExtrapolated)(Actor *this, const Vec3 *result, float);
  Vec3 *(__fastcall *getAttachPos)(Actor *this, Vec3 *result, ActorLocation, float);
  Vec3 *(__fastcall *getFiringPos)(Actor *this, Vec3 *result);
  void (__fastcall *setRot)(Actor *this, const Vec2 *);
  void (__fastcall *move)(Actor *this, IActorMovementProxy *, const Vec3 *);
  void (__fastcall *move)(Actor *this, const Vec3 *);
  Vec3 *(__fastcall *getInterpolatedRidingPosition)(Actor *this, Vec3 *result, float);
  float (__fastcall *getInterpolatedBodyRot)(Actor *this, float);
  float (__fastcall *getInterpolatedHeadRot)(Actor *this, float);
  float (__fastcall *getInterpolatedBodyYaw)(Actor *this, float);
  float (__fastcall *getYawSpeedInDegreesPerSecond)(Actor *this);
  float (__fastcall *getInterpolatedWalkAnimSpeed)(Actor *this, float);
  Vec3 *(__fastcall *getInterpolatedRidingOffset)(Actor *this, Vec3 *result, float);
  void (__fastcall *checkBlockCollisions)(Actor *this);
  void (__fastcall *checkBlockCollisions)(Actor *this, const AABB *, std::function&lt;void __cdecl(BlockSource &amp;,Block const &amp;,BlockPos const &amp;,Actor &amp;)&gt;);
  bool (__fastcall *isFireImmune)(Actor *this);
  bool (__fastcall *breaksFallingBlocks)(Actor *this);
  void (__fastcall *blockedByShield)(Actor *this, const ActorDamageSource *, Actor *);
  void (__fastcall *teleportTo)(Actor *this, const Vec3 *, bool, int, int, const ActorUniqueID *);
  bool (__fastcall *tryTeleportTo)(Actor *this, const Vec3 *, bool, bool, int, int);
  void (__fastcall *chorusFruitTeleport)(Actor *this, Vec3 *);
  void (__fastcall *lerpTo)(Actor *this, const Vec3 *, const Vec2 *, int);
  void (__fastcall *lerpMotion)(Actor *this, const Vec3 *);
  std::unique_ptr&lt;AddActorBasePacket&gt; *(__fastcall *getAddPacket)(Actor *this, std::unique_ptr&lt;AddActorBasePacket&gt; *result);
  void (__fastcall *normalTick)(Actor *this);
  void (__fastcall *baseTick)(Actor *this);
  void (__fastcall *rideTick)(Actor *this);
  void (__fastcall *positionRider)(Actor *this, Actor *, float);
  float (__fastcall *getRidingHeight)(Actor *this);
  bool (__fastcall *startRiding)(Actor *this, Actor *);
  void (__fastcall *addRider)(Actor *this, Actor *);
  void (__fastcall *flagRiderToRemove)(Actor *this, Actor *);
  std::string *(__fastcall *getExitTip)(Actor *this, std::string *result, const std::string *, InputMode);
  bool (__fastcall *intersects)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *, float);
  bool (__fastcall *isInWall)(Actor *this);
  bool (__fastcall *isInvisible)(Actor *this);
  bool (__fastcall *canShowNameTag)(Actor *this);
  bool (__fastcall *canExistInPeaceful)(Actor *this);
  void (__fastcall *setNameTagVisible)(Actor *this, bool);
  const std::string *(__fastcall *getNameTag)(Actor *this);
  unsigned __int64 (__fastcall *getNameTagAsHash)(Actor *this);
  std::string *(__fastcall *getFormattedNameTag)(Actor *this, std::string *result);
  void (__fastcall *filterFormattedNameTag)(Actor *this, const UIProfanityContext *);
  void (__fastcall *setNameTag)(Actor *this, const std::string *);
  bool (__fastcall *getAlwaysShowNameTag)(Actor *this);
  void (__fastcall *setScoreTag)(Actor *this, const std::string *);
  const std::string *(__fastcall *getScoreTag)(Actor *this);
  bool (__fastcall *isInWater)(Actor *this);
  bool (__fastcall *hasEnteredWater)(Actor *this);
  bool (__fastcall *isImmersedInWater)(Actor *this);
  bool (__fastcall *isInWaterOrRain)(Actor *this);
  bool (__fastcall *isInLava)(Actor *this);
  bool (__fastcall *isUnderLiquid)(Actor *this, MaterialType);
  bool (__fastcall *isOverWater)(Actor *this);
  void (__fastcall *makeStuckInBlock)(Actor *this, const Vec3 *);
  float (__fastcall *getCameraOffset)(Actor *this);
  float (__fastcall *getShadowHeightOffs)(Actor *this);
  float (__fastcall *getShadowRadius)(Actor *this);
  Vec3 *(__fastcall *getHeadLookVector)(Actor *this, Vec3 *result, float);
  bool (__fastcall *canSeeInvisible)(Actor *this);
  bool (__fastcall *canSee)(Actor *this, const Vec3 *);
  bool (__fastcall *canSee)(Actor *this, const Actor *);
  bool (__fastcall *isSkyLit)(Actor *this, float);
  float (__fastcall *getBrightness)(Actor *this, float);
  bool (__fastcall *interactPreventDefault)(Actor *this);
  void (__fastcall *playerTouch)(Actor *this, Player *);
  void (__fastcall *onAboveBubbleColumn)(Actor *this, const bool);
  void (__fastcall *onInsideBubbleColumn)(Actor *this, const bool);
  bool (__fastcall *isImmobile)(Actor *this);
  bool (__fastcall *isSilent)(Actor *this);
  bool (__fastcall *isPickable)(Actor *this);
  bool (__fastcall *isFishable)(Actor *this);
  bool (__fastcall *isSleeping)(Actor *this);
  bool (__fastcall *isShootable)(Actor *this);
  void (__fastcall *setSneaking)(Actor *this, bool);
  bool (__fastcall *isBlocking)(Actor *this);
  bool (__fastcall *isDamageBlocked)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *isAlive)(Actor *this);
  bool (__fastcall *isOnFire)(Actor *this);
  bool (__fastcall *isOnHotBlock)(Actor *this);
  bool (__fastcall *isCreativeModeAllowed)(Actor *this);
  bool (__fastcall *isSurfaceMob)(Actor *this);
  bool (__fastcall *isTargetable)(Actor *this);
  bool (__fastcall *isLocalPlayer)(Actor *this);
  bool (__fastcall *isPlayer)(Actor *this);
  bool (__fastcall *canAttack)(Actor *this, Actor *, bool);
  void (__fastcall *setTarget)(Actor *this, Actor *);
  Actor *(__fastcall *findAttackTarget)(Actor *this);
  bool (__fastcall *isValidTarget)(Actor *this, Actor *);
  bool (__fastcall *attack)(Actor *this, Actor *);
  void (__fastcall *performRangedAttack)(Actor *this, Actor *, float);
  void (__fastcall *adjustDamageAmount)(Actor *this, int *);
  int (__fastcall *getEquipmentCount)(Actor *this);
  void (__fastcall *setOwner)(Actor *this, const ActorUniqueID);
  void (__fastcall *setSitting)(Actor *this, bool);
  void (__fastcall *onTame)(Actor *this);
  void (__fastcall *onFailedTame)(Actor *this);
  int (__fastcall *getInventorySize)(Actor *this);
  int (__fastcall *getEquipSlots)(Actor *this);
  int (__fastcall *getChestSlots)(Actor *this);
  void (__fastcall *setStanding)(Actor *this, bool);
  bool (__fastcall *canPowerJump)(Actor *this);
  void (__fastcall *setCanPowerJump)(Actor *this, bool);
  bool (__fastcall *isJumping)(Actor *this);
  bool (__fastcall *isEnchanted)(Actor *this);
  void (__fastcall *rideJumped)(Actor *this);
  void (__fastcall *rideLanded)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *shouldRender)(Actor *this);
  bool (__fastcall *isInvulnerableTo)(Actor *this, const ActorDamageSource *);
  ActorDamageCause (__fastcall *getBlockDamageCause)(Actor *this, const Block *);
  void (__fastcall *actuallyHurt)(Actor *this, int, const ActorDamageSource *, bool);
  void (__fastcall *animateHurt)(Actor *this);
  bool (__fastcall *doFireHurt)(Actor *this, int);
  void (__fastcall *onLightningHit)(Actor *this);
  void (__fastcall *onBounceStarted)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *feed)(Actor *this, int);
  void (__fastcall *handleEntityEvent)(Actor *this, ActorEvent, int);
  float (__fastcall *getPickRadius)(Actor *this);
  const HashedString *(__fastcall *getActorRendererId)(Actor *this);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const ItemStack *, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int);
  void (__fastcall *despawn)(Actor *this);
  void (__fastcall *killed)(Actor *this, Actor *);
  void (__fastcall *awardKillScore)(Actor *this, Actor *, int);
  void (__fastcall *setArmor)(Actor *this, ArmorSlot, const ItemStack *);
  const ItemStack *(__fastcall *getArmor)(Actor *this, ArmorSlot);
  ArmorMaterialType (__fastcall *getArmorMaterialTypeInSlot)(Actor *this, ArmorSlot);
  ArmorTextureType (__fastcall *getArmorMaterialTextureTypeInSlot)(Actor *this, ArmorSlot);
  float (__fastcall *getArmorColorInSlot)(Actor *this, ArmorSlot, int);
  const ItemStack *(__fastcall *getEquippedSlot)(Actor *this, EquipmentSlot);
  void (__fastcall *setEquippedSlot)(Actor *this, EquipmentSlot, const ItemStack *);
  const ItemStack *(__fastcall *getCarriedItem)(Actor *this);
  void (__fastcall *setCarriedItem)(Actor *this, const ItemStack *);
  void (__fastcall *setOffhandSlot)(Actor *this, const ItemStack *);
  const ItemStack *(__fastcall *getEquippedTotem)(Actor *this);
  bool (__fastcall *consumeTotem)(Actor *this);
  bool (__fastcall *save)(Actor *this, CompoundTag *);
  void (__fastcall *saveWithoutId)(Actor *this, CompoundTag *);
  bool (__fastcall *load)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *loadLinks)(Actor *this, const CompoundTag *, std::vector&lt;ActorLink&gt; *, DataLoadHelper *);
  ActorType (__fastcall *getEntityTypeId)(Actor *this);
  const HashedString *(__fastcall *queryEntityRenderer)(Actor *this);
  ActorUniqueID *(__fastcall *getSourceUniqueID)(Actor *this, ActorUniqueID *result);
  void (__fastcall *setOnFire)(Actor *this, int);
  AABB *(__fastcall *getHandleWaterAABB)(Actor *this, AABB *result);
  void (__fastcall *handleInsidePortal)(Actor *this, const BlockPos *);
  int (__fastcall *getPortalCooldown)(Actor *this);
  int (__fastcall *getPortalWaitTime)(Actor *this);
  AutomaticID&lt;Dimension,int&gt; *(__fastcall *getDimensionId)(Actor *this, AutomaticID&lt;Dimension,int&gt; *result);
  bool (__fastcall *canChangeDimensions)(Actor *this);
  void (__fastcall *changeDimension)(Actor *this, const ChangeDimensionPacket *);
  void (__fastcall *changeDimension)(Actor *this, AutomaticID&lt;Dimension,int&gt;, bool);
  ActorUniqueID *(__fastcall *getControllingPlayer)(Actor *this, ActorUniqueID *result);
  void (__fastcall *checkFallDamage)(Actor *this, float, bool);
  void (__fastcall *causeFallDamage)(Actor *this, float);
  void (__fastcall *handleFallDistanceOnServer)(Actor *this, float, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, int, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, const Block *, bool);
  void (__fastcall *onSynchedDataUpdate)(Actor *this, int);
  bool (__fastcall *canAddRider)(Actor *this, Actor *);
  bool (__fastcall *canPickupItem)(Actor *this, const ItemStack *);
  bool (__fastcall *canBePulledIntoVehicle)(Actor *this);
  bool (__fastcall *inCaravan)(Actor *this);
  bool (__fastcall *isLeashableType)(Actor *this);
  void (__fastcall *tickLeash)(Actor *this);
  void (__fastcall *sendMotionPacketIfNeeded)(Actor *this);
  bool (__fastcall *canSynchronizeNewEntity)(Actor *this);
  bool (__fastcall *stopRiding)(Actor *this, bool, bool, bool, bool);
  void (__fastcall *startSwimming)(Actor *this);
  void (__fastcall *stopSwimming)(Actor *this);
  void (__fastcall *buildDebugInfo)(Actor *this, std::string *);
  CommandPermissionLevel (__fastcall *getCommandPermissionLevel)(Actor *this);
  AttributeInstance *(__fastcall *getMutableAttribute)(Actor *this, const Attribute *);
  const AttributeInstance *(__fastcall *getAttribute)(Actor *this, const Attribute *);
  int (__fastcall *getDeathTime)(Actor *this);
  void (__fastcall *heal)(Actor *this, int);
  bool (__fastcall *isInvertedHealAndHarm)(Actor *this);
  bool (__fastcall *canBeAffected)(Actor *this, const MobEffectInstance *);
  bool (__fastcall *canBeAffected)(Actor *this, int);
  bool (__fastcall *canBeAffectedByArrow)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectAdded)(Actor *this, MobEffectInstance *);
  void (__fastcall *onEffectUpdated)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectRemoved)(Actor *this, MobEffectInstance *);
  AnimationComponent *(__fastcall *getAnimationComponent)(Actor *this);
  void (__fastcall *openContainerComponent)(Actor *this, Player *);
  void (__fastcall *swing)(Actor *this);
  void (__fastcall *useItem)(Actor *this, ItemStackBase *, ItemUseMethod, bool);
  bool (__fastcall *hasOutputSignal)(Actor *this, unsigned __int8);
  int (__fastcall *getOutputSignal)(Actor *this);
  void (__fastcall *getDebugText)(Actor *this, std::vector&lt;std::string&gt; *);
  float (__fastcall *getMapDecorationRotation)(Actor *this);
  float (__fastcall *getRiderYRotation)(Actor *this, const Actor *);
  float (__fastcall *getYHeadRot)(Actor *this);
  bool (__fastcall *isWorldBuilder)(Actor *this);
  bool (__fastcall *isCreative)(Actor *this);
  bool (__fastcall *isAdventure)(Actor *this);
  bool (__fastcall *add)(Actor *this, ItemStack *);
  bool (__fastcall *drop)(Actor *this, const ItemStack *, bool);
  bool (__fastcall *getInteraction)(Actor *this, Player *, ActorInteraction *, const Vec3 *);
  bool (__fastcall *canDestroyBlock)(Actor *this, const Block *);
  void (__fastcall *setAuxValue)(Actor *this, int);
  void (__fastcall *setSize)(Actor *this, float, float);
  int (__fastcall *getLifeSpan)(Actor *this);
  void (__fastcall *onOrphan)(Actor *this);
  void (__fastcall *wobble)(Actor *this);
  bool (__fastcall *wasHurt)(Actor *this);
  void (__fastcall *startSpinAttack)(Actor *this);
  void (__fastcall *stopSpinAttack)(Actor *this);
  void (__fastcall *setDamageNearbyMobs)(Actor *this, bool);
  bool (__fastcall *hasCritBox)(Actor *this);
  bool (__fastcall *isCritHit)(Actor *this);
  void (__fastcall *renderDebugServerState)(Actor *this, const Options *);
  void (__fastcall *reloadLootTable)(Actor *this, const EquipmentTableDefinition *);
  void (__fastcall *reloadLootTable)(Actor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(Actor *this);
  void (__fastcall *kill)(Actor *this);
  void (__fastcall *die)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *shouldTick)(Actor *this);
  std::shared_ptr&lt;IActorMovementProxy&gt; *(__fastcall *createMovementProxy)(Actor *this, std::shared_ptr&lt;IActorMovementProxy&gt; *result);
  void (__fastcall *updateEntitySpecificMolangVariables)(Actor *this, RenderParams *);
  bool (__fastcall *shouldTryMakeStepSound)(Actor *this);
  float (__fastcall *getNextStep)(Actor *this, const float);
  bool (__fastcall *canMakeStepSound)(Actor *this);
  void (__fastcall *outOfWorld)(Actor *this);
  bool (__fastcall *_hurt)(Actor *this, const ActorDamageSource *, int, bool, bool);
  void (__fastcall *markHurt)(Actor *this);
  void (__fastcall *readAdditionalSaveData)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *addAdditionalSaveData)(Actor *this, CompoundTag *);
  void (__fastcall *_playStepSound)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *_playFlySound)(Actor *this, const BlockPos *, const Block *);
  bool (__fastcall *_makeFlySound)(Actor *this);
  void (__fastcall *checkInsideBlocks)(Actor *this, float);
  void (__fastcall *pushOutOfBlocks)(Actor *this, const Vec3 *);
  bool (__fastcall *updateWaterState)(Actor *this);
  void (__fastcall *doWaterSplashEffect)(Actor *this);
  void (__fastcall *spawnTrailBubbles)(Actor *this);
  void (__fastcall *updateInsideBlock)(Actor *this);
  LootTable *(__fastcall *getLootTable)(Actor *this);
  LootTable *(__fastcall *getDefaultLootTable)(Actor *this);
  void (__fastcall *_removeRider)(Actor *this, const ActorUniqueID *, bool, bool, bool);
  void (__fastcall *_onSizeUpdated)(Actor *this);
  void (__fastcall *_doAutoAttackOnTouch)(Actor *this, Actor *);
};

</code></pre></div><h3 id="blaze"><a href="#blaze" class="header-anchor">#</a> <code>Blaze</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Blaze : Monster
{
  float mAllowedHeightOffset;
  int mNextHeightOffsetChangeTick;
};

</code></pre></div><h3 id="beaconpaymentcontainercontroller"><a href="#beaconpaymentcontainercontroller" class="header-anchor">#</a> <code>BeaconPaymentContainerController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BeaconPaymentContainerController : ContainerController
{
};

</code></pre></div><h3 id="beaconpaymentcontainercontroller-vtbl"><a href="#beaconpaymentcontainercontroller-vtbl" class="header-anchor">#</a> <code>BeaconPaymentContainerController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BeaconPaymentContainerController_vtbl
{
  void (__fastcall *~ContainerController)(ContainerController *this);
  bool (__fastcall *canRemove)(ContainerController *this, int, int);
  bool (__fastcall *isItemAllowed)(ContainerController *this, const ItemStackBase *);
  bool (__fastcall *isItemFiltered)(ContainerController *this, const Recipes *, const ItemStackBase *);
  int (__fastcall *getBackgroundStyle)(ContainerController *this, int, bool);
  ItemSetType (__fastcall *_canSet)(ContainerController *this, int, const ItemStackBase *, ItemTransferAmount);
  int (__fastcall *_getAvailableSetCount)(ContainerController *this, int, const ItemStackBase *);
  bool (__fastcall *_canRemove)(ContainerController *this, int, int);
  void (__fastcall *_onItemChanged)(ContainerController *this, int);
};

</code></pre></div><h3 id="blockreducer-vtbl"><a href="#blockreducer-vtbl" class="header-anchor">#</a> <code>BlockReducer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockReducer_vtbl
{
  void (__fastcall *~BlockReducer)(BlockReducer *this);
  void (__fastcall *_registerBlock)(BlockReducer *this, const ItemStack *, std::vector&lt;ItemStack&gt; *);
};

</code></pre></div><h3 id="bedrock-nonownerpointer-itemstackrequestactioncraftresults-deprecatedasktylaing"><a href="#bedrock-nonownerpointer-itemstackrequestactioncraftresults-deprecatedasktylaing" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;ItemStackRequestActionCraftResults_DEPRECATEDASKTYLAING&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;ItemStackRequestActionCraftResults_DEPRECATEDASKTYLAING&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="blockeventtracker"><a href="#blockeventtracker" class="header-anchor">#</a> <code>BlockEventTracker</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockEventTracker : BlockSourceListener
{
  std::unordered_map&lt;BlockPos,Block const &amp;&gt; mBlockChangesMap;
  std::unordered_map&lt;BlockPos,Block const &amp;&gt; mExtraBlockChangesMap;
  std::mutex mMapMutex;
};

</code></pre></div><h3 id="blockeventtracker-vtbl"><a href="#blockeventtracker-vtbl" class="header-anchor">#</a> <code>BlockEventTracker_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockEventTracker_vtbl
{
  void (__fastcall *~BlockSourceListener)(BlockSourceListener *this);
  void (__fastcall *onSourceCreated)(BlockSourceListener *this, BlockSource *);
  void (__fastcall *onSourceDestroyed)(BlockSourceListener *this, BlockSource *);
  void (__fastcall *onAreaChanged)(BlockSourceListener *this, BlockSource *, const BlockPos *, const BlockPos *);
  void (__fastcall *onBlockChanged)(BlockSourceListener *this, BlockSource *, const BlockPos *, unsigned int, const Block *, const Block *, int, const ActorBlockSyncMessage *);
  void (__fastcall *onBrightnessChanged)(BlockSourceListener *this, BlockSource *, const BlockPos *);
  void (__fastcall *onBlockEntityChanged)(BlockSourceListener *this, BlockSource *, BlockActor *);
  void (__fastcall *onBlockEntityAboutToBeRemoved)(BlockSourceListener *this, BlockSource *, std::shared_ptr&lt;BlockActor&gt;);
  void (__fastcall *onEntityChanged)(BlockSourceListener *this, BlockSource *, Actor *);
  void (__fastcall *onBlockEvent)(BlockSourceListener *this, BlockSource *, int, int, int, int, int);
};

</code></pre></div><h3 id="blockeventcoordinator-sendunknownblockreceived-l2-lambda-f6f042af8191ca65bf8adc7717dcf957"><a href="#blockeventcoordinator-sendunknownblockreceived-l2-lambda-f6f042af8191ca65bf8adc7717dcf957" class="header-anchor">#</a> <code>BlockEventCoordinator::sendUnknownBlockReceived::__l2::&lt;lambda_f6f042af8191ca65bf8adc7717dcf957&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockEventCoordinator::sendUnknownBlockReceived::__l2::&lt;lambda_f6f042af8191ca65bf8adc7717dcf957&gt;
{
  Level *level;
  const NewBlockID *blockId;
  unsigned __int16 data;
};

</code></pre></div><h3 id="blockeventcoordinator-sendblockexploded-l2-lambda-848cdfb5e8da833dbc0dcc7f87da5a4f"><a href="#blockeventcoordinator-sendblockexploded-l2-lambda-848cdfb5e8da833dbc0dcc7f87da5a4f" class="header-anchor">#</a> <code>BlockEventCoordinator::sendBlockExploded::__l2::&lt;lambda_848cdfb5e8da833dbc0dcc7f87da5a4f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockEventCoordinator::sendBlockExploded::__l2::&lt;lambda_848cdfb5e8da833dbc0dcc7f87da5a4f&gt;
{
  const BlockPos *blockPos;
  const Block *destroyedBlock;
  Actor **source;
};

</code></pre></div><h3 id="blockeventcoordinator-sendblockinteractedwith-l2-lambda-a33e208c0cd2aef60e110b74b695498d"><a href="#blockeventcoordinator-sendblockinteractedwith-l2-lambda-a33e208c0cd2aef60e110b74b695498d" class="header-anchor">#</a> <code>BlockEventCoordinator::sendBlockInteractedWith::__l2::&lt;lambda_a33e208c0cd2aef60e110b74b695498d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockEventCoordinator::sendBlockInteractedWith::__l2::&lt;lambda_a33e208c0cd2aef60e110b74b695498d&gt;
{
  Player *player;
  const BlockPos *blockPos;
};

</code></pre></div><h3 id="blockeventcoordinator-sendblockdestructionstarted-l2-lambda-45a6a2b7778b47f799f30451c24f4705"><a href="#blockeventcoordinator-sendblockdestructionstarted-l2-lambda-45a6a2b7778b47f799f30451c24f4705" class="header-anchor">#</a> <code>BlockEventCoordinator::sendBlockDestructionStarted::__l2::&lt;lambda_45a6a2b7778b47f799f30451c24f4705&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockEventCoordinator::sendBlockDestructionStarted::__l2::&lt;lambda_45a6a2b7778b47f799f30451c24f4705&gt;
{
  Player *player;
  const BlockPos *blockPos;
};

</code></pre></div><h3 id="blockeventcoordinator-sendblockdestructionstopped-l2-lambda-b9d39bcdda4ef5e1d13e651401ee6702"><a href="#blockeventcoordinator-sendblockdestructionstopped-l2-lambda-b9d39bcdda4ef5e1d13e651401ee6702" class="header-anchor">#</a> <code>BlockEventCoordinator::sendBlockDestructionStopped::__l2::&lt;lambda_b9d39bcdda4ef5e1d13e651401ee6702&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockEventCoordinator::sendBlockDestructionStopped::__l2::&lt;lambda_b9d39bcdda4ef5e1d13e651401ee6702&gt;
{
  Player *player;
  const BlockPos *blockPos;
  int *progress;
};

</code></pre></div><h3 id="blockeventcoordinator-sendblockmovedbypiston-l2-lambda-9a6aa89b570a5b9cc497ec2fa821185c"><a href="#blockeventcoordinator-sendblockmovedbypiston-l2-lambda-9a6aa89b570a5b9cc497ec2fa821185c" class="header-anchor">#</a> <code>BlockEventCoordinator::sendBlockMovedByPiston::__l2::&lt;lambda_9a6aa89b570a5b9cc497ec2fa821185c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockEventCoordinator::sendBlockMovedByPiston::__l2::&lt;lambda_9a6aa89b570a5b9cc497ec2fa821185c&gt;
{
  const BlockPos *pistonPos;
  const BlockPos *blockPos;
  const PistonBlockActor::PistonState *action;
};

</code></pre></div><h3 id="blockeventcoordinator-sendblockdestroyedbyplayer-l2-lambda-b770ae23f89ec602603799970f9877a0"><a href="#blockeventcoordinator-sendblockdestroyedbyplayer-l2-lambda-b770ae23f89ec602603799970f9877a0" class="header-anchor">#</a> <code>BlockEventCoordinator::sendBlockDestroyedByPlayer::__l2::&lt;lambda_b770ae23f89ec602603799970f9877a0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockEventCoordinator::sendBlockDestroyedByPlayer::__l2::&lt;lambda_b770ae23f89ec602603799970f9877a0&gt;
{
  Player *player;
  const std::string *destroyedBlock;
  const BlockPos *pos;
};

</code></pre></div><h3 id="blockeventcoordinator-sendblockplacedbyplayer-l2-lambda-04b45a6d32fc9beb76aef0d7f48ebe01"><a href="#blockeventcoordinator-sendblockplacedbyplayer-l2-lambda-04b45a6d32fc9beb76aef0d7f48ebe01" class="header-anchor">#</a> <code>BlockEventCoordinator::sendBlockPlacedByPlayer::__l2::&lt;lambda_04b45a6d32fc9beb76aef0d7f48ebe01&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockEventCoordinator::sendBlockPlacedByPlayer::__l2::&lt;lambda_04b45a6d32fc9beb76aef0d7f48ebe01&gt;
{
  Player *player;
  const Block *placedBlock;
  const BlockPos *pos;
  bool isUnderwater;
};

</code></pre></div><h3 id="blockisnametest"><a href="#blockisnametest" class="header-anchor">#</a> <code>BlockIsNameTest</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockIsNameTest : SimpleHashStringFilterTest
{
};

</code></pre></div><h3 id="blockisnametest-vtbl"><a href="#blockisnametest-vtbl" class="header-anchor">#</a> <code>BlockIsNameTest_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockIsNameTest_vtbl
{
  void (__fastcall *~FilterTest)(FilterTest *this);
  bool (__fastcall *setup)(FilterTest *this, const FilterTest::Definition *, const FilterInputs *);
  bool (__fastcall *evaluate)(FilterTest *this, const FilterContext *);
  void (__fastcall *finalizeParsedValue)(FilterTest *this, IWorldRegistriesProvider *);
  gsl::basic_string_span&lt;char const ,-1&gt; *(__fastcall *getName)(FilterTest *this, gsl::basic_string_span&lt;char const ,-1&gt; *result);
  Json::Value *(__fastcall *_serializeDomain)(FilterTest *this, Json::Value *result);
  Json::Value *(__fastcall *_serializeValue)(FilterTest *this, Json::Value *result);
};

</code></pre></div><h3 id="bambooblockitem"><a href="#bambooblockitem" class="header-anchor">#</a> <code>BambooBlockItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BambooBlockItem : BlockItem
{
};

</code></pre></div><h3 id="banneritem"><a href="#banneritem" class="header-anchor">#</a> <code>BannerItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BannerItem : Item
{
};

</code></pre></div><h3 id="bannerpatternitem"><a href="#bannerpatternitem" class="header-anchor">#</a> <code>BannerPatternItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BannerPatternItem : Item
{
  BannerPatternItem::Type mType;
};

</code></pre></div><h3 id="beditem"><a href="#beditem" class="header-anchor">#</a> <code>BedItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BedItem : Item
{
  TextureAtlasItem m_uvTextureItem;
};

</code></pre></div><h3 id="bellblockitem"><a href="#bellblockitem" class="header-anchor">#</a> <code>BellBlockItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BellBlockItem : BlockItem
{
};

</code></pre></div><h3 id="bellblock"><a href="#bellblock" class="header-anchor">#</a> <code>BellBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BellBlock : ActorBlock
{
};

</code></pre></div><h3 id="bellblock-vtbl"><a href="#bellblock-vtbl" class="header-anchor">#</a> <code>BellBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BellBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
};

</code></pre></div><h3 id="boatitem"><a href="#boatitem" class="header-anchor">#</a> <code>BoatItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BoatItem : Item
{
  WoodType mWoodType;
  TextureAtlasItem m_uvTextureItem;
};

</code></pre></div><h3 id="bottleitem"><a href="#bottleitem" class="header-anchor">#</a> <code>BottleItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BottleItem : Item
{
};

</code></pre></div><h3 id="blockplanteritem-useon-l8-lambda-dafc49cfe85b6ec4610f185da06c6323"><a href="#blockplanteritem-useon-l8-lambda-dafc49cfe85b6ec4610f185da06c6323" class="header-anchor">#</a> <code>BlockPlanterItem::_useOn::__l8::&lt;lambda_dafc49cfe85b6ec4610f185da06c6323&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockPlanterItem::_useOn::__l8::&lt;lambda_dafc49cfe85b6ec4610f185da06c6323&gt;
{
  BlockPos *pos;
  const Block *placedBlock;
  const CompoundTag *dataID;
  Actor *entity;
  unsigned __int8 *face;
  bool *canceled;
};

</code></pre></div><h3 id="blockitem-useon-l61-lambda-3df6778bcdd597be9284d46d0b403515"><a href="#blockitem-useon-l61-lambda-3df6778bcdd597be9284d46d0b403515" class="header-anchor">#</a> <code>BlockItem::_useOn::__l61::&lt;lambda_3df6778bcdd597be9284d46d0b403515&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockItem::_useOn::__l61::&lt;lambda_3df6778bcdd597be9284d46d0b403515&gt;
{
  BlockPos *pos;
  const Block **placedBlock;
  const CompoundTag *dataID;
  Actor *entity;
  unsigned __int8 *face;
};

</code></pre></div><h3 id="blockitem-useon-l17-lambda-76337a7577d3a09baa0857f2aa986cfe"><a href="#blockitem-useon-l17-lambda-76337a7577d3a09baa0857f2aa986cfe" class="header-anchor">#</a> <code>BlockItem::_useOn::__l17::&lt;lambda_76337a7577d3a09baa0857f2aa986cfe&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockItem::_useOn::__l17::&lt;lambda_76337a7577d3a09baa0857f2aa986cfe&gt;
{
  BlockPos *pos;
  const Block **placedBlock;
  const CompoundTag *dataID;
  Actor *entity;
  unsigned __int8 *face;
  bool *canceled;
};

</code></pre></div><h3 id="bambooblockitem-useon-l44-lambda-ceb2dedadc834c479cf92b2081c39bd1"><a href="#bambooblockitem-useon-l44-lambda-ceb2dedadc834c479cf92b2081c39bd1" class="header-anchor">#</a> <code>BambooBlockItem::_useOn::__l44::&lt;lambda_ceb2dedadc834c479cf92b2081c39bd1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BambooBlockItem::_useOn::__l44::&lt;lambda_ceb2dedadc834c479cf92b2081c39bd1&gt;
{
  BlockPos *pos;
  const CompoundTag *dataID;
  Actor *entity;
  unsigned __int8 *face;
  bool *canceled;
};

</code></pre></div><h3 id="bowitem"><a href="#bowitem" class="header-anchor">#</a> <code>BowItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BowItem : RangedWeaponItem
{
  TextureUVCoordinateSet mFrame[3];
};

</code></pre></div><h3 id="bowenchant"><a href="#bowenchant" class="header-anchor">#</a> <code>BowEnchant</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BowEnchant : Enchant
{
};

</code></pre></div><h3 id="bowenchant-vtbl"><a href="#bowenchant-vtbl" class="header-anchor">#</a> <code>BowEnchant_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BowEnchant_vtbl
{
  void (__fastcall *~Enchant)(Enchant *this);
  bool (__fastcall *isCompatibleWith)(Enchant *this, Enchant::Type);
  int (__fastcall *getMinCost)(Enchant *this, int);
  int (__fastcall *getMaxCost)(Enchant *this, int);
  int (__fastcall *getMinLevel)(Enchant *this);
  int (__fastcall *getMaxLevel)(Enchant *this);
  int (__fastcall *getDamageProtection)(Enchant *this, int, const ActorDamageSource *);
  float (__fastcall *getDamageBonus)(Enchant *this, int, const Actor *);
  void (__fastcall *doPostAttack)(Enchant *this, Actor *, Actor *, int);
  void (__fastcall *doPostHurt)(Enchant *this, ItemInstance *, Actor *, Actor *, int);
  bool (__fastcall *isMeleeDamageEnchant)(Enchant *this);
  bool (__fastcall *isProtectionEnchant)(Enchant *this);
  bool (__fastcall *isTreasureOnly)(Enchant *this);
  bool (__fastcall *isDiscoverable)(Enchant *this);
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-2c33b9a3c940e38e331beb3951273cfb"><a href="#biomecomponentloading-buildschema-l2-lambda-2c33b9a3c940e38e331beb3951273cfb" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_2c33b9a3c940e38e331beb3951273cfb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_2c33b9a3c940e38e331beb3951273cfb&gt;
{
  std::function&lt;ClimateAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-986ad8af33ac3ed9626d4e4c93db052f"><a href="#biomecomponentloading-buildschema-l2-lambda-986ad8af33ac3ed9626d4e4c93db052f" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_986ad8af33ac3ed9626d4e4c93db052f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_986ad8af33ac3ed9626d4e4c93db052f&gt;
{
  std::function&lt;ClimateAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-4043dd1967c51e1afe0bf9b59d10806d"><a href="#biomecomponentloading-buildschema-l2-lambda-4043dd1967c51e1afe0bf9b59d10806d" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_4043dd1967c51e1afe0bf9b59d10806d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_4043dd1967c51e1afe0bf9b59d10806d&gt;
{
  std::function&lt;ClimateAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-70b1c8711f1412db1910c25a69dbcc73"><a href="#biomecomponentloading-buildschema-l2-lambda-70b1c8711f1412db1910c25a69dbcc73" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_70b1c8711f1412db1910c25a69dbcc73&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_70b1c8711f1412db1910c25a69dbcc73&gt;
{
  std::function&lt;ClimateAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-9f92eafcdd93e111d6dcc461b580b677"><a href="#biomecomponentloading-buildschema-l2-lambda-9f92eafcdd93e111d6dcc461b580b677" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_9f92eafcdd93e111d6dcc461b580b677&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_9f92eafcdd93e111d6dcc461b580b677&gt;
{
  std::function&lt;ClimateAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-74b06c550f1d03282e6811d3a149df1d"><a href="#biomecomponentloading-buildschema-l2-lambda-74b06c550f1d03282e6811d3a149df1d" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_74b06c550f1d03282e6811d3a149df1d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_74b06c550f1d03282e6811d3a149df1d&gt;
{
  std::function&lt;ClimateAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-3de2852c01811dbb30ee8e9819bb06d2"><a href="#biomecomponentloading-buildschema-l2-lambda-3de2852c01811dbb30ee8e9819bb06d2" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_3de2852c01811dbb30ee8e9819bb06d2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_3de2852c01811dbb30ee8e9819bb06d2&gt;
{
  std::function&lt;ClimateAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-47d3ebb4fbf9d771bb39ed1ef100b972"><a href="#biomecomponentloading-buildschema-l2-lambda-47d3ebb4fbf9d771bb39ed1ef100b972" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_47d3ebb4fbf9d771bb39ed1ef100b972&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_47d3ebb4fbf9d771bb39ed1ef100b972&gt;
{
  std::function&lt;ClimateAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-588cbba04482f56d12cfb2e5c6cae432-l2-lambda-0e9e988f4be8fccbf1f02bb6d99a088d"><a href="#biomecomponentloading-buildschema-l2-lambda-588cbba04482f56d12cfb2e5c6cae432-l2-lambda-0e9e988f4be8fccbf1f02bb6d99a088d" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_588cbba04482f56d12cfb2e5c6cae432&gt;::()::__l2::&lt;lambda_0e9e988f4be8fccbf1f02bb6d99a088d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_588cbba04482f56d12cfb2e5c6cae432&gt;::()::__l2::&lt;lambda_0e9e988f4be8fccbf1f02bb6d99a088d&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-588cbba04482f56d12cfb2e5c6cae432-l2-lambda-a4a8160f33e1a57e394012deaba8bba7"><a href="#biomecomponentloading-buildschema-l2-lambda-588cbba04482f56d12cfb2e5c6cae432-l2-lambda-a4a8160f33e1a57e394012deaba8bba7" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_588cbba04482f56d12cfb2e5c6cae432&gt;::()::__l2::&lt;lambda_a4a8160f33e1a57e394012deaba8bba7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_588cbba04482f56d12cfb2e5c6cae432&gt;::()::__l2::&lt;lambda_a4a8160f33e1a57e394012deaba8bba7&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-588cbba04482f56d12cfb2e5c6cae432-l2-lambda-24781fac43e82524bfe294929ffcbc02"><a href="#biomecomponentloading-buildschema-l2-lambda-588cbba04482f56d12cfb2e5c6cae432-l2-lambda-24781fac43e82524bfe294929ffcbc02" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_588cbba04482f56d12cfb2e5c6cae432&gt;::()::__l2::&lt;lambda_24781fac43e82524bfe294929ffcbc02&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_588cbba04482f56d12cfb2e5c6cae432&gt;::()::__l2::&lt;lambda_24781fac43e82524bfe294929ffcbc02&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-588cbba04482f56d12cfb2e5c6cae432-l2-lambda-be3876604811fcef7cc22dea8bb87277"><a href="#biomecomponentloading-buildschema-l2-lambda-588cbba04482f56d12cfb2e5c6cae432-l2-lambda-be3876604811fcef7cc22dea8bb87277" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_588cbba04482f56d12cfb2e5c6cae432&gt;::()::__l2::&lt;lambda_be3876604811fcef7cc22dea8bb87277&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_588cbba04482f56d12cfb2e5c6cae432&gt;::()::__l2::&lt;lambda_be3876604811fcef7cc22dea8bb87277&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-588cbba04482f56d12cfb2e5c6cae432-l2-lambda-587dadbdd7697181135b67ed601fb42d"><a href="#biomecomponentloading-buildschema-l2-lambda-588cbba04482f56d12cfb2e5c6cae432-l2-lambda-587dadbdd7697181135b67ed601fb42d" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_588cbba04482f56d12cfb2e5c6cae432&gt;::()::__l2::&lt;lambda_587dadbdd7697181135b67ed601fb42d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_588cbba04482f56d12cfb2e5c6cae432&gt;::()::__l2::&lt;lambda_587dadbdd7697181135b67ed601fb42d&gt;
{
};

</code></pre></div><h3 id="biomemetadata"><a href="#biomemetadata" class="header-anchor">#</a> <code>BiomeMetadata</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeMetadata
{
  std::string mName;
  std::string mInherits;
  Json::Value mLocalComponents;
};

</code></pre></div><h3 id="biomeregistrymergestrategy"><a href="#biomeregistrymergestrategy" class="header-anchor">#</a> <code>BiomeRegistryMergeStrategy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeRegistryMergeStrategy : ResourcePackMergeStrategy
{
  Core::PathBuffer&lt;std::string &gt; mBiomePath;
  Json::Value *mRoot;
};

</code></pre></div><h3 id="biomeregistrymergestrategy-vtbl"><a href="#biomeregistrymergestrategy-vtbl" class="header-anchor">#</a> <code>BiomeRegistryMergeStrategy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BiomeRegistryMergeStrategy_vtbl
{
  void (__fastcall *~ResourcePackMergeStrategy)(ResourcePackMergeStrategy *this);
  void (__fastcall *mergeFiles)(ResourcePackMergeStrategy *this, const std::vector&lt;LoadedResourceData&gt; *);
};

</code></pre></div><h3 id="biomesource-vtbl"><a href="#biomesource-vtbl" class="header-anchor">#</a> <code>BiomeSource_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BiomeSource_vtbl
{
  void (__fastcall *~BiomeSource)(BiomeSource *this);
  void (__fastcall *fillBiomes)(BiomeSource *this, LevelChunk *);
  BiomeArea *(__fastcall *getBiomeArea)(BiomeSource *this, BiomeArea *result, const BoundingBox *, unsigned int);
  bool (__fastcall *containsOnly)(BiomeSource *this, int, int, int, gsl::span&lt;int const ,-1&gt;);
  const Biome *(__fastcall *getBiome)(BiomeSource *this, int, int);
};

</code></pre></div><h3 id="biomeregistry-initmoddimensions-l6-lambda-1fcb4717fe6be111942f2205fbc1a668"><a href="#biomeregistry-initmoddimensions-l6-lambda-1fcb4717fe6be111942f2205fbc1a668" class="header-anchor">#</a> <code>BiomeRegistry::initModDimensions::__l6::&lt;lambda_1fcb4717fe6be111942f2205fbc1a668&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeRegistry::initModDimensions::__l6::&lt;lambda_1fcb4717fe6be111942f2205fbc1a668&gt;
{
};

</code></pre></div><h3 id="biomeregistry-loadonedimension-l2-lambda-c1d36d2c0e755f6d6cc7f448cdf58979"><a href="#biomeregistry-loadonedimension-l2-lambda-c1d36d2c0e755f6d6cc7f448cdf58979" class="header-anchor">#</a> <code>BiomeRegistry::_loadOneDimension::__l2::&lt;lambda_c1d36d2c0e755f6d6cc7f448cdf58979&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeRegistry::_loadOneDimension::__l2::&lt;lambda_c1d36d2c0e755f6d6cc7f448cdf58979&gt;
{
  std::vector&lt;std::string&gt; *biomesToLoad;
};

</code></pre></div><h3 id="biomeregistry-initserverfrominheritancetree-l2-lambda-6c6a66314c67757f5c65376080a34747"><a href="#biomeregistry-initserverfrominheritancetree-l2-lambda-6c6a66314c67757f5c65376080a34747" class="header-anchor">#</a> <code>BiomeRegistry::_initServerFromInheritanceTree::__l2::&lt;lambda_6c6a66314c67757f5c65376080a34747&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeRegistry::_initServerFromInheritanceTree::__l2::&lt;lambda_6c6a66314c67757f5c65376080a34747&gt;
{
  BiomeRegistry *const __this;
  InheritanceTree&lt;BiomeRegistry::BiomeParent&gt; *inheritance;
  IWorldRegistriesProvider *worldRegistries;
};

</code></pre></div><h3 id="biomeregistry-mergedatainheritance-l5-lambda-2aa0ea63de42f370212b65a4b11b230e"><a href="#biomeregistry-mergedatainheritance-l5-lambda-2aa0ea63de42f370212b65a4b11b230e" class="header-anchor">#</a> <code>BiomeRegistry::_mergeDataInheritance::__l5::&lt;lambda_2aa0ea63de42f370212b65a4b11b230e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeRegistry::_mergeDataInheritance::__l5::&lt;lambda_2aa0ea63de42f370212b65a4b11b230e&gt;
{
  BiomeRegistry *const __this;
  Json::Value *mergeInto;
  InheritanceTree&lt;BiomeRegistry::BiomeParent&gt; *inheritance;
};

</code></pre></div><h3 id="biomeregistry-buildinheritancetree-l4-lambda-0d4594063b6df1dd593fd643071b49c0"><a href="#biomeregistry-buildinheritancetree-l4-lambda-0d4594063b6df1dd593fd643071b49c0" class="header-anchor">#</a> <code>BiomeRegistry::_buildInheritanceTree::__l4::&lt;lambda_0d4594063b6df1dd593fd643071b49c0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeRegistry::_buildInheritanceTree::__l4::&lt;lambda_0d4594063b6df1dd593fd643071b49c0&gt;
{
  std::vector&lt;std::string&gt; *biomesToLoad;
};

</code></pre></div><h3 id="biomeregistry-buildinheritancetree-l2-lambda-3891362f1148dfaff1fd5eb8cc4a95f6"><a href="#biomeregistry-buildinheritancetree-l2-lambda-3891362f1148dfaff1fd5eb8cc4a95f6" class="header-anchor">#</a> <code>BiomeRegistry::_buildInheritanceTree::__l2::&lt;lambda_3891362f1148dfaff1fd5eb8cc4a95f6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeRegistry::_buildInheritanceTree::__l2::&lt;lambda_3891362f1148dfaff1fd5eb8cc4a95f6&gt;
{
  std::vector&lt;std::string&gt; *biomesToLoad;
};

</code></pre></div><h3 id="biomeregistry-initclientfrompacks-l16-lambda-12d4c7037bf9214c92b1365a74424493"><a href="#biomeregistry-initclientfrompacks-l16-lambda-12d4c7037bf9214c92b1365a74424493" class="header-anchor">#</a> <code>BiomeRegistry::initClientFromPacks::__l16::&lt;lambda_12d4c7037bf9214c92b1365a74424493&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeRegistry::initClientFromPacks::__l16::&lt;lambda_12d4c7037bf9214c92b1365a74424493&gt;
{
  const Json::Value *root;
  const Json::Value *defaultJson;
  gsl::not_null&lt;Bedrock::NonOwnerPointer&lt;FogDefinitionRegistry&gt; &gt; *fogRegistry;
};

</code></pre></div><h3 id="biomeregistry-getmergestrategy-l2-lambda-a54dc79f09743eeb2de26dc51679844e"><a href="#biomeregistry-getmergestrategy-l2-lambda-a54dc79f09743eeb2de26dc51679844e" class="header-anchor">#</a> <code>BiomeRegistry::getMergeStrategy::__l2::&lt;lambda_a54dc79f09743eeb2de26dc51679844e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeRegistry::getMergeStrategy::__l2::&lt;lambda_a54dc79f09743eeb2de26dc51679844e&gt;
{
};

</code></pre></div><h3 id="biomecomponentfactory-registrationfinished-l2-lambda-14fdba31cb0ef81d6cd5c2760c9d1928"><a href="#biomecomponentfactory-registrationfinished-l2-lambda-14fdba31cb0ef81d6cd5c2760c9d1928" class="header-anchor">#</a> <code>BiomeComponentFactory::registrationFinished::__l2::&lt;lambda_14fdba31cb0ef81d6cd5c2760c9d1928&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentFactory::registrationFinished::__l2::&lt;lambda_14fdba31cb0ef81d6cd5c2760c9d1928&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-9cae496891550c5a044677317c96b590"><a href="#biomecomponentloading-buildschema-l2-lambda-9cae496891550c5a044677317c96b590" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_9cae496891550c5a044677317c96b590&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_9cae496891550c5a044677317c96b590&gt;
{
  std::function&lt;WorldGenMultiNoiseClimateAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-31f6d7ef5e86b9004496c6c5438bebc3"><a href="#biomecomponentloading-buildschema-l2-lambda-31f6d7ef5e86b9004496c6c5438bebc3" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_31f6d7ef5e86b9004496c6c5438bebc3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_31f6d7ef5e86b9004496c6c5438bebc3&gt;
{
  std::function&lt;WorldGenMultiNoiseClimateAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-d5c8386347dd70773df6f7b0e51aa0f4"><a href="#biomecomponentloading-buildschema-l2-lambda-d5c8386347dd70773df6f7b0e51aa0f4" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_d5c8386347dd70773df6f7b0e51aa0f4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_d5c8386347dd70773df6f7b0e51aa0f4&gt;
{
  std::function&lt;WorldGenMultiNoiseClimateAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-e62c1925c1af6d050260328ca3a20417"><a href="#biomecomponentloading-buildschema-l2-lambda-e62c1925c1af6d050260328ca3a20417" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_e62c1925c1af6d050260328ca3a20417&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_e62c1925c1af6d050260328ca3a20417&gt;
{
  std::function&lt;WorldGenMultiNoiseClimateAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-fdb3f7f0568767171627b654bfa20245"><a href="#biomecomponentloading-buildschema-l2-lambda-fdb3f7f0568767171627b654bfa20245" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_fdb3f7f0568767171627b654bfa20245&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_fdb3f7f0568767171627b654bfa20245&gt;
{
  std::function&lt;WorldGenMultiNoiseClimateAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-00c3dfeb26715b95f766f45ae45a4b8a"><a href="#biomecomponentloading-buildschema-l2-lambda-00c3dfeb26715b95f766f45ae45a4b8a" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_00c3dfeb26715b95f766f45ae45a4b8a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_00c3dfeb26715b95f766f45ae45a4b8a&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-1c9a498ad1009e5bb757ec0164b4df00"><a href="#biomecomponentloading-buildschema-l2-lambda-1c9a498ad1009e5bb757ec0164b4df00" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_1c9a498ad1009e5bb757ec0164b4df00&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_1c9a498ad1009e5bb757ec0164b4df00&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-4b8343632b080be1f205b1998080acc9"><a href="#biomecomponentloading-buildschema-l2-lambda-4b8343632b080be1f205b1998080acc9" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_4b8343632b080be1f205b1998080acc9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_4b8343632b080be1f205b1998080acc9&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-de44ce577397417461fc346b323847d9"><a href="#biomecomponentloading-buildschema-l2-lambda-de44ce577397417461fc346b323847d9" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_de44ce577397417461fc346b323847d9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_de44ce577397417461fc346b323847d9&gt;
{
  std::function&lt;WorldGenClimateMappingAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-a7b07a0bb8678bcc8099e3b5561ab8de"><a href="#biomecomponentloading-buildschema-l2-lambda-a7b07a0bb8678bcc8099e3b5561ab8de" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_a7b07a0bb8678bcc8099e3b5561ab8de&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_a7b07a0bb8678bcc8099e3b5561ab8de&gt;
{
  std::function&lt;OverworldHeightAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-6f5dd31b8d509c3ea58a2e27e5121198"><a href="#biomecomponentloading-buildschema-l2-lambda-6f5dd31b8d509c3ea58a2e27e5121198" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_6f5dd31b8d509c3ea58a2e27e5121198&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_6f5dd31b8d509c3ea58a2e27e5121198&gt;
{
  std::function&lt;OverworldHeightAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-647b9dafc48ef4fe7d2bc246cd3fa37f"><a href="#biomecomponentloading-buildschema-l2-lambda-647b9dafc48ef4fe7d2bc246cd3fa37f" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_647b9dafc48ef4fe7d2bc246cd3fa37f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_647b9dafc48ef4fe7d2bc246cd3fa37f&gt;
{
  std::function&lt;OverworldHeightAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-071d75551199967bfd308b1ccaeba427"><a href="#biomecomponentloading-buildschema-l2-lambda-071d75551199967bfd308b1ccaeba427" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_071d75551199967bfd308b1ccaeba427&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_071d75551199967bfd308b1ccaeba427&gt;
{
  std::function&lt;OverworldHeightAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-13fcf2973c4f4959793e47b98a4fe16d"><a href="#biomecomponentloading-buildschema-l2-lambda-13fcf2973c4f4959793e47b98a4fe16d" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_13fcf2973c4f4959793e47b98a4fe16d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_13fcf2973c4f4959793e47b98a4fe16d&gt;
{
  std::function&lt;SurfaceMaterialAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-ebf5a741828bce024289db8a9317073c"><a href="#biomecomponentloading-buildschema-l2-lambda-ebf5a741828bce024289db8a9317073c" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_ebf5a741828bce024289db8a9317073c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_ebf5a741828bce024289db8a9317073c&gt;
{
  std::function&lt;SurfaceMaterialAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-6702ad38bcdce54fbd866d895e5bdde3"><a href="#biomecomponentloading-buildschema-l2-lambda-6702ad38bcdce54fbd866d895e5bdde3" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_6702ad38bcdce54fbd866d895e5bdde3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_6702ad38bcdce54fbd866d895e5bdde3&gt;
{
  std::function&lt;SurfaceMaterialAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-7c35618b9151048fb5f40c044803f09b"><a href="#biomecomponentloading-buildschema-l2-lambda-7c35618b9151048fb5f40c044803f09b" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_7c35618b9151048fb5f40c044803f09b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_7c35618b9151048fb5f40c044803f09b&gt;
{
  std::function&lt;SurfaceMaterialAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-5573650260b13fa6c75ed850cb3b791d"><a href="#biomecomponentloading-buildschema-l2-lambda-5573650260b13fa6c75ed850cb3b791d" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_5573650260b13fa6c75ed850cb3b791d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_5573650260b13fa6c75ed850cb3b791d&gt;
{
  std::function&lt;SurfaceMaterialAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-079223d09d7929335bbdc5ee3051db02"><a href="#biomecomponentloading-buildschema-l2-lambda-079223d09d7929335bbdc5ee3051db02" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_079223d09d7929335bbdc5ee3051db02&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_079223d09d7929335bbdc5ee3051db02&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-317f0cb0ca88680b14d95e0d23e2b481"><a href="#biomecomponentloading-buildschema-l2-lambda-317f0cb0ca88680b14d95e0d23e2b481" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_317f0cb0ca88680b14d95e0d23e2b481&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_317f0cb0ca88680b14d95e0d23e2b481&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-521c942abe59445dc605c74e5770790b"><a href="#biomecomponentloading-buildschema-l2-lambda-521c942abe59445dc605c74e5770790b" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_521c942abe59445dc605c74e5770790b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_521c942abe59445dc605c74e5770790b&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-14139a2735e3e592c1254ac860a3050e"><a href="#biomecomponentloading-buildschema-l2-lambda-14139a2735e3e592c1254ac860a3050e" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_14139a2735e3e592c1254ac860a3050e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_14139a2735e3e592c1254ac860a3050e&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-79909220629f22558cb770a16046cdb7"><a href="#biomecomponentloading-buildschema-l2-lambda-79909220629f22558cb770a16046cdb7" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_79909220629f22558cb770a16046cdb7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_79909220629f22558cb770a16046cdb7&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-f88a4512ffe5a7d91ed9ab1ed8900771"><a href="#biomecomponentloading-buildschema-l2-lambda-f88a4512ffe5a7d91ed9ab1ed8900771" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_f88a4512ffe5a7d91ed9ab1ed8900771&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_f88a4512ffe5a7d91ed9ab1ed8900771&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-aa5cfd92a64dfd72bd49549d0bd77884"><a href="#biomecomponentloading-buildschema-l2-lambda-aa5cfd92a64dfd72bd49549d0bd77884" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_aa5cfd92a64dfd72bd49549d0bd77884&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_aa5cfd92a64dfd72bd49549d0bd77884&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-7c49cd51b0ff49fc379b3c623d7100e7"><a href="#biomecomponentloading-buildschema-l2-lambda-7c49cd51b0ff49fc379b3c623d7100e7" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_7c49cd51b0ff49fc379b3c623d7100e7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_7c49cd51b0ff49fc379b3c623d7100e7&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-8ade96da80901bc7101fd7b815724e12"><a href="#biomecomponentloading-buildschema-l2-lambda-8ade96da80901bc7101fd7b815724e12" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_8ade96da80901bc7101fd7b815724e12&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_8ade96da80901bc7101fd7b815724e12&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-0f0f789fcabd05839a8f4072bdd5b7a1"><a href="#biomecomponentloading-buildschema-l2-lambda-0f0f789fcabd05839a8f4072bdd5b7a1" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_0f0f789fcabd05839a8f4072bdd5b7a1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_0f0f789fcabd05839a8f4072bdd5b7a1&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-7c0b138f98f9658636c148b465c6d818"><a href="#biomecomponentloading-buildschema-l2-lambda-7c0b138f98f9658636c148b465c6d818" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_7c0b138f98f9658636c148b465c6d818&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_7c0b138f98f9658636c148b465c6d818&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-12f9dbe7b6fca75e36a0974e7b639bd6"><a href="#biomecomponentloading-buildschema-l2-lambda-12f9dbe7b6fca75e36a0974e7b639bd6" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_12f9dbe7b6fca75e36a0974e7b639bd6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_12f9dbe7b6fca75e36a0974e7b639bd6&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-1958774ba91c2a8a8e7c0da9e5e1d4fa"><a href="#biomecomponentloading-buildschema-l2-lambda-1958774ba91c2a8a8e7c0da9e5e1d4fa" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_1958774ba91c2a8a8e7c0da9e5e1d4fa&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_1958774ba91c2a8a8e7c0da9e5e1d4fa&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-1a7595583583d62ba48aea65aa95d936"><a href="#biomecomponentloading-buildschema-l2-lambda-1a7595583583d62ba48aea65aa95d936" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_1a7595583583d62ba48aea65aa95d936&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_1a7595583583d62ba48aea65aa95d936&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-bea0759ff1a264047c5afddfde4ec3fd"><a href="#biomecomponentloading-buildschema-l2-lambda-bea0759ff1a264047c5afddfde4ec3fd" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_bea0759ff1a264047c5afddfde4ec3fd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_bea0759ff1a264047c5afddfde4ec3fd&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-f2ce1ff6ee67b84720bcb09ebf7fea04"><a href="#biomecomponentloading-buildschema-l2-lambda-f2ce1ff6ee67b84720bcb09ebf7fea04" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_f2ce1ff6ee67b84720bcb09ebf7fea04&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_f2ce1ff6ee67b84720bcb09ebf7fea04&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-225167b354dd44524961a932de0b7a51"><a href="#biomecomponentloading-buildschema-l2-lambda-225167b354dd44524961a932de0b7a51" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_225167b354dd44524961a932de0b7a51&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_225167b354dd44524961a932de0b7a51&gt;
{
  std::function&lt;SurfaceMaterialAdjustmentAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; componentAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-971455b9357b3536ff5dad3d9c75c370"><a href="#biomecomponentloading-buildschema-l2-lambda-971455b9357b3536ff5dad3d9c75c370" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_971455b9357b3536ff5dad3d9c75c370&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_971455b9357b3536ff5dad3d9c75c370&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-100aefda7a177bed57c3ee89f1a167b9"><a href="#biomecomponentloading-buildschema-l2-lambda-100aefda7a177bed57c3ee89f1a167b9" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_100aefda7a177bed57c3ee89f1a167b9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_100aefda7a177bed57c3ee89f1a167b9&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-ec658f3ed0ee9fcb77be3770ebe27063"><a href="#biomecomponentloading-buildschema-l2-lambda-ec658f3ed0ee9fcb77be3770ebe27063" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_ec658f3ed0ee9fcb77be3770ebe27063&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_ec658f3ed0ee9fcb77be3770ebe27063&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-f5b63f54e8163365fbc4fd41abd61dbc"><a href="#biomecomponentloading-buildschema-l2-lambda-f5b63f54e8163365fbc4fd41abd61dbc" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_f5b63f54e8163365fbc4fd41abd61dbc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_f5b63f54e8163365fbc4fd41abd61dbc&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-c3bd4d2c9b8db0215a27d95f588f01dd"><a href="#biomecomponentloading-buildschema-l2-lambda-c3bd4d2c9b8db0215a27d95f588f01dd" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_c3bd4d2c9b8db0215a27d95f588f01dd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_c3bd4d2c9b8db0215a27d95f588f01dd&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-8cc184e2f1c5afd59ee37440bc7e558d"><a href="#biomecomponentloading-buildschema-l2-lambda-8cc184e2f1c5afd59ee37440bc7e558d" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_8cc184e2f1c5afd59ee37440bc7e558d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_8cc184e2f1c5afd59ee37440bc7e558d&gt;
{
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-d2561560f3ee380d0ec045cd18e2c99f"><a href="#biomecomponentloading-buildschema-l2-lambda-d2561560f3ee380d0ec045cd18e2c99f" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_d2561560f3ee380d0ec045cd18e2c99f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_d2561560f3ee380d0ec045cd18e2c99f&gt;
{
  std::function&lt;std::vector&lt;std::pair&lt;Biome *,unsigned int&gt;&gt; &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt; biomeVectorAccessor;
};

</code></pre></div><h3 id="biomecomponentloading-buildschema-l2-lambda-909cc6b1dd127ca9c80909ce62807b61"><a href="#biomecomponentloading-buildschema-l2-lambda-909cc6b1dd127ca9c80909ce62807b61" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_909cc6b1dd127ca9c80909ce62807b61&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_909cc6b1dd127ca9c80909ce62807b61&gt;
{
};

</code></pre></div><h3 id="biomedecorationattributes-consolidatedfeatures"><a href="#biomedecorationattributes-consolidatedfeatures" class="header-anchor">#</a> <code>BiomeDecorationAttributes&lt;ConsolidatedFeatures&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeDecorationAttributes&lt;ConsolidatedFeatures&gt;
{
  std::vector&lt;BiomeDecorationFeature *&gt; mFeatures;
  std::unordered_set&lt;HashedString&gt; mFeatureRuleNameSet;
};

</code></pre></div><h3 id="biomedecorationattributes-implicitfeatures"><a href="#biomedecorationattributes-implicitfeatures" class="header-anchor">#</a> <code>BiomeDecorationAttributes&lt;ImplicitFeatures&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeDecorationAttributes&lt;ImplicitFeatures&gt;
{
  std::vector&lt;BiomeDecorationFeature *&gt; mFeatures;
  std::unordered_set&lt;HashedString&gt; mFeatureRuleNameSet;
};

</code></pre></div><h3 id="baserailtransporter"><a href="#baserailtransporter" class="header-anchor">#</a> <code>BaseRailTransporter</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BaseRailTransporter : BaseCircuitComponent
{
  BaseRailTransporter::RailType mRailType;
};

</code></pre></div><h3 id="baserailtransporter-vtbl"><a href="#baserailtransporter-vtbl" class="header-anchor">#</a> <code>BaseRailTransporter_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BaseRailTransporter_vtbl
{
  void (__fastcall *~BaseCircuitComponent)(BaseCircuitComponent *this);
  int (__fastcall *getStrength)(BaseCircuitComponent *this);
  int (__fastcall *getDirection)(BaseCircuitComponent *this);
  void (__fastcall *setStrength)(BaseCircuitComponent *this, int);
  void (__fastcall *setDirection)(BaseCircuitComponent *this, unsigned __int8);
  bool (__fastcall *consumePowerAnyDirection)(BaseCircuitComponent *this);
  bool (__fastcall *canConsumerPower)(BaseCircuitComponent *this);
  bool (__fastcall *canStopPower)(BaseCircuitComponent *this);
  void (__fastcall *setStopPower)(BaseCircuitComponent *this, bool);
  unsigned __int64 (__fastcall *getBaseType)(BaseCircuitComponent *this);
  unsigned __int64 (__fastcall *getInstanceType)(BaseCircuitComponent *this);
  bool (__fastcall *removeSource)(BaseCircuitComponent *this, const BlockPos *, const BaseCircuitComponent *);
  bool (__fastcall *addSource)(BaseCircuitComponent *this, CircuitSceneGraph *, const CircuitTrackingInfo *, int *, bool *);
  bool (__fastcall *allowConnection)(BaseCircuitComponent *this, CircuitSceneGraph *, const CircuitTrackingInfo *, bool *);
  void (__fastcall *checkLock)(BaseCircuitComponent *this, CircuitSystem *, const BlockPos *);
  bool (__fastcall *evaluate)(BaseCircuitComponent *this, CircuitSystem *, const BlockPos *);
  void (__fastcall *cacheValues)(BaseCircuitComponent *this, CircuitSystem *, const BlockPos *);
  void (__fastcall *updateDependencies)(BaseCircuitComponent *this, CircuitSceneGraph *, const BlockPos *);
  bool (__fastcall *allowIndirect)(BaseCircuitComponent *this);
  bool (__fastcall *isHalfPulse)(BaseCircuitComponent *this);
  bool (__fastcall *hasSource)(BaseCircuitComponent *this, BaseCircuitComponent *);
  bool (__fastcall *hasChildrenSource)(BaseCircuitComponent *this);
  bool (__fastcall *isSecondaryPowered)(BaseCircuitComponent *this);
};

</code></pre></div><h3 id="biomedecorationsystem-consolidatedecorationfeatures-l2-lambda-931762908d800d263659cffde2a0977f"><a href="#biomedecorationsystem-consolidatedecorationfeatures-l2-lambda-931762908d800d263659cffde2a0977f" class="header-anchor">#</a> <code>BiomeDecorationSystem::consolidateDecorationFeatures::__l2::&lt;lambda_931762908d800d263659cffde2a0977f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeDecorationSystem::consolidateDecorationFeatures::__l2::&lt;lambda_931762908d800d263659cffde2a0977f&gt;
{
};

</code></pre></div><h3 id="barrelblock"><a href="#barrelblock" class="header-anchor">#</a> <code>BarrelBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BarrelBlock : FaceDirectionalBlock
{
};

</code></pre></div><h3 id="barrelblock-vtbl"><a href="#barrelblock-vtbl" class="header-anchor">#</a> <code>BarrelBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BarrelBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="blastfurnaceblockactor"><a href="#blastfurnaceblockactor" class="header-anchor">#</a> <code>BlastFurnaceBlockActor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlastFurnaceBlockActor : FurnaceBlockActor
{
};

</code></pre></div><h3 id="blastfurnaceblockactor-vtbl"><a href="#blastfurnaceblockactor-vtbl" class="header-anchor">#</a> <code>BlastFurnaceBlockActor_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlastFurnaceBlockActor_vtbl
{
  void (__fastcall *~BlockActor)(BlockActor *this);
  void (__fastcall *load)(BlockActor *this, Level *, const CompoundTag *, DataLoadHelper *);
  bool (__fastcall *save)(BlockActor *this, CompoundTag *);
  bool (__fastcall *saveItemInstanceData)(BlockActor *this, CompoundTag *);
  void (__fastcall *saveBlockData)(BlockActor *this, CompoundTag *, BlockSource *);
  void (__fastcall *loadBlockData)(BlockActor *this, const CompoundTag *, BlockSource *, DataLoadHelper *);
  void (__fastcall *onCustomTagLoadDone)(BlockActor *this, BlockSource *);
  void (__fastcall *tick)(BlockActor *this, BlockSource *);
  bool (__fastcall *isFinished)(BlockActor *this);
  void (__fastcall *onChanged)(BlockActor *this, BlockSource *);
  bool (__fastcall *isMovable)(BlockActor *this, BlockSource *);
  bool (__fastcall *isCustomNameSaved)(BlockActor *this);
  bool (__fastcall *onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *, const Player *);
  void (__fastcall *onPlace)(BlockActor *this, BlockSource *);
  void (__fastcall *onMove)(BlockActor *this);
  void (__fastcall *onRemoved)(BlockActor *this, BlockSource *);
  void (__fastcall *triggerEvent)(BlockActor *this, int, int);
  void (__fastcall *clearCache)(BlockActor *this);
  void (__fastcall *onNeighborChanged)(BlockActor *this, BlockSource *, const BlockPos *);
  float (__fastcall *getShadowRadius)(BlockActor *this, BlockSource *);
  bool (__fastcall *hasAlphaLayer)(BlockActor *this);
  BlockActor *(__fastcall *getCrackEntity)(BlockActor *this, BlockSource *, const BlockPos *);
  void (__fastcall *getDebugText)(BlockActor *this, std::vector&lt;std::string&gt; *, const BlockPos *);
  const std::string *(__fastcall *getCustomName)(BlockActor *this);
  const std::string *(__fastcall *getFilteredCustomName)(BlockActor *this, const UIProfanityContext *);
  std::string *(__fastcall *getName)(BlockActor *this, std::string *result);
  void (__fastcall *setCustomName)(BlockActor *this, const std::string *);
  std::string *(__fastcall *getImmersiveReaderText)(BlockActor *this, std::string *result, BlockSource *);
  int (__fastcall *getRepairCost)(BlockActor *this);
  PistonBlockActor *(__fastcall *getOwningPiston)(BlockActor *this, BlockSource *);
  const Container *(__fastcall *getContainer)(BlockActor *this);
  Container *(__fastcall *getContainer)(BlockActor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(BlockActor *this);
  void (__fastcall *checkWordsOnChunkLoad)(BlockActor *this, LevelChunk *);
  void (__fastcall *checkWordsOnUpdate)(BlockActor *this, Player *);
  void (__fastcall *onChunkLoaded)(BlockActor *this, LevelChunk *);
  void (__fastcall *onChunkUnloaded)(BlockActor *this, LevelChunk *);
  std::unique_ptr&lt;BlockActorDataPacket&gt; *(__fastcall *_getUpdatePacket)(BlockActor *this, std::unique_ptr&lt;BlockActorDataPacket&gt; *result, BlockSource *);
  void (__fastcall *_onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *);
  bool (__fastcall *_playerCanUpdate)(BlockActor *this, const Player *);
};

</code></pre></div><h3 id="blockactorfactory"><a href="#blockactorfactory" class="header-anchor">#</a> <code>BlockActorFactory</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockActorFactory
{
};

</code></pre></div><h3 id="beehiveblockactor-tick-l2-lambda-b392b9a4f8c12bc74b03b27e80b70a94"><a href="#beehiveblockactor-tick-l2-lambda-b392b9a4f8c12bc74b03b27e80b70a94" class="header-anchor">#</a> <code>BeehiveBlockActor::tick::__l2::&lt;lambda_b392b9a4f8c12bc74b03b27e80b70a94&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BeehiveBlockActor::tick::__l2::&lt;lambda_b392b9a4f8c12bc74b03b27e80b70a94&gt;
{
  BeehiveBlockActor *const __this;
  BlockSource *region;
};

</code></pre></div><h3 id="beaconblockactor-applyeffects-l14-lambda-b5cf0b164fc3fb877a74bed916b0b10e"><a href="#beaconblockactor-applyeffects-l14-lambda-b5cf0b164fc3fb877a74bed916b0b10e" class="header-anchor">#</a> <code>BeaconBlockActor::_applyEffects::__l14::&lt;lambda_b5cf0b164fc3fb877a74bed916b0b10e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BeaconBlockActor::_applyEffects::__l14::&lt;lambda_b5cf0b164fc3fb877a74bed916b0b10e&gt;
{
  const Vec3 *posBeacon;
  const float *halfExtent;
  std::vector&lt;Player *&gt; *playersInRange;
};

</code></pre></div><h3 id="beaconblockactor-checkshapeandachievement-l20-lambda-36931bbf3f3b12ac54c465f8cbab0fe5"><a href="#beaconblockactor-checkshapeandachievement-l20-lambda-36931bbf3f3b12ac54c465f8cbab0fe5" class="header-anchor">#</a> <code>BeaconBlockActor::checkShapeAndAchievement::__l20::&lt;lambda_36931bbf3f3b12ac54c465f8cbab0fe5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BeaconBlockActor::checkShapeAndAchievement::__l20::&lt;lambda_36931bbf3f3b12ac54c465f8cbab0fe5&gt;
{
  AABB *area;
};

</code></pre></div><h3 id="beaconblockactor-onupdatepacket-l5-lambda-41531286337530fe5a4ae271b716e292"><a href="#beaconblockactor-onupdatepacket-l5-lambda-41531286337530fe5a4ae271b716e292" class="header-anchor">#</a> <code>BeaconBlockActor::_onUpdatePacket::__l5::&lt;lambda_41531286337530fe5a4ae271b716e292&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BeaconBlockActor::_onUpdatePacket::__l5::&lt;lambda_41531286337530fe5a4ae271b716e292&gt;
{
};

</code></pre></div><h3 id="burstreactioncomponent"><a href="#burstreactioncomponent" class="header-anchor">#</a> <code>BurstReactionComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) BurstReactionComponent : LabTableReactionComponent
{
  ParticleType mParticleType;
  HashedString mNewParticleType;
  Vec3 mDims;
  Vec3 mDirRange;
  int mCount;
  int mDataMin;
  int mDataMax;
  bool mDirOneWay;
};

</code></pre></div><h3 id="burstreactioncomponent-vtbl"><a href="#burstreactioncomponent-vtbl" class="header-anchor">#</a> <code>BurstReactionComponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BurstReactionComponent_vtbl
{
  void (__fastcall *~LabTableReactionComponent)(LabTableReactionComponent *this);
  void (__fastcall *_onStart)(LabTableReactionComponent *this, LabTableReaction *, BlockSource *);
  void (__fastcall *_onTick)(LabTableReactionComponent *this, LabTableReaction *, BlockSource *);
  void (__fastcall *_onEnd)(LabTableReactionComponent *this, LabTableReaction *, BlockSource *);
};

</code></pre></div><h3 id="bambooblock"><a href="#bambooblock" class="header-anchor">#</a> <code>BambooBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BambooBlock : BlockLegacy
{
};

</code></pre></div><h3 id="bambooblock-vtbl"><a href="#bambooblock-vtbl" class="header-anchor">#</a> <code>BambooBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BambooBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="bamboosapling"><a href="#bamboosapling" class="header-anchor">#</a> <code>BambooSapling</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BambooSapling : Sapling
{
};

</code></pre></div><h3 id="bamboosapling-vtbl"><a href="#bamboosapling-vtbl" class="header-anchor">#</a> <code>BambooSapling_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BambooSapling_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *checkAlive)(BushBlock *this, BlockSource *, const BlockPos *);
};

</code></pre></div><h3 id="bannerblock"><a href="#bannerblock" class="header-anchor">#</a> <code>BannerBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BannerBlock : ActorBlock
{
  bool mOnGround;
};

</code></pre></div><h3 id="bannerblock-vtbl"><a href="#bannerblock-vtbl" class="header-anchor">#</a> <code>BannerBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BannerBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
};

</code></pre></div><h3 id="barrierblock"><a href="#barrierblock" class="header-anchor">#</a> <code>BarrierBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BarrierBlock : BlockLegacy
{
};

</code></pre></div><h3 id="barrierblock-vtbl"><a href="#barrierblock-vtbl" class="header-anchor">#</a> <code>BarrierBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BarrierBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="basepressureplateblock"><a href="#basepressureplateblock" class="header-anchor">#</a> <code>BasePressurePlateBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BasePressurePlateBlock : BlockLegacy
{
  std::string texture;
};

</code></pre></div><h3 id="basepressureplateblock-vtbl"><a href="#basepressureplateblock-vtbl" class="header-anchor">#</a> <code>BasePressurePlateBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BasePressurePlateBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  int (__fastcall *getTickDelay)(BasePressurePlateBlock *this);
  int (__fastcall *getSignalStrength)(BasePressurePlateBlock *this, BlockSource *, const BlockPos *);
  int (__fastcall *getSignalForData)(BasePressurePlateBlock *this, int);
  int (__fastcall *getRedstoneSignal)(BasePressurePlateBlock *this, int);
  const AABB *(__fastcall *getSensitiveAABB)(BasePressurePlateBlock *this, const AABB *result, const BlockPos *);
};

</code></pre></div><h3 id="beaconblock"><a href="#beaconblock" class="header-anchor">#</a> <code>BeaconBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BeaconBlock : ActorBlock
{
};

</code></pre></div><h3 id="beaconblock-vtbl"><a href="#beaconblock-vtbl" class="header-anchor">#</a> <code>BeaconBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BeaconBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
};

</code></pre></div><h3 id="basepressureplateblock-entityinside-l17-lambda-e218216a8f7135fcc6348d1cf3645f7b"><a href="#basepressureplateblock-entityinside-l17-lambda-e218216a8f7135fcc6348d1cf3645f7b" class="header-anchor">#</a> <code>BasePressurePlateBlock::entityInside::__l17::&lt;lambda_e218216a8f7135fcc6348d1cf3645f7b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BasePressurePlateBlock::entityInside::__l17::&lt;lambda_e218216a8f7135fcc6348d1cf3645f7b&gt;
{
  Actor *entity;
  const BasePressurePlateBlock *const __this;
  const BlockPos *pos;
  BlockSource *region;
};

</code></pre></div><h3 id="bedrockblock"><a href="#bedrockblock" class="header-anchor">#</a> <code>BedrockBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BedrockBlock : BlockLegacy
{
};

</code></pre></div><h3 id="bedrockblock-vtbl"><a href="#bedrockblock-vtbl" class="header-anchor">#</a> <code>BedrockBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BedrockBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="beetrootblock"><a href="#beetrootblock" class="header-anchor">#</a> <code>BeetrootBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BeetrootBlock : CropBlock
{
};

</code></pre></div><h3 id="beetrootblock-vtbl"><a href="#beetrootblock-vtbl" class="header-anchor">#</a> <code>BeetrootBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BeetrootBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *checkAlive)(BushBlock *this, BlockSource *, const BlockPos *);
  const ItemInstance *(__fastcall *getBaseSeed)(CropBlock *this, const ItemInstance *result);
  const ItemInstance *(__fastcall *getBaseCrop)(CropBlock *this, const ItemInstance *result);
  int (__fastcall *getSeedNum)(CropBlock *this, Random *, int, int, bool);
  int (__fastcall *getCropNum)(CropBlock *this, Random *, int, int, bool);
};

</code></pre></div><h3 id="blastfurnaceblock"><a href="#blastfurnaceblock" class="header-anchor">#</a> <code>BlastFurnaceBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlastFurnaceBlock : FurnaceBlock
{
};

</code></pre></div><h3 id="blastfurnaceblock-vtbl"><a href="#blastfurnaceblock-vtbl" class="header-anchor">#</a> <code>BlastFurnaceBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlastFurnaceBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
};

</code></pre></div><h3 id="blockactorcomponentdescription"><a href="#blockactorcomponentdescription" class="header-anchor">#</a> <code>BlockActorComponentDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockActorComponentDescription : BlockComponentDescription
{
  bool mListenTick;
  bool mIsMovable;
};

</code></pre></div><h3 id="blockactorcomponentdescription-vtbl"><a href="#blockactorcomponentdescription-vtbl" class="header-anchor">#</a> <code>BlockActorComponentDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockActorComponentDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockactorcomponent"><a href="#blockactorcomponent" class="header-anchor">#</a> <code>BlockActorComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct BlockActorComponent
{
  bool mListenTick;
  bool mIsMovable;
};

</code></pre></div><h3 id="blockserializationutils-lambda-6fdc15de22a520ca156369c24e880172"><a href="#blockserializationutils-lambda-6fdc15de22a520ca156369c24e880172" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_6fdc15de22a520ca156369c24e880172&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_6fdc15de22a520ca156369c24e880172&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-eec5f314ab07ecb90fdbd203ea1346af"><a href="#blockserializationutils-lambda-eec5f314ab07ecb90fdbd203ea1346af" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_eec5f314ab07ecb90fdbd203ea1346af&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_eec5f314ab07ecb90fdbd203ea1346af&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-a1110cc62a51982954179bd25bf77129"><a href="#blockserializationutils-lambda-a1110cc62a51982954179bd25bf77129" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_a1110cc62a51982954179bd25bf77129&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_a1110cc62a51982954179bd25bf77129&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-d0a6215a0f7bc9986b97d84c5e60ffac"><a href="#blockserializationutils-lambda-d0a6215a0f7bc9986b97d84c5e60ffac" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_d0a6215a0f7bc9986b97d84c5e60ffac&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_d0a6215a0f7bc9986b97d84c5e60ffac&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-983915c06c07d38b7eeb9b007ba5973c"><a href="#blockserializationutils-lambda-983915c06c07d38b7eeb9b007ba5973c" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_983915c06c07d38b7eeb9b007ba5973c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_983915c06c07d38b7eeb9b007ba5973c&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-c4f1d652ffa81f41c47c703fce7f06f9"><a href="#blockserializationutils-lambda-c4f1d652ffa81f41c47c703fce7f06f9" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_c4f1d652ffa81f41c47c703fce7f06f9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_c4f1d652ffa81f41c47c703fce7f06f9&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-7523242e50f57937d64b42feb6b56a14"><a href="#blockserializationutils-lambda-7523242e50f57937d64b42feb6b56a14" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_7523242e50f57937d64b42feb6b56a14&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_7523242e50f57937d64b42feb6b56a14&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-74a5a603128082ca82f2f8d0cd88766a"><a href="#blockserializationutils-lambda-74a5a603128082ca82f2f8d0cd88766a" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_74a5a603128082ca82f2f8d0cd88766a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_74a5a603128082ca82f2f8d0cd88766a&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-32e40a35da8c3294f43732418fde296e"><a href="#blockserializationutils-lambda-32e40a35da8c3294f43732418fde296e" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_32e40a35da8c3294f43732418fde296e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_32e40a35da8c3294f43732418fde296e&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-bb35ed5f5ef5cb1ffbbfa69a4d3c6326"><a href="#blockserializationutils-lambda-bb35ed5f5ef5cb1ffbbfa69a4d3c6326" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_bb35ed5f5ef5cb1ffbbfa69a4d3c6326&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_bb35ed5f5ef5cb1ffbbfa69a4d3c6326&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-f0cc804bef9fa0dd72b808dfae7386bd"><a href="#blockserializationutils-lambda-f0cc804bef9fa0dd72b808dfae7386bd" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_f0cc804bef9fa0dd72b808dfae7386bd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_f0cc804bef9fa0dd72b808dfae7386bd&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-4e3010ef0db32b85e6ee2e6852546fdf"><a href="#blockserializationutils-lambda-4e3010ef0db32b85e6ee2e6852546fdf" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_4e3010ef0db32b85e6ee2e6852546fdf&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_4e3010ef0db32b85e6ee2e6852546fdf&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-33409d97eef6295cc053556720fcdef0"><a href="#blockserializationutils-lambda-33409d97eef6295cc053556720fcdef0" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_33409d97eef6295cc053556720fcdef0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_33409d97eef6295cc053556720fcdef0&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-b671c635c1771fef52af19473cfe7ad9"><a href="#blockserializationutils-lambda-b671c635c1771fef52af19473cfe7ad9" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_b671c635c1771fef52af19473cfe7ad9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_b671c635c1771fef52af19473cfe7ad9&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-6e2477e4b65052724097b3043b39f74e"><a href="#blockserializationutils-lambda-6e2477e4b65052724097b3043b39f74e" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_6e2477e4b65052724097b3043b39f74e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_6e2477e4b65052724097b3043b39f74e&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-44c104413fc5ea03e5c27b8a7b40cff9"><a href="#blockserializationutils-lambda-44c104413fc5ea03e5c27b8a7b40cff9" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_44c104413fc5ea03e5c27b8a7b40cff9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_44c104413fc5ea03e5c27b8a7b40cff9&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-2793c93a8f04d82b30d40cd963fb3419"><a href="#blockserializationutils-lambda-2793c93a8f04d82b30d40cd963fb3419" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_2793c93a8f04d82b30d40cd963fb3419&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_2793c93a8f04d82b30d40cd963fb3419&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-d58fa707dc3a10518dac5dcb7ddbe677"><a href="#blockserializationutils-lambda-d58fa707dc3a10518dac5dcb7ddbe677" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_d58fa707dc3a10518dac5dcb7ddbe677&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_d58fa707dc3a10518dac5dcb7ddbe677&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-ab5229346ce48dd02810d3cfb2d04c26"><a href="#blockserializationutils-lambda-ab5229346ce48dd02810d3cfb2d04c26" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_ab5229346ce48dd02810d3cfb2d04c26&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_ab5229346ce48dd02810d3cfb2d04c26&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-1af544942bf3d7d818e66af9eb8cdff1"><a href="#blockserializationutils-lambda-1af544942bf3d7d818e66af9eb8cdff1" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_1af544942bf3d7d818e66af9eb8cdff1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_1af544942bf3d7d818e66af9eb8cdff1&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-85712aad558f95b090474f511201e2e7"><a href="#blockserializationutils-lambda-85712aad558f95b090474f511201e2e7" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_85712aad558f95b090474f511201e2e7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_85712aad558f95b090474f511201e2e7&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-1cd52a4d357ff67d3c4df9b88d9fd919"><a href="#blockserializationutils-lambda-1cd52a4d357ff67d3c4df9b88d9fd919" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_1cd52a4d357ff67d3c4df9b88d9fd919&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_1cd52a4d357ff67d3c4df9b88d9fd919&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-4886fcdffb1232a180350714b5ae36ed"><a href="#blockserializationutils-lambda-4886fcdffb1232a180350714b5ae36ed" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_4886fcdffb1232a180350714b5ae36ed&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_4886fcdffb1232a180350714b5ae36ed&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-649f988dd6e7f09896e7d241a734c864"><a href="#blockserializationutils-lambda-649f988dd6e7f09896e7d241a734c864" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_649f988dd6e7f09896e7d241a734c864&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_649f988dd6e7f09896e7d241a734c864&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-5991a7d46158b816eea851b55503ad9b"><a href="#blockserializationutils-lambda-5991a7d46158b816eea851b55503ad9b" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_5991a7d46158b816eea851b55503ad9b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_5991a7d46158b816eea851b55503ad9b&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-d7206e335b67aeba01b09fed7d5611a0"><a href="#blockserializationutils-lambda-d7206e335b67aeba01b09fed7d5611a0" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_d7206e335b67aeba01b09fed7d5611a0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_d7206e335b67aeba01b09fed7d5611a0&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-2cf8b0d99804c4cd0fc88a4a5d905a1d"><a href="#blockserializationutils-lambda-2cf8b0d99804c4cd0fc88a4a5d905a1d" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_2cf8b0d99804c4cd0fc88a4a5d905a1d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_2cf8b0d99804c4cd0fc88a4a5d905a1d&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-ac8200090f7b5a7b0d59a74faff7340e"><a href="#blockserializationutils-lambda-ac8200090f7b5a7b0d59a74faff7340e" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_ac8200090f7b5a7b0d59a74faff7340e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_ac8200090f7b5a7b0d59a74faff7340e&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-baf6a5dfea72ac67a7eaf2b0c7ad75ba"><a href="#blockserializationutils-lambda-baf6a5dfea72ac67a7eaf2b0c7ad75ba" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_baf6a5dfea72ac67a7eaf2b0c7ad75ba&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_baf6a5dfea72ac67a7eaf2b0c7ad75ba&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-f829a2f0efcb053c6a1a24e77a7adabc"><a href="#blockserializationutils-lambda-f829a2f0efcb053c6a1a24e77a7adabc" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_f829a2f0efcb053c6a1a24e77a7adabc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_f829a2f0efcb053c6a1a24e77a7adabc&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-cf5f9de946c2870c5eb438da65e83ff5"><a href="#blockserializationutils-lambda-cf5f9de946c2870c5eb438da65e83ff5" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_cf5f9de946c2870c5eb438da65e83ff5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_cf5f9de946c2870c5eb438da65e83ff5&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-2c607cc9cce0494718d74689c2e81e23"><a href="#blockserializationutils-lambda-2c607cc9cce0494718d74689c2e81e23" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_2c607cc9cce0494718d74689c2e81e23&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_2c607cc9cce0494718d74689c2e81e23&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-11801299155af1503d46179ae9105a8c"><a href="#blockserializationutils-lambda-11801299155af1503d46179ae9105a8c" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_11801299155af1503d46179ae9105a8c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_11801299155af1503d46179ae9105a8c&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-8aeaa4b2dbbc370eb42715c4738e9776"><a href="#blockserializationutils-lambda-8aeaa4b2dbbc370eb42715c4738e9776" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_8aeaa4b2dbbc370eb42715c4738e9776&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_8aeaa4b2dbbc370eb42715c4738e9776&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-9162d39776f698a2f0ba606e4e270ec7"><a href="#blockserializationutils-lambda-9162d39776f698a2f0ba606e4e270ec7" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_9162d39776f698a2f0ba606e4e270ec7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_9162d39776f698a2f0ba606e4e270ec7&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-2803c18f812d4f4b2b92030797283b5f"><a href="#blockserializationutils-lambda-2803c18f812d4f4b2b92030797283b5f" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_2803c18f812d4f4b2b92030797283b5f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_2803c18f812d4f4b2b92030797283b5f&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-32f5ac5757bf39bcc1afe354ef82f89d"><a href="#blockserializationutils-lambda-32f5ac5757bf39bcc1afe354ef82f89d" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_32f5ac5757bf39bcc1afe354ef82f89d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_32f5ac5757bf39bcc1afe354ef82f89d&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-b2a8a73e6cc8989dc74ab8201791eda0"><a href="#blockserializationutils-lambda-b2a8a73e6cc8989dc74ab8201791eda0" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_b2a8a73e6cc8989dc74ab8201791eda0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_b2a8a73e6cc8989dc74ab8201791eda0&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-7b1eb2b2353b7ab47b5165a14bc7e71b"><a href="#blockserializationutils-lambda-7b1eb2b2353b7ab47b5165a14bc7e71b" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_7b1eb2b2353b7ab47b5165a14bc7e71b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_7b1eb2b2353b7ab47b5165a14bc7e71b&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-de5cb65c165db3ab320bde30c00532ab"><a href="#blockserializationutils-lambda-de5cb65c165db3ab320bde30c00532ab" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_de5cb65c165db3ab320bde30c00532ab&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_de5cb65c165db3ab320bde30c00532ab&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-463e99393e64e816cb77ba56aadd83ba"><a href="#blockserializationutils-lambda-463e99393e64e816cb77ba56aadd83ba" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_463e99393e64e816cb77ba56aadd83ba&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_463e99393e64e816cb77ba56aadd83ba&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-5f5d23befb5501f9de8b466b56e153c4"><a href="#blockserializationutils-lambda-5f5d23befb5501f9de8b466b56e153c4" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_5f5d23befb5501f9de8b466b56e153c4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_5f5d23befb5501f9de8b466b56e153c4&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-b9900bd6cdf5f758cf670f56b0b537e6"><a href="#blockserializationutils-lambda-b9900bd6cdf5f758cf670f56b0b537e6" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_b9900bd6cdf5f758cf670f56b0b537e6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_b9900bd6cdf5f758cf670f56b0b537e6&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-a359a906504ea464babfa36eb3058d03"><a href="#blockserializationutils-lambda-a359a906504ea464babfa36eb3058d03" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_a359a906504ea464babfa36eb3058d03&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_a359a906504ea464babfa36eb3058d03&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-caed70072474ed1910ab2bfbc542a6ce"><a href="#blockserializationutils-lambda-caed70072474ed1910ab2bfbc542a6ce" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_caed70072474ed1910ab2bfbc542a6ce&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_caed70072474ed1910ab2bfbc542a6ce&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-f55516643c745c324938ddfd0a1a863b"><a href="#blockserializationutils-lambda-f55516643c745c324938ddfd0a1a863b" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_f55516643c745c324938ddfd0a1a863b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_f55516643c745c324938ddfd0a1a863b&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-f8c7dadd1bbef2461d5dd674e68da0e6"><a href="#blockserializationutils-lambda-f8c7dadd1bbef2461d5dd674e68da0e6" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_f8c7dadd1bbef2461d5dd674e68da0e6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_f8c7dadd1bbef2461d5dd674e68da0e6&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-c96f7ac2a43505e3d39aa02f59be8b9a"><a href="#blockserializationutils-lambda-c96f7ac2a43505e3d39aa02f59be8b9a" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_c96f7ac2a43505e3d39aa02f59be8b9a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_c96f7ac2a43505e3d39aa02f59be8b9a&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-a4526e648df3660ceab1a72087cd2fac"><a href="#blockserializationutils-lambda-a4526e648df3660ceab1a72087cd2fac" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_a4526e648df3660ceab1a72087cd2fac&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_a4526e648df3660ceab1a72087cd2fac&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-aa1b013aa4c6322f14796cd81f42b5cd"><a href="#blockserializationutils-lambda-aa1b013aa4c6322f14796cd81f42b5cd" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_aa1b013aa4c6322f14796cd81f42b5cd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_aa1b013aa4c6322f14796cd81f42b5cd&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-86b2c16786202c2a0126cc0817bbf393"><a href="#blockserializationutils-lambda-86b2c16786202c2a0126cc0817bbf393" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_86b2c16786202c2a0126cc0817bbf393&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_86b2c16786202c2a0126cc0817bbf393&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-fd524c11c78dee318673618cf6d1bedb"><a href="#blockserializationutils-lambda-fd524c11c78dee318673618cf6d1bedb" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_fd524c11c78dee318673618cf6d1bedb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_fd524c11c78dee318673618cf6d1bedb&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-bd0c6af5812dd5f22c4cf33464b05ca8"><a href="#blockserializationutils-lambda-bd0c6af5812dd5f22c4cf33464b05ca8" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_bd0c6af5812dd5f22c4cf33464b05ca8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_bd0c6af5812dd5f22c4cf33464b05ca8&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-120724d97a1a0b780536216a55a12907"><a href="#blockserializationutils-lambda-120724d97a1a0b780536216a55a12907" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_120724d97a1a0b780536216a55a12907&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_120724d97a1a0b780536216a55a12907&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-afe3986df72b54efdd35597efee6368a"><a href="#blockserializationutils-lambda-afe3986df72b54efdd35597efee6368a" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_afe3986df72b54efdd35597efee6368a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_afe3986df72b54efdd35597efee6368a&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-6fa0e5e321ce32175536bef513af4097"><a href="#blockserializationutils-lambda-6fa0e5e321ce32175536bef513af4097" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_6fa0e5e321ce32175536bef513af4097&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_6fa0e5e321ce32175536bef513af4097&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-356e117505dc1c8c0527834f0213d4d4"><a href="#blockserializationutils-lambda-356e117505dc1c8c0527834f0213d4d4" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_356e117505dc1c8c0527834f0213d4d4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_356e117505dc1c8c0527834f0213d4d4&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-f58139ce1a15611cdb8d24fb5f331dfc"><a href="#blockserializationutils-lambda-f58139ce1a15611cdb8d24fb5f331dfc" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_f58139ce1a15611cdb8d24fb5f331dfc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_f58139ce1a15611cdb8d24fb5f331dfc&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-bfd98adef72dec2bcf0c23e534b4cc5c"><a href="#blockserializationutils-lambda-bfd98adef72dec2bcf0c23e534b4cc5c" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_bfd98adef72dec2bcf0c23e534b4cc5c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_bfd98adef72dec2bcf0c23e534b4cc5c&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-1a3286eb4837fe9da6660a6f6b9fe35e"><a href="#blockserializationutils-lambda-1a3286eb4837fe9da6660a6f6b9fe35e" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_1a3286eb4837fe9da6660a6f6b9fe35e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_1a3286eb4837fe9da6660a6f6b9fe35e&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-0286863a89754b1ddff522b25ac0a1c5"><a href="#blockserializationutils-lambda-0286863a89754b1ddff522b25ac0a1c5" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_0286863a89754b1ddff522b25ac0a1c5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_0286863a89754b1ddff522b25ac0a1c5&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-482394891ab632a56cf0ec6d92adbde4"><a href="#blockserializationutils-lambda-482394891ab632a56cf0ec6d92adbde4" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_482394891ab632a56cf0ec6d92adbde4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_482394891ab632a56cf0ec6d92adbde4&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-952fab1cdca066de4ac0daeda27ce3e3"><a href="#blockserializationutils-lambda-952fab1cdca066de4ac0daeda27ce3e3" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_952fab1cdca066de4ac0daeda27ce3e3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_952fab1cdca066de4ac0daeda27ce3e3&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-6536a8fa2b2fdbd0c5c7a184201b2549"><a href="#blockserializationutils-lambda-6536a8fa2b2fdbd0c5c7a184201b2549" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_6536a8fa2b2fdbd0c5c7a184201b2549&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_6536a8fa2b2fdbd0c5c7a184201b2549&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-deb10ec0c7a9ddefde8ab21d2c35c767"><a href="#blockserializationutils-lambda-deb10ec0c7a9ddefde8ab21d2c35c767" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_deb10ec0c7a9ddefde8ab21d2c35c767&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_deb10ec0c7a9ddefde8ab21d2c35c767&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-49dcdd42820e764c1f2b338ba8b16de8"><a href="#blockserializationutils-lambda-49dcdd42820e764c1f2b338ba8b16de8" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_49dcdd42820e764c1f2b338ba8b16de8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_49dcdd42820e764c1f2b338ba8b16de8&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-961f66577b3125927f56c21e1f6a4f9a"><a href="#blockserializationutils-lambda-961f66577b3125927f56c21e1f6a4f9a" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_961f66577b3125927f56c21e1f6a4f9a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_961f66577b3125927f56c21e1f6a4f9a&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-a11d431fef459d3df413f4eb2617c8b7"><a href="#blockserializationutils-lambda-a11d431fef459d3df413f4eb2617c8b7" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_a11d431fef459d3df413f4eb2617c8b7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_a11d431fef459d3df413f4eb2617c8b7&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-1c707fa07b1ff7c717e025eea5542e5d"><a href="#blockserializationutils-lambda-1c707fa07b1ff7c717e025eea5542e5d" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_1c707fa07b1ff7c717e025eea5542e5d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_1c707fa07b1ff7c717e025eea5542e5d&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-76c28052043f4402e41e4506e9833791"><a href="#blockserializationutils-lambda-76c28052043f4402e41e4506e9833791" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_76c28052043f4402e41e4506e9833791&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_76c28052043f4402e41e4506e9833791&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-2504fee695490b12d4af8f1e10410d9e"><a href="#blockserializationutils-lambda-2504fee695490b12d4af8f1e10410d9e" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_2504fee695490b12d4af8f1e10410d9e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_2504fee695490b12d4af8f1e10410d9e&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-1364fa5bf15868d8c11c786949cf3cb7"><a href="#blockserializationutils-lambda-1364fa5bf15868d8c11c786949cf3cb7" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_1364fa5bf15868d8c11c786949cf3cb7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_1364fa5bf15868d8c11c786949cf3cb7&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-688d1708202b2c1b91ad3445756d1731"><a href="#blockserializationutils-lambda-688d1708202b2c1b91ad3445756d1731" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_688d1708202b2c1b91ad3445756d1731&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_688d1708202b2c1b91ad3445756d1731&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-f9a2a48e95ae986b8f1f31d8b4b07007"><a href="#blockserializationutils-lambda-f9a2a48e95ae986b8f1f31d8b4b07007" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_f9a2a48e95ae986b8f1f31d8b4b07007&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_f9a2a48e95ae986b8f1f31d8b4b07007&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-e3ed33be2a558f2791743a8a07f27c1a"><a href="#blockserializationutils-lambda-e3ed33be2a558f2791743a8a07f27c1a" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_e3ed33be2a558f2791743a8a07f27c1a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_e3ed33be2a558f2791743a8a07f27c1a&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-2f4365bdc54b6da9acdb3bde1fadef86"><a href="#blockserializationutils-lambda-2f4365bdc54b6da9acdb3bde1fadef86" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_2f4365bdc54b6da9acdb3bde1fadef86&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_2f4365bdc54b6da9acdb3bde1fadef86&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-8c60ea3a92969cc1c0b6a6899ca2a32e"><a href="#blockserializationutils-lambda-8c60ea3a92969cc1c0b6a6899ca2a32e" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_8c60ea3a92969cc1c0b6a6899ca2a32e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_8c60ea3a92969cc1c0b6a6899ca2a32e&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-726975e58168013c5385d2e7610013e5"><a href="#blockserializationutils-lambda-726975e58168013c5385d2e7610013e5" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_726975e58168013c5385d2e7610013e5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_726975e58168013c5385d2e7610013e5&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-9d3dbb6d6bce2cb555178c19c453a08b"><a href="#blockserializationutils-lambda-9d3dbb6d6bce2cb555178c19c453a08b" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_9d3dbb6d6bce2cb555178c19c453a08b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_9d3dbb6d6bce2cb555178c19c453a08b&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-0fe75d0e25cee86e8ff52a8713ef77ae"><a href="#blockserializationutils-lambda-0fe75d0e25cee86e8ff52a8713ef77ae" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_0fe75d0e25cee86e8ff52a8713ef77ae&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_0fe75d0e25cee86e8ff52a8713ef77ae&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-2c03e7c8e15d88d893cd88bdbf82f8ca"><a href="#blockserializationutils-lambda-2c03e7c8e15d88d893cd88bdbf82f8ca" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_2c03e7c8e15d88d893cd88bdbf82f8ca&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_2c03e7c8e15d88d893cd88bdbf82f8ca&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-909dcd7ce6d171f2544da41d7f521cbe"><a href="#blockserializationutils-lambda-909dcd7ce6d171f2544da41d7f521cbe" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_909dcd7ce6d171f2544da41d7f521cbe&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_909dcd7ce6d171f2544da41d7f521cbe&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-2861872706d1618ff6c5540b9522c333"><a href="#blockserializationutils-lambda-2861872706d1618ff6c5540b9522c333" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_2861872706d1618ff6c5540b9522c333&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_2861872706d1618ff6c5540b9522c333&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-9c81cca2bc07f493f58b7ad575637daa"><a href="#blockserializationutils-lambda-9c81cca2bc07f493f58b7ad575637daa" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_9c81cca2bc07f493f58b7ad575637daa&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_9c81cca2bc07f493f58b7ad575637daa&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-e4ffe1915cdb08948830b8ae67eddf8c"><a href="#blockserializationutils-lambda-e4ffe1915cdb08948830b8ae67eddf8c" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_e4ffe1915cdb08948830b8ae67eddf8c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_e4ffe1915cdb08948830b8ae67eddf8c&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-8f95b6dcff13443a45b56973d05613ad"><a href="#blockserializationutils-lambda-8f95b6dcff13443a45b56973d05613ad" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_8f95b6dcff13443a45b56973d05613ad&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_8f95b6dcff13443a45b56973d05613ad&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-9bf14eafc7038d1e8115f55f6616c527"><a href="#blockserializationutils-lambda-9bf14eafc7038d1e8115f55f6616c527" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_9bf14eafc7038d1e8115f55f6616c527&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_9bf14eafc7038d1e8115f55f6616c527&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-08de8f02cd1235cb91db8d72b5330a40"><a href="#blockserializationutils-lambda-08de8f02cd1235cb91db8d72b5330a40" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_08de8f02cd1235cb91db8d72b5330a40&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_08de8f02cd1235cb91db8d72b5330a40&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-989a564efee623cd3ddd0f72bf988e57"><a href="#blockserializationutils-lambda-989a564efee623cd3ddd0f72bf988e57" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_989a564efee623cd3ddd0f72bf988e57&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_989a564efee623cd3ddd0f72bf988e57&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-50edb6a334ed8e799210e99afd191fc6"><a href="#blockserializationutils-lambda-50edb6a334ed8e799210e99afd191fc6" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_50edb6a334ed8e799210e99afd191fc6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_50edb6a334ed8e799210e99afd191fc6&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-a228982349169ce148712dfe490ae519"><a href="#blockserializationutils-lambda-a228982349169ce148712dfe490ae519" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_a228982349169ce148712dfe490ae519&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_a228982349169ce148712dfe490ae519&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-c51626a2d86135e2ac70650eee7fe552"><a href="#blockserializationutils-lambda-c51626a2d86135e2ac70650eee7fe552" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_c51626a2d86135e2ac70650eee7fe552&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_c51626a2d86135e2ac70650eee7fe552&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-2bfa752f547e87ed344ce74e19fecb96"><a href="#blockserializationutils-lambda-2bfa752f547e87ed344ce74e19fecb96" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_2bfa752f547e87ed344ce74e19fecb96&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_2bfa752f547e87ed344ce74e19fecb96&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-896cd9dcb0f02b56f1ad2efb8a567ff0"><a href="#blockserializationutils-lambda-896cd9dcb0f02b56f1ad2efb8a567ff0" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_896cd9dcb0f02b56f1ad2efb8a567ff0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_896cd9dcb0f02b56f1ad2efb8a567ff0&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-d113438834d0614839bba2c528b53b3f"><a href="#blockserializationutils-lambda-d113438834d0614839bba2c528b53b3f" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_d113438834d0614839bba2c528b53b3f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_d113438834d0614839bba2c528b53b3f&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-d55872600daa00ea84d46752f8149052"><a href="#blockserializationutils-lambda-d55872600daa00ea84d46752f8149052" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_d55872600daa00ea84d46752f8149052&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_d55872600daa00ea84d46752f8149052&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-b59cc2a447e78643ca0b4d0215f568ee"><a href="#blockserializationutils-lambda-b59cc2a447e78643ca0b4d0215f568ee" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_b59cc2a447e78643ca0b4d0215f568ee&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_b59cc2a447e78643ca0b4d0215f568ee&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-7efda1a3afc251a60489e70e6fee043a"><a href="#blockserializationutils-lambda-7efda1a3afc251a60489e70e6fee043a" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_7efda1a3afc251a60489e70e6fee043a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_7efda1a3afc251a60489e70e6fee043a&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-a8aea26d4affce3a7cff8c83479a984e"><a href="#blockserializationutils-lambda-a8aea26d4affce3a7cff8c83479a984e" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_a8aea26d4affce3a7cff8c83479a984e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_a8aea26d4affce3a7cff8c83479a984e&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-7c111c639de802ed8f3f595c199786b1"><a href="#blockserializationutils-lambda-7c111c639de802ed8f3f595c199786b1" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_7c111c639de802ed8f3f595c199786b1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_7c111c639de802ed8f3f595c199786b1&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-78e8ca433d9f14fb7e86c1b77a21e900"><a href="#blockserializationutils-lambda-78e8ca433d9f14fb7e86c1b77a21e900" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_78e8ca433d9f14fb7e86c1b77a21e900&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_78e8ca433d9f14fb7e86c1b77a21e900&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-8257867c58fed36c81b682f912a6b281"><a href="#blockserializationutils-lambda-8257867c58fed36c81b682f912a6b281" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_8257867c58fed36c81b682f912a6b281&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_8257867c58fed36c81b682f912a6b281&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-dc56b327c9e0705d4ad5ef7abc2b1cf2"><a href="#blockserializationutils-lambda-dc56b327c9e0705d4ad5ef7abc2b1cf2" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_dc56b327c9e0705d4ad5ef7abc2b1cf2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_dc56b327c9e0705d4ad5ef7abc2b1cf2&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-4d325f6d56fc641a1e1f6102241f9213"><a href="#blockserializationutils-lambda-4d325f6d56fc641a1e1f6102241f9213" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_4d325f6d56fc641a1e1f6102241f9213&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_4d325f6d56fc641a1e1f6102241f9213&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-fa3600bd56a1534f63666da7b3cfbd7b"><a href="#blockserializationutils-lambda-fa3600bd56a1534f63666da7b3cfbd7b" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_fa3600bd56a1534f63666da7b3cfbd7b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_fa3600bd56a1534f63666da7b3cfbd7b&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-244ef704eea5aa63cb1f9d18883bc534"><a href="#blockserializationutils-lambda-244ef704eea5aa63cb1f9d18883bc534" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_244ef704eea5aa63cb1f9d18883bc534&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_244ef704eea5aa63cb1f9d18883bc534&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-d91658c8cc09b0339182c5a1a9e87015"><a href="#blockserializationutils-lambda-d91658c8cc09b0339182c5a1a9e87015" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_d91658c8cc09b0339182c5a1a9e87015&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_d91658c8cc09b0339182c5a1a9e87015&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-4a62419ca4a02c449b017cd0fce13986"><a href="#blockserializationutils-lambda-4a62419ca4a02c449b017cd0fce13986" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_4a62419ca4a02c449b017cd0fce13986&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_4a62419ca4a02c449b017cd0fce13986&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-e778efc78cc8ddf4d370f7912963d6eb"><a href="#blockserializationutils-lambda-e778efc78cc8ddf4d370f7912963d6eb" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_e778efc78cc8ddf4d370f7912963d6eb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_e778efc78cc8ddf4d370f7912963d6eb&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-886224d4082bdf8c086dd2f61e422482"><a href="#blockserializationutils-lambda-886224d4082bdf8c086dd2f61e422482" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_886224d4082bdf8c086dd2f61e422482&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_886224d4082bdf8c086dd2f61e422482&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-5904a2917e55a67f8a253b60b6f8fd36"><a href="#blockserializationutils-lambda-5904a2917e55a67f8a253b60b6f8fd36" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_5904a2917e55a67f8a253b60b6f8fd36&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_5904a2917e55a67f8a253b60b6f8fd36&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-f1ed6f48f9a7b639a231f501856d019f"><a href="#blockserializationutils-lambda-f1ed6f48f9a7b639a231f501856d019f" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_f1ed6f48f9a7b639a231f501856d019f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_f1ed6f48f9a7b639a231f501856d019f&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-2ef117843c80acd549be97116c8dde90"><a href="#blockserializationutils-lambda-2ef117843c80acd549be97116c8dde90" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_2ef117843c80acd549be97116c8dde90&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_2ef117843c80acd549be97116c8dde90&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-213dc2d94875495d5097ea3dd15d9a1e"><a href="#blockserializationutils-lambda-213dc2d94875495d5097ea3dd15d9a1e" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_213dc2d94875495d5097ea3dd15d9a1e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_213dc2d94875495d5097ea3dd15d9a1e&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-417d1e96c37e1ca48f2dafb6a9c6228d"><a href="#blockserializationutils-lambda-417d1e96c37e1ca48f2dafb6a9c6228d" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_417d1e96c37e1ca48f2dafb6a9c6228d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_417d1e96c37e1ca48f2dafb6a9c6228d&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-2f9e6b501bab06c9271a912361d42fed"><a href="#blockserializationutils-lambda-2f9e6b501bab06c9271a912361d42fed" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_2f9e6b501bab06c9271a912361d42fed&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_2f9e6b501bab06c9271a912361d42fed&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-67a63e26aa15305377f26047eb0a56df"><a href="#blockserializationutils-lambda-67a63e26aa15305377f26047eb0a56df" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_67a63e26aa15305377f26047eb0a56df&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_67a63e26aa15305377f26047eb0a56df&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-9f43e194fb0ac5e519d42e530b4e9b8f"><a href="#blockserializationutils-lambda-9f43e194fb0ac5e519d42e530b4e9b8f" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_9f43e194fb0ac5e519d42e530b4e9b8f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_9f43e194fb0ac5e519d42e530b4e9b8f&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-798a04fd2847211a026b83a1d7a042d8"><a href="#blockserializationutils-lambda-798a04fd2847211a026b83a1d7a042d8" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_798a04fd2847211a026b83a1d7a042d8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_798a04fd2847211a026b83a1d7a042d8&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-62546bb4a527560d6418061ae8df526d"><a href="#blockserializationutils-lambda-62546bb4a527560d6418061ae8df526d" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_62546bb4a527560d6418061ae8df526d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_62546bb4a527560d6418061ae8df526d&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-132571df59eb34a18f760a98fba05206"><a href="#blockserializationutils-lambda-132571df59eb34a18f760a98fba05206" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_132571df59eb34a18f760a98fba05206&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_132571df59eb34a18f760a98fba05206&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-0c468b720adc7c9254e30817f3890b7a"><a href="#blockserializationutils-lambda-0c468b720adc7c9254e30817f3890b7a" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_0c468b720adc7c9254e30817f3890b7a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_0c468b720adc7c9254e30817f3890b7a&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-e7120cd4e9b688165b9aa1e73b0f809f"><a href="#blockserializationutils-lambda-e7120cd4e9b688165b9aa1e73b0f809f" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_e7120cd4e9b688165b9aa1e73b0f809f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_e7120cd4e9b688165b9aa1e73b0f809f&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-52d008f53c49bd081219984e761fb544"><a href="#blockserializationutils-lambda-52d008f53c49bd081219984e761fb544" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_52d008f53c49bd081219984e761fb544&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_52d008f53c49bd081219984e761fb544&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-9f343462091d01c098a6fa28e542a2bf"><a href="#blockserializationutils-lambda-9f343462091d01c098a6fa28e542a2bf" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_9f343462091d01c098a6fa28e542a2bf&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_9f343462091d01c098a6fa28e542a2bf&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-17da692630b94393008544e8f2c1073e"><a href="#blockserializationutils-lambda-17da692630b94393008544e8f2c1073e" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_17da692630b94393008544e8f2c1073e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_17da692630b94393008544e8f2c1073e&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-58c3360145a5c1ffbc17058e4903fce0"><a href="#blockserializationutils-lambda-58c3360145a5c1ffbc17058e4903fce0" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_58c3360145a5c1ffbc17058e4903fce0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_58c3360145a5c1ffbc17058e4903fce0&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-6d291b38ad7503b1063a69c4c4a0d373"><a href="#blockserializationutils-lambda-6d291b38ad7503b1063a69c4c4a0d373" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_6d291b38ad7503b1063a69c4c4a0d373&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_6d291b38ad7503b1063a69c4c4a0d373&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-77b3bba338ba37df6b8f39abb11f2e84"><a href="#blockserializationutils-lambda-77b3bba338ba37df6b8f39abb11f2e84" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_77b3bba338ba37df6b8f39abb11f2e84&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_77b3bba338ba37df6b8f39abb11f2e84&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-9c8777d21e42fef9d68ac5391cb9bece"><a href="#blockserializationutils-lambda-9c8777d21e42fef9d68ac5391cb9bece" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_9c8777d21e42fef9d68ac5391cb9bece&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_9c8777d21e42fef9d68ac5391cb9bece&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-83daccaee1122b8327ff046e252a2042"><a href="#blockserializationutils-lambda-83daccaee1122b8327ff046e252a2042" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_83daccaee1122b8327ff046e252a2042&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_83daccaee1122b8327ff046e252a2042&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-f7c3c8206c88a2520e27451ff1392891"><a href="#blockserializationutils-lambda-f7c3c8206c88a2520e27451ff1392891" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_f7c3c8206c88a2520e27451ff1392891&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_f7c3c8206c88a2520e27451ff1392891&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-25a90d9c4ebba7333b67781be8b3c122"><a href="#blockserializationutils-lambda-25a90d9c4ebba7333b67781be8b3c122" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_25a90d9c4ebba7333b67781be8b3c122&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_25a90d9c4ebba7333b67781be8b3c122&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-dfe2b161b80c37784e81cfdd60a64fd7"><a href="#blockserializationutils-lambda-dfe2b161b80c37784e81cfdd60a64fd7" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_dfe2b161b80c37784e81cfdd60a64fd7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_dfe2b161b80c37784e81cfdd60a64fd7&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-e8b6d3924e6395d5c61e9f6a88daff3a"><a href="#blockserializationutils-lambda-e8b6d3924e6395d5c61e9f6a88daff3a" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_e8b6d3924e6395d5c61e9f6a88daff3a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_e8b6d3924e6395d5c61e9f6a88daff3a&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-e1b39284fb325a9fc5fee4db216ede87"><a href="#blockserializationutils-lambda-e1b39284fb325a9fc5fee4db216ede87" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_e1b39284fb325a9fc5fee4db216ede87&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_e1b39284fb325a9fc5fee4db216ede87&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-514eaf3e167c4cc40851d43fedcdc402"><a href="#blockserializationutils-lambda-514eaf3e167c4cc40851d43fedcdc402" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_514eaf3e167c4cc40851d43fedcdc402&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_514eaf3e167c4cc40851d43fedcdc402&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-4870085a47b514f0533913c903dcd1a9"><a href="#blockserializationutils-lambda-4870085a47b514f0533913c903dcd1a9" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_4870085a47b514f0533913c903dcd1a9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_4870085a47b514f0533913c903dcd1a9&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-5ed417f39bd98751db56e791ece7cb10"><a href="#blockserializationutils-lambda-5ed417f39bd98751db56e791ece7cb10" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_5ed417f39bd98751db56e791ece7cb10&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_5ed417f39bd98751db56e791ece7cb10&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-633bd25265605641a8f9cb5d1ccab560"><a href="#blockserializationutils-lambda-633bd25265605641a8f9cb5d1ccab560" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_633bd25265605641a8f9cb5d1ccab560&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_633bd25265605641a8f9cb5d1ccab560&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-39fbcccb7c7bf029cb18111282f8c368"><a href="#blockserializationutils-lambda-39fbcccb7c7bf029cb18111282f8c368" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_39fbcccb7c7bf029cb18111282f8c368&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_39fbcccb7c7bf029cb18111282f8c368&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-f7865132b42f5c8f7cf98bddaf9fc08c"><a href="#blockserializationutils-lambda-f7865132b42f5c8f7cf98bddaf9fc08c" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_f7865132b42f5c8f7cf98bddaf9fc08c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_f7865132b42f5c8f7cf98bddaf9fc08c&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-5a919aa231f9ba1f4b63a9263fce778d"><a href="#blockserializationutils-lambda-5a919aa231f9ba1f4b63a9263fce778d" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_5a919aa231f9ba1f4b63a9263fce778d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_5a919aa231f9ba1f4b63a9263fce778d&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-4acab81f8277b78b0d65320d8303db54"><a href="#blockserializationutils-lambda-4acab81f8277b78b0d65320d8303db54" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_4acab81f8277b78b0d65320d8303db54&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_4acab81f8277b78b0d65320d8303db54&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-9dc5fe5c9fa7b26ea354e190fe5ee983"><a href="#blockserializationutils-lambda-9dc5fe5c9fa7b26ea354e190fe5ee983" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_9dc5fe5c9fa7b26ea354e190fe5ee983&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_9dc5fe5c9fa7b26ea354e190fe5ee983&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-7c4774d03f6bdfef7d3c09c34cb90361"><a href="#blockserializationutils-lambda-7c4774d03f6bdfef7d3c09c34cb90361" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_7c4774d03f6bdfef7d3c09c34cb90361&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_7c4774d03f6bdfef7d3c09c34cb90361&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-87e3ca8383c2e6c0d80d8f86a30404a3"><a href="#blockserializationutils-lambda-87e3ca8383c2e6c0d80d8f86a30404a3" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_87e3ca8383c2e6c0d80d8f86a30404a3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_87e3ca8383c2e6c0d80d8f86a30404a3&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-8ee582a5d5ef889ae713440f7b568db1"><a href="#blockserializationutils-lambda-8ee582a5d5ef889ae713440f7b568db1" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_8ee582a5d5ef889ae713440f7b568db1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_8ee582a5d5ef889ae713440f7b568db1&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-8f3aec30a2b85700b60a88197cc2c0d7"><a href="#blockserializationutils-lambda-8f3aec30a2b85700b60a88197cc2c0d7" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_8f3aec30a2b85700b60a88197cc2c0d7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_8f3aec30a2b85700b60a88197cc2c0d7&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-37374d23cdd4b05e89d1f8c2ab538dc6"><a href="#blockserializationutils-lambda-37374d23cdd4b05e89d1f8c2ab538dc6" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_37374d23cdd4b05e89d1f8c2ab538dc6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_37374d23cdd4b05e89d1f8c2ab538dc6&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-b69e0b83aa82a8115c8a8f6395157c66"><a href="#blockserializationutils-lambda-b69e0b83aa82a8115c8a8f6395157c66" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_b69e0b83aa82a8115c8a8f6395157c66&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_b69e0b83aa82a8115c8a8f6395157c66&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-92cbd13327c65817b8da5515f319827f"><a href="#blockserializationutils-lambda-92cbd13327c65817b8da5515f319827f" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_92cbd13327c65817b8da5515f319827f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_92cbd13327c65817b8da5515f319827f&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-fc03a6576434cddee2bbf3252d500c7c"><a href="#blockserializationutils-lambda-fc03a6576434cddee2bbf3252d500c7c" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_fc03a6576434cddee2bbf3252d500c7c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_fc03a6576434cddee2bbf3252d500c7c&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-46dec10d01150c8df455d6443728e9e9"><a href="#blockserializationutils-lambda-46dec10d01150c8df455d6443728e9e9" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_46dec10d01150c8df455d6443728e9e9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_46dec10d01150c8df455d6443728e9e9&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-cc2ff158363c3e4cad7786e84d0574c9"><a href="#blockserializationutils-lambda-cc2ff158363c3e4cad7786e84d0574c9" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_cc2ff158363c3e4cad7786e84d0574c9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_cc2ff158363c3e4cad7786e84d0574c9&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-0da51c364bdadd59bc27fa537a15e0d4"><a href="#blockserializationutils-lambda-0da51c364bdadd59bc27fa537a15e0d4" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_0da51c364bdadd59bc27fa537a15e0d4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_0da51c364bdadd59bc27fa537a15e0d4&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-ea10f2191d60813c2f7f96b0b907e7dd"><a href="#blockserializationutils-lambda-ea10f2191d60813c2f7f96b0b907e7dd" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_ea10f2191d60813c2f7f96b0b907e7dd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_ea10f2191d60813c2f7f96b0b907e7dd&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-4fb3118920b9164aaf8908c5eb1b951a"><a href="#blockserializationutils-lambda-4fb3118920b9164aaf8908c5eb1b951a" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_4fb3118920b9164aaf8908c5eb1b951a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_4fb3118920b9164aaf8908c5eb1b951a&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-894121c1bdb7e464b30645e16073fd2b"><a href="#blockserializationutils-lambda-894121c1bdb7e464b30645e16073fd2b" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_894121c1bdb7e464b30645e16073fd2b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_894121c1bdb7e464b30645e16073fd2b&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-21f90e89907a39f26e33d0138efabc5f"><a href="#blockserializationutils-lambda-21f90e89907a39f26e33d0138efabc5f" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_21f90e89907a39f26e33d0138efabc5f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_21f90e89907a39f26e33d0138efabc5f&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-bfb1de0b875d4d43bf37f438dbee6a4e"><a href="#blockserializationutils-lambda-bfb1de0b875d4d43bf37f438dbee6a4e" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_bfb1de0b875d4d43bf37f438dbee6a4e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_bfb1de0b875d4d43bf37f438dbee6a4e&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-7541b4dfa2ac6a7db09ac2e8a7eecb0e"><a href="#blockserializationutils-lambda-7541b4dfa2ac6a7db09ac2e8a7eecb0e" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_7541b4dfa2ac6a7db09ac2e8a7eecb0e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_7541b4dfa2ac6a7db09ac2e8a7eecb0e&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-a89591253bb4bab0ca5c6b449e90dc86"><a href="#blockserializationutils-lambda-a89591253bb4bab0ca5c6b449e90dc86" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_a89591253bb4bab0ca5c6b449e90dc86&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_a89591253bb4bab0ca5c6b449e90dc86&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-cec701a19c5f9f5bc36dfdf03c642ceb"><a href="#blockserializationutils-lambda-cec701a19c5f9f5bc36dfdf03c642ceb" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_cec701a19c5f9f5bc36dfdf03c642ceb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_cec701a19c5f9f5bc36dfdf03c642ceb&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-c9d612fbfad9699669f760f0160a02db"><a href="#blockserializationutils-lambda-c9d612fbfad9699669f760f0160a02db" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_c9d612fbfad9699669f760f0160a02db&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_c9d612fbfad9699669f760f0160a02db&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-956cdab44be66d5197e22c3a855e5b69"><a href="#blockserializationutils-lambda-956cdab44be66d5197e22c3a855e5b69" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_956cdab44be66d5197e22c3a855e5b69&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_956cdab44be66d5197e22c3a855e5b69&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-b5ec29e6aa1a63684dd74e8901379a71"><a href="#blockserializationutils-lambda-b5ec29e6aa1a63684dd74e8901379a71" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_b5ec29e6aa1a63684dd74e8901379a71&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_b5ec29e6aa1a63684dd74e8901379a71&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-7a4b7ad1b18e5ad29c5dcd63724ec623"><a href="#blockserializationutils-lambda-7a4b7ad1b18e5ad29c5dcd63724ec623" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_7a4b7ad1b18e5ad29c5dcd63724ec623&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_7a4b7ad1b18e5ad29c5dcd63724ec623&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-953f8970144e1c7e010b1bf50aceb858"><a href="#blockserializationutils-lambda-953f8970144e1c7e010b1bf50aceb858" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_953f8970144e1c7e010b1bf50aceb858&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_953f8970144e1c7e010b1bf50aceb858&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-3be53f580cd60341de483f3b38e95be4"><a href="#blockserializationutils-lambda-3be53f580cd60341de483f3b38e95be4" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_3be53f580cd60341de483f3b38e95be4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_3be53f580cd60341de483f3b38e95be4&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-072e20da3c3546077ad9fac18aff268f"><a href="#blockserializationutils-lambda-072e20da3c3546077ad9fac18aff268f" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_072e20da3c3546077ad9fac18aff268f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_072e20da3c3546077ad9fac18aff268f&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-c33fa34117d50e6d84953ee6ac15f21f"><a href="#blockserializationutils-lambda-c33fa34117d50e6d84953ee6ac15f21f" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_c33fa34117d50e6d84953ee6ac15f21f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_c33fa34117d50e6d84953ee6ac15f21f&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-3ba8d13556d0208451be9f301b20488f"><a href="#blockserializationutils-lambda-3ba8d13556d0208451be9f301b20488f" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_3ba8d13556d0208451be9f301b20488f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_3ba8d13556d0208451be9f301b20488f&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-ad220bcab3fa600f37cd234a06c2f562"><a href="#blockserializationutils-lambda-ad220bcab3fa600f37cd234a06c2f562" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_ad220bcab3fa600f37cd234a06c2f562&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_ad220bcab3fa600f37cd234a06c2f562&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-55a996f326e9bd25d76cd6345f632a7a"><a href="#blockserializationutils-lambda-55a996f326e9bd25d76cd6345f632a7a" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_55a996f326e9bd25d76cd6345f632a7a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_55a996f326e9bd25d76cd6345f632a7a&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-846c4b8abb6ba7fcac664aa7377aa006"><a href="#blockserializationutils-lambda-846c4b8abb6ba7fcac664aa7377aa006" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_846c4b8abb6ba7fcac664aa7377aa006&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_846c4b8abb6ba7fcac664aa7377aa006&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-8f29401e704da5e05ec9734a207f563b"><a href="#blockserializationutils-lambda-8f29401e704da5e05ec9734a207f563b" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_8f29401e704da5e05ec9734a207f563b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_8f29401e704da5e05ec9734a207f563b&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-004be5b6fa5b78c9b8adeaf94069d601"><a href="#blockserializationutils-lambda-004be5b6fa5b78c9b8adeaf94069d601" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_004be5b6fa5b78c9b8adeaf94069d601&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_004be5b6fa5b78c9b8adeaf94069d601&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-19eaaaa315c8a15378bed5bb1897da50"><a href="#blockserializationutils-lambda-19eaaaa315c8a15378bed5bb1897da50" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_19eaaaa315c8a15378bed5bb1897da50&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_19eaaaa315c8a15378bed5bb1897da50&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-b86e514372db9652b8fa3805b0df3a1e"><a href="#blockserializationutils-lambda-b86e514372db9652b8fa3805b0df3a1e" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_b86e514372db9652b8fa3805b0df3a1e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_b86e514372db9652b8fa3805b0df3a1e&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-a8fca6a99b2e989d529019f6a8656001"><a href="#blockserializationutils-lambda-a8fca6a99b2e989d529019f6a8656001" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_a8fca6a99b2e989d529019f6a8656001&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_a8fca6a99b2e989d529019f6a8656001&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-bbd8a0dea13b4a27264cab0ddabc331c"><a href="#blockserializationutils-lambda-bbd8a0dea13b4a27264cab0ddabc331c" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_bbd8a0dea13b4a27264cab0ddabc331c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_bbd8a0dea13b4a27264cab0ddabc331c&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-7238f1484e2fe70ac6df34442375cd94"><a href="#blockserializationutils-lambda-7238f1484e2fe70ac6df34442375cd94" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_7238f1484e2fe70ac6df34442375cd94&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_7238f1484e2fe70ac6df34442375cd94&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-77a9d01c9329a5b267133cb97b47b40b"><a href="#blockserializationutils-lambda-77a9d01c9329a5b267133cb97b47b40b" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_77a9d01c9329a5b267133cb97b47b40b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_77a9d01c9329a5b267133cb97b47b40b&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-38a9b0207bb3fc83a8770b5470c79eec"><a href="#blockserializationutils-lambda-38a9b0207bb3fc83a8770b5470c79eec" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_38a9b0207bb3fc83a8770b5470c79eec&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_38a9b0207bb3fc83a8770b5470c79eec&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-f8ef20131a7fca5fb97d6e361fc3943f"><a href="#blockserializationutils-lambda-f8ef20131a7fca5fb97d6e361fc3943f" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_f8ef20131a7fca5fb97d6e361fc3943f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_f8ef20131a7fca5fb97d6e361fc3943f&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-004685af1a11991fd7dfcf021cdaa64d"><a href="#blockserializationutils-lambda-004685af1a11991fd7dfcf021cdaa64d" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_004685af1a11991fd7dfcf021cdaa64d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_004685af1a11991fd7dfcf021cdaa64d&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-dcea529a71bef71f14749d8c90f399b2"><a href="#blockserializationutils-lambda-dcea529a71bef71f14749d8c90f399b2" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_dcea529a71bef71f14749d8c90f399b2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_dcea529a71bef71f14749d8c90f399b2&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-3b9d5e9eacb1a1a865c43b51fed2a2e3"><a href="#blockserializationutils-lambda-3b9d5e9eacb1a1a865c43b51fed2a2e3" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_3b9d5e9eacb1a1a865c43b51fed2a2e3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_3b9d5e9eacb1a1a865c43b51fed2a2e3&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-d091ef4edf66be00a00642c2bd2a97f0"><a href="#blockserializationutils-lambda-d091ef4edf66be00a00642c2bd2a97f0" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_d091ef4edf66be00a00642c2bd2a97f0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_d091ef4edf66be00a00642c2bd2a97f0&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-48bdc52667a74a9cba6ac48bb060c4e7"><a href="#blockserializationutils-lambda-48bdc52667a74a9cba6ac48bb060c4e7" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_48bdc52667a74a9cba6ac48bb060c4e7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_48bdc52667a74a9cba6ac48bb060c4e7&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-3d9136b72324b1c1e85620fb476ccb3f"><a href="#blockserializationutils-lambda-3d9136b72324b1c1e85620fb476ccb3f" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_3d9136b72324b1c1e85620fb476ccb3f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_3d9136b72324b1c1e85620fb476ccb3f&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-79d10e13b89dd9fab80a33352fdb1e3b"><a href="#blockserializationutils-lambda-79d10e13b89dd9fab80a33352fdb1e3b" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_79d10e13b89dd9fab80a33352fdb1e3b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_79d10e13b89dd9fab80a33352fdb1e3b&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-77c84c148e95142eb75c7826f6649bc0"><a href="#blockserializationutils-lambda-77c84c148e95142eb75c7826f6649bc0" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_77c84c148e95142eb75c7826f6649bc0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_77c84c148e95142eb75c7826f6649bc0&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-d6987d7bf7fd30400e4b9256bf31af66"><a href="#blockserializationutils-lambda-d6987d7bf7fd30400e4b9256bf31af66" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_d6987d7bf7fd30400e4b9256bf31af66&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_d6987d7bf7fd30400e4b9256bf31af66&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-52a9006590c0e7dda0c284315f59f3e1"><a href="#blockserializationutils-lambda-52a9006590c0e7dda0c284315f59f3e1" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_52a9006590c0e7dda0c284315f59f3e1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_52a9006590c0e7dda0c284315f59f3e1&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-a13fe0e459ff7fe0ecc915115cb98f36"><a href="#blockserializationutils-lambda-a13fe0e459ff7fe0ecc915115cb98f36" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_a13fe0e459ff7fe0ecc915115cb98f36&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_a13fe0e459ff7fe0ecc915115cb98f36&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-a77974a6853122b76d5c74fd39c59957"><a href="#blockserializationutils-lambda-a77974a6853122b76d5c74fd39c59957" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_a77974a6853122b76d5c74fd39c59957&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_a77974a6853122b76d5c74fd39c59957&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-6ea1eca1adcae043c74a11f68b3da135"><a href="#blockserializationutils-lambda-6ea1eca1adcae043c74a11f68b3da135" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_6ea1eca1adcae043c74a11f68b3da135&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_6ea1eca1adcae043c74a11f68b3da135&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-e2859667c953321c444c777bdef35622"><a href="#blockserializationutils-lambda-e2859667c953321c444c777bdef35622" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_e2859667c953321c444c777bdef35622&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_e2859667c953321c444c777bdef35622&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-a92e69a4c04f92cbf1e8e19b0c12fa2d"><a href="#blockserializationutils-lambda-a92e69a4c04f92cbf1e8e19b0c12fa2d" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_a92e69a4c04f92cbf1e8e19b0c12fa2d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_a92e69a4c04f92cbf1e8e19b0c12fa2d&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-8428118b34244b71b887a59143e7a9fa"><a href="#blockserializationutils-lambda-8428118b34244b71b887a59143e7a9fa" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_8428118b34244b71b887a59143e7a9fa&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_8428118b34244b71b887a59143e7a9fa&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-6cf682a8d95c29558beca2661793f8ed"><a href="#blockserializationutils-lambda-6cf682a8d95c29558beca2661793f8ed" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_6cf682a8d95c29558beca2661793f8ed&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_6cf682a8d95c29558beca2661793f8ed&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-d8fa2f79c98b9dc97e1d575cb7c91879"><a href="#blockserializationutils-lambda-d8fa2f79c98b9dc97e1d575cb7c91879" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_d8fa2f79c98b9dc97e1d575cb7c91879&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_d8fa2f79c98b9dc97e1d575cb7c91879&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-c9e8b0aa6a78d42c6312471d06b8516c"><a href="#blockserializationutils-lambda-c9e8b0aa6a78d42c6312471d06b8516c" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_c9e8b0aa6a78d42c6312471d06b8516c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_c9e8b0aa6a78d42c6312471d06b8516c&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-4cf77149a2917fde5bfaeb7a88f03e29"><a href="#blockserializationutils-lambda-4cf77149a2917fde5bfaeb7a88f03e29" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_4cf77149a2917fde5bfaeb7a88f03e29&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_4cf77149a2917fde5bfaeb7a88f03e29&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-46501efeb038e1117703698f94186212"><a href="#blockserializationutils-lambda-46501efeb038e1117703698f94186212" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_46501efeb038e1117703698f94186212&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_46501efeb038e1117703698f94186212&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-d3ae9a9d053e9156ececa7b5569c3736"><a href="#blockserializationutils-lambda-d3ae9a9d053e9156ececa7b5569c3736" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_d3ae9a9d053e9156ececa7b5569c3736&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_d3ae9a9d053e9156ececa7b5569c3736&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-0730084efe72c8be9d237570b2a7fcc3"><a href="#blockserializationutils-lambda-0730084efe72c8be9d237570b2a7fcc3" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_0730084efe72c8be9d237570b2a7fcc3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_0730084efe72c8be9d237570b2a7fcc3&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-f33152037d93e168ee2daf602f847cbf"><a href="#blockserializationutils-lambda-f33152037d93e168ee2daf602f847cbf" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_f33152037d93e168ee2daf602f847cbf&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_f33152037d93e168ee2daf602f847cbf&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-dbb7c86e78cb4d856820de1cdef3d9ad"><a href="#blockserializationutils-lambda-dbb7c86e78cb4d856820de1cdef3d9ad" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_dbb7c86e78cb4d856820de1cdef3d9ad&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_dbb7c86e78cb4d856820de1cdef3d9ad&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-65363a572086fb22ab5ec06a3afe3853"><a href="#blockserializationutils-lambda-65363a572086fb22ab5ec06a3afe3853" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_65363a572086fb22ab5ec06a3afe3853&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_65363a572086fb22ab5ec06a3afe3853&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-b83d5145f9711a48958f86f683c3e703"><a href="#blockserializationutils-lambda-b83d5145f9711a48958f86f683c3e703" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_b83d5145f9711a48958f86f683c3e703&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_b83d5145f9711a48958f86f683c3e703&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-6bb229817dc72b323ebfe9ff605e00b8"><a href="#blockserializationutils-lambda-6bb229817dc72b323ebfe9ff605e00b8" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_6bb229817dc72b323ebfe9ff605e00b8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_6bb229817dc72b323ebfe9ff605e00b8&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-537f727195b63c5e49d00b56a3af7cc6"><a href="#blockserializationutils-lambda-537f727195b63c5e49d00b56a3af7cc6" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_537f727195b63c5e49d00b56a3af7cc6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_537f727195b63c5e49d00b56a3af7cc6&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-9dd905b5dcc2c2ce02cf416f0354ae2a"><a href="#blockserializationutils-lambda-9dd905b5dcc2c2ce02cf416f0354ae2a" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_9dd905b5dcc2c2ce02cf416f0354ae2a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_9dd905b5dcc2c2ce02cf416f0354ae2a&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-cd9dafb2469335aa35b0b5f5aeac25b9"><a href="#blockserializationutils-lambda-cd9dafb2469335aa35b0b5f5aeac25b9" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_cd9dafb2469335aa35b0b5f5aeac25b9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_cd9dafb2469335aa35b0b5f5aeac25b9&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-a39287cc5453d8bd8270c603aa4a2ed4"><a href="#blockserializationutils-lambda-a39287cc5453d8bd8270c603aa4a2ed4" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_a39287cc5453d8bd8270c603aa4a2ed4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_a39287cc5453d8bd8270c603aa4a2ed4&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-880eb1662c280a9a54fc30e52c108db1"><a href="#blockserializationutils-lambda-880eb1662c280a9a54fc30e52c108db1" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_880eb1662c280a9a54fc30e52c108db1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_880eb1662c280a9a54fc30e52c108db1&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-c1930eb8f1d3d87d6c21d78c5b5af506"><a href="#blockserializationutils-lambda-c1930eb8f1d3d87d6c21d78c5b5af506" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_c1930eb8f1d3d87d6c21d78c5b5af506&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_c1930eb8f1d3d87d6c21d78c5b5af506&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-9b6ae55357330423f18f3e6ff446dd1c"><a href="#blockserializationutils-lambda-9b6ae55357330423f18f3e6ff446dd1c" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_9b6ae55357330423f18f3e6ff446dd1c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_9b6ae55357330423f18f3e6ff446dd1c&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-2f0f08543c10cb0afdfa867616f57f57"><a href="#blockserializationutils-lambda-2f0f08543c10cb0afdfa867616f57f57" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_2f0f08543c10cb0afdfa867616f57f57&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_2f0f08543c10cb0afdfa867616f57f57&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-5c7b3f99b943689ca2cd428c9fbd4bea"><a href="#blockserializationutils-lambda-5c7b3f99b943689ca2cd428c9fbd4bea" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_5c7b3f99b943689ca2cd428c9fbd4bea&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_5c7b3f99b943689ca2cd428c9fbd4bea&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-0cf65595139336f3e89cbbf78e78c9b0"><a href="#blockserializationutils-lambda-0cf65595139336f3e89cbbf78e78c9b0" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_0cf65595139336f3e89cbbf78e78c9b0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_0cf65595139336f3e89cbbf78e78c9b0&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-0a6f5383d730dd8b92e1159be66ec376"><a href="#blockserializationutils-lambda-0a6f5383d730dd8b92e1159be66ec376" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_0a6f5383d730dd8b92e1159be66ec376&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_0a6f5383d730dd8b92e1159be66ec376&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-6d9740f9d85b8fe0fe2fcd3ac015d095"><a href="#blockserializationutils-lambda-6d9740f9d85b8fe0fe2fcd3ac015d095" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_6d9740f9d85b8fe0fe2fcd3ac015d095&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_6d9740f9d85b8fe0fe2fcd3ac015d095&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-e81423d5a7ebefcd0e55b180efc99dd4"><a href="#blockserializationutils-lambda-e81423d5a7ebefcd0e55b180efc99dd4" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_e81423d5a7ebefcd0e55b180efc99dd4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_e81423d5a7ebefcd0e55b180efc99dd4&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-976efd94a5f0085b9dad031f49cf7e0e"><a href="#blockserializationutils-lambda-976efd94a5f0085b9dad031f49cf7e0e" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_976efd94a5f0085b9dad031f49cf7e0e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_976efd94a5f0085b9dad031f49cf7e0e&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-e7edf058f6cdd8704ff56c1b7651c98b"><a href="#blockserializationutils-lambda-e7edf058f6cdd8704ff56c1b7651c98b" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_e7edf058f6cdd8704ff56c1b7651c98b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_e7edf058f6cdd8704ff56c1b7651c98b&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-de1b9469f49bd9cbf443affd2dce3bfc"><a href="#blockserializationutils-lambda-de1b9469f49bd9cbf443affd2dce3bfc" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_de1b9469f49bd9cbf443affd2dce3bfc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_de1b9469f49bd9cbf443affd2dce3bfc&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-9ad0876a6b34d7d84a87821c07ad588f"><a href="#blockserializationutils-lambda-9ad0876a6b34d7d84a87821c07ad588f" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_9ad0876a6b34d7d84a87821c07ad588f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_9ad0876a6b34d7d84a87821c07ad588f&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-8c29a74f21ea5c343fef298b3f2b0872"><a href="#blockserializationutils-lambda-8c29a74f21ea5c343fef298b3f2b0872" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_8c29a74f21ea5c343fef298b3f2b0872&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_8c29a74f21ea5c343fef298b3f2b0872&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-7af4031d2b0a9e035cd44eb97fc216ce"><a href="#blockserializationutils-lambda-7af4031d2b0a9e035cd44eb97fc216ce" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_7af4031d2b0a9e035cd44eb97fc216ce&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_7af4031d2b0a9e035cd44eb97fc216ce&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-3f5b2342cf87bbafc2a8943847a51b18"><a href="#blockserializationutils-lambda-3f5b2342cf87bbafc2a8943847a51b18" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_3f5b2342cf87bbafc2a8943847a51b18&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_3f5b2342cf87bbafc2a8943847a51b18&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-9fa357ecc7ef5bef6d2d0ff4eea8f1ac"><a href="#blockserializationutils-lambda-9fa357ecc7ef5bef6d2d0ff4eea8f1ac" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_9fa357ecc7ef5bef6d2d0ff4eea8f1ac&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_9fa357ecc7ef5bef6d2d0ff4eea8f1ac&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-51c4cccda65e8f8640e0a6cda2f5a5a2"><a href="#blockserializationutils-lambda-51c4cccda65e8f8640e0a6cda2f5a5a2" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_51c4cccda65e8f8640e0a6cda2f5a5a2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_51c4cccda65e8f8640e0a6cda2f5a5a2&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-e0dac7234f50d867291491a20b5d2f14"><a href="#blockserializationutils-lambda-e0dac7234f50d867291491a20b5d2f14" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_e0dac7234f50d867291491a20b5d2f14&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_e0dac7234f50d867291491a20b5d2f14&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-dd23a837fd20abc0d0c0c8deba79c056"><a href="#blockserializationutils-lambda-dd23a837fd20abc0d0c0c8deba79c056" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_dd23a837fd20abc0d0c0c8deba79c056&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_dd23a837fd20abc0d0c0c8deba79c056&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-7084b57e619eb27e60cacefd434af631"><a href="#blockserializationutils-lambda-7084b57e619eb27e60cacefd434af631" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_7084b57e619eb27e60cacefd434af631&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_7084b57e619eb27e60cacefd434af631&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-8ace8b70b8924be52d731e7bcb93ce54"><a href="#blockserializationutils-lambda-8ace8b70b8924be52d731e7bcb93ce54" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_8ace8b70b8924be52d731e7bcb93ce54&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_8ace8b70b8924be52d731e7bcb93ce54&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-395376adf60bee2159de113e8b4d30e2"><a href="#blockserializationutils-lambda-395376adf60bee2159de113e8b4d30e2" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_395376adf60bee2159de113e8b4d30e2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_395376adf60bee2159de113e8b4d30e2&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-153d23d352602ec24cff82763dab3f73"><a href="#blockserializationutils-lambda-153d23d352602ec24cff82763dab3f73" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_153d23d352602ec24cff82763dab3f73&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_153d23d352602ec24cff82763dab3f73&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-992b07d152f9524e793f0ee752eaf4db"><a href="#blockserializationutils-lambda-992b07d152f9524e793f0ee752eaf4db" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_992b07d152f9524e793f0ee752eaf4db&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_992b07d152f9524e793f0ee752eaf4db&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-d9a3a0f3e48e5c4dd98e17e014eb08c0"><a href="#blockserializationutils-lambda-d9a3a0f3e48e5c4dd98e17e014eb08c0" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_d9a3a0f3e48e5c4dd98e17e014eb08c0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_d9a3a0f3e48e5c4dd98e17e014eb08c0&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-7095affb4e5945ed9f44bd67398d0cf0"><a href="#blockserializationutils-lambda-7095affb4e5945ed9f44bd67398d0cf0" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_7095affb4e5945ed9f44bd67398d0cf0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_7095affb4e5945ed9f44bd67398d0cf0&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-cc9497af8781284fa59c10670c38f11a"><a href="#blockserializationutils-lambda-cc9497af8781284fa59c10670c38f11a" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_cc9497af8781284fa59c10670c38f11a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_cc9497af8781284fa59c10670c38f11a&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-3cef73b50357c121285c3a6191b13e25"><a href="#blockserializationutils-lambda-3cef73b50357c121285c3a6191b13e25" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_3cef73b50357c121285c3a6191b13e25&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_3cef73b50357c121285c3a6191b13e25&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-6bdae7ef3ade7d293d80a28ff70aef7e"><a href="#blockserializationutils-lambda-6bdae7ef3ade7d293d80a28ff70aef7e" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_6bdae7ef3ade7d293d80a28ff70aef7e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_6bdae7ef3ade7d293d80a28ff70aef7e&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-910d614436e4bc1f78188f9f3dfe3b3a"><a href="#blockserializationutils-lambda-910d614436e4bc1f78188f9f3dfe3b3a" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_910d614436e4bc1f78188f9f3dfe3b3a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_910d614436e4bc1f78188f9f3dfe3b3a&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-0d92256ccb9d888aa7cb78ecfd5bb865"><a href="#blockserializationutils-lambda-0d92256ccb9d888aa7cb78ecfd5bb865" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_0d92256ccb9d888aa7cb78ecfd5bb865&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_0d92256ccb9d888aa7cb78ecfd5bb865&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-519a254294a692c54630dcea2ba973c4"><a href="#blockserializationutils-lambda-519a254294a692c54630dcea2ba973c4" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_519a254294a692c54630dcea2ba973c4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_519a254294a692c54630dcea2ba973c4&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-079767928ff9a283b9b7705874e4ecbd"><a href="#blockserializationutils-lambda-079767928ff9a283b9b7705874e4ecbd" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_079767928ff9a283b9b7705874e4ecbd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_079767928ff9a283b9b7705874e4ecbd&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-2f9df7967aa8d6f004fd5c3bff3ea19e"><a href="#blockserializationutils-lambda-2f9df7967aa8d6f004fd5c3bff3ea19e" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_2f9df7967aa8d6f004fd5c3bff3ea19e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_2f9df7967aa8d6f004fd5c3bff3ea19e&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-fbedc31c5d4c0956f04251234851414e"><a href="#blockserializationutils-lambda-fbedc31c5d4c0956f04251234851414e" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_fbedc31c5d4c0956f04251234851414e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_fbedc31c5d4c0956f04251234851414e&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-6872e4b36780ab15bb3ab0e34f56849a"><a href="#blockserializationutils-lambda-6872e4b36780ab15bb3ab0e34f56849a" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_6872e4b36780ab15bb3ab0e34f56849a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_6872e4b36780ab15bb3ab0e34f56849a&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-8085dcaef47b52aa22ab669ad03399e9"><a href="#blockserializationutils-lambda-8085dcaef47b52aa22ab669ad03399e9" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_8085dcaef47b52aa22ab669ad03399e9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_8085dcaef47b52aa22ab669ad03399e9&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-e147176d4a2f90ea786d5c583afa519f"><a href="#blockserializationutils-lambda-e147176d4a2f90ea786d5c583afa519f" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_e147176d4a2f90ea786d5c583afa519f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_e147176d4a2f90ea786d5c583afa519f&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-dd137991a6886a22c6644ffc6c55af1d"><a href="#blockserializationutils-lambda-dd137991a6886a22c6644ffc6c55af1d" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_dd137991a6886a22c6644ffc6c55af1d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_dd137991a6886a22c6644ffc6c55af1d&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-078e28398be7c95fdde00677d660e3b6"><a href="#blockserializationutils-lambda-078e28398be7c95fdde00677d660e3b6" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_078e28398be7c95fdde00677d660e3b6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_078e28398be7c95fdde00677d660e3b6&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-53b3394ae5179fecc6a12c1fd473e4e8"><a href="#blockserializationutils-lambda-53b3394ae5179fecc6a12c1fd473e4e8" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_53b3394ae5179fecc6a12c1fd473e4e8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_53b3394ae5179fecc6a12c1fd473e4e8&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-1b31d9c8eb125087f2302b69f119f287"><a href="#blockserializationutils-lambda-1b31d9c8eb125087f2302b69f119f287" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_1b31d9c8eb125087f2302b69f119f287&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_1b31d9c8eb125087f2302b69f119f287&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-b2a67c9e23dd0e630f7d8fbb6b480293"><a href="#blockserializationutils-lambda-b2a67c9e23dd0e630f7d8fbb6b480293" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_b2a67c9e23dd0e630f7d8fbb6b480293&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_b2a67c9e23dd0e630f7d8fbb6b480293&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-1c94a60dbf2a625ac0033030fda0ba05"><a href="#blockserializationutils-lambda-1c94a60dbf2a625ac0033030fda0ba05" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_1c94a60dbf2a625ac0033030fda0ba05&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_1c94a60dbf2a625ac0033030fda0ba05&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-5a68674f1a3517c6c0fcd038bd5fe6e4"><a href="#blockserializationutils-lambda-5a68674f1a3517c6c0fcd038bd5fe6e4" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_5a68674f1a3517c6c0fcd038bd5fe6e4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_5a68674f1a3517c6c0fcd038bd5fe6e4&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-d3eed8840205e457507d8b28b4bdcfd9"><a href="#blockserializationutils-lambda-d3eed8840205e457507d8b28b4bdcfd9" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_d3eed8840205e457507d8b28b4bdcfd9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_d3eed8840205e457507d8b28b4bdcfd9&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-40789fddd04686ba9830e71fa2bd92c3"><a href="#blockserializationutils-lambda-40789fddd04686ba9830e71fa2bd92c3" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_40789fddd04686ba9830e71fa2bd92c3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_40789fddd04686ba9830e71fa2bd92c3&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-c6e007ebb1adb882ad51375fc56095fb"><a href="#blockserializationutils-lambda-c6e007ebb1adb882ad51375fc56095fb" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_c6e007ebb1adb882ad51375fc56095fb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_c6e007ebb1adb882ad51375fc56095fb&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-95079b4ec55f954c0b7558155e6c9aa5"><a href="#blockserializationutils-lambda-95079b4ec55f954c0b7558155e6c9aa5" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_95079b4ec55f954c0b7558155e6c9aa5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_95079b4ec55f954c0b7558155e6c9aa5&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-3f3d2908ded9142320b8159948eefa96"><a href="#blockserializationutils-lambda-3f3d2908ded9142320b8159948eefa96" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_3f3d2908ded9142320b8159948eefa96&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_3f3d2908ded9142320b8159948eefa96&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-1cc70504779daa11198f8918a7f05f0a"><a href="#blockserializationutils-lambda-1cc70504779daa11198f8918a7f05f0a" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_1cc70504779daa11198f8918a7f05f0a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_1cc70504779daa11198f8918a7f05f0a&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-a86ba1034d7be72cffab510bd562b738"><a href="#blockserializationutils-lambda-a86ba1034d7be72cffab510bd562b738" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_a86ba1034d7be72cffab510bd562b738&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_a86ba1034d7be72cffab510bd562b738&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-94b388d3e55ad1773f279a5246e39d6b"><a href="#blockserializationutils-lambda-94b388d3e55ad1773f279a5246e39d6b" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_94b388d3e55ad1773f279a5246e39d6b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_94b388d3e55ad1773f279a5246e39d6b&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-3df30e04482179476cce1b4994a8bdda"><a href="#blockserializationutils-lambda-3df30e04482179476cce1b4994a8bdda" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_3df30e04482179476cce1b4994a8bdda&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_3df30e04482179476cce1b4994a8bdda&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-ba18e5cb7301b95f93caf86de1c7bc2f"><a href="#blockserializationutils-lambda-ba18e5cb7301b95f93caf86de1c7bc2f" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_ba18e5cb7301b95f93caf86de1c7bc2f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_ba18e5cb7301b95f93caf86de1c7bc2f&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-6c52f7f4cb6c8f798fbeda07f28bd1e5"><a href="#blockserializationutils-lambda-6c52f7f4cb6c8f798fbeda07f28bd1e5" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_6c52f7f4cb6c8f798fbeda07f28bd1e5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_6c52f7f4cb6c8f798fbeda07f28bd1e5&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-c4d2a6f1190fa0fb976b7655c0ee6dd2"><a href="#blockserializationutils-lambda-c4d2a6f1190fa0fb976b7655c0ee6dd2" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_c4d2a6f1190fa0fb976b7655c0ee6dd2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_c4d2a6f1190fa0fb976b7655c0ee6dd2&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-1ff600a0163b53a0c3aacd7cadc86776"><a href="#blockserializationutils-lambda-1ff600a0163b53a0c3aacd7cadc86776" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_1ff600a0163b53a0c3aacd7cadc86776&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_1ff600a0163b53a0c3aacd7cadc86776&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-286029a71ffa1f14653bacf7c0697e4f"><a href="#blockserializationutils-lambda-286029a71ffa1f14653bacf7c0697e4f" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_286029a71ffa1f14653bacf7c0697e4f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_286029a71ffa1f14653bacf7c0697e4f&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-9cd28e0f75edbdae525cf70c55f2db89"><a href="#blockserializationutils-lambda-9cd28e0f75edbdae525cf70c55f2db89" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_9cd28e0f75edbdae525cf70c55f2db89&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_9cd28e0f75edbdae525cf70c55f2db89&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-e8b4f668f54201cd3709a54bdaf9c430"><a href="#blockserializationutils-lambda-e8b4f668f54201cd3709a54bdaf9c430" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_e8b4f668f54201cd3709a54bdaf9c430&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_e8b4f668f54201cd3709a54bdaf9c430&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-69f4c8651dedfd511daccf8814a6e210"><a href="#blockserializationutils-lambda-69f4c8651dedfd511daccf8814a6e210" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_69f4c8651dedfd511daccf8814a6e210&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_69f4c8651dedfd511daccf8814a6e210&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-0db45da1a1eb846d9bfc1b0e1fa7e06e"><a href="#blockserializationutils-lambda-0db45da1a1eb846d9bfc1b0e1fa7e06e" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_0db45da1a1eb846d9bfc1b0e1fa7e06e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_0db45da1a1eb846d9bfc1b0e1fa7e06e&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-aa672cd002332cdb0211e3d1501f8231"><a href="#blockserializationutils-lambda-aa672cd002332cdb0211e3d1501f8231" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_aa672cd002332cdb0211e3d1501f8231&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_aa672cd002332cdb0211e3d1501f8231&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-8fe8d9c20f8b73440c650b54cdfc8b49"><a href="#blockserializationutils-lambda-8fe8d9c20f8b73440c650b54cdfc8b49" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_8fe8d9c20f8b73440c650b54cdfc8b49&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_8fe8d9c20f8b73440c650b54cdfc8b49&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-829aafbfc7349c3b12733f2fcdb1b440"><a href="#blockserializationutils-lambda-829aafbfc7349c3b12733f2fcdb1b440" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_829aafbfc7349c3b12733f2fcdb1b440&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_829aafbfc7349c3b12733f2fcdb1b440&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-7f72b5723c115bb2f4ac0b7c17989e02"><a href="#blockserializationutils-lambda-7f72b5723c115bb2f4ac0b7c17989e02" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_7f72b5723c115bb2f4ac0b7c17989e02&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_7f72b5723c115bb2f4ac0b7c17989e02&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-28bce0213573e981d8496bc59ef25a39"><a href="#blockserializationutils-lambda-28bce0213573e981d8496bc59ef25a39" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_28bce0213573e981d8496bc59ef25a39&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_28bce0213573e981d8496bc59ef25a39&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-a7b5eff23447e9db48b1aca54c835b5e"><a href="#blockserializationutils-lambda-a7b5eff23447e9db48b1aca54c835b5e" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_a7b5eff23447e9db48b1aca54c835b5e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_a7b5eff23447e9db48b1aca54c835b5e&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-4b32584e5a89e19541299f9bfd397ca8"><a href="#blockserializationutils-lambda-4b32584e5a89e19541299f9bfd397ca8" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_4b32584e5a89e19541299f9bfd397ca8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_4b32584e5a89e19541299f9bfd397ca8&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-d4498dd8704ab60c900bcedbd359c5ff"><a href="#blockserializationutils-lambda-d4498dd8704ab60c900bcedbd359c5ff" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_d4498dd8704ab60c900bcedbd359c5ff&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_d4498dd8704ab60c900bcedbd359c5ff&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-cc0b8eeee0034935b8cc7bfa61369244"><a href="#blockserializationutils-lambda-cc0b8eeee0034935b8cc7bfa61369244" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_cc0b8eeee0034935b8cc7bfa61369244&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_cc0b8eeee0034935b8cc7bfa61369244&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-50d6bdbae09ef7526f42e04802e3d9ce"><a href="#blockserializationutils-lambda-50d6bdbae09ef7526f42e04802e3d9ce" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_50d6bdbae09ef7526f42e04802e3d9ce&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_50d6bdbae09ef7526f42e04802e3d9ce&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-65d8bf2a47d12c2db3557340b5b507dd"><a href="#blockserializationutils-lambda-65d8bf2a47d12c2db3557340b5b507dd" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_65d8bf2a47d12c2db3557340b5b507dd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_65d8bf2a47d12c2db3557340b5b507dd&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-a74442faabc957bf146f5e75908b39f4"><a href="#blockserializationutils-lambda-a74442faabc957bf146f5e75908b39f4" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_a74442faabc957bf146f5e75908b39f4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_a74442faabc957bf146f5e75908b39f4&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-0b380bf2d0055ddea198adcf459af685"><a href="#blockserializationutils-lambda-0b380bf2d0055ddea198adcf459af685" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_0b380bf2d0055ddea198adcf459af685&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_0b380bf2d0055ddea198adcf459af685&gt;
{
};

</code></pre></div><h3 id="blockserializationutils-lambda-93133e4ec108c7abdd10c4236b87cbf3"><a href="#blockserializationutils-lambda-93133e4ec108c7abdd10c4236b87cbf3" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_93133e4ec108c7abdd10c4236b87cbf3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSerializationUtils::&lt;lambda_93133e4ec108c7abdd10c4236b87cbf3&gt;
{
};

</code></pre></div><h3 id="blocklegacy-onremove-l8-lambda-7800bbdc4cb23d1438ff620c65b45a41"><a href="#blocklegacy-onremove-l8-lambda-7800bbdc4cb23d1438ff620c65b45a41" class="header-anchor">#</a> <code>BlockLegacy::onRemove::__l8::&lt;lambda_7800bbdc4cb23d1438ff620c65b45a41&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockLegacy::onRemove::__l8::&lt;lambda_7800bbdc4cb23d1438ff620c65b45a41&gt;
{
  BlockSource *region;
  const BlockPos *pos;
  const BlockLegacy *const __this;
};

</code></pre></div><h3 id="blocklegacy-deprecatedcallongraphicsmodechanged-l2-lambda-18b6b7d71f34cb1c3cabd20e7fb6e537"><a href="#blocklegacy-deprecatedcallongraphicsmodechanged-l2-lambda-18b6b7d71f34cb1c3cabd20e7fb6e537" class="header-anchor">#</a> <code>BlockLegacy::DEPRECATEDcallOnGraphicsModeChanged::__l2::&lt;lambda_18b6b7d71f34cb1c3cabd20e7fb6e537&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockLegacy::DEPRECATEDcallOnGraphicsModeChanged::__l2::&lt;lambda_18b6b7d71f34cb1c3cabd20e7fb6e537&gt;
{
  const BlockGraphicsModeChangeContext *context;
};

</code></pre></div><h3 id="block-sendshearsdestoryclienteventandreturnwhethercancel-l2-lambda-9a411960c4f05cc7270251b3a7552d4c"><a href="#block-sendshearsdestoryclienteventandreturnwhethercancel-l2-lambda-9a411960c4f05cc7270251b3a7552d4c" class="header-anchor">#</a> <code>Block::sendShearsDestoryClientEventAndReturnWhetherCancel::__l2::&lt;lambda_9a411960c4f05cc7270251b3a7552d4c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Block::sendShearsDestoryClientEventAndReturnWhetherCancel::__l2::&lt;lambda_9a411960c4f05cc7270251b3a7552d4c&gt;
{
  const BlockPos *pos;
  const Block *const __this;
  const std::string *dropName;
  const int *dropCount;
  const Player *player;
};

</code></pre></div><h3 id="block-sendshearsdestoryeventandreturnwhethercancel-l2-lambda-7f82bfb32741affe50ae92294b4b4459"><a href="#block-sendshearsdestoryeventandreturnwhethercancel-l2-lambda-7f82bfb32741affe50ae92294b4b4459" class="header-anchor">#</a> <code>Block::sendShearsDestoryEventAndReturnWhetherCancel::__l2::&lt;lambda_7f82bfb32741affe50ae92294b4b4459&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Block::sendShearsDestoryEventAndReturnWhetherCancel::__l2::&lt;lambda_7f82bfb32741affe50ae92294b4b4459&gt;
{
  const BlockPos *pos;
  const Block *const __this;
  const std::string *dropName;
  const int *dropCount;
  const Player *player;
};

</code></pre></div><h3 id="block-sendshearsuseeventandreturnwhethercancel-l2-lambda-4aea5b65e5091f5d8b1b0bc41688f382"><a href="#block-sendshearsuseeventandreturnwhethercancel-l2-lambda-4aea5b65e5091f5d8b1b0bc41688f382" class="header-anchor">#</a> <code>Block::sendShearsUseEventAndReturnWhetherCancel::__l2::&lt;lambda_4aea5b65e5091f5d8b1b0bc41688f382&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Block::sendShearsUseEventAndReturnWhetherCancel::__l2::&lt;lambda_4aea5b65e5091f5d8b1b0bc41688f382&gt;
{
  const BlockPos *pos;
  const Block *const __this;
  const std::string *dropName;
  const int *dropCount;
  const Actor *entity;
};

</code></pre></div><h3 id="block-use-l28-lambda-f0190cd8f8393a15d907c1657001ce97"><a href="#block-use-l28-lambda-f0190cd8f8393a15d907c1657001ce97" class="header-anchor">#</a> <code>Block::use::__l28::&lt;lambda_f0190cd8f8393a15d907c1657001ce97&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Block::use::__l28::&lt;lambda_f0190cd8f8393a15d907c1657001ce97&gt;
{
  Player *player;
  const Block *const __this;
  const BlockPos *pos;
  bool *cancel;
};

</code></pre></div><h3 id="block-use-l20-lambda-d1e2ab651db4318ad3859856883ccd8a"><a href="#block-use-l20-lambda-d1e2ab651db4318ad3859856883ccd8a" class="header-anchor">#</a> <code>Block::use::__l20::&lt;lambda_d1e2ab651db4318ad3859856883ccd8a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Block::use::__l20::&lt;lambda_d1e2ab651db4318ad3859856883ccd8a&gt;
{
  Player *player;
  const Block *const __this;
  const BlockPos *pos;
  bool *cancel;
};

</code></pre></div><h3 id="block-use-l8-lambda-7422f341742097701f32fd419aa24ddf"><a href="#block-use-l8-lambda-7422f341742097701f32fd419aa24ddf" class="header-anchor">#</a> <code>Block::use::__l8::&lt;lambda_7422f341742097701f32fd419aa24ddf&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Block::use::__l8::&lt;lambda_7422f341742097701f32fd419aa24ddf&gt;
{
  Player *player;
  const Block *const __this;
  const BlockPos *pos;
  bool *cancel;
};

</code></pre></div><h3 id="block-tickinternal-l8-lambda-7d31a6c885ce46283e31ada2fbdac636"><a href="#block-tickinternal-l8-lambda-7d31a6c885ce46283e31ada2fbdac636" class="header-anchor">#</a> <code>Block::tickInternal::__l8::&lt;lambda_7d31a6c885ce46283e31ada2fbdac636&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Block::tickInternal::__l8::&lt;lambda_7d31a6c885ce46283e31ada2fbdac636&gt;
{
  const BlockPos *pos;
  const Block *const __this;
  BlockSource *region;
};

</code></pre></div><h3 id="bedblock-use-l20-lambda-0949a301607bf01f6b80e2a23970522f"><a href="#bedblock-use-l20-lambda-0949a301607bf01f6b80e2a23970522f" class="header-anchor">#</a> <code>BedBlock::use::__l20::&lt;lambda_0949a301607bf01f6b80e2a23970522f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BedBlock::use::__l20::&lt;lambda_0949a301607bf01f6b80e2a23970522f&gt;
{
  Player **sleepingPlayer;
  BlockPos *offset;
};

</code></pre></div><h3 id="bluefireblock"><a href="#bluefireblock" class="header-anchor">#</a> <code>BlueFireBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlueFireBlock : BlockLegacy
{
  AABB mAabb;
};

</code></pre></div><h3 id="bluefireblock-vtbl"><a href="#bluefireblock-vtbl" class="header-anchor">#</a> <code>BlueFireBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlueFireBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="blueiceblock"><a href="#blueiceblock" class="header-anchor">#</a> <code>BlueIceBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlueIceBlock : BlockLegacy
{
};

</code></pre></div><h3 id="blueiceblock-vtbl"><a href="#blueiceblock-vtbl" class="header-anchor">#</a> <code>BlueIceBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlueIceBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="bookshelfblock"><a href="#bookshelfblock" class="header-anchor">#</a> <code>BookshelfBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookshelfBlock : BlockLegacy
{
};

</code></pre></div><h3 id="bookshelfblock-vtbl"><a href="#bookshelfblock-vtbl" class="header-anchor">#</a> <code>BookshelfBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BookshelfBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="borderblock"><a href="#borderblock" class="header-anchor">#</a> <code>BorderBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BorderBlock : WallBlock
{
};

</code></pre></div><h3 id="borderblock-vtbl"><a href="#borderblock-vtbl" class="header-anchor">#</a> <code>BorderBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BorderBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="brewingstandblock"><a href="#brewingstandblock" class="header-anchor">#</a> <code>BrewingStandBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BrewingStandBlock : ActorBlock
{
};

</code></pre></div><h3 id="brewingstandblock-vtbl"><a href="#brewingstandblock-vtbl" class="header-anchor">#</a> <code>BrewingStandBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BrewingStandBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
};

</code></pre></div><h3 id="bubblecolumnblock"><a href="#bubblecolumnblock" class="header-anchor">#</a> <code>BubbleColumnBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BubbleColumnBlock : BlockLegacy
{
  bool mFancyBubbles;
};

</code></pre></div><h3 id="bubblecolumnblock-vtbl"><a href="#bubblecolumnblock-vtbl" class="header-anchor">#</a> <code>BubbleColumnBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BubbleColumnBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      
      <a href="/mcstructure/1.16.201/structure/B.html" class="prev">
        B
      </a></span> <span class="next"><a href="/mcstructure/1.16.201/structure/B~2.html">
        B~2
      </a>
      
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/mcstructure/assets/js/app.56b0ab36.js" defer></script><script src="/mcstructure/assets/js/2.56e23786.js" defer></script><script src="/mcstructure/assets/js/91.85f8c578.js" defer></script>
  </body>
</html>
