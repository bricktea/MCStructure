<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>T~1 | MC TIL</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Some structure and enum information for minecraft bedrock edition.">
    
    <link rel="preload" href="/mcstructure/assets/css/0.styles.5de0a167.css" as="style"><link rel="preload" href="/mcstructure/assets/js/app.56b0ab36.js" as="script"><link rel="preload" href="/mcstructure/assets/js/2.56e23786.js" as="script"><link rel="preload" href="/mcstructure/assets/js/142.08052153.js" as="script"><link rel="prefetch" href="/mcstructure/assets/js/10.dda8da32.js"><link rel="prefetch" href="/mcstructure/assets/js/100.d193fca3.js"><link rel="prefetch" href="/mcstructure/assets/js/101.324df8d1.js"><link rel="prefetch" href="/mcstructure/assets/js/102.81d32953.js"><link rel="prefetch" href="/mcstructure/assets/js/103.bafffe55.js"><link rel="prefetch" href="/mcstructure/assets/js/104.4a4116d4.js"><link rel="prefetch" href="/mcstructure/assets/js/105.ee5ab7c3.js"><link rel="prefetch" href="/mcstructure/assets/js/106.16520c01.js"><link rel="prefetch" href="/mcstructure/assets/js/107.e4e2fef9.js"><link rel="prefetch" href="/mcstructure/assets/js/108.9771cecd.js"><link rel="prefetch" href="/mcstructure/assets/js/109.07a059f8.js"><link rel="prefetch" href="/mcstructure/assets/js/11.84aff5f4.js"><link rel="prefetch" href="/mcstructure/assets/js/110.79e73184.js"><link rel="prefetch" href="/mcstructure/assets/js/111.735fe11b.js"><link rel="prefetch" href="/mcstructure/assets/js/112.5b8c9633.js"><link rel="prefetch" href="/mcstructure/assets/js/113.a961fd7d.js"><link rel="prefetch" href="/mcstructure/assets/js/114.f46e6ac6.js"><link rel="prefetch" href="/mcstructure/assets/js/115.29d129b9.js"><link rel="prefetch" href="/mcstructure/assets/js/116.0761604d.js"><link rel="prefetch" href="/mcstructure/assets/js/117.8fa51bbe.js"><link rel="prefetch" href="/mcstructure/assets/js/118.65b68c09.js"><link rel="prefetch" href="/mcstructure/assets/js/119.0b88b1c0.js"><link rel="prefetch" href="/mcstructure/assets/js/12.fb0b2343.js"><link rel="prefetch" href="/mcstructure/assets/js/120.6514cc60.js"><link rel="prefetch" href="/mcstructure/assets/js/121.30792057.js"><link rel="prefetch" href="/mcstructure/assets/js/122.ac6c9052.js"><link rel="prefetch" href="/mcstructure/assets/js/123.9dde14ff.js"><link rel="prefetch" href="/mcstructure/assets/js/124.1b8cd48f.js"><link rel="prefetch" href="/mcstructure/assets/js/125.ba14f223.js"><link rel="prefetch" href="/mcstructure/assets/js/126.5dd69ba6.js"><link rel="prefetch" href="/mcstructure/assets/js/127.32df8d72.js"><link rel="prefetch" href="/mcstructure/assets/js/128.aa9a14cc.js"><link rel="prefetch" href="/mcstructure/assets/js/129.d7a703a5.js"><link rel="prefetch" href="/mcstructure/assets/js/13.b8437649.js"><link rel="prefetch" href="/mcstructure/assets/js/130.d8f7ecf5.js"><link rel="prefetch" href="/mcstructure/assets/js/131.0c1d33fe.js"><link rel="prefetch" href="/mcstructure/assets/js/132.8b6e6ff3.js"><link rel="prefetch" href="/mcstructure/assets/js/133.f999118d.js"><link rel="prefetch" href="/mcstructure/assets/js/134.bc4a2893.js"><link rel="prefetch" href="/mcstructure/assets/js/135.e6e793b3.js"><link rel="prefetch" href="/mcstructure/assets/js/136.c50dcaff.js"><link rel="prefetch" href="/mcstructure/assets/js/137.209d5c8a.js"><link rel="prefetch" href="/mcstructure/assets/js/138.3eed47db.js"><link rel="prefetch" href="/mcstructure/assets/js/139.5e9afeaa.js"><link rel="prefetch" href="/mcstructure/assets/js/14.c94aa248.js"><link rel="prefetch" href="/mcstructure/assets/js/140.ac85c96f.js"><link rel="prefetch" href="/mcstructure/assets/js/141.82f0f06f.js"><link rel="prefetch" href="/mcstructure/assets/js/143.97d16176.js"><link rel="prefetch" href="/mcstructure/assets/js/144.66c74f2b.js"><link rel="prefetch" href="/mcstructure/assets/js/145.58e96ed1.js"><link rel="prefetch" href="/mcstructure/assets/js/146.4c73b3b4.js"><link rel="prefetch" href="/mcstructure/assets/js/147.0e0e09a7.js"><link rel="prefetch" href="/mcstructure/assets/js/148.a8c2c253.js"><link rel="prefetch" href="/mcstructure/assets/js/149.99f1b4f1.js"><link rel="prefetch" href="/mcstructure/assets/js/15.fd6df6e3.js"><link rel="prefetch" href="/mcstructure/assets/js/16.855c8adf.js"><link rel="prefetch" href="/mcstructure/assets/js/17.860009b0.js"><link rel="prefetch" href="/mcstructure/assets/js/18.63105a6b.js"><link rel="prefetch" href="/mcstructure/assets/js/19.fbddb16b.js"><link rel="prefetch" href="/mcstructure/assets/js/20.605578ab.js"><link rel="prefetch" href="/mcstructure/assets/js/21.1e5adf90.js"><link rel="prefetch" href="/mcstructure/assets/js/22.29bfa69a.js"><link rel="prefetch" href="/mcstructure/assets/js/23.566201a2.js"><link rel="prefetch" href="/mcstructure/assets/js/24.d912e845.js"><link rel="prefetch" href="/mcstructure/assets/js/25.8885d257.js"><link rel="prefetch" href="/mcstructure/assets/js/26.8409713f.js"><link rel="prefetch" href="/mcstructure/assets/js/27.49cb5267.js"><link rel="prefetch" href="/mcstructure/assets/js/28.2a890355.js"><link rel="prefetch" href="/mcstructure/assets/js/29.6ea7598b.js"><link rel="prefetch" href="/mcstructure/assets/js/3.50967458.js"><link rel="prefetch" href="/mcstructure/assets/js/30.1a3c3902.js"><link rel="prefetch" href="/mcstructure/assets/js/31.24ec9e8b.js"><link rel="prefetch" href="/mcstructure/assets/js/32.40831503.js"><link rel="prefetch" href="/mcstructure/assets/js/33.6602f7d9.js"><link rel="prefetch" href="/mcstructure/assets/js/34.75d333d9.js"><link rel="prefetch" href="/mcstructure/assets/js/35.84bf3e5a.js"><link rel="prefetch" href="/mcstructure/assets/js/36.fe4e7307.js"><link rel="prefetch" href="/mcstructure/assets/js/37.b2ee95ad.js"><link rel="prefetch" href="/mcstructure/assets/js/38.c03d5dee.js"><link rel="prefetch" href="/mcstructure/assets/js/39.a60df6e0.js"><link rel="prefetch" href="/mcstructure/assets/js/4.f5835878.js"><link rel="prefetch" href="/mcstructure/assets/js/40.6322a006.js"><link rel="prefetch" href="/mcstructure/assets/js/41.420acfde.js"><link rel="prefetch" href="/mcstructure/assets/js/42.a4ef9cfe.js"><link rel="prefetch" href="/mcstructure/assets/js/43.660cc3cf.js"><link rel="prefetch" href="/mcstructure/assets/js/44.683fc1e0.js"><link rel="prefetch" href="/mcstructure/assets/js/45.f27a9ad0.js"><link rel="prefetch" href="/mcstructure/assets/js/46.9f9edd2c.js"><link rel="prefetch" href="/mcstructure/assets/js/47.fd3ae547.js"><link rel="prefetch" href="/mcstructure/assets/js/48.375f8f97.js"><link rel="prefetch" href="/mcstructure/assets/js/49.e0d0f024.js"><link rel="prefetch" href="/mcstructure/assets/js/5.e0bd9261.js"><link rel="prefetch" href="/mcstructure/assets/js/50.aa126f14.js"><link rel="prefetch" href="/mcstructure/assets/js/51.e939b03e.js"><link rel="prefetch" href="/mcstructure/assets/js/52.a2d46eef.js"><link rel="prefetch" href="/mcstructure/assets/js/53.72de48c3.js"><link rel="prefetch" href="/mcstructure/assets/js/54.54675155.js"><link rel="prefetch" href="/mcstructure/assets/js/55.8b419ad8.js"><link rel="prefetch" href="/mcstructure/assets/js/56.07af8dcf.js"><link rel="prefetch" href="/mcstructure/assets/js/57.0bedaec9.js"><link rel="prefetch" href="/mcstructure/assets/js/58.37c94f2a.js"><link rel="prefetch" href="/mcstructure/assets/js/59.b0866a6a.js"><link rel="prefetch" href="/mcstructure/assets/js/6.04e2a2d2.js"><link rel="prefetch" href="/mcstructure/assets/js/60.5c5afc8c.js"><link rel="prefetch" href="/mcstructure/assets/js/61.ea56e4d6.js"><link rel="prefetch" href="/mcstructure/assets/js/62.3cb13464.js"><link rel="prefetch" href="/mcstructure/assets/js/63.83c0082d.js"><link rel="prefetch" href="/mcstructure/assets/js/64.2cd02c8b.js"><link rel="prefetch" href="/mcstructure/assets/js/65.c16cc8f2.js"><link rel="prefetch" href="/mcstructure/assets/js/66.ad2d4521.js"><link rel="prefetch" href="/mcstructure/assets/js/67.83e59ab1.js"><link rel="prefetch" href="/mcstructure/assets/js/68.beec9ddd.js"><link rel="prefetch" href="/mcstructure/assets/js/69.b4bc257c.js"><link rel="prefetch" href="/mcstructure/assets/js/7.fd995bdf.js"><link rel="prefetch" href="/mcstructure/assets/js/70.1ea3abef.js"><link rel="prefetch" href="/mcstructure/assets/js/71.3cf65839.js"><link rel="prefetch" href="/mcstructure/assets/js/72.6f64c4ab.js"><link rel="prefetch" href="/mcstructure/assets/js/73.452d7013.js"><link rel="prefetch" href="/mcstructure/assets/js/74.0660e6d9.js"><link rel="prefetch" href="/mcstructure/assets/js/75.b7b5e783.js"><link rel="prefetch" href="/mcstructure/assets/js/76.5fddaea1.js"><link rel="prefetch" href="/mcstructure/assets/js/77.be26bbc6.js"><link rel="prefetch" href="/mcstructure/assets/js/78.0e00fef4.js"><link rel="prefetch" href="/mcstructure/assets/js/79.731c37fb.js"><link rel="prefetch" href="/mcstructure/assets/js/8.1cbf1ff3.js"><link rel="prefetch" href="/mcstructure/assets/js/80.2282d655.js"><link rel="prefetch" href="/mcstructure/assets/js/81.33a53399.js"><link rel="prefetch" href="/mcstructure/assets/js/82.196f3fc3.js"><link rel="prefetch" href="/mcstructure/assets/js/83.e9cb3f05.js"><link rel="prefetch" href="/mcstructure/assets/js/84.35c05041.js"><link rel="prefetch" href="/mcstructure/assets/js/85.16e996b6.js"><link rel="prefetch" href="/mcstructure/assets/js/86.97412bd5.js"><link rel="prefetch" href="/mcstructure/assets/js/87.2244cc28.js"><link rel="prefetch" href="/mcstructure/assets/js/88.f00d5fcc.js"><link rel="prefetch" href="/mcstructure/assets/js/89.13359307.js"><link rel="prefetch" href="/mcstructure/assets/js/9.86a5a003.js"><link rel="prefetch" href="/mcstructure/assets/js/90.3b4668a2.js"><link rel="prefetch" href="/mcstructure/assets/js/91.85f8c578.js"><link rel="prefetch" href="/mcstructure/assets/js/92.c7bfeb53.js"><link rel="prefetch" href="/mcstructure/assets/js/93.87278538.js"><link rel="prefetch" href="/mcstructure/assets/js/94.9636adb8.js"><link rel="prefetch" href="/mcstructure/assets/js/95.49a2df5b.js"><link rel="prefetch" href="/mcstructure/assets/js/96.f84087c6.js"><link rel="prefetch" href="/mcstructure/assets/js/97.777e52ef.js"><link rel="prefetch" href="/mcstructure/assets/js/98.95f637bf.js"><link rel="prefetch" href="/mcstructure/assets/js/99.535a1eab.js">
    <link rel="stylesheet" href="/mcstructure/assets/css/0.styles.5de0a167.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/mcstructure/" class="home-link router-link-active"><!----> <span class="site-name">MC TIL</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/mcstructure/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/Redbeanw44602/mcstructure" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/mcstructure/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/Redbeanw44602/mcstructure" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Struct</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/mcstructure/1.16.201/structure/A.html" class="sidebar-link">A</a></li><li><a href="/mcstructure/1.16.201/structure/A~1.html" class="sidebar-link">A~1</a></li><li><a href="/mcstructure/1.16.201/structure/B.html" class="sidebar-link">B</a></li><li><a href="/mcstructure/1.16.201/structure/B~1.html" class="sidebar-link">B~1</a></li><li><a href="/mcstructure/1.16.201/structure/B~2.html" class="sidebar-link">B~2</a></li><li><a href="/mcstructure/1.16.201/structure/C.html" class="sidebar-link">C</a></li><li><a href="/mcstructure/1.16.201/structure/C~1.html" class="sidebar-link">C~1</a></li><li><a href="/mcstructure/1.16.201/structure/C~2.html" class="sidebar-link">C~2</a></li><li><a href="/mcstructure/1.16.201/structure/C~3.html" class="sidebar-link">C~3</a></li><li><a href="/mcstructure/1.16.201/structure/D.html" class="sidebar-link">D</a></li><li><a href="/mcstructure/1.16.201/structure/D~1.html" class="sidebar-link">D~1</a></li><li><a href="/mcstructure/1.16.201/structure/D~2.html" class="sidebar-link">D~2</a></li><li><a href="/mcstructure/1.16.201/structure/D~3.html" class="sidebar-link">D~3</a></li><li><a href="/mcstructure/1.16.201/structure/D~4.html" class="sidebar-link">D~4</a></li><li><a href="/mcstructure/1.16.201/structure/D~5.html" class="sidebar-link">D~5</a></li><li><a href="/mcstructure/1.16.201/structure/D~6.html" class="sidebar-link">D~6</a></li><li><a href="/mcstructure/1.16.201/structure/D~7.html" class="sidebar-link">D~7</a></li><li><a href="/mcstructure/1.16.201/structure/D~8.html" class="sidebar-link">D~8</a></li><li><a href="/mcstructure/1.16.201/structure/D~9.html" class="sidebar-link">D~9</a></li><li><a href="/mcstructure/1.16.201/structure/D~10.html" class="sidebar-link">D~10</a></li><li><a href="/mcstructure/1.16.201/structure/E.html" class="sidebar-link">E</a></li><li><a href="/mcstructure/1.16.201/structure/E~1.html" class="sidebar-link">E~1</a></li><li><a href="/mcstructure/1.16.201/structure/F.html" class="sidebar-link">F</a></li><li><a href="/mcstructure/1.16.201/structure/F~1.html" class="sidebar-link">F~1</a></li><li><a href="/mcstructure/1.16.201/structure/G.html" class="sidebar-link">G</a></li><li><a href="/mcstructure/1.16.201/structure/H.html" class="sidebar-link">H</a></li><li><a href="/mcstructure/1.16.201/structure/I.html" class="sidebar-link">I</a></li><li><a href="/mcstructure/1.16.201/structure/I~1.html" class="sidebar-link">I~1</a></li><li><a href="/mcstructure/1.16.201/structure/I~2.html" class="sidebar-link">I~2</a></li><li><a href="/mcstructure/1.16.201/structure/J.html" class="sidebar-link">J</a></li><li><a href="/mcstructure/1.16.201/structure/K.html" class="sidebar-link">K</a></li><li><a href="/mcstructure/1.16.201/structure/L.html" class="sidebar-link">L</a></li><li><a href="/mcstructure/1.16.201/structure/L~1.html" class="sidebar-link">L~1</a></li><li><a href="/mcstructure/1.16.201/structure/M.html" class="sidebar-link">M</a></li><li><a href="/mcstructure/1.16.201/structure/M~1.html" class="sidebar-link">M~1</a></li><li><a href="/mcstructure/1.16.201/structure/M~2.html" class="sidebar-link">M~2</a></li><li><a href="/mcstructure/1.16.201/structure/M~3.html" class="sidebar-link">M~3</a></li><li><a href="/mcstructure/1.16.201/structure/N.html" class="sidebar-link">N</a></li><li><a href="/mcstructure/1.16.201/structure/O.html" class="sidebar-link">O</a></li><li><a href="/mcstructure/1.16.201/structure/P.html" class="sidebar-link">P</a></li><li><a href="/mcstructure/1.16.201/structure/P~1.html" class="sidebar-link">P~1</a></li><li><a href="/mcstructure/1.16.201/structure/P~2.html" class="sidebar-link">P~2</a></li><li><a href="/mcstructure/1.16.201/structure/P~3.html" class="sidebar-link">P~3</a></li><li><a href="/mcstructure/1.16.201/structure/Q.html" class="sidebar-link">Q</a></li><li><a href="/mcstructure/1.16.201/structure/R.html" class="sidebar-link">R</a></li><li><a href="/mcstructure/1.16.201/structure/R~1.html" class="sidebar-link">R~1</a></li><li><a href="/mcstructure/1.16.201/structure/R~2.html" class="sidebar-link">R~2</a></li><li><a href="/mcstructure/1.16.201/structure/R~3.html" class="sidebar-link">R~3</a></li><li><a href="/mcstructure/1.16.201/structure/S.html" class="sidebar-link">S</a></li><li><a href="/mcstructure/1.16.201/structure/S~1.html" class="sidebar-link">S~1</a></li><li><a href="/mcstructure/1.16.201/structure/S~2.html" class="sidebar-link">S~2</a></li><li><a href="/mcstructure/1.16.201/structure/S~3.html" class="sidebar-link">S~3</a></li><li><a href="/mcstructure/1.16.201/structure/S~4.html" class="sidebar-link">S~4</a></li><li><a href="/mcstructure/1.16.201/structure/T.html" class="sidebar-link">T</a></li><li><a href="/mcstructure/1.16.201/structure/T~1.html" aria-current="page" class="active sidebar-link">T~1</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/mcstructure/1.16.201/structure/U.html" class="sidebar-link">U</a></li><li><a href="/mcstructure/1.16.201/structure/V.html" class="sidebar-link">V</a></li><li><a href="/mcstructure/1.16.201/structure/W.html" class="sidebar-link">W</a></li><li><a href="/mcstructure/1.16.201/structure/W~1.html" class="sidebar-link">W~1</a></li><li><a href="/mcstructure/1.16.201/structure/X.html" class="sidebar-link">X</a></li><li><a href="/mcstructure/1.16.201/structure/Z.html" class="sidebar-link">Z</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Enums</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="t-1"><a href="#t-1" class="header-anchor">#</a> T~1</h1> <h3 id="takepicturecommand"><a href="#takepicturecommand" class="header-anchor">#</a> <code>TakePictureCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) TakePictureCommand : Command
{
  CommandSelector&lt;Actor&gt; mCameraTargets;
  CommandSelector&lt;Player&gt; mPlayerTargets;
  CommandPosition mCameraSpawnPos;
  bool mCameraPositionProvided;
  bool mCameraTargetProvided;
};

</code></pre></div><h3 id="takepicturecommand-vtbl"><a href="#takepicturecommand-vtbl" class="header-anchor">#</a> <code>TakePictureCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TakePictureCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="takepicturecommand-execute-l2-lambda-cc590f793e7a5cf4bb497762ce148e7d"><a href="#takepicturecommand-execute-l2-lambda-cc590f793e7a5cf4bb497762ce148e7d" class="header-anchor">#</a> <code>TakePictureCommand::execute::__l2::&lt;lambda_cc590f793e7a5cf4bb497762ce148e7d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TakePictureCommand::execute::__l2::&lt;lambda_cc590f793e7a5cf4bb497762ce148e7d&gt;
{
  Player *player;
  TripodCamera *camera;
};

</code></pre></div><h3 id="testservercommands"><a href="#testservercommands" class="header-anchor">#</a> <code>TestServerCommands</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TestServerCommands
{
};

</code></pre></div><h3 id="tagcommand"><a href="#tagcommand" class="header-anchor">#</a> <code>TagCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TagCommand : Command
{
  _BYTE mAction[1];
  __declspec(align(8)) WildcardCommandSelector&lt;Actor&gt; mSelector;
  std::string mTagString;
};

</code></pre></div><h3 id="tagcommand-vtbl"><a href="#tagcommand-vtbl" class="header-anchor">#</a> <code>TagCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TagCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="teleportcommand"><a href="#teleportcommand" class="header-anchor">#</a> <code>TeleportCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(2)) TeleportCommand : Command
{
  CommandSelector&lt;Actor&gt; mTargets;
  CommandSelector&lt;Actor&gt; mDestinationEntity;
  CommandPositionFloat mDestinationPos;
  CommandSelector&lt;Actor&gt; mFacingEntity;
  CommandPositionFloat mFacingPos;
  RelativeFloat mYRot;
  RelativeFloat mXRot;
  TeleportCommand::FacingResult mHaveFacing;
  bool mDestinationIsPosition;
  bool mFacingIsPosition;
  bool mCheckForBlocks;
};

</code></pre></div><h3 id="teleportcommand-vtbl"><a href="#teleportcommand-vtbl" class="header-anchor">#</a> <code>TeleportCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TeleportCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="tellcommand"><a href="#tellcommand" class="header-anchor">#</a> <code>TellCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TellCommand : MessagingCommand
{
  CommandSelector&lt;Player&gt; mTargets;
  CommandMessage mMessage;
};

</code></pre></div><h3 id="tellcommand-vtbl"><a href="#tellcommand-vtbl" class="header-anchor">#</a> <code>TellCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TellCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="tellrawcommand"><a href="#tellrawcommand" class="header-anchor">#</a> <code>TellRawCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TellRawCommand : MessagingCommand
{
  CommandSelector&lt;Player&gt; mTargets;
  Json::Value mRawText;
};

</code></pre></div><h3 id="tellrawcommand-vtbl"><a href="#tellrawcommand-vtbl" class="header-anchor">#</a> <code>TellRawCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TellRawCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="testforblockcommand"><a href="#testforblockcommand" class="header-anchor">#</a> <code>TestForBlockCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) TestForBlockCommand : Command
{
  CommandPosition mPosition;
  const Block *mBlock;
  int mData;
};

</code></pre></div><h3 id="testforblockcommand-vtbl"><a href="#testforblockcommand-vtbl" class="header-anchor">#</a> <code>TestForBlockCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TestForBlockCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="testforblockscommand"><a href="#testforblockscommand" class="header-anchor">#</a> <code>TestForBlocksCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) TestForBlocksCommand : Command
{
  CommandPosition mBegin;
  CommandPosition mEnd;
  CommandPosition mDestination;
  TestForBlocksCommand::Mode mMode;
};

</code></pre></div><h3 id="testforblockscommand-vtbl"><a href="#testforblockscommand-vtbl" class="header-anchor">#</a> <code>TestForBlocksCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TestForBlocksCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="testforcommand"><a href="#testforcommand" class="header-anchor">#</a> <code>TestForCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TestForCommand : Command
{
  CommandSelector&lt;Actor&gt; mTargets;
};

</code></pre></div><h3 id="testforcommand-vtbl"><a href="#testforcommand-vtbl" class="header-anchor">#</a> <code>TestForCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TestForCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="tickingareacommand"><a href="#tickingareacommand" class="header-anchor">#</a> <code>TickingAreaCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) TickingAreaCommand : Command
{
  TickingAreaCommand::Mode mMode;
  _BYTE mAddAreaType[4];
  TickingAreaCommand::TargetDimensions mTargetDimensions;
  CommandPosition mPosition;
  CommandPosition mMax;
  std::string mName;
  int mRadius;
};

</code></pre></div><h3 id="tickingareacommand-vtbl"><a href="#tickingareacommand-vtbl" class="header-anchor">#</a> <code>TickingAreaCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TickingAreaCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="timecommand"><a href="#timecommand" class="header-anchor">#</a> <code>TimeCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TimeCommand : Command
{
  TimeCommand::Mode mMode;
  TimeCommand::Query mQuery;
  TimeCommand::TimeSpec mSpec;
  int mValue;
};

</code></pre></div><h3 id="timecommand-vtbl"><a href="#timecommand-vtbl" class="header-anchor">#</a> <code>TimeCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TimeCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="titlecommand"><a href="#titlecommand" class="header-anchor">#</a> <code>TitleCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TitleCommand : MessagingCommand
{
  _BYTE mMode[4];
  __declspec(align(8)) CommandSelector&lt;Player&gt; mTargets;
  CommandMessage mMessage;
  int mFadeIn;
  int mStay;
  int mFadeOut;
};

</code></pre></div><h3 id="titlecommand-vtbl"><a href="#titlecommand-vtbl" class="header-anchor">#</a> <code>TitleCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TitleCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="titlerawcommand"><a href="#titlerawcommand" class="header-anchor">#</a> <code>TitleRawCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TitleRawCommand : MessagingCommand
{
  _BYTE mMode[4];
  __declspec(align(8)) CommandSelector&lt;Player&gt; mTargets;
  Json::Value mMessage;
  int mFadeIn;
  int mStay;
  int mFadeOut;
};

</code></pre></div><h3 id="titlerawcommand-vtbl"><a href="#titlerawcommand-vtbl" class="header-anchor">#</a> <code>TitleRawCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TitleRawCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="toggledownfallcommand"><a href="#toggledownfallcommand" class="header-anchor">#</a> <code>ToggleDownfallCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ToggleDownfallCommand : Command
{
};

</code></pre></div><h3 id="toggledownfallcommand-vtbl"><a href="#toggledownfallcommand-vtbl" class="header-anchor">#</a> <code>ToggleDownfallCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ToggleDownfallCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="tickingareacommand-list-l15-lambda-ef527cf2db8145510630afcadcb9e9a5"><a href="#tickingareacommand-list-l15-lambda-ef527cf2db8145510630afcadcb9e9a5" class="header-anchor">#</a> <code>TickingAreaCommand::_list::__l15::&lt;lambda_ef527cf2db8145510630afcadcb9e9a5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TickingAreaCommand::_list::__l15::&lt;lambda_ef527cf2db8145510630afcadcb9e9a5&gt;
{
  std::string *listOfTickingAreas;
  const TickingAreaCommand *const __this;
};

</code></pre></div><h3 id="teleportcommand-execute-l32-lambda-d12bd4980707bc17e4326e7408eadb2e"><a href="#teleportcommand-execute-l32-lambda-d12bd4980707bc17e4326e7408eadb2e" class="header-anchor">#</a> <code>TeleportCommand::execute::__l32::&lt;lambda_d12bd4980707bc17e4326e7408eadb2e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TeleportCommand::execute::__l32::&lt;lambda_d12bd4980707bc17e4326e7408eadb2e&gt;
{
  Actor *target;
  AutomaticID&lt;Dimension,int&gt; *destinationDimension;
  Vec3 *destination;
};

</code></pre></div><h3 id="tagscomponent-idtype-leveltagsetidtype"><a href="#tagscomponent-idtype-leveltagsetidtype" class="header-anchor">#</a> <code>TagsComponent&lt;IDType&lt;LevelTagSetIDType&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TagsComponent&lt;IDType&lt;LevelTagSetIDType&gt; &gt; : IEntityComponent
{
  IDType&lt;LevelTagSetIDType&gt; mTagSetID;
};

</code></pre></div><h3 id="tree-desc-s"><a href="#tree-desc-s" class="header-anchor">#</a> <code>tree_desc_s</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tree_desc_s
{
  ct_data_s *dyn_tree;
  int max_code;
  const static_tree_desc_s *stat_desc;
};

</code></pre></div><h3 id="timestamp"><a href="#timestamp" class="header-anchor">#</a> <code>TimeStamp</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TimeStamp
{
};

</code></pre></div><h3 id="tropicalfish"><a href="#tropicalfish" class="header-anchor">#</a> <code>TropicalFish</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TropicalFish : WaterAnimal
{
  float mAnimationAmount;
  float mAnimationAmountPrev;
};

</code></pre></div><h3 id="targetgoaldefinition"><a href="#targetgoaldefinition" class="header-anchor">#</a> <code>TargetGoalDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TargetGoalDefinition : BaseGoalDefinition
{
  bool mAttackOwner;
  bool mMustReach;
  bool mMustSee;
  float mDefaultFollowDistance;
  float mForgetTargetTime;
  float mPersistTargetTime;
  std::vector&lt;MobDescriptor&gt; mTargetTypes;
};

</code></pre></div><h3 id="targetgoaldefinition-vtbl"><a href="#targetgoaldefinition-vtbl" class="header-anchor">#</a> <code>TargetGoalDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TargetGoalDefinition_vtbl
{
  void (__fastcall *~BaseGoalDefinition)(BaseGoalDefinition *this);
  bool (__fastcall *validateMobType)(BaseGoalDefinition *this, Mob *);
  bool (__fastcall *validate)(BaseGoalDefinition *this, Mob *);
};

</code></pre></div><h3 id="targetgoal"><a href="#targetgoal" class="header-anchor">#</a> <code>TargetGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TargetGoal : Goal
{
  Mob *mMob;
  bool mAttackOwner;
  bool mMustReach;
  bool mGlobalMustSee;
  bool mTargetMustSee;
  int mTargetMustSeeForgetTicks;
  bool mFilterFailure;
  int mFilterFailureTicks;
  int mGlobalMustSeeForgetTicks;
  int mPersistTargetTicks;
  int mReachCache;
  int mReachCacheTime;
  int mUnseenTicks;
  float mWithinDefault;
  std::vector&lt;MobDescriptor&gt; mTargetTypes;
};

</code></pre></div><h3 id="targetgoal-vtbl"><a href="#targetgoal-vtbl" class="header-anchor">#</a> <code>TargetGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TargetGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
  bool (__fastcall *_canAttack)(TargetGoal *this, Mob *, Actor *, bool, bool, const MobDescriptor **);
};

</code></pre></div><h3 id="typeid-t-goal"><a href="#typeid-t-goal" class="header-anchor">#</a> <code>typeid_t&lt;Goal&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj typeid_t&lt;Goal&gt;
{
  unsigned __int16 mID;
};

</code></pre></div><h3 id="turtle"><a href="#turtle" class="header-anchor">#</a> <code>Turtle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Turtle : Animal
{
};

</code></pre></div><h3 id="testnode"><a href="#testnode" class="header-anchor">#</a> <code>TestNode</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) TestNode : BehaviorNode
{
  std::string mTestVal;
  int mCnt;
};

</code></pre></div><h3 id="testnode-vtbl"><a href="#testnode-vtbl" class="header-anchor">#</a> <code>TestNode_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TestNode_vtbl
{
  void (__fastcall *~BehaviorNode)(BehaviorNode *this);
  BehaviorStatus (__fastcall *tick)(BehaviorNode *this, Actor *);
  void (__fastcall *initializeFromDefinition)(BehaviorNode *this, Actor *);
};

</code></pre></div><h3 id="testdefinition"><a href="#testdefinition" class="header-anchor">#</a> <code>TestDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TestDefinition : BehaviorDefinition
{
  std::string mTestValue;
  std::string mTestValueId;
};

</code></pre></div><h3 id="testdefinition-vtbl"><a href="#testdefinition-vtbl" class="header-anchor">#</a> <code>TestDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TestDefinition_vtbl
{
  void (__fastcall *~BehaviorDefinition)(BehaviorDefinition *this);
  void (__fastcall *load)(BehaviorDefinition *this, Json::Value, const BehaviorFactory *);
  std::unique_ptr&lt;BehaviorNode&gt; *(__fastcall *createNode)(BehaviorDefinition *this, std::unique_ptr&lt;BehaviorNode&gt; *result, Actor *, const BehaviorFactory *, BehaviorNode *, BehaviorData *);
};

</code></pre></div><h3 id="tiercomponentdescription"><a href="#tiercomponentdescription" class="header-anchor">#</a> <code>TierComponentDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) TierComponentDescription : BlockComponentDescription
{
  DiggerType mDiggerType;
  int mLevel;
  bool mDestroySpecial;
};

</code></pre></div><h3 id="tiercomponentdescription-vtbl"><a href="#tiercomponentdescription-vtbl" class="header-anchor">#</a> <code>TierComponentDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TierComponentDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="tiercomponent"><a href="#tiercomponent" class="header-anchor">#</a> <code>TierComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) TierComponent
{
  DiggerType mDiggerType;
  int mLevel;
  bool mDestroySpecial;
};

</code></pre></div><h3 id="thrownegg"><a href="#thrownegg" class="header-anchor">#</a> <code>ThrownEgg</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ThrownEgg : Throwable
{
};

</code></pre></div><h3 id="thrownegg-vtbl"><a href="#thrownegg-vtbl" class="header-anchor">#</a> <code>ThrownEgg_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ThrownEgg_vtbl
{
  bool (__fastcall *hasComponent)(Actor *this, const HashedString *);
  void (__fastcall *reloadHardcoded)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadHardcodedClient)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *initializeComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *_serverInitItemStackIds)(Actor *this);
  void (__fastcall *_doInitialMove)(Actor *this);
  bool (__fastcall *checkAllSensitiveWords)(Actor *this);
  bool (__fastcall *checkNameTag)(Actor *this);
  void (__fastcall *~Actor)(Actor *this);
  void (__fastcall *reset)(Actor *this);
  int (__fastcall *getOnDeathExperience)(Actor *this);
  ActorType (__fastcall *getOwnerEntityType)(Actor *this);
  void (__fastcall *remove)(Actor *this);
  void (__fastcall *setPos)(Actor *this, const Vec3 *);
  const PredictedMovementValues *(__fastcall *getPredictedMovementValues)(Actor *this);
  const Vec3 *(__fastcall *getPos)(Actor *this);
  const Vec3 *(__fastcall *getPosOld)(Actor *this);
  const Vec3 *(__fastcall *getPosExtrapolated)(Actor *this, const Vec3 *result, float);
  Vec3 *(__fastcall *getAttachPos)(Actor *this, Vec3 *result, ActorLocation, float);
  Vec3 *(__fastcall *getFiringPos)(Actor *this, Vec3 *result);
  void (__fastcall *setRot)(Actor *this, const Vec2 *);
  void (__fastcall *move)(Actor *this, IActorMovementProxy *, const Vec3 *);
  void (__fastcall *move)(Actor *this, const Vec3 *);
  Vec3 *(__fastcall *getInterpolatedRidingPosition)(Actor *this, Vec3 *result, float);
  float (__fastcall *getInterpolatedBodyRot)(Actor *this, float);
  float (__fastcall *getInterpolatedHeadRot)(Actor *this, float);
  float (__fastcall *getInterpolatedBodyYaw)(Actor *this, float);
  float (__fastcall *getYawSpeedInDegreesPerSecond)(Actor *this);
  float (__fastcall *getInterpolatedWalkAnimSpeed)(Actor *this, float);
  Vec3 *(__fastcall *getInterpolatedRidingOffset)(Actor *this, Vec3 *result, float);
  void (__fastcall *checkBlockCollisions)(Actor *this);
  void (__fastcall *checkBlockCollisions)(Actor *this, const AABB *, std::function&lt;void __cdecl(BlockSource &amp;,Block const &amp;,BlockPos const &amp;,Actor &amp;)&gt;);
  bool (__fastcall *isFireImmune)(Actor *this);
  bool (__fastcall *breaksFallingBlocks)(Actor *this);
  void (__fastcall *blockedByShield)(Actor *this, const ActorDamageSource *, Actor *);
  void (__fastcall *teleportTo)(Actor *this, const Vec3 *, bool, int, int, const ActorUniqueID *);
  bool (__fastcall *tryTeleportTo)(Actor *this, const Vec3 *, bool, bool, int, int);
  void (__fastcall *chorusFruitTeleport)(Actor *this, Vec3 *);
  void (__fastcall *lerpTo)(Actor *this, const Vec3 *, const Vec2 *, int);
  void (__fastcall *lerpMotion)(Actor *this, const Vec3 *);
  std::unique_ptr&lt;AddActorBasePacket&gt; *(__fastcall *getAddPacket)(Actor *this, std::unique_ptr&lt;AddActorBasePacket&gt; *result);
  void (__fastcall *normalTick)(Actor *this);
  void (__fastcall *baseTick)(Actor *this);
  void (__fastcall *rideTick)(Actor *this);
  void (__fastcall *positionRider)(Actor *this, Actor *, float);
  float (__fastcall *getRidingHeight)(Actor *this);
  bool (__fastcall *startRiding)(Actor *this, Actor *);
  void (__fastcall *addRider)(Actor *this, Actor *);
  void (__fastcall *flagRiderToRemove)(Actor *this, Actor *);
  std::string *(__fastcall *getExitTip)(Actor *this, std::string *result, const std::string *, InputMode);
  bool (__fastcall *intersects)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *, float);
  bool (__fastcall *isInWall)(Actor *this);
  bool (__fastcall *isInvisible)(Actor *this);
  bool (__fastcall *canShowNameTag)(Actor *this);
  bool (__fastcall *canExistInPeaceful)(Actor *this);
  void (__fastcall *setNameTagVisible)(Actor *this, bool);
  const std::string *(__fastcall *getNameTag)(Actor *this);
  unsigned __int64 (__fastcall *getNameTagAsHash)(Actor *this);
  std::string *(__fastcall *getFormattedNameTag)(Actor *this, std::string *result);
  void (__fastcall *filterFormattedNameTag)(Actor *this, const UIProfanityContext *);
  void (__fastcall *setNameTag)(Actor *this, const std::string *);
  bool (__fastcall *getAlwaysShowNameTag)(Actor *this);
  void (__fastcall *setScoreTag)(Actor *this, const std::string *);
  const std::string *(__fastcall *getScoreTag)(Actor *this);
  bool (__fastcall *isInWater)(Actor *this);
  bool (__fastcall *hasEnteredWater)(Actor *this);
  bool (__fastcall *isImmersedInWater)(Actor *this);
  bool (__fastcall *isInWaterOrRain)(Actor *this);
  bool (__fastcall *isInLava)(Actor *this);
  bool (__fastcall *isUnderLiquid)(Actor *this, MaterialType);
  bool (__fastcall *isOverWater)(Actor *this);
  void (__fastcall *makeStuckInBlock)(Actor *this, const Vec3 *);
  float (__fastcall *getCameraOffset)(Actor *this);
  float (__fastcall *getShadowHeightOffs)(Actor *this);
  float (__fastcall *getShadowRadius)(Actor *this);
  Vec3 *(__fastcall *getHeadLookVector)(Actor *this, Vec3 *result, float);
  bool (__fastcall *canSeeInvisible)(Actor *this);
  bool (__fastcall *canSee)(Actor *this, const Vec3 *);
  bool (__fastcall *canSee)(Actor *this, const Actor *);
  bool (__fastcall *isSkyLit)(Actor *this, float);
  float (__fastcall *getBrightness)(Actor *this, float);
  bool (__fastcall *interactPreventDefault)(Actor *this);
  void (__fastcall *playerTouch)(Actor *this, Player *);
  void (__fastcall *onAboveBubbleColumn)(Actor *this, const bool);
  void (__fastcall *onInsideBubbleColumn)(Actor *this, const bool);
  bool (__fastcall *isImmobile)(Actor *this);
  bool (__fastcall *isSilent)(Actor *this);
  bool (__fastcall *isPickable)(Actor *this);
  bool (__fastcall *isFishable)(Actor *this);
  bool (__fastcall *isSleeping)(Actor *this);
  bool (__fastcall *isShootable)(Actor *this);
  void (__fastcall *setSneaking)(Actor *this, bool);
  bool (__fastcall *isBlocking)(Actor *this);
  bool (__fastcall *isDamageBlocked)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *isAlive)(Actor *this);
  bool (__fastcall *isOnFire)(Actor *this);
  bool (__fastcall *isOnHotBlock)(Actor *this);
  bool (__fastcall *isCreativeModeAllowed)(Actor *this);
  bool (__fastcall *isSurfaceMob)(Actor *this);
  bool (__fastcall *isTargetable)(Actor *this);
  bool (__fastcall *isLocalPlayer)(Actor *this);
  bool (__fastcall *isPlayer)(Actor *this);
  bool (__fastcall *canAttack)(Actor *this, Actor *, bool);
  void (__fastcall *setTarget)(Actor *this, Actor *);
  Actor *(__fastcall *findAttackTarget)(Actor *this);
  bool (__fastcall *isValidTarget)(Actor *this, Actor *);
  bool (__fastcall *attack)(Actor *this, Actor *);
  void (__fastcall *performRangedAttack)(Actor *this, Actor *, float);
  void (__fastcall *adjustDamageAmount)(Actor *this, int *);
  int (__fastcall *getEquipmentCount)(Actor *this);
  void (__fastcall *setOwner)(Actor *this, const ActorUniqueID);
  void (__fastcall *setSitting)(Actor *this, bool);
  void (__fastcall *onTame)(Actor *this);
  void (__fastcall *onFailedTame)(Actor *this);
  int (__fastcall *getInventorySize)(Actor *this);
  int (__fastcall *getEquipSlots)(Actor *this);
  int (__fastcall *getChestSlots)(Actor *this);
  void (__fastcall *setStanding)(Actor *this, bool);
  bool (__fastcall *canPowerJump)(Actor *this);
  void (__fastcall *setCanPowerJump)(Actor *this, bool);
  bool (__fastcall *isJumping)(Actor *this);
  bool (__fastcall *isEnchanted)(Actor *this);
  void (__fastcall *rideJumped)(Actor *this);
  void (__fastcall *rideLanded)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *shouldRender)(Actor *this);
  bool (__fastcall *isInvulnerableTo)(Actor *this, const ActorDamageSource *);
  ActorDamageCause (__fastcall *getBlockDamageCause)(Actor *this, const Block *);
  void (__fastcall *actuallyHurt)(Actor *this, int, const ActorDamageSource *, bool);
  void (__fastcall *animateHurt)(Actor *this);
  bool (__fastcall *doFireHurt)(Actor *this, int);
  void (__fastcall *onLightningHit)(Actor *this);
  void (__fastcall *onBounceStarted)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *feed)(Actor *this, int);
  void (__fastcall *handleEntityEvent)(Actor *this, ActorEvent, int);
  float (__fastcall *getPickRadius)(Actor *this);
  const HashedString *(__fastcall *getActorRendererId)(Actor *this);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const ItemStack *, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int);
  void (__fastcall *despawn)(Actor *this);
  void (__fastcall *killed)(Actor *this, Actor *);
  void (__fastcall *awardKillScore)(Actor *this, Actor *, int);
  void (__fastcall *setArmor)(Actor *this, ArmorSlot, const ItemStack *);
  const ItemStack *(__fastcall *getArmor)(Actor *this, ArmorSlot);
  ArmorMaterialType (__fastcall *getArmorMaterialTypeInSlot)(Actor *this, ArmorSlot);
  ArmorTextureType (__fastcall *getArmorMaterialTextureTypeInSlot)(Actor *this, ArmorSlot);
  float (__fastcall *getArmorColorInSlot)(Actor *this, ArmorSlot, int);
  const ItemStack *(__fastcall *getEquippedSlot)(Actor *this, EquipmentSlot);
  void (__fastcall *setEquippedSlot)(Actor *this, EquipmentSlot, const ItemStack *);
  const ItemStack *(__fastcall *getCarriedItem)(Actor *this);
  void (__fastcall *setCarriedItem)(Actor *this, const ItemStack *);
  void (__fastcall *setOffhandSlot)(Actor *this, const ItemStack *);
  const ItemStack *(__fastcall *getEquippedTotem)(Actor *this);
  bool (__fastcall *consumeTotem)(Actor *this);
  bool (__fastcall *save)(Actor *this, CompoundTag *);
  void (__fastcall *saveWithoutId)(Actor *this, CompoundTag *);
  bool (__fastcall *load)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *loadLinks)(Actor *this, const CompoundTag *, std::vector&lt;ActorLink&gt; *, DataLoadHelper *);
  ActorType (__fastcall *getEntityTypeId)(Actor *this);
  const HashedString *(__fastcall *queryEntityRenderer)(Actor *this);
  ActorUniqueID *(__fastcall *getSourceUniqueID)(Actor *this, ActorUniqueID *result);
  void (__fastcall *setOnFire)(Actor *this, int);
  AABB *(__fastcall *getHandleWaterAABB)(Actor *this, AABB *result);
  void (__fastcall *handleInsidePortal)(Actor *this, const BlockPos *);
  int (__fastcall *getPortalCooldown)(Actor *this);
  int (__fastcall *getPortalWaitTime)(Actor *this);
  AutomaticID&lt;Dimension,int&gt; *(__fastcall *getDimensionId)(Actor *this, AutomaticID&lt;Dimension,int&gt; *result);
  bool (__fastcall *canChangeDimensions)(Actor *this);
  void (__fastcall *changeDimension)(Actor *this, const ChangeDimensionPacket *);
  void (__fastcall *changeDimension)(Actor *this, AutomaticID&lt;Dimension,int&gt;, bool);
  ActorUniqueID *(__fastcall *getControllingPlayer)(Actor *this, ActorUniqueID *result);
  void (__fastcall *checkFallDamage)(Actor *this, float, bool);
  void (__fastcall *causeFallDamage)(Actor *this, float);
  void (__fastcall *handleFallDistanceOnServer)(Actor *this, float, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, int, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, const Block *, bool);
  void (__fastcall *onSynchedDataUpdate)(Actor *this, int);
  bool (__fastcall *canAddRider)(Actor *this, Actor *);
  bool (__fastcall *canPickupItem)(Actor *this, const ItemStack *);
  bool (__fastcall *canBePulledIntoVehicle)(Actor *this);
  bool (__fastcall *inCaravan)(Actor *this);
  bool (__fastcall *isLeashableType)(Actor *this);
  void (__fastcall *tickLeash)(Actor *this);
  void (__fastcall *sendMotionPacketIfNeeded)(Actor *this);
  bool (__fastcall *canSynchronizeNewEntity)(Actor *this);
  bool (__fastcall *stopRiding)(Actor *this, bool, bool, bool, bool);
  void (__fastcall *startSwimming)(Actor *this);
  void (__fastcall *stopSwimming)(Actor *this);
  void (__fastcall *buildDebugInfo)(Actor *this, std::string *);
  CommandPermissionLevel (__fastcall *getCommandPermissionLevel)(Actor *this);
  AttributeInstance *(__fastcall *getMutableAttribute)(Actor *this, const Attribute *);
  const AttributeInstance *(__fastcall *getAttribute)(Actor *this, const Attribute *);
  int (__fastcall *getDeathTime)(Actor *this);
  void (__fastcall *heal)(Actor *this, int);
  bool (__fastcall *isInvertedHealAndHarm)(Actor *this);
  bool (__fastcall *canBeAffected)(Actor *this, const MobEffectInstance *);
  bool (__fastcall *canBeAffected)(Actor *this, int);
  bool (__fastcall *canBeAffectedByArrow)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectAdded)(Actor *this, MobEffectInstance *);
  void (__fastcall *onEffectUpdated)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectRemoved)(Actor *this, MobEffectInstance *);
  AnimationComponent *(__fastcall *getAnimationComponent)(Actor *this);
  void (__fastcall *openContainerComponent)(Actor *this, Player *);
  void (__fastcall *swing)(Actor *this);
  void (__fastcall *useItem)(Actor *this, ItemStackBase *, ItemUseMethod, bool);
  bool (__fastcall *hasOutputSignal)(Actor *this, unsigned __int8);
  int (__fastcall *getOutputSignal)(Actor *this);
  void (__fastcall *getDebugText)(Actor *this, std::vector&lt;std::string&gt; *);
  float (__fastcall *getMapDecorationRotation)(Actor *this);
  float (__fastcall *getRiderYRotation)(Actor *this, const Actor *);
  float (__fastcall *getYHeadRot)(Actor *this);
  bool (__fastcall *isWorldBuilder)(Actor *this);
  bool (__fastcall *isCreative)(Actor *this);
  bool (__fastcall *isAdventure)(Actor *this);
  bool (__fastcall *add)(Actor *this, ItemStack *);
  bool (__fastcall *drop)(Actor *this, const ItemStack *, bool);
  bool (__fastcall *getInteraction)(Actor *this, Player *, ActorInteraction *, const Vec3 *);
  bool (__fastcall *canDestroyBlock)(Actor *this, const Block *);
  void (__fastcall *setAuxValue)(Actor *this, int);
  void (__fastcall *setSize)(Actor *this, float, float);
  int (__fastcall *getLifeSpan)(Actor *this);
  void (__fastcall *onOrphan)(Actor *this);
  void (__fastcall *wobble)(Actor *this);
  bool (__fastcall *wasHurt)(Actor *this);
  void (__fastcall *startSpinAttack)(Actor *this);
  void (__fastcall *stopSpinAttack)(Actor *this);
  void (__fastcall *setDamageNearbyMobs)(Actor *this, bool);
  bool (__fastcall *hasCritBox)(Actor *this);
  bool (__fastcall *isCritHit)(Actor *this);
  void (__fastcall *renderDebugServerState)(Actor *this, const Options *);
  void (__fastcall *reloadLootTable)(Actor *this, const EquipmentTableDefinition *);
  void (__fastcall *reloadLootTable)(Actor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(Actor *this);
  void (__fastcall *kill)(Actor *this);
  void (__fastcall *die)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *shouldTick)(Actor *this);
  std::shared_ptr&lt;IActorMovementProxy&gt; *(__fastcall *createMovementProxy)(Actor *this, std::shared_ptr&lt;IActorMovementProxy&gt; *result);
  void (__fastcall *updateEntitySpecificMolangVariables)(Actor *this, RenderParams *);
  bool (__fastcall *shouldTryMakeStepSound)(Actor *this);
  float (__fastcall *getNextStep)(Actor *this, const float);
  bool (__fastcall *canMakeStepSound)(Actor *this);
  void (__fastcall *outOfWorld)(Actor *this);
  bool (__fastcall *_hurt)(Actor *this, const ActorDamageSource *, int, bool, bool);
  void (__fastcall *markHurt)(Actor *this);
  void (__fastcall *readAdditionalSaveData)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *addAdditionalSaveData)(Actor *this, CompoundTag *);
  void (__fastcall *_playStepSound)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *_playFlySound)(Actor *this, const BlockPos *, const Block *);
  bool (__fastcall *_makeFlySound)(Actor *this);
  void (__fastcall *checkInsideBlocks)(Actor *this, float);
  void (__fastcall *pushOutOfBlocks)(Actor *this, const Vec3 *);
  bool (__fastcall *updateWaterState)(Actor *this);
  void (__fastcall *doWaterSplashEffect)(Actor *this);
  void (__fastcall *spawnTrailBubbles)(Actor *this);
  void (__fastcall *updateInsideBlock)(Actor *this);
  LootTable *(__fastcall *getLootTable)(Actor *this);
  LootTable *(__fastcall *getDefaultLootTable)(Actor *this);
  void (__fastcall *_removeRider)(Actor *this, const ActorUniqueID *, bool, bool, bool);
  void (__fastcall *_onSizeUpdated)(Actor *this);
  void (__fastcall *_doAutoAttackOnTouch)(Actor *this, Actor *);
  float (__fastcall *getThrowPower)(Throwable *this);
  bool (__fastcall *stopUponGroundCollision)(Throwable *this);
  float (__fastcall *getThrowUpAngleOffset)(Throwable *this);
  float (__fastcall *getGravity)(Throwable *this);
  ParticleType (__fastcall *getParticleType)(Throwable *this);
  void (__fastcall *onHit)(Throwable *this, const HitResult *);
};

</code></pre></div><h3 id="thrownenderpearl"><a href="#thrownenderpearl" class="header-anchor">#</a> <code>ThrownEnderpearl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ThrownEnderpearl : Throwable
{
};

</code></pre></div><h3 id="thrownenderpearl-vtbl"><a href="#thrownenderpearl-vtbl" class="header-anchor">#</a> <code>ThrownEnderpearl_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ThrownEnderpearl_vtbl
{
  bool (__fastcall *hasComponent)(Actor *this, const HashedString *);
  void (__fastcall *reloadHardcoded)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadHardcodedClient)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *initializeComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *_serverInitItemStackIds)(Actor *this);
  void (__fastcall *_doInitialMove)(Actor *this);
  bool (__fastcall *checkAllSensitiveWords)(Actor *this);
  bool (__fastcall *checkNameTag)(Actor *this);
  void (__fastcall *~Actor)(Actor *this);
  void (__fastcall *reset)(Actor *this);
  int (__fastcall *getOnDeathExperience)(Actor *this);
  ActorType (__fastcall *getOwnerEntityType)(Actor *this);
  void (__fastcall *remove)(Actor *this);
  void (__fastcall *setPos)(Actor *this, const Vec3 *);
  const PredictedMovementValues *(__fastcall *getPredictedMovementValues)(Actor *this);
  const Vec3 *(__fastcall *getPos)(Actor *this);
  const Vec3 *(__fastcall *getPosOld)(Actor *this);
  const Vec3 *(__fastcall *getPosExtrapolated)(Actor *this, const Vec3 *result, float);
  Vec3 *(__fastcall *getAttachPos)(Actor *this, Vec3 *result, ActorLocation, float);
  Vec3 *(__fastcall *getFiringPos)(Actor *this, Vec3 *result);
  void (__fastcall *setRot)(Actor *this, const Vec2 *);
  void (__fastcall *move)(Actor *this, IActorMovementProxy *, const Vec3 *);
  void (__fastcall *move)(Actor *this, const Vec3 *);
  Vec3 *(__fastcall *getInterpolatedRidingPosition)(Actor *this, Vec3 *result, float);
  float (__fastcall *getInterpolatedBodyRot)(Actor *this, float);
  float (__fastcall *getInterpolatedHeadRot)(Actor *this, float);
  float (__fastcall *getInterpolatedBodyYaw)(Actor *this, float);
  float (__fastcall *getYawSpeedInDegreesPerSecond)(Actor *this);
  float (__fastcall *getInterpolatedWalkAnimSpeed)(Actor *this, float);
  Vec3 *(__fastcall *getInterpolatedRidingOffset)(Actor *this, Vec3 *result, float);
  void (__fastcall *checkBlockCollisions)(Actor *this);
  void (__fastcall *checkBlockCollisions)(Actor *this, const AABB *, std::function&lt;void __cdecl(BlockSource &amp;,Block const &amp;,BlockPos const &amp;,Actor &amp;)&gt;);
  bool (__fastcall *isFireImmune)(Actor *this);
  bool (__fastcall *breaksFallingBlocks)(Actor *this);
  void (__fastcall *blockedByShield)(Actor *this, const ActorDamageSource *, Actor *);
  void (__fastcall *teleportTo)(Actor *this, const Vec3 *, bool, int, int, const ActorUniqueID *);
  bool (__fastcall *tryTeleportTo)(Actor *this, const Vec3 *, bool, bool, int, int);
  void (__fastcall *chorusFruitTeleport)(Actor *this, Vec3 *);
  void (__fastcall *lerpTo)(Actor *this, const Vec3 *, const Vec2 *, int);
  void (__fastcall *lerpMotion)(Actor *this, const Vec3 *);
  std::unique_ptr&lt;AddActorBasePacket&gt; *(__fastcall *getAddPacket)(Actor *this, std::unique_ptr&lt;AddActorBasePacket&gt; *result);
  void (__fastcall *normalTick)(Actor *this);
  void (__fastcall *baseTick)(Actor *this);
  void (__fastcall *rideTick)(Actor *this);
  void (__fastcall *positionRider)(Actor *this, Actor *, float);
  float (__fastcall *getRidingHeight)(Actor *this);
  bool (__fastcall *startRiding)(Actor *this, Actor *);
  void (__fastcall *addRider)(Actor *this, Actor *);
  void (__fastcall *flagRiderToRemove)(Actor *this, Actor *);
  std::string *(__fastcall *getExitTip)(Actor *this, std::string *result, const std::string *, InputMode);
  bool (__fastcall *intersects)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *, float);
  bool (__fastcall *isInWall)(Actor *this);
  bool (__fastcall *isInvisible)(Actor *this);
  bool (__fastcall *canShowNameTag)(Actor *this);
  bool (__fastcall *canExistInPeaceful)(Actor *this);
  void (__fastcall *setNameTagVisible)(Actor *this, bool);
  const std::string *(__fastcall *getNameTag)(Actor *this);
  unsigned __int64 (__fastcall *getNameTagAsHash)(Actor *this);
  std::string *(__fastcall *getFormattedNameTag)(Actor *this, std::string *result);
  void (__fastcall *filterFormattedNameTag)(Actor *this, const UIProfanityContext *);
  void (__fastcall *setNameTag)(Actor *this, const std::string *);
  bool (__fastcall *getAlwaysShowNameTag)(Actor *this);
  void (__fastcall *setScoreTag)(Actor *this, const std::string *);
  const std::string *(__fastcall *getScoreTag)(Actor *this);
  bool (__fastcall *isInWater)(Actor *this);
  bool (__fastcall *hasEnteredWater)(Actor *this);
  bool (__fastcall *isImmersedInWater)(Actor *this);
  bool (__fastcall *isInWaterOrRain)(Actor *this);
  bool (__fastcall *isInLava)(Actor *this);
  bool (__fastcall *isUnderLiquid)(Actor *this, MaterialType);
  bool (__fastcall *isOverWater)(Actor *this);
  void (__fastcall *makeStuckInBlock)(Actor *this, const Vec3 *);
  float (__fastcall *getCameraOffset)(Actor *this);
  float (__fastcall *getShadowHeightOffs)(Actor *this);
  float (__fastcall *getShadowRadius)(Actor *this);
  Vec3 *(__fastcall *getHeadLookVector)(Actor *this, Vec3 *result, float);
  bool (__fastcall *canSeeInvisible)(Actor *this);
  bool (__fastcall *canSee)(Actor *this, const Vec3 *);
  bool (__fastcall *canSee)(Actor *this, const Actor *);
  bool (__fastcall *isSkyLit)(Actor *this, float);
  float (__fastcall *getBrightness)(Actor *this, float);
  bool (__fastcall *interactPreventDefault)(Actor *this);
  void (__fastcall *playerTouch)(Actor *this, Player *);
  void (__fastcall *onAboveBubbleColumn)(Actor *this, const bool);
  void (__fastcall *onInsideBubbleColumn)(Actor *this, const bool);
  bool (__fastcall *isImmobile)(Actor *this);
  bool (__fastcall *isSilent)(Actor *this);
  bool (__fastcall *isPickable)(Actor *this);
  bool (__fastcall *isFishable)(Actor *this);
  bool (__fastcall *isSleeping)(Actor *this);
  bool (__fastcall *isShootable)(Actor *this);
  void (__fastcall *setSneaking)(Actor *this, bool);
  bool (__fastcall *isBlocking)(Actor *this);
  bool (__fastcall *isDamageBlocked)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *isAlive)(Actor *this);
  bool (__fastcall *isOnFire)(Actor *this);
  bool (__fastcall *isOnHotBlock)(Actor *this);
  bool (__fastcall *isCreativeModeAllowed)(Actor *this);
  bool (__fastcall *isSurfaceMob)(Actor *this);
  bool (__fastcall *isTargetable)(Actor *this);
  bool (__fastcall *isLocalPlayer)(Actor *this);
  bool (__fastcall *isPlayer)(Actor *this);
  bool (__fastcall *canAttack)(Actor *this, Actor *, bool);
  void (__fastcall *setTarget)(Actor *this, Actor *);
  Actor *(__fastcall *findAttackTarget)(Actor *this);
  bool (__fastcall *isValidTarget)(Actor *this, Actor *);
  bool (__fastcall *attack)(Actor *this, Actor *);
  void (__fastcall *performRangedAttack)(Actor *this, Actor *, float);
  void (__fastcall *adjustDamageAmount)(Actor *this, int *);
  int (__fastcall *getEquipmentCount)(Actor *this);
  void (__fastcall *setOwner)(Actor *this, const ActorUniqueID);
  void (__fastcall *setSitting)(Actor *this, bool);
  void (__fastcall *onTame)(Actor *this);
  void (__fastcall *onFailedTame)(Actor *this);
  int (__fastcall *getInventorySize)(Actor *this);
  int (__fastcall *getEquipSlots)(Actor *this);
  int (__fastcall *getChestSlots)(Actor *this);
  void (__fastcall *setStanding)(Actor *this, bool);
  bool (__fastcall *canPowerJump)(Actor *this);
  void (__fastcall *setCanPowerJump)(Actor *this, bool);
  bool (__fastcall *isJumping)(Actor *this);
  bool (__fastcall *isEnchanted)(Actor *this);
  void (__fastcall *rideJumped)(Actor *this);
  void (__fastcall *rideLanded)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *shouldRender)(Actor *this);
  bool (__fastcall *isInvulnerableTo)(Actor *this, const ActorDamageSource *);
  ActorDamageCause (__fastcall *getBlockDamageCause)(Actor *this, const Block *);
  void (__fastcall *actuallyHurt)(Actor *this, int, const ActorDamageSource *, bool);
  void (__fastcall *animateHurt)(Actor *this);
  bool (__fastcall *doFireHurt)(Actor *this, int);
  void (__fastcall *onLightningHit)(Actor *this);
  void (__fastcall *onBounceStarted)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *feed)(Actor *this, int);
  void (__fastcall *handleEntityEvent)(Actor *this, ActorEvent, int);
  float (__fastcall *getPickRadius)(Actor *this);
  const HashedString *(__fastcall *getActorRendererId)(Actor *this);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const ItemStack *, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int);
  void (__fastcall *despawn)(Actor *this);
  void (__fastcall *killed)(Actor *this, Actor *);
  void (__fastcall *awardKillScore)(Actor *this, Actor *, int);
  void (__fastcall *setArmor)(Actor *this, ArmorSlot, const ItemStack *);
  const ItemStack *(__fastcall *getArmor)(Actor *this, ArmorSlot);
  ArmorMaterialType (__fastcall *getArmorMaterialTypeInSlot)(Actor *this, ArmorSlot);
  ArmorTextureType (__fastcall *getArmorMaterialTextureTypeInSlot)(Actor *this, ArmorSlot);
  float (__fastcall *getArmorColorInSlot)(Actor *this, ArmorSlot, int);
  const ItemStack *(__fastcall *getEquippedSlot)(Actor *this, EquipmentSlot);
  void (__fastcall *setEquippedSlot)(Actor *this, EquipmentSlot, const ItemStack *);
  const ItemStack *(__fastcall *getCarriedItem)(Actor *this);
  void (__fastcall *setCarriedItem)(Actor *this, const ItemStack *);
  void (__fastcall *setOffhandSlot)(Actor *this, const ItemStack *);
  const ItemStack *(__fastcall *getEquippedTotem)(Actor *this);
  bool (__fastcall *consumeTotem)(Actor *this);
  bool (__fastcall *save)(Actor *this, CompoundTag *);
  void (__fastcall *saveWithoutId)(Actor *this, CompoundTag *);
  bool (__fastcall *load)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *loadLinks)(Actor *this, const CompoundTag *, std::vector&lt;ActorLink&gt; *, DataLoadHelper *);
  ActorType (__fastcall *getEntityTypeId)(Actor *this);
  const HashedString *(__fastcall *queryEntityRenderer)(Actor *this);
  ActorUniqueID *(__fastcall *getSourceUniqueID)(Actor *this, ActorUniqueID *result);
  void (__fastcall *setOnFire)(Actor *this, int);
  AABB *(__fastcall *getHandleWaterAABB)(Actor *this, AABB *result);
  void (__fastcall *handleInsidePortal)(Actor *this, const BlockPos *);
  int (__fastcall *getPortalCooldown)(Actor *this);
  int (__fastcall *getPortalWaitTime)(Actor *this);
  AutomaticID&lt;Dimension,int&gt; *(__fastcall *getDimensionId)(Actor *this, AutomaticID&lt;Dimension,int&gt; *result);
  bool (__fastcall *canChangeDimensions)(Actor *this);
  void (__fastcall *changeDimension)(Actor *this, const ChangeDimensionPacket *);
  void (__fastcall *changeDimension)(Actor *this, AutomaticID&lt;Dimension,int&gt;, bool);
  ActorUniqueID *(__fastcall *getControllingPlayer)(Actor *this, ActorUniqueID *result);
  void (__fastcall *checkFallDamage)(Actor *this, float, bool);
  void (__fastcall *causeFallDamage)(Actor *this, float);
  void (__fastcall *handleFallDistanceOnServer)(Actor *this, float, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, int, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, const Block *, bool);
  void (__fastcall *onSynchedDataUpdate)(Actor *this, int);
  bool (__fastcall *canAddRider)(Actor *this, Actor *);
  bool (__fastcall *canPickupItem)(Actor *this, const ItemStack *);
  bool (__fastcall *canBePulledIntoVehicle)(Actor *this);
  bool (__fastcall *inCaravan)(Actor *this);
  bool (__fastcall *isLeashableType)(Actor *this);
  void (__fastcall *tickLeash)(Actor *this);
  void (__fastcall *sendMotionPacketIfNeeded)(Actor *this);
  bool (__fastcall *canSynchronizeNewEntity)(Actor *this);
  bool (__fastcall *stopRiding)(Actor *this, bool, bool, bool, bool);
  void (__fastcall *startSwimming)(Actor *this);
  void (__fastcall *stopSwimming)(Actor *this);
  void (__fastcall *buildDebugInfo)(Actor *this, std::string *);
  CommandPermissionLevel (__fastcall *getCommandPermissionLevel)(Actor *this);
  AttributeInstance *(__fastcall *getMutableAttribute)(Actor *this, const Attribute *);
  const AttributeInstance *(__fastcall *getAttribute)(Actor *this, const Attribute *);
  int (__fastcall *getDeathTime)(Actor *this);
  void (__fastcall *heal)(Actor *this, int);
  bool (__fastcall *isInvertedHealAndHarm)(Actor *this);
  bool (__fastcall *canBeAffected)(Actor *this, const MobEffectInstance *);
  bool (__fastcall *canBeAffected)(Actor *this, int);
  bool (__fastcall *canBeAffectedByArrow)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectAdded)(Actor *this, MobEffectInstance *);
  void (__fastcall *onEffectUpdated)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectRemoved)(Actor *this, MobEffectInstance *);
  AnimationComponent *(__fastcall *getAnimationComponent)(Actor *this);
  void (__fastcall *openContainerComponent)(Actor *this, Player *);
  void (__fastcall *swing)(Actor *this);
  void (__fastcall *useItem)(Actor *this, ItemStackBase *, ItemUseMethod, bool);
  bool (__fastcall *hasOutputSignal)(Actor *this, unsigned __int8);
  int (__fastcall *getOutputSignal)(Actor *this);
  void (__fastcall *getDebugText)(Actor *this, std::vector&lt;std::string&gt; *);
  float (__fastcall *getMapDecorationRotation)(Actor *this);
  float (__fastcall *getRiderYRotation)(Actor *this, const Actor *);
  float (__fastcall *getYHeadRot)(Actor *this);
  bool (__fastcall *isWorldBuilder)(Actor *this);
  bool (__fastcall *isCreative)(Actor *this);
  bool (__fastcall *isAdventure)(Actor *this);
  bool (__fastcall *add)(Actor *this, ItemStack *);
  bool (__fastcall *drop)(Actor *this, const ItemStack *, bool);
  bool (__fastcall *getInteraction)(Actor *this, Player *, ActorInteraction *, const Vec3 *);
  bool (__fastcall *canDestroyBlock)(Actor *this, const Block *);
  void (__fastcall *setAuxValue)(Actor *this, int);
  void (__fastcall *setSize)(Actor *this, float, float);
  int (__fastcall *getLifeSpan)(Actor *this);
  void (__fastcall *onOrphan)(Actor *this);
  void (__fastcall *wobble)(Actor *this);
  bool (__fastcall *wasHurt)(Actor *this);
  void (__fastcall *startSpinAttack)(Actor *this);
  void (__fastcall *stopSpinAttack)(Actor *this);
  void (__fastcall *setDamageNearbyMobs)(Actor *this, bool);
  bool (__fastcall *hasCritBox)(Actor *this);
  bool (__fastcall *isCritHit)(Actor *this);
  void (__fastcall *renderDebugServerState)(Actor *this, const Options *);
  void (__fastcall *reloadLootTable)(Actor *this, const EquipmentTableDefinition *);
  void (__fastcall *reloadLootTable)(Actor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(Actor *this);
  void (__fastcall *kill)(Actor *this);
  void (__fastcall *die)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *shouldTick)(Actor *this);
  std::shared_ptr&lt;IActorMovementProxy&gt; *(__fastcall *createMovementProxy)(Actor *this, std::shared_ptr&lt;IActorMovementProxy&gt; *result);
  void (__fastcall *updateEntitySpecificMolangVariables)(Actor *this, RenderParams *);
  bool (__fastcall *shouldTryMakeStepSound)(Actor *this);
  float (__fastcall *getNextStep)(Actor *this, const float);
  bool (__fastcall *canMakeStepSound)(Actor *this);
  void (__fastcall *outOfWorld)(Actor *this);
  bool (__fastcall *_hurt)(Actor *this, const ActorDamageSource *, int, bool, bool);
  void (__fastcall *markHurt)(Actor *this);
  void (__fastcall *readAdditionalSaveData)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *addAdditionalSaveData)(Actor *this, CompoundTag *);
  void (__fastcall *_playStepSound)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *_playFlySound)(Actor *this, const BlockPos *, const Block *);
  bool (__fastcall *_makeFlySound)(Actor *this);
  void (__fastcall *checkInsideBlocks)(Actor *this, float);
  void (__fastcall *pushOutOfBlocks)(Actor *this, const Vec3 *);
  bool (__fastcall *updateWaterState)(Actor *this);
  void (__fastcall *doWaterSplashEffect)(Actor *this);
  void (__fastcall *spawnTrailBubbles)(Actor *this);
  void (__fastcall *updateInsideBlock)(Actor *this);
  LootTable *(__fastcall *getLootTable)(Actor *this);
  LootTable *(__fastcall *getDefaultLootTable)(Actor *this);
  void (__fastcall *_removeRider)(Actor *this, const ActorUniqueID *, bool, bool, bool);
  void (__fastcall *_onSizeUpdated)(Actor *this);
  void (__fastcall *_doAutoAttackOnTouch)(Actor *this, Actor *);
  float (__fastcall *getThrowPower)(Throwable *this);
  bool (__fastcall *stopUponGroundCollision)(Throwable *this);
  float (__fastcall *getThrowUpAngleOffset)(Throwable *this);
  float (__fastcall *getGravity)(Throwable *this);
  ParticleType (__fastcall *getParticleType)(Throwable *this);
  void (__fastcall *onHit)(Throwable *this, const HitResult *);
};

</code></pre></div><h3 id="thrownicebomb"><a href="#thrownicebomb" class="header-anchor">#</a> <code>ThrownIceBomb</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ThrownIceBomb : Throwable
{
};

</code></pre></div><h3 id="thrownicebomb-vtbl"><a href="#thrownicebomb-vtbl" class="header-anchor">#</a> <code>ThrownIceBomb_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ThrownIceBomb_vtbl
{
  bool (__fastcall *hasComponent)(Actor *this, const HashedString *);
  void (__fastcall *reloadHardcoded)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadHardcodedClient)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *initializeComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *_serverInitItemStackIds)(Actor *this);
  void (__fastcall *_doInitialMove)(Actor *this);
  bool (__fastcall *checkAllSensitiveWords)(Actor *this);
  bool (__fastcall *checkNameTag)(Actor *this);
  void (__fastcall *~Actor)(Actor *this);
  void (__fastcall *reset)(Actor *this);
  int (__fastcall *getOnDeathExperience)(Actor *this);
  ActorType (__fastcall *getOwnerEntityType)(Actor *this);
  void (__fastcall *remove)(Actor *this);
  void (__fastcall *setPos)(Actor *this, const Vec3 *);
  const PredictedMovementValues *(__fastcall *getPredictedMovementValues)(Actor *this);
  const Vec3 *(__fastcall *getPos)(Actor *this);
  const Vec3 *(__fastcall *getPosOld)(Actor *this);
  const Vec3 *(__fastcall *getPosExtrapolated)(Actor *this, const Vec3 *result, float);
  Vec3 *(__fastcall *getAttachPos)(Actor *this, Vec3 *result, ActorLocation, float);
  Vec3 *(__fastcall *getFiringPos)(Actor *this, Vec3 *result);
  void (__fastcall *setRot)(Actor *this, const Vec2 *);
  void (__fastcall *move)(Actor *this, IActorMovementProxy *, const Vec3 *);
  void (__fastcall *move)(Actor *this, const Vec3 *);
  Vec3 *(__fastcall *getInterpolatedRidingPosition)(Actor *this, Vec3 *result, float);
  float (__fastcall *getInterpolatedBodyRot)(Actor *this, float);
  float (__fastcall *getInterpolatedHeadRot)(Actor *this, float);
  float (__fastcall *getInterpolatedBodyYaw)(Actor *this, float);
  float (__fastcall *getYawSpeedInDegreesPerSecond)(Actor *this);
  float (__fastcall *getInterpolatedWalkAnimSpeed)(Actor *this, float);
  Vec3 *(__fastcall *getInterpolatedRidingOffset)(Actor *this, Vec3 *result, float);
  void (__fastcall *checkBlockCollisions)(Actor *this);
  void (__fastcall *checkBlockCollisions)(Actor *this, const AABB *, std::function&lt;void __cdecl(BlockSource &amp;,Block const &amp;,BlockPos const &amp;,Actor &amp;)&gt;);
  bool (__fastcall *isFireImmune)(Actor *this);
  bool (__fastcall *breaksFallingBlocks)(Actor *this);
  void (__fastcall *blockedByShield)(Actor *this, const ActorDamageSource *, Actor *);
  void (__fastcall *teleportTo)(Actor *this, const Vec3 *, bool, int, int, const ActorUniqueID *);
  bool (__fastcall *tryTeleportTo)(Actor *this, const Vec3 *, bool, bool, int, int);
  void (__fastcall *chorusFruitTeleport)(Actor *this, Vec3 *);
  void (__fastcall *lerpTo)(Actor *this, const Vec3 *, const Vec2 *, int);
  void (__fastcall *lerpMotion)(Actor *this, const Vec3 *);
  std::unique_ptr&lt;AddActorBasePacket&gt; *(__fastcall *getAddPacket)(Actor *this, std::unique_ptr&lt;AddActorBasePacket&gt; *result);
  void (__fastcall *normalTick)(Actor *this);
  void (__fastcall *baseTick)(Actor *this);
  void (__fastcall *rideTick)(Actor *this);
  void (__fastcall *positionRider)(Actor *this, Actor *, float);
  float (__fastcall *getRidingHeight)(Actor *this);
  bool (__fastcall *startRiding)(Actor *this, Actor *);
  void (__fastcall *addRider)(Actor *this, Actor *);
  void (__fastcall *flagRiderToRemove)(Actor *this, Actor *);
  std::string *(__fastcall *getExitTip)(Actor *this, std::string *result, const std::string *, InputMode);
  bool (__fastcall *intersects)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *, float);
  bool (__fastcall *isInWall)(Actor *this);
  bool (__fastcall *isInvisible)(Actor *this);
  bool (__fastcall *canShowNameTag)(Actor *this);
  bool (__fastcall *canExistInPeaceful)(Actor *this);
  void (__fastcall *setNameTagVisible)(Actor *this, bool);
  const std::string *(__fastcall *getNameTag)(Actor *this);
  unsigned __int64 (__fastcall *getNameTagAsHash)(Actor *this);
  std::string *(__fastcall *getFormattedNameTag)(Actor *this, std::string *result);
  void (__fastcall *filterFormattedNameTag)(Actor *this, const UIProfanityContext *);
  void (__fastcall *setNameTag)(Actor *this, const std::string *);
  bool (__fastcall *getAlwaysShowNameTag)(Actor *this);
  void (__fastcall *setScoreTag)(Actor *this, const std::string *);
  const std::string *(__fastcall *getScoreTag)(Actor *this);
  bool (__fastcall *isInWater)(Actor *this);
  bool (__fastcall *hasEnteredWater)(Actor *this);
  bool (__fastcall *isImmersedInWater)(Actor *this);
  bool (__fastcall *isInWaterOrRain)(Actor *this);
  bool (__fastcall *isInLava)(Actor *this);
  bool (__fastcall *isUnderLiquid)(Actor *this, MaterialType);
  bool (__fastcall *isOverWater)(Actor *this);
  void (__fastcall *makeStuckInBlock)(Actor *this, const Vec3 *);
  float (__fastcall *getCameraOffset)(Actor *this);
  float (__fastcall *getShadowHeightOffs)(Actor *this);
  float (__fastcall *getShadowRadius)(Actor *this);
  Vec3 *(__fastcall *getHeadLookVector)(Actor *this, Vec3 *result, float);
  bool (__fastcall *canSeeInvisible)(Actor *this);
  bool (__fastcall *canSee)(Actor *this, const Vec3 *);
  bool (__fastcall *canSee)(Actor *this, const Actor *);
  bool (__fastcall *isSkyLit)(Actor *this, float);
  float (__fastcall *getBrightness)(Actor *this, float);
  bool (__fastcall *interactPreventDefault)(Actor *this);
  void (__fastcall *playerTouch)(Actor *this, Player *);
  void (__fastcall *onAboveBubbleColumn)(Actor *this, const bool);
  void (__fastcall *onInsideBubbleColumn)(Actor *this, const bool);
  bool (__fastcall *isImmobile)(Actor *this);
  bool (__fastcall *isSilent)(Actor *this);
  bool (__fastcall *isPickable)(Actor *this);
  bool (__fastcall *isFishable)(Actor *this);
  bool (__fastcall *isSleeping)(Actor *this);
  bool (__fastcall *isShootable)(Actor *this);
  void (__fastcall *setSneaking)(Actor *this, bool);
  bool (__fastcall *isBlocking)(Actor *this);
  bool (__fastcall *isDamageBlocked)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *isAlive)(Actor *this);
  bool (__fastcall *isOnFire)(Actor *this);
  bool (__fastcall *isOnHotBlock)(Actor *this);
  bool (__fastcall *isCreativeModeAllowed)(Actor *this);
  bool (__fastcall *isSurfaceMob)(Actor *this);
  bool (__fastcall *isTargetable)(Actor *this);
  bool (__fastcall *isLocalPlayer)(Actor *this);
  bool (__fastcall *isPlayer)(Actor *this);
  bool (__fastcall *canAttack)(Actor *this, Actor *, bool);
  void (__fastcall *setTarget)(Actor *this, Actor *);
  Actor *(__fastcall *findAttackTarget)(Actor *this);
  bool (__fastcall *isValidTarget)(Actor *this, Actor *);
  bool (__fastcall *attack)(Actor *this, Actor *);
  void (__fastcall *performRangedAttack)(Actor *this, Actor *, float);
  void (__fastcall *adjustDamageAmount)(Actor *this, int *);
  int (__fastcall *getEquipmentCount)(Actor *this);
  void (__fastcall *setOwner)(Actor *this, const ActorUniqueID);
  void (__fastcall *setSitting)(Actor *this, bool);
  void (__fastcall *onTame)(Actor *this);
  void (__fastcall *onFailedTame)(Actor *this);
  int (__fastcall *getInventorySize)(Actor *this);
  int (__fastcall *getEquipSlots)(Actor *this);
  int (__fastcall *getChestSlots)(Actor *this);
  void (__fastcall *setStanding)(Actor *this, bool);
  bool (__fastcall *canPowerJump)(Actor *this);
  void (__fastcall *setCanPowerJump)(Actor *this, bool);
  bool (__fastcall *isJumping)(Actor *this);
  bool (__fastcall *isEnchanted)(Actor *this);
  void (__fastcall *rideJumped)(Actor *this);
  void (__fastcall *rideLanded)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *shouldRender)(Actor *this);
  bool (__fastcall *isInvulnerableTo)(Actor *this, const ActorDamageSource *);
  ActorDamageCause (__fastcall *getBlockDamageCause)(Actor *this, const Block *);
  void (__fastcall *actuallyHurt)(Actor *this, int, const ActorDamageSource *, bool);
  void (__fastcall *animateHurt)(Actor *this);
  bool (__fastcall *doFireHurt)(Actor *this, int);
  void (__fastcall *onLightningHit)(Actor *this);
  void (__fastcall *onBounceStarted)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *feed)(Actor *this, int);
  void (__fastcall *handleEntityEvent)(Actor *this, ActorEvent, int);
  float (__fastcall *getPickRadius)(Actor *this);
  const HashedString *(__fastcall *getActorRendererId)(Actor *this);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const ItemStack *, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int);
  void (__fastcall *despawn)(Actor *this);
  void (__fastcall *killed)(Actor *this, Actor *);
  void (__fastcall *awardKillScore)(Actor *this, Actor *, int);
  void (__fastcall *setArmor)(Actor *this, ArmorSlot, const ItemStack *);
  const ItemStack *(__fastcall *getArmor)(Actor *this, ArmorSlot);
  ArmorMaterialType (__fastcall *getArmorMaterialTypeInSlot)(Actor *this, ArmorSlot);
  ArmorTextureType (__fastcall *getArmorMaterialTextureTypeInSlot)(Actor *this, ArmorSlot);
  float (__fastcall *getArmorColorInSlot)(Actor *this, ArmorSlot, int);
  const ItemStack *(__fastcall *getEquippedSlot)(Actor *this, EquipmentSlot);
  void (__fastcall *setEquippedSlot)(Actor *this, EquipmentSlot, const ItemStack *);
  const ItemStack *(__fastcall *getCarriedItem)(Actor *this);
  void (__fastcall *setCarriedItem)(Actor *this, const ItemStack *);
  void (__fastcall *setOffhandSlot)(Actor *this, const ItemStack *);
  const ItemStack *(__fastcall *getEquippedTotem)(Actor *this);
  bool (__fastcall *consumeTotem)(Actor *this);
  bool (__fastcall *save)(Actor *this, CompoundTag *);
  void (__fastcall *saveWithoutId)(Actor *this, CompoundTag *);
  bool (__fastcall *load)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *loadLinks)(Actor *this, const CompoundTag *, std::vector&lt;ActorLink&gt; *, DataLoadHelper *);
  ActorType (__fastcall *getEntityTypeId)(Actor *this);
  const HashedString *(__fastcall *queryEntityRenderer)(Actor *this);
  ActorUniqueID *(__fastcall *getSourceUniqueID)(Actor *this, ActorUniqueID *result);
  void (__fastcall *setOnFire)(Actor *this, int);
  AABB *(__fastcall *getHandleWaterAABB)(Actor *this, AABB *result);
  void (__fastcall *handleInsidePortal)(Actor *this, const BlockPos *);
  int (__fastcall *getPortalCooldown)(Actor *this);
  int (__fastcall *getPortalWaitTime)(Actor *this);
  AutomaticID&lt;Dimension,int&gt; *(__fastcall *getDimensionId)(Actor *this, AutomaticID&lt;Dimension,int&gt; *result);
  bool (__fastcall *canChangeDimensions)(Actor *this);
  void (__fastcall *changeDimension)(Actor *this, const ChangeDimensionPacket *);
  void (__fastcall *changeDimension)(Actor *this, AutomaticID&lt;Dimension,int&gt;, bool);
  ActorUniqueID *(__fastcall *getControllingPlayer)(Actor *this, ActorUniqueID *result);
  void (__fastcall *checkFallDamage)(Actor *this, float, bool);
  void (__fastcall *causeFallDamage)(Actor *this, float);
  void (__fastcall *handleFallDistanceOnServer)(Actor *this, float, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, int, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, const Block *, bool);
  void (__fastcall *onSynchedDataUpdate)(Actor *this, int);
  bool (__fastcall *canAddRider)(Actor *this, Actor *);
  bool (__fastcall *canPickupItem)(Actor *this, const ItemStack *);
  bool (__fastcall *canBePulledIntoVehicle)(Actor *this);
  bool (__fastcall *inCaravan)(Actor *this);
  bool (__fastcall *isLeashableType)(Actor *this);
  void (__fastcall *tickLeash)(Actor *this);
  void (__fastcall *sendMotionPacketIfNeeded)(Actor *this);
  bool (__fastcall *canSynchronizeNewEntity)(Actor *this);
  bool (__fastcall *stopRiding)(Actor *this, bool, bool, bool, bool);
  void (__fastcall *startSwimming)(Actor *this);
  void (__fastcall *stopSwimming)(Actor *this);
  void (__fastcall *buildDebugInfo)(Actor *this, std::string *);
  CommandPermissionLevel (__fastcall *getCommandPermissionLevel)(Actor *this);
  AttributeInstance *(__fastcall *getMutableAttribute)(Actor *this, const Attribute *);
  const AttributeInstance *(__fastcall *getAttribute)(Actor *this, const Attribute *);
  int (__fastcall *getDeathTime)(Actor *this);
  void (__fastcall *heal)(Actor *this, int);
  bool (__fastcall *isInvertedHealAndHarm)(Actor *this);
  bool (__fastcall *canBeAffected)(Actor *this, const MobEffectInstance *);
  bool (__fastcall *canBeAffected)(Actor *this, int);
  bool (__fastcall *canBeAffectedByArrow)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectAdded)(Actor *this, MobEffectInstance *);
  void (__fastcall *onEffectUpdated)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectRemoved)(Actor *this, MobEffectInstance *);
  AnimationComponent *(__fastcall *getAnimationComponent)(Actor *this);
  void (__fastcall *openContainerComponent)(Actor *this, Player *);
  void (__fastcall *swing)(Actor *this);
  void (__fastcall *useItem)(Actor *this, ItemStackBase *, ItemUseMethod, bool);
  bool (__fastcall *hasOutputSignal)(Actor *this, unsigned __int8);
  int (__fastcall *getOutputSignal)(Actor *this);
  void (__fastcall *getDebugText)(Actor *this, std::vector&lt;std::string&gt; *);
  float (__fastcall *getMapDecorationRotation)(Actor *this);
  float (__fastcall *getRiderYRotation)(Actor *this, const Actor *);
  float (__fastcall *getYHeadRot)(Actor *this);
  bool (__fastcall *isWorldBuilder)(Actor *this);
  bool (__fastcall *isCreative)(Actor *this);
  bool (__fastcall *isAdventure)(Actor *this);
  bool (__fastcall *add)(Actor *this, ItemStack *);
  bool (__fastcall *drop)(Actor *this, const ItemStack *, bool);
  bool (__fastcall *getInteraction)(Actor *this, Player *, ActorInteraction *, const Vec3 *);
  bool (__fastcall *canDestroyBlock)(Actor *this, const Block *);
  void (__fastcall *setAuxValue)(Actor *this, int);
  void (__fastcall *setSize)(Actor *this, float, float);
  int (__fastcall *getLifeSpan)(Actor *this);
  void (__fastcall *onOrphan)(Actor *this);
  void (__fastcall *wobble)(Actor *this);
  bool (__fastcall *wasHurt)(Actor *this);
  void (__fastcall *startSpinAttack)(Actor *this);
  void (__fastcall *stopSpinAttack)(Actor *this);
  void (__fastcall *setDamageNearbyMobs)(Actor *this, bool);
  bool (__fastcall *hasCritBox)(Actor *this);
  bool (__fastcall *isCritHit)(Actor *this);
  void (__fastcall *renderDebugServerState)(Actor *this, const Options *);
  void (__fastcall *reloadLootTable)(Actor *this, const EquipmentTableDefinition *);
  void (__fastcall *reloadLootTable)(Actor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(Actor *this);
  void (__fastcall *kill)(Actor *this);
  void (__fastcall *die)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *shouldTick)(Actor *this);
  std::shared_ptr&lt;IActorMovementProxy&gt; *(__fastcall *createMovementProxy)(Actor *this, std::shared_ptr&lt;IActorMovementProxy&gt; *result);
  void (__fastcall *updateEntitySpecificMolangVariables)(Actor *this, RenderParams *);
  bool (__fastcall *shouldTryMakeStepSound)(Actor *this);
  float (__fastcall *getNextStep)(Actor *this, const float);
  bool (__fastcall *canMakeStepSound)(Actor *this);
  void (__fastcall *outOfWorld)(Actor *this);
  bool (__fastcall *_hurt)(Actor *this, const ActorDamageSource *, int, bool, bool);
  void (__fastcall *markHurt)(Actor *this);
  void (__fastcall *readAdditionalSaveData)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *addAdditionalSaveData)(Actor *this, CompoundTag *);
  void (__fastcall *_playStepSound)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *_playFlySound)(Actor *this, const BlockPos *, const Block *);
  bool (__fastcall *_makeFlySound)(Actor *this);
  void (__fastcall *checkInsideBlocks)(Actor *this, float);
  void (__fastcall *pushOutOfBlocks)(Actor *this, const Vec3 *);
  bool (__fastcall *updateWaterState)(Actor *this);
  void (__fastcall *doWaterSplashEffect)(Actor *this);
  void (__fastcall *spawnTrailBubbles)(Actor *this);
  void (__fastcall *updateInsideBlock)(Actor *this);
  LootTable *(__fastcall *getLootTable)(Actor *this);
  LootTable *(__fastcall *getDefaultLootTable)(Actor *this);
  void (__fastcall *_removeRider)(Actor *this, const ActorUniqueID *, bool, bool, bool);
  void (__fastcall *_onSizeUpdated)(Actor *this);
  void (__fastcall *_doAutoAttackOnTouch)(Actor *this, Actor *);
  float (__fastcall *getThrowPower)(Throwable *this);
  bool (__fastcall *stopUponGroundCollision)(Throwable *this);
  float (__fastcall *getThrowUpAngleOffset)(Throwable *this);
  float (__fastcall *getGravity)(Throwable *this);
  ParticleType (__fastcall *getParticleType)(Throwable *this);
  void (__fastcall *onHit)(Throwable *this, const HitResult *);
};

</code></pre></div><h3 id="tradeingredientcontainercontroller"><a href="#tradeingredientcontainercontroller" class="header-anchor">#</a> <code>TradeIngredientContainerController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TradeIngredientContainerController : ContainerController
{
  ItemStack mItem;
};

</code></pre></div><h3 id="tradeingredientcontainercontroller-vtbl"><a href="#tradeingredientcontainercontroller-vtbl" class="header-anchor">#</a> <code>TradeIngredientContainerController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TradeIngredientContainerController_vtbl
{
  void (__fastcall *~ContainerController)(ContainerController *this);
  bool (__fastcall *canRemove)(ContainerController *this, int, int);
  bool (__fastcall *isItemAllowed)(ContainerController *this, const ItemStackBase *);
  bool (__fastcall *isItemFiltered)(ContainerController *this, const Recipes *, const ItemStackBase *);
  int (__fastcall *getBackgroundStyle)(ContainerController *this, int, bool);
  ItemSetType (__fastcall *_canSet)(ContainerController *this, int, const ItemStackBase *, ItemTransferAmount);
  int (__fastcall *_getAvailableSetCount)(ContainerController *this, int, const ItemStackBase *);
  bool (__fastcall *_canRemove)(ContainerController *this, int, int);
  void (__fastcall *_onItemChanged)(ContainerController *this, int);
};

</code></pre></div><h3 id="tradecontainermanagercontroller-setupcallbacks-l2-lambda-6ead60eba553363bbbfc19e792c62b61"><a href="#tradecontainermanagercontroller-setupcallbacks-l2-lambda-6ead60eba553363bbbfc19e792c62b61" class="header-anchor">#</a> <code>TradeContainerManagerController::_setupCallbacks::__l2::&lt;lambda_6ead60eba553363bbbfc19e792c62b61&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TradeContainerManagerController::_setupCallbacks::__l2::&lt;lambda_6ead60eba553363bbbfc19e792c62b61&gt;
{
  TradeContainerManagerController *const __this;
};

</code></pre></div><h3 id="tradecontainermanagercontroller-setupcallbacks-l2-lambda-a0152511d2602a805c722ce7437a7a50"><a href="#tradecontainermanagercontroller-setupcallbacks-l2-lambda-a0152511d2602a805c722ce7437a7a50" class="header-anchor">#</a> <code>TradeContainerManagerController::_setupCallbacks::__l2::&lt;lambda_a0152511d2602a805c722ce7437a7a50&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TradeContainerManagerController::_setupCallbacks::__l2::&lt;lambda_a0152511d2602a805c722ce7437a7a50&gt;
{
  TradeContainerManagerController *const __this;
};

</code></pre></div><h3 id="trade2containermanagercontroller-setupcallbacks-l2-lambda-0ba538fec63dfff7a8c31c230ccd8490"><a href="#trade2containermanagercontroller-setupcallbacks-l2-lambda-0ba538fec63dfff7a8c31c230ccd8490" class="header-anchor">#</a> <code>Trade2ContainerManagerController::_setupCallbacks::__l2::&lt;lambda_0ba538fec63dfff7a8c31c230ccd8490&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Trade2ContainerManagerController::_setupCallbacks::__l2::&lt;lambda_0ba538fec63dfff7a8c31c230ccd8490&gt;
{
  Trade2ContainerManagerController *const __this;
};

</code></pre></div><h3 id="trade2containermanagercontroller-setupcallbacks-l2-lambda-500a8ea3460df322e01d98c97ed7c9b2"><a href="#trade2containermanagercontroller-setupcallbacks-l2-lambda-500a8ea3460df322e01d98c97ed7c9b2" class="header-anchor">#</a> <code>Trade2ContainerManagerController::_setupCallbacks::__l2::&lt;lambda_500a8ea3460df322e01d98c97ed7c9b2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Trade2ContainerManagerController::_setupCallbacks::__l2::&lt;lambda_500a8ea3460df322e01d98c97ed7c9b2&gt;
{
  Trade2ContainerManagerController *const __this;
};

</code></pre></div><h3 id="torchblock"><a href="#torchblock" class="header-anchor">#</a> <code>TorchBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TorchBlock : BlockLegacy
{
};

</code></pre></div><h3 id="torchblock-vtbl"><a href="#torchblock-vtbl" class="header-anchor">#</a> <code>TorchBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TorchBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="toolrecipes"><a href="#toolrecipes" class="header-anchor">#</a> <code>ToolRecipes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ToolRecipes
{
};

</code></pre></div><h3 id="tridentimpalerenchant"><a href="#tridentimpalerenchant" class="header-anchor">#</a> <code>TridentImpalerEnchant</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TridentImpalerEnchant : Enchant
{
};

</code></pre></div><h3 id="tridentimpalerenchant-vtbl"><a href="#tridentimpalerenchant-vtbl" class="header-anchor">#</a> <code>TridentImpalerEnchant_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TridentImpalerEnchant_vtbl
{
  void (__fastcall *~Enchant)(Enchant *this);
  bool (__fastcall *isCompatibleWith)(Enchant *this, Enchant::Type);
  int (__fastcall *getMinCost)(Enchant *this, int);
  int (__fastcall *getMaxCost)(Enchant *this, int);
  int (__fastcall *getMinLevel)(Enchant *this);
  int (__fastcall *getMaxLevel)(Enchant *this);
  int (__fastcall *getDamageProtection)(Enchant *this, int, const ActorDamageSource *);
  float (__fastcall *getDamageBonus)(Enchant *this, int, const Actor *);
  void (__fastcall *doPostAttack)(Enchant *this, Actor *, Actor *, int);
  void (__fastcall *doPostHurt)(Enchant *this, ItemInstance *, Actor *, Actor *, int);
  bool (__fastcall *isMeleeDamageEnchant)(Enchant *this);
  bool (__fastcall *isProtectionEnchant)(Enchant *this);
  bool (__fastcall *isTreasureOnly)(Enchant *this);
  bool (__fastcall *isDiscoverable)(Enchant *this);
};

</code></pre></div><h3 id="tridentriptideenchant"><a href="#tridentriptideenchant" class="header-anchor">#</a> <code>TridentRiptideEnchant</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TridentRiptideEnchant : Enchant
{
};

</code></pre></div><h3 id="tridentriptideenchant-vtbl"><a href="#tridentriptideenchant-vtbl" class="header-anchor">#</a> <code>TridentRiptideEnchant_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TridentRiptideEnchant_vtbl
{
  void (__fastcall *~Enchant)(Enchant *this);
  bool (__fastcall *isCompatibleWith)(Enchant *this, Enchant::Type);
  int (__fastcall *getMinCost)(Enchant *this, int);
  int (__fastcall *getMaxCost)(Enchant *this, int);
  int (__fastcall *getMinLevel)(Enchant *this);
  int (__fastcall *getMaxLevel)(Enchant *this);
  int (__fastcall *getDamageProtection)(Enchant *this, int, const ActorDamageSource *);
  float (__fastcall *getDamageBonus)(Enchant *this, int, const Actor *);
  void (__fastcall *doPostAttack)(Enchant *this, Actor *, Actor *, int);
  void (__fastcall *doPostHurt)(Enchant *this, ItemInstance *, Actor *, Actor *, int);
  bool (__fastcall *isMeleeDamageEnchant)(Enchant *this);
  bool (__fastcall *isProtectionEnchant)(Enchant *this);
  bool (__fastcall *isTreasureOnly)(Enchant *this);
  bool (__fastcall *isDiscoverable)(Enchant *this);
};

</code></pre></div><h3 id="tridentloyaltyenchant"><a href="#tridentloyaltyenchant" class="header-anchor">#</a> <code>TridentLoyaltyEnchant</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TridentLoyaltyEnchant : Enchant
{
};

</code></pre></div><h3 id="tridentloyaltyenchant-vtbl"><a href="#tridentloyaltyenchant-vtbl" class="header-anchor">#</a> <code>TridentLoyaltyEnchant_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TridentLoyaltyEnchant_vtbl
{
  void (__fastcall *~Enchant)(Enchant *this);
  bool (__fastcall *isCompatibleWith)(Enchant *this, Enchant::Type);
  int (__fastcall *getMinCost)(Enchant *this, int);
  int (__fastcall *getMaxCost)(Enchant *this, int);
  int (__fastcall *getMinLevel)(Enchant *this);
  int (__fastcall *getMaxLevel)(Enchant *this);
  int (__fastcall *getDamageProtection)(Enchant *this, int, const ActorDamageSource *);
  float (__fastcall *getDamageBonus)(Enchant *this, int, const Actor *);
  void (__fastcall *doPostAttack)(Enchant *this, Actor *, Actor *, int);
  void (__fastcall *doPostHurt)(Enchant *this, ItemInstance *, Actor *, Actor *, int);
  bool (__fastcall *isMeleeDamageEnchant)(Enchant *this);
  bool (__fastcall *isProtectionEnchant)(Enchant *this);
  bool (__fastcall *isTreasureOnly)(Enchant *this);
  bool (__fastcall *isDiscoverable)(Enchant *this);
};

</code></pre></div><h3 id="tridentchannelingenchant"><a href="#tridentchannelingenchant" class="header-anchor">#</a> <code>TridentChannelingEnchant</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TridentChannelingEnchant : Enchant
{
};

</code></pre></div><h3 id="tridentchannelingenchant-vtbl"><a href="#tridentchannelingenchant-vtbl" class="header-anchor">#</a> <code>TridentChannelingEnchant_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TridentChannelingEnchant_vtbl
{
  void (__fastcall *~Enchant)(Enchant *this);
  bool (__fastcall *isCompatibleWith)(Enchant *this, Enchant::Type);
  int (__fastcall *getMinCost)(Enchant *this, int);
  int (__fastcall *getMaxCost)(Enchant *this, int);
  int (__fastcall *getMinLevel)(Enchant *this);
  int (__fastcall *getMaxLevel)(Enchant *this);
  int (__fastcall *getDamageProtection)(Enchant *this, int, const ActorDamageSource *);
  float (__fastcall *getDamageBonus)(Enchant *this, int, const Actor *);
  void (__fastcall *doPostAttack)(Enchant *this, Actor *, Actor *, int);
  void (__fastcall *doPostHurt)(Enchant *this, ItemInstance *, Actor *, Actor *, int);
  bool (__fastcall *isMeleeDamageEnchant)(Enchant *this);
  bool (__fastcall *isProtectionEnchant)(Enchant *this);
  bool (__fastcall *isTreasureOnly)(Enchant *this);
  bool (__fastcall *isDiscoverable)(Enchant *this);
};

</code></pre></div><h3 id="tntblock"><a href="#tntblock" class="header-anchor">#</a> <code>TntBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TntBlock : BlockLegacy
{
};

</code></pre></div><h3 id="tntblock-vtbl"><a href="#tntblock-vtbl" class="header-anchor">#</a> <code>TntBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TntBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="topsnowblockitem"><a href="#topsnowblockitem" class="header-anchor">#</a> <code>TopSnowBlockItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TopSnowBlockItem : BlockItem
{
};

</code></pre></div><h3 id="tagscomponent-idtype-biometagsetidtype"><a href="#tagscomponent-idtype-biometagsetidtype" class="header-anchor">#</a> <code>TagsComponent&lt;IDType&lt;BiomeTagSetIDType&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TagsComponent&lt;IDType&lt;BiomeTagSetIDType&gt; &gt; : IEntityComponent
{
  IDType&lt;BiomeTagSetIDType&gt; mTagSetID;
};

</code></pre></div><h3 id="transportercomponent"><a href="#transportercomponent" class="header-anchor">#</a> <code>TransporterComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) TransporterComponent : BaseCircuitComponent
{
  int mNextStrength;
};

</code></pre></div><h3 id="transportercomponent-vtbl"><a href="#transportercomponent-vtbl" class="header-anchor">#</a> <code>TransporterComponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TransporterComponent_vtbl
{
  void (__fastcall *~BaseCircuitComponent)(BaseCircuitComponent *this);
  int (__fastcall *getStrength)(BaseCircuitComponent *this);
  int (__fastcall *getDirection)(BaseCircuitComponent *this);
  void (__fastcall *setStrength)(BaseCircuitComponent *this, int);
  void (__fastcall *setDirection)(BaseCircuitComponent *this, unsigned __int8);
  bool (__fastcall *consumePowerAnyDirection)(BaseCircuitComponent *this);
  bool (__fastcall *canConsumerPower)(BaseCircuitComponent *this);
  bool (__fastcall *canStopPower)(BaseCircuitComponent *this);
  void (__fastcall *setStopPower)(BaseCircuitComponent *this, bool);
  unsigned __int64 (__fastcall *getBaseType)(BaseCircuitComponent *this);
  unsigned __int64 (__fastcall *getInstanceType)(BaseCircuitComponent *this);
  bool (__fastcall *removeSource)(BaseCircuitComponent *this, const BlockPos *, const BaseCircuitComponent *);
  bool (__fastcall *addSource)(BaseCircuitComponent *this, CircuitSceneGraph *, const CircuitTrackingInfo *, int *, bool *);
  bool (__fastcall *allowConnection)(BaseCircuitComponent *this, CircuitSceneGraph *, const CircuitTrackingInfo *, bool *);
  void (__fastcall *checkLock)(BaseCircuitComponent *this, CircuitSystem *, const BlockPos *);
  bool (__fastcall *evaluate)(BaseCircuitComponent *this, CircuitSystem *, const BlockPos *);
  void (__fastcall *cacheValues)(BaseCircuitComponent *this, CircuitSystem *, const BlockPos *);
  void (__fastcall *updateDependencies)(BaseCircuitComponent *this, CircuitSceneGraph *, const BlockPos *);
  bool (__fastcall *allowIndirect)(BaseCircuitComponent *this);
  bool (__fastcall *isHalfPulse)(BaseCircuitComponent *this);
  bool (__fastcall *hasSource)(BaseCircuitComponent *this, BaseCircuitComponent *);
  bool (__fastcall *hasChildrenSource)(BaseCircuitComponent *this);
  bool (__fastcall *isSecondaryPowered)(BaseCircuitComponent *this);
};

</code></pre></div><h3 id="terrainburstreactioncomponent"><a href="#terrainburstreactioncomponent" class="header-anchor">#</a> <code>TerrainBurstReactionComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) TerrainBurstReactionComponent : LabTableReactionComponent
{
  int mData;
  Vec3 mDims;
  Vec3 mDirRange;
  int mCount;
  bool mDirOneWay;
};

</code></pre></div><h3 id="terrainburstreactioncomponent-vtbl"><a href="#terrainburstreactioncomponent-vtbl" class="header-anchor">#</a> <code>TerrainBurstReactionComponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TerrainBurstReactionComponent_vtbl
{
  void (__fastcall *~LabTableReactionComponent)(LabTableReactionComponent *this);
  void (__fastcall *_onStart)(LabTableReactionComponent *this, LabTableReaction *, BlockSource *);
  void (__fastcall *_onTick)(LabTableReactionComponent *this, LabTableReaction *, BlockSource *);
  void (__fastcall *_onEnd)(LabTableReactionComponent *this, LabTableReaction *, BlockSource *);
};

</code></pre></div><h3 id="transformcomponentdescription"><a href="#transformcomponentdescription" class="header-anchor">#</a> <code>TransformComponentDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TransformComponentDescription : BlockComponentDescription
{
  TransformConditions mConditions;
  std::string mResult;
};

</code></pre></div><h3 id="transformcomponentdescription-vtbl"><a href="#transformcomponentdescription-vtbl" class="header-anchor">#</a> <code>TransformComponentDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TransformComponentDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="tallgrass"><a href="#tallgrass" class="header-anchor">#</a> <code>TallGrass</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TallGrass : BushBlock
{
};

</code></pre></div><h3 id="tallgrass-vtbl"><a href="#tallgrass-vtbl" class="header-anchor">#</a> <code>TallGrass_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TallGrass_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *checkAlive)(BushBlock *this, BlockSource *, const BlockPos *);
};

</code></pre></div><h3 id="trapdoorblock"><a href="#trapdoorblock" class="header-anchor">#</a> <code>TrapDoorBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TrapDoorBlock : BlockLegacy
{
};

</code></pre></div><h3 id="trapdoorblock-vtbl"><a href="#trapdoorblock-vtbl" class="header-anchor">#</a> <code>TrapDoorBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TrapDoorBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="thinfenceblock"><a href="#thinfenceblock" class="header-anchor">#</a> <code>ThinFenceBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ThinFenceBlock : BlockLegacy
{
  const bool mDropsResources;
  const bool mCanBeUsedInCommands;
};

</code></pre></div><h3 id="thinfenceblock-vtbl"><a href="#thinfenceblock-vtbl" class="header-anchor">#</a> <code>ThinFenceBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ThinFenceBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="tripwirehookblock"><a href="#tripwirehookblock" class="header-anchor">#</a> <code>TripWireHookBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TripWireHookBlock : BlockLegacy
{
};

</code></pre></div><h3 id="tripwirehookblock-vtbl"><a href="#tripwirehookblock-vtbl" class="header-anchor">#</a> <code>TripWireHookBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TripWireHookBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="turtleeggblock"><a href="#turtleeggblock" class="header-anchor">#</a> <code>TurtleEggBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) TurtleEggBlock : BlockLegacy
{
  float mShapeOffset;
};

</code></pre></div><h3 id="turtleeggblock-vtbl"><a href="#turtleeggblock-vtbl" class="header-anchor">#</a> <code>TurtleEggBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TurtleEggBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="targetblock"><a href="#targetblock" class="header-anchor">#</a> <code>TargetBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TargetBlock : BlockLegacy
{
};

</code></pre></div><h3 id="targetblock-vtbl"><a href="#targetblock-vtbl" class="header-anchor">#</a> <code>TargetBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TargetBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="turtleeggblock-destroyegg-l19-lambda-269ba72276ec6875a2f570f4af2d700d"><a href="#turtleeggblock-destroyegg-l19-lambda-269ba72276ec6875a2f570f4af2d700d" class="header-anchor">#</a> <code>TurtleEggBlock::_destroyEgg::__l19::&lt;lambda_269ba72276ec6875a2f570f4af2d700d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TurtleEggBlock::_destroyEgg::__l19::&lt;lambda_269ba72276ec6875a2f570f4af2d700d&gt;
{
  Actor *entity;
  const Block *block;
  const BlockPos *pos;
  BlockSource *region;
};

</code></pre></div><h3 id="tripwireblock-entityinside-l11-lambda-a7ce562379b7c702df77d878f0eca511"><a href="#tripwireblock-entityinside-l11-lambda-a7ce562379b7c702df77d878f0eca511" class="header-anchor">#</a> <code>TripWireBlock::entityInside::__l11::&lt;lambda_a7ce562379b7c702df77d878f0eca511&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TripWireBlock::entityInside::__l11::&lt;lambda_a7ce562379b7c702df77d878f0eca511&gt;
{
  Actor *entity;
  const TripWireBlock *const __this;
  const BlockPos *pos;
  BlockSource *region;
};

</code></pre></div><h3 id="treehelper-treeparams"><a href="#treehelper-treeparams" class="header-anchor">#</a> <code>TreeHelper::TreeParams</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj TreeHelper::TreeParams
{
  int mNumBaseClusters;
  int mClusterRadius;
  std::vector&lt;BlockDescriptor&gt; mValidBaseBlocks;
  std::vector&lt;BlockDescriptor&gt; mBaseMayReplace;
  std::vector&lt;BlockDescriptor&gt; mMayGrowOn;
  std::vector&lt;BlockDescriptor&gt; mMayReplace;
  std::vector&lt;BlockDescriptor&gt; mMayGrowThrough;
};

</code></pre></div><h3 id="treehelper-attachabledecoration"><a href="#treehelper-attachabledecoration" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration
{
  ChanceInformation mDecorationChance;
  BlockDescriptor mDecorationBlock;
  int mNumSteps;
  TreeHelper::AttachableDecoration::GrowthDirection mDirection;
};

</code></pre></div><h3 id="transactionalworldblocktarget"><a href="#transactionalworldblocktarget" class="header-anchor">#</a> <code>TransactionalWorldBlockTarget</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TransactionalWorldBlockTarget : IBlockWorldGenAPI
{
  WorldChangeTransaction mTransaction;
};

</code></pre></div><h3 id="transactionalworldblocktarget-vtbl"><a href="#transactionalworldblocktarget-vtbl" class="header-anchor">#</a> <code>TransactionalWorldBlockTarget_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TransactionalWorldBlockTarget_vtbl
{
  void (__fastcall *~IBlockWorldGenAPI)(IBlockWorldGenAPI *this);
  const Block *(__fastcall *getBlock)(IBlockWorldGenAPI *this, const BlockPos *);
  bool (__fastcall *hasBiomeTag)(IBlockWorldGenAPI *this, unsigned __int64, const BlockPos *);
  bool (__fastcall *setBlock)(IBlockWorldGenAPI *this, const BlockPos *, const Block *, int);
  bool (__fastcall *apply)(IBlockWorldGenAPI *this);
  bool (__fastcall *placeStructure)(IBlockWorldGenAPI *this, const BlockPos *, StructureTemplate *, StructureSettings *);
  bool (__fastcall *mayPlace)(IBlockWorldGenAPI *this, const BlockPos *, const Block *);
  bool (__fastcall *canSurvive)(IBlockWorldGenAPI *this, const BlockPos *, const Block *);
  __int16 (__fastcall *getMaxHeight)(IBlockWorldGenAPI *this);
  __int16 (__fastcall *getMinHeight)(IBlockWorldGenAPI *this);
  bool (__fastcall *shimPlaceForOldFeatures)(IBlockWorldGenAPI *this, const Feature *, const BlockPos *, Random *);
  __int16 (__fastcall *getHeightmap)(IBlockWorldGenAPI *this, int, int);
  bool (__fastcall *isLegacyLevel)(IBlockWorldGenAPI *this);
};

</code></pre></div><h3 id="templatestructurepiece"><a href="#templatestructurepiece" class="header-anchor">#</a> <code>TemplateStructurePiece</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) TemplateStructurePiece : StructurePiece
{
  LegacyStructureTemplate *mTemplate;
  LegacyStructureSettings mSettings;
  BlockPos mTemplatePosition;
};

</code></pre></div><h3 id="templatestructurepiece-vtbl"><a href="#templatestructurepiece-vtbl" class="header-anchor">#</a> <code>TemplateStructurePiece_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TemplateStructurePiece_vtbl
{
  void (__fastcall *~StructurePiece)(StructurePiece *this);
  void (__fastcall *moveBoundingBox)(StructurePiece *this, int, int, int);
  PoolElementStructurePiece *(__fastcall *asPoolElement)(StructurePiece *this);
  StructurePieceType (__fastcall *getType)(StructurePiece *this);
  void (__fastcall *addChildren)(StructurePiece *this, StructurePiece *, std::vector&lt;std::unique_ptr&lt;StructurePiece&gt;&gt; *, Random *);
  bool (__fastcall *postProcess)(StructurePiece *this, BlockSource *, Random *, const BoundingBox *);
  void (__fastcall *postProcessMobsAt)(StructurePiece *this, BlockSource *, Random *, const BoundingBox *);
  int (__fastcall *getWorldX)(StructurePiece *this, int, int);
  int (__fastcall *getWorldZ)(StructurePiece *this, int, int);
  void (__fastcall *placeBlock)(StructurePiece *this, BlockSource *, const Block *, int, int, int, const BoundingBox *);
  void (__fastcall *generateBox)(StructurePiece *this, BlockSource *, const BoundingBox *, int, int, int, int, int, int, const Block *, const Block *, bool);
  void (__fastcall *addHardcodedSpawnAreas)(StructurePiece *this, LevelChunk *);
  void (__fastcall *_handleDataMarker)(TemplateStructurePiece *this, const std::string *, const BlockPos *, BlockSource *, Random *, const BoundingBox *);
};

</code></pre></div><h3 id="tickingareaview-tick-l24-lambda-e93ece0c982b1407c5f6ea0f18f0084f"><a href="#tickingareaview-tick-l24-lambda-e93ece0c982b1407c5f6ea0f18f0084f" class="header-anchor">#</a> <code>TickingAreaView::tick::__l24::&lt;lambda_e93ece0c982b1407c5f6ea0f18f0084f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TickingAreaView::tick::__l24::&lt;lambda_e93ece0c982b1407c5f6ea0f18f0084f&gt;
{
  const Pos *minBounds;
  const bool *isCircleArea;
  const GridArea&lt;std::shared_ptr&lt;LevelChunk&gt; &gt; *view;
  TickingAreaView *const __this;
  const Tick *currentTick;
  BlockSource *region;
  Level *level;
};

</code></pre></div><h3 id="tickingarea-ctor-l2-lambda-ecbdd7020b8c77fb7806c64c03108081"><a href="#tickingarea-ctor-l2-lambda-ecbdd7020b8c77fb7806c64c03108081" class="header-anchor">#</a> <code>TickingArea::{ctor}::__l2::&lt;lambda_ecbdd7020b8c77fb7806c64c03108081&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TickingArea::{ctor}::__l2::&lt;lambda_ecbdd7020b8c77fb7806c64c03108081&gt;
{
  Dimension *dimension;
};

</code></pre></div><h3 id="tagxhr-cookie"><a href="#tagxhr-cookie" class="header-anchor">#</a> <code>tagXHR_COOKIE</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(8)) tagXHR_COOKIE
{
  wchar_t *pwszUrl;
  wchar_t *pwszName;
  wchar_t *pwszValue;
  wchar_t *pwszP3PPolicy;
  _FILETIME ftExpires;
  unsigned int dwFlags;
};

</code></pre></div><h3 id="taghelper"><a href="#taghelper" class="header-anchor">#</a> <code>TagHelper</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TagHelper
{
};

</code></pre></div><h3 id="tagrpc-call-attributes-v3-w"><a href="#tagrpc-call-attributes-v3-w" class="header-anchor">#</a> <code>tagRPC_CALL_ATTRIBUTES_V3_W</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tagRPC_CALL_ATTRIBUTES_V3_W
{
  unsigned int Version;
  unsigned int Flags;
  unsigned int ServerPrincipalNameBufferLength;
  unsigned __int16 *ServerPrincipalName;
  unsigned int ClientPrincipalNameBufferLength;
  unsigned __int16 *ClientPrincipalName;
  unsigned int AuthenticationLevel;
  unsigned int AuthenticationService;
  int NullSession;
  int KernelModeCaller;
  unsigned int ProtocolSequence;
  tagRpcCallClientLocality IsClientLocal;
  void *ClientPID;
  unsigned int CallStatus;
  tagRpcCallType CallType;
  _RPC_CALL_LOCAL_ADDRESS_V1 *CallLocalAddress;
  unsigned __int16 OpNum;
  _GUID InterfaceUuid;
  unsigned int ClientIdentifierBufferLength;
  unsigned __int8 *ClientIdentifier;
};

</code></pre></div><h3 id="tagserverinformation"><a href="#tagserverinformation" class="header-anchor">#</a> <code>tagServerInformation</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tagServerInformation
{
  unsigned int dwServerPid;
  unsigned int dwServerTid;
  unsigned __int64 ui64ServerAddress;
};

</code></pre></div><h3 id="tagrpc-call-attributes-v3-a"><a href="#tagrpc-call-attributes-v3-a" class="header-anchor">#</a> <code>tagRPC_CALL_ATTRIBUTES_V3_A</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tagRPC_CALL_ATTRIBUTES_V3_A
{
  unsigned int Version;
  unsigned int Flags;
  unsigned int ServerPrincipalNameBufferLength;
  unsigned __int8 *ServerPrincipalName;
  unsigned int ClientPrincipalNameBufferLength;
  unsigned __int8 *ClientPrincipalName;
  unsigned int AuthenticationLevel;
  unsigned int AuthenticationService;
  int NullSession;
  int KernelModeCaller;
  unsigned int ProtocolSequence;
  unsigned int IsClientLocal;
  void *ClientPID;
  unsigned int CallStatus;
  tagRpcCallType CallType;
  _RPC_CALL_LOCAL_ADDRESS_V1 *CallLocalAddress;
  unsigned __int16 OpNum;
  _GUID InterfaceUuid;
  unsigned int ClientIdentifierBufferLength;
  unsigned __int8 *ClientIdentifier;
};

</code></pre></div><h3 id="tpatchupdateinfo"><a href="#tpatchupdateinfo" class="header-anchor">#</a> <code>tPatchUpdateInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) tPatchUpdateInfo
{
  std::string patchVer;
  std::string patchUrl;
  std::string patchMD5;
  int patchSize;
};

</code></pre></div><h3 id="transferhandler-notifypythonupdatestate-l2-lambda-afd70fad5bd69b087231a1a613a8b71d"><a href="#transferhandler-notifypythonupdatestate-l2-lambda-afd70fad5bd69b087231a1a613a8b71d" class="header-anchor">#</a> <code>TransferHandler::notifyPythonUpdateState::__l2::&lt;lambda_afd70fad5bd69b087231a1a613a8b71d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TransferHandler::notifyPythonUpdateState::__l2::&lt;lambda_afd70fad5bd69b087231a1a613a8b71d&gt;
{
  TransferHandler *const __this;
};

</code></pre></div><h3 id="trace-t"><a href="#trace-t" class="header-anchor">#</a> <code>trace_t</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct trace_t
{
  unsigned __int64 size;
  traceback_t *traceback;
};

</code></pre></div><h3 id="tiercomponentdescription-buildschema-l2-lambda-bcdfe114008b2394d9ad807c812ceba2"><a href="#tiercomponentdescription-buildschema-l2-lambda-bcdfe114008b2394d9ad807c812ceba2" class="header-anchor">#</a> <code>TierComponentDescription::buildSchema::__l2::&lt;lambda_bcdfe114008b2394d9ad807c812ceba2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TierComponentDescription::buildSchema::__l2::&lt;lambda_bcdfe114008b2394d9ad807c812ceba2&gt;
{
};

</code></pre></div><h3 id="tiercomponentdescription-buildschema-l2-lambda-1fb0a0a39752f2be29816afd76f0350d"><a href="#tiercomponentdescription-buildschema-l2-lambda-1fb0a0a39752f2be29816afd76f0350d" class="header-anchor">#</a> <code>TierComponentDescription::buildSchema::__l2::&lt;lambda_1fb0a0a39752f2be29816afd76f0350d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TierComponentDescription::buildSchema::__l2::&lt;lambda_1fb0a0a39752f2be29816afd76f0350d&gt;
{
};

</code></pre></div><h3 id="tiercomponentdescription-buildschema-l2-lambda-10780ac71d4569ba6b03abaf9d720665"><a href="#tiercomponentdescription-buildschema-l2-lambda-10780ac71d4569ba6b03abaf9d720665" class="header-anchor">#</a> <code>TierComponentDescription::buildSchema::__l2::&lt;lambda_10780ac71d4569ba6b03abaf9d720665&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TierComponentDescription::buildSchema::__l2::&lt;lambda_10780ac71d4569ba6b03abaf9d720665&gt;
{
};

</code></pre></div><h3 id="tiercomponentdescription-buildschema-l2-lambda-ee1ce6d16b39680e7effbc4cb509458e"><a href="#tiercomponentdescription-buildschema-l2-lambda-ee1ce6d16b39680e7effbc4cb509458e" class="header-anchor">#</a> <code>TierComponentDescription::buildSchema::__l2::&lt;lambda_ee1ce6d16b39680e7effbc4cb509458e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TierComponentDescription::buildSchema::__l2::&lt;lambda_ee1ce6d16b39680e7effbc4cb509458e&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="transformcomponentdescription-buildschema-l2-lambda-5568880fee4ed2a7481f54241155db51"><a href="#transformcomponentdescription-buildschema-l2-lambda-5568880fee4ed2a7481f54241155db51" class="header-anchor">#</a> <code>TransformComponentDescription::buildSchema::__l2::&lt;lambda_5568880fee4ed2a7481f54241155db51&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TransformComponentDescription::buildSchema::__l2::&lt;lambda_5568880fee4ed2a7481f54241155db51&gt;
{
};

</code></pre></div><h3 id="transformcomponentdescription-buildschema-l2-lambda-05bff39358757891f8a72a27d6c6b4b5"><a href="#transformcomponentdescription-buildschema-l2-lambda-05bff39358757891f8a72a27d6c6b4b5" class="header-anchor">#</a> <code>TransformComponentDescription::buildSchema::__l2::&lt;lambda_05bff39358757891f8a72a27d6c6b4b5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TransformComponentDescription::buildSchema::__l2::&lt;lambda_05bff39358757891f8a72a27d6c6b4b5&gt;
{
};

</code></pre></div><h3 id="transformcomponentdescription-buildschema-l2-lambda-ec76577b05acff01e13b0423b61a640f"><a href="#transformcomponentdescription-buildschema-l2-lambda-ec76577b05acff01e13b0423b61a640f" class="header-anchor">#</a> <code>TransformComponentDescription::buildSchema::__l2::&lt;lambda_ec76577b05acff01e13b0423b61a640f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TransformComponentDescription::buildSchema::__l2::&lt;lambda_ec76577b05acff01e13b0423b61a640f&gt;
{
  const BlockComponentFactory *factory;
};

</code></pre></div><h3 id="touchcamerajoystickcontrol"><a href="#touchcamerajoystickcontrol" class="header-anchor">#</a> <code>TouchCameraJoystickControl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) TouchCameraJoystickControl : TouchControl
{
  std::function&lt;bool __cdecl(void)&gt; mCondition;
  unsigned int mButtonId;
  unsigned int mJumpButtonId;
  ButtonState mButtonState;
  mce::Color mPressedColor;
  mce::Color mReleasedColor;
  int mUx;
  int mUv;
  int mUvWidth;
  int mUvHeight;
  int mUx1;
  int mUv1;
  int mUvWidth1;
  int mUvHeight1;
  bool mPassThrough;
  bool mPromiscuous;
  int mTouchStateRequirement;
  int mTicksSinceFirstPress;
  bool mWaitingForSecondPress;
  std::string mName;
  int mTouchId;
  float mSensitivityX;
  float mSensitivityY;
  float mRenderPosX;
  float mRenderPosY;
  float mBeginPosX;
  float mBeginPosY;
  float mLastPosX;
  float mLastPosY;
  int mJumping;
  float mGlyphScale;
};

</code></pre></div><h3 id="touchcamerajoystickcontrol-vtbl"><a href="#touchcamerajoystickcontrol-vtbl" class="header-anchor">#</a> <code>TouchCameraJoystickControl_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TouchCameraJoystickControl_vtbl
{
  void (__fastcall *~TouchControl)(TouchControl *this);
  void (__fastcall *render)(TouchControl *this, InputRenderContext *);
  void (__fastcall *tick)(TouchControl *this, InputEventQueue *, TouchPointResults *, int);
  void (__fastcall *release)(TouchControl *this, InputEventQueue *);
};

</code></pre></div><h3 id="touchglyphbuttoncontrol"><a href="#touchglyphbuttoncontrol" class="header-anchor">#</a> <code>TouchGlyphButtonControl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) TouchGlyphButtonControl : TouchControl
{
  std::function&lt;bool __cdecl(void)&gt; mCondition;
  unsigned int mButtonId;
  ButtonState mButtonState;
  mce::Color mPressedColor;
  mce::Color mReleasedColor;
  int mUx;
  int mUv;
  int mUvWidth;
  int mUvHeight;
  bool mPassThrough;
  bool mPromiscuous;
  int mTouchStateRequirement;
  int mTicksSinceFirstPress;
  bool mWaitingForSecondPress;
  std::string mName;
  float mGlyphScale;
};

</code></pre></div><h3 id="touchglyphbuttoncontrol-vtbl"><a href="#touchglyphbuttoncontrol-vtbl" class="header-anchor">#</a> <code>TouchGlyphButtonControl_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TouchGlyphButtonControl_vtbl
{
  void (__fastcall *~TouchControl)(TouchControl *this);
  void (__fastcall *render)(TouchControl *this, InputRenderContext *);
  void (__fastcall *tick)(TouchControl *this, InputEventQueue *, TouchPointResults *, int);
  void (__fastcall *release)(TouchControl *this, InputEventQueue *);
};

</code></pre></div><h3 id="touchglyphradiobuttoncontrol"><a href="#touchglyphradiobuttoncontrol" class="header-anchor">#</a> <code>TouchGlyphRadioButtonControl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) TouchGlyphRadioButtonControl : TouchControl
{
  std::function&lt;bool __cdecl(void)&gt; mCondition;
  std::function&lt;bool __cdecl(void)&gt; mStateCondition;
  unsigned int mButtonId;
  ButtonState mButtonState;
  mce::Color mPressedColor;
  mce::Color mReleasedColor;
  int mUx;
  int mUv;
  int mUvWidth;
  int mUvHeight;
  bool mPassThrough;
  bool mPromiscuous;
  int mTouchStateRequirement;
  int mTicksSinceFirstPress;
  bool mWaitingForSecondPress;
  std::string mName;
  float mGlyphScale;
};

</code></pre></div><h3 id="touchglyphradiobuttoncontrol-vtbl"><a href="#touchglyphradiobuttoncontrol-vtbl" class="header-anchor">#</a> <code>TouchGlyphRadioButtonControl_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TouchGlyphRadioButtonControl_vtbl
{
  void (__fastcall *~TouchControl)(TouchControl *this);
  void (__fastcall *render)(TouchControl *this, InputRenderContext *);
  void (__fastcall *tick)(TouchControl *this, InputEventQueue *, TouchPointResults *, int);
  void (__fastcall *release)(TouchControl *this, InputEventQueue *);
};

</code></pre></div><h3 id="touchjoystickcontrol"><a href="#touchjoystickcontrol" class="header-anchor">#</a> <code>TouchJoystickControl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) TouchJoystickControl : TouchControl
{
  std::function&lt;bool __cdecl(void)&gt; mCondition;
  unsigned int mButtonUpId;
  unsigned int mButtonDownId;
  unsigned int mButtonLeftId;
  unsigned int mButtonRightId;
  bool mButtonStateUp;
  bool mButtonStateDown;
  bool mButtonStateLeft;
  bool mButtonStateRight;
  ButtonState mButtonState;
  mce::Color mPressedColor;
  mce::Color mReleasedColor;
  int mUx;
  int mUv;
  int mUvWidth;
  int mUvHeight;
  int mUx1;
  int mUv1;
  int mUvWidth1;
  int mUvHeight1;
  bool mPassThrough;
  bool mPromiscuous;
  int mTouchStateRequirement;
  int mTicksSinceFirstPress;
  bool mWaitingForSecondPress;
  std::string mName;
  int mTouchId;
  bool mCaptured;
  float mGlyphScale;
};

</code></pre></div><h3 id="touchjoystickcontrol-vtbl"><a href="#touchjoystickcontrol-vtbl" class="header-anchor">#</a> <code>TouchJoystickControl_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TouchJoystickControl_vtbl
{
  void (__fastcall *~TouchControl)(TouchControl *this);
  void (__fastcall *render)(TouchControl *this, InputRenderContext *);
  void (__fastcall *tick)(TouchControl *this, InputEventQueue *, TouchPointResults *, int);
  void (__fastcall *release)(TouchControl *this, InputEventQueue *);
};

</code></pre></div><h3 id="touchglyphbuttonexcontrol"><a href="#touchglyphbuttonexcontrol" class="header-anchor">#</a> <code>TouchGlyphButtonEXControl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) TouchGlyphButtonEXControl : TouchControl
{
  std::function&lt;bool __cdecl(void)&gt; mCondition;
  unsigned int mButtonId;
  unsigned int mButtonId2;
  ButtonState mButtonState;
  mce::Color mPressedColor;
  mce::Color mReleasedColor;
  int mUx;
  int mUv;
  int mUvWidth;
  int mUvHeight;
  bool mPassThrough;
  bool mPromiscuous;
  int mTouchStateRequirement;
  int mTicksSinceFirstPress;
  bool mWaitingHold;
  bool mHolding;
  std::string mName;
  std::string mName2;
  float mGlyphScale;
};

</code></pre></div><h3 id="touchglyphbuttonexcontrol-vtbl"><a href="#touchglyphbuttonexcontrol-vtbl" class="header-anchor">#</a> <code>TouchGlyphButtonEXControl_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TouchGlyphButtonEXControl_vtbl
{
  void (__fastcall *~TouchControl)(TouchControl *this);
  void (__fastcall *render)(TouchControl *this, InputRenderContext *);
  void (__fastcall *tick)(TouchControl *this, InputEventQueue *, TouchPointResults *, int);
  void (__fastcall *release)(TouchControl *this, InputEventQueue *);
};

</code></pre></div><h3 id="theendlighttextureimagebuilder"><a href="#theendlighttextureimagebuilder" class="header-anchor">#</a> <code>TheEndLightTextureImageBuilder</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TheEndLightTextureImageBuilder : BaseLightTextureImageBuilder
{
};

</code></pre></div><h3 id="theendlighttextureimagebuilder-vtbl"><a href="#theendlighttextureimagebuilder-vtbl" class="header-anchor">#</a> <code>TheEndLightTextureImageBuilder_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TheEndLightTextureImageBuilder_vtbl
{
  void (__fastcall *~BaseLightTextureImageBuilder)(BaseLightTextureImageBuilder *this);
  void (__fastcall *init)(BaseLightTextureImageBuilder *this, Dimension *);
  bool (__fastcall *buildImage)(BaseLightTextureImageBuilder *this, const BaseLightData *, mce::Image *, unsigned int, float, float, bool);
  void (__fastcall *getModifiedBlockBrightnessColor)(BaseLightTextureImageBuilder *this, const BlockPos *, const Block *, const Brightness *, BrightnessPair *);
  std::unique_ptr&lt;BaseLightData&gt; *(__fastcall *createBaseLightTextureData)(BaseLightTextureImageBuilder *this, std::unique_ptr&lt;BaseLightData&gt; *result, IClientInstance *, const BaseLightData *);
};

</code></pre></div><h3 id="theenddimension"><a href="#theenddimension" class="header-anchor">#</a> <code>TheEndDimension</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) TheEndDimension : Dimension
{
  std::unique_ptr&lt;EndDragonFight&gt; mDragonFight;
  bool mHasInitDragon;
};

</code></pre></div><h3 id="tradeablesystem"><a href="#tradeablesystem" class="header-anchor">#</a> <code>TradeableSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TradeableSystem : ITickingSystem
{
};

</code></pre></div><h3 id="tradeablesystem-vtbl"><a href="#tradeablesystem-vtbl" class="header-anchor">#</a> <code>TradeableSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TradeableSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="trailsystem"><a href="#trailsystem" class="header-anchor">#</a> <code>TrailSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TrailSystem : ITickingSystem
{
};

</code></pre></div><h3 id="trailsystem-vtbl"><a href="#trailsystem-vtbl" class="header-anchor">#</a> <code>TrailSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TrailSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="transformationsystem"><a href="#transformationsystem" class="header-anchor">#</a> <code>TransformationSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TransformationSystem : ITickingSystem
{
};

</code></pre></div><h3 id="transformationsystem-vtbl"><a href="#transformationsystem-vtbl" class="header-anchor">#</a> <code>TransformationSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TransformationSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="tempeptr-villager"><a href="#tempeptr-villager" class="header-anchor">#</a> <code>TempEPtr&lt;Villager&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) TempEPtr&lt;Villager&gt; : _TickPtr
{
  Villager *tmp;
  ActorUniqueID mEntityId;
  Level *mLevel;
  bool mHasLocked;
};

</code></pre></div><h3 id="tempeptr-villager-vtbl"><a href="#tempeptr-villager-vtbl" class="header-anchor">#</a> <code>TempEPtr&lt;Villager&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TempEPtr&lt;Villager&gt;_vtbl
{
  void (__fastcall *invalidate)(_TickPtr *this);
  void (__fastcall *~_TickPtr)(_TickPtr *this);
};

</code></pre></div><h3 id="tempeptr-irongolem"><a href="#tempeptr-irongolem" class="header-anchor">#</a> <code>TempEPtr&lt;IronGolem&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) TempEPtr&lt;IronGolem&gt; : _TickPtr
{
  IronGolem *tmp;
  ActorUniqueID mEntityId;
  Level *mLevel;
  bool mHasLocked;
};

</code></pre></div><h3 id="tempeptr-irongolem-vtbl"><a href="#tempeptr-irongolem-vtbl" class="header-anchor">#</a> <code>TempEPtr&lt;IronGolem&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TempEPtr&lt;IronGolem&gt;_vtbl
{
  void (__fastcall *invalidate)(_TickPtr *this);
  void (__fastcall *~_TickPtr)(_TickPtr *this);
};

</code></pre></div><h3 id="takeflowergoal"><a href="#takeflowergoal" class="header-anchor">#</a> <code>TakeFlowerGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TakeFlowerGoal : Goal
{
  TempEPtr&lt;IronGolem&gt; mGolem;
  int mPickupTick;
  bool mTakeFlower;
  Mob *mMob;
};

</code></pre></div><h3 id="takeflowergoal-vtbl"><a href="#takeflowergoal-vtbl" class="header-anchor">#</a> <code>TakeFlowerGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TakeFlowerGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="targetwhenpushedgoal"><a href="#targetwhenpushedgoal" class="header-anchor">#</a> <code>TargetWhenPushedGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TargetWhenPushedGoal : Goal
{
  Mob *mSelf;
  float mPercentChance;
  const std::vector&lt;MobDescriptor&gt; mTargetTypes;
};

</code></pre></div><h3 id="targetwhenpushedgoal-vtbl"><a href="#targetwhenpushedgoal-vtbl" class="header-anchor">#</a> <code>TargetWhenPushedGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TargetWhenPushedGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="temptgoal"><a href="#temptgoal" class="header-anchor">#</a> <code>TemptGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TemptGoal : Goal
{
  Mob *mMob;
  float mSpeed;
  TempEPtr&lt;Player&gt; mPlayer;
  Vec3 mOldPlayerPosition;
  Vec2 mOldPlayerRotation;
  bool mCanGetScared;
  int mCalmDown;
  bool mIsRunning;
  bool mOldAvoidWater;
  bool mCanTemptWhileRidden;
  int mPathfinderWaitTicks;
  float mTemptDistance;
  std::vector&lt;ItemDescriptor&gt; mItems;
  bool mCanTemptVertically;
  LevelSoundEvent mSoundEvent;
  FloatRange mSoundIntervalRange;
  Tick mNextSoundEventTick;
};

</code></pre></div><h3 id="temptgoal-vtbl"><a href="#temptgoal-vtbl" class="header-anchor">#</a> <code>TemptGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TemptGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="tradeinterestgoal"><a href="#tradeinterestgoal" class="header-anchor">#</a> <code>TradeInterestGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TradeInterestGoal : Goal
{
  Mob *mMob;
  TempEPtr&lt;Player&gt; mPlayer;
  bool mIsRunning;
  bool mIsOnlyTargetItemFound;
  float mInterestDistance;
  unsigned __int64 mCurrentIndex;
  ItemStack mCarriedItem;
  ItemStack mPlayerItem;
  Tick mCarriedItemSwitchTimer;
  Tick mRemoveItemTimer;
  Tick mInterestTimer;
  Tick mInterestCooldown;
  const Tick mInterestTimeMax;
  const Tick mInterestTimeMaxHalf;
  const Tick mRemoveTimeMax;
  const Tick mCarriedSwitchMax;
  const Tick mInterestCooldownMax;
};

</code></pre></div><h3 id="tradeinterestgoal-vtbl"><a href="#tradeinterestgoal-vtbl" class="header-anchor">#</a> <code>TradeInterestGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TradeInterestGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="tradewithplayergoal"><a href="#tradewithplayergoal" class="header-anchor">#</a> <code>TradeWithPlayerGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TradeWithPlayerGoal : Goal
{
  Mob *mMob;
};

</code></pre></div><h3 id="tradewithplayergoal-vtbl"><a href="#tradewithplayergoal-vtbl" class="header-anchor">#</a> <code>TradeWithPlayerGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TradeWithPlayerGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="theendgenerator-threaddata"><a href="#theendgenerator-threaddata" class="header-anchor">#</a> <code>TheEndGenerator::ThreadData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TheEndGenerator::ThreadData
{
  std::array&lt;Block const *,32768&gt; blockBuffer;
};

</code></pre></div><h3 id="theendgenerator"><a href="#theendgenerator" class="header-anchor">#</a> <code>TheEndGenerator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TheEndGenerator : ChunkSource, WorldGenerator
{
  std::unique_ptr&lt;PerlinNoise&gt; mLPerlinNoise1;
  std::unique_ptr&lt;PerlinNoise&gt; mLPerlinNoise2;
  std::unique_ptr&lt;PerlinNoise&gt; mPerlinNoise1;
  std::unique_ptr&lt;SimplexNoise&gt; mIslandNoise;
  std::unique_ptr&lt;PerlinSimplexNoise&gt; mMaterialAdjNoise;
  Bedrock::Threading::InstancedThreadLocal&lt;TheEndGenerator::ThreadData,std::allocator&lt;TheEndGenerator::ThreadData&gt; &gt; generatorHelpersPool;
  EndCityFeature mEndCityFeature;
  std::shared_mutex mTryGetHeightMutex;
  std::unordered_map&lt;BlockPos,int&gt; mHeightCache;
};

</code></pre></div><h3 id="theendgenerator-vtbl"><a href="#theendgenerator-vtbl" class="header-anchor">#</a> <code>TheEndGenerator_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TheEndGenerator_vtbl
{
  void (__fastcall *~ChunkSource)(ChunkSource *this);
  void (__fastcall *shutdown)(ChunkSource *this);
  bool (__fastcall *isShutdownDone)(ChunkSource *this);
  std::shared_ptr&lt;LevelChunk&gt; *(__fastcall *getExistingChunk)(ChunkSource *this, std::shared_ptr&lt;LevelChunk&gt; *result, const ChunkPos *);
  std::shared_ptr&lt;LevelChunk&gt; *(__fastcall *getRandomChunk)(ChunkSource *this, std::shared_ptr&lt;LevelChunk&gt; *result, Random *);
  std::shared_ptr&lt;LevelChunk&gt; *(__fastcall *createNewChunk)(ChunkSource *this, std::shared_ptr&lt;LevelChunk&gt; *result, const ChunkPos *, ChunkSource::LoadMode);
  std::shared_ptr&lt;LevelChunk&gt; *(__fastcall *getOrLoadChunk)(ChunkSource *this, std::shared_ptr&lt;LevelChunk&gt; *result, const ChunkPos *, ChunkSource::LoadMode);
  bool (__fastcall *postProcess)(ChunkSource *this, ChunkViewSource *);
  void (__fastcall *checkAndReplaceChunk)(ChunkSource *this, ChunkViewSource *, LevelChunk *);
  void (__fastcall *loadChunk)(ChunkSource *this, LevelChunk *, bool);
  void (__fastcall *postProcessMobsAt)(ChunkSource *this, BlockSource *, int, int, Random *);
  bool (__fastcall *saveLiveChunk)(ChunkSource *this, LevelChunk *);
  void (__fastcall *hintDiscardBatchBegin)(ChunkSource *this);
  void (__fastcall *hintDiscardBatchEnd)(ChunkSource *this);
  void (__fastcall *acquireDiscarded)(ChunkSource *this, std::unique_ptr&lt;LevelChunk,LevelChunkFinalDeleter&gt;);
  void (__fastcall *compact)(ChunkSource *this);
  void (__fastcall *flushPendingWrites)(ChunkSource *this);
  bool (__fastcall *isWithinWorldLimit)(ChunkSource *this, const ChunkPos *);
  const std::unordered_map&lt;ChunkPos,std::weak_ptr&lt;LevelChunk&gt;&gt; *(__fastcall *getChunkMap)(ChunkSource *this);
  const std::unordered_map&lt;ChunkPos,std::weak_ptr&lt;LevelChunk&gt;&gt; *(__fastcall *getStorage)(ChunkSource *this);
  void (__fastcall *clearDeletedEntities)(ChunkSource *this);
  void (__fastcall *removeDimensionData)(ChunkSource *this, const std::unordered_set&lt;AutomaticID&lt;Dimension,int&gt;&gt; *);
  bool (__fastcall *hasChunk)(ChunkSource *this, const ChunkPos *, AutomaticID&lt;Dimension,int&gt;);
  bool (__fastcall *canCreateViews)(ChunkSource *this);
};

</code></pre></div><h3 id="twistingvinesclusterfeature"><a href="#twistingvinesclusterfeature" class="header-anchor">#</a> <code>TwistingVinesClusterFeature</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TwistingVinesClusterFeature : Feature
{
};

</code></pre></div><h3 id="twistingvinesclusterfeature-vtbl"><a href="#twistingvinesclusterfeature-vtbl" class="header-anchor">#</a> <code>TwistingVinesClusterFeature_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TwistingVinesClusterFeature_vtbl
{
  void (__fastcall *~IFeature)(IFeature *this);
  std::optional&lt;BlockPos&gt; *(__fastcall *place)(IFeature *this, std::optional&lt;BlockPos&gt; *result, IBlockWorldGenAPI *, const BlockPos *, Random *, RenderParams *);
  std::string *(__fastcall *getStructureName)(IFeature *this, std::string *result);
  bool (__fastcall *parse)(IFeature *this, const rapidjson::GenericValue&lt;rapidjson::UTF8&lt;char&gt;,rapidjson::MemoryPoolAllocator&lt;rapidjson::CrtAllocator&gt; &gt; *, IWorldRegistriesProvider *);
  bool (__fastcall *place)(Feature *this, BlockSource *, const BlockPos *, Random *);
};

</code></pre></div><h3 id="trunkvariantbuilder-buildtrunkvariant-l2-lambda-6d9a4349d26e94dea794c1fdacfc3b13"><a href="#trunkvariantbuilder-buildtrunkvariant-l2-lambda-6d9a4349d26e94dea794c1fdacfc3b13" class="header-anchor">#</a> <code>TrunkVariantBuilder::buildTrunkVariant::__l2::&lt;lambda_6d9a4349d26e94dea794c1fdacfc3b13&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TrunkVariantBuilder::buildTrunkVariant::__l2::&lt;lambda_6d9a4349d26e94dea794c1fdacfc3b13&gt;
{
  std::function&lt;ITreeTrunkWrapper &amp; __cdecl(FeatureLoading::ConcreteFeatureHolder&lt;VanillaTreeFeature&gt; *)&gt; trunkAccessor;
};

</code></pre></div><h3 id="trunkvariantbuilder-buildtrunkvariant-l2-lambda-2891af02dc87b30718ec6f87b7028bd4"><a href="#trunkvariantbuilder-buildtrunkvariant-l2-lambda-2891af02dc87b30718ec6f87b7028bd4" class="header-anchor">#</a> <code>TrunkVariantBuilder::buildTrunkVariant::__l2::&lt;lambda_2891af02dc87b30718ec6f87b7028bd4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TrunkVariantBuilder::buildTrunkVariant::__l2::&lt;lambda_2891af02dc87b30718ec6f87b7028bd4&gt;
{
  std::function&lt;ITreeTrunkWrapper &amp; __cdecl(FeatureLoading::ConcreteFeatureHolder&lt;VanillaTreeFeature&gt; *)&gt; trunkAccessor;
};

</code></pre></div><h3 id="trunkvariantbuilder-buildtrunkvariant-l2-lambda-298c2fc108d44315676cf647fb15a899"><a href="#trunkvariantbuilder-buildtrunkvariant-l2-lambda-298c2fc108d44315676cf647fb15a899" class="header-anchor">#</a> <code>TrunkVariantBuilder::buildTrunkVariant::__l2::&lt;lambda_298c2fc108d44315676cf647fb15a899&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TrunkVariantBuilder::buildTrunkVariant::__l2::&lt;lambda_298c2fc108d44315676cf647fb15a899&gt;
{
  std::function&lt;ITreeTrunkWrapper &amp; __cdecl(FeatureLoading::ConcreteFeatureHolder&lt;VanillaTreeFeature&gt; *)&gt; trunkAccessor;
};

</code></pre></div><h3 id="trunkvariantbuilder-buildtrunkvariant-l2-lambda-4c94e9e62cef84b17089b42c799f1b62"><a href="#trunkvariantbuilder-buildtrunkvariant-l2-lambda-4c94e9e62cef84b17089b42c799f1b62" class="header-anchor">#</a> <code>TrunkVariantBuilder::buildTrunkVariant::__l2::&lt;lambda_4c94e9e62cef84b17089b42c799f1b62&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TrunkVariantBuilder::buildTrunkVariant::__l2::&lt;lambda_4c94e9e62cef84b17089b42c799f1b62&gt;
{
  std::function&lt;ITreeTrunkWrapper &amp; __cdecl(FeatureLoading::ConcreteFeatureHolder&lt;VanillaTreeFeature&gt; *)&gt; trunkAccessor;
};

</code></pre></div><h3 id="treehelper-treeparams-buildschema-l2-lambda-04126ab3841162f070846e248505fe78"><a href="#treehelper-treeparams-buildschema-l2-lambda-04126ab3841162f070846e248505fe78" class="header-anchor">#</a> <code>TreeHelper::TreeParams::buildSchema::__l2::&lt;lambda_04126ab3841162f070846e248505fe78&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::TreeParams::buildSchema::__l2::&lt;lambda_04126ab3841162f070846e248505fe78&gt;
{
  std::function&lt;TreeHelper::TreeParams &amp; __cdecl(FeatureLoading::ConcreteFeatureHolder&lt;VanillaTreeFeature&gt; *)&gt; paramAccessor;
};

</code></pre></div><h3 id="treehelper-treeparams-buildschema-l2-lambda-93c22a781df6dc6af71b4dd5e0b171f1"><a href="#treehelper-treeparams-buildschema-l2-lambda-93c22a781df6dc6af71b4dd5e0b171f1" class="header-anchor">#</a> <code>TreeHelper::TreeParams::buildSchema::__l2::&lt;lambda_93c22a781df6dc6af71b4dd5e0b171f1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::TreeParams::buildSchema::__l2::&lt;lambda_93c22a781df6dc6af71b4dd5e0b171f1&gt;
{
  std::function&lt;TreeHelper::TreeParams &amp; __cdecl(FeatureLoading::ConcreteFeatureHolder&lt;VanillaTreeFeature&gt; *)&gt; paramAccessor;
};

</code></pre></div><h3 id="treehelper-treeparams-buildschema-l2-lambda-ffd665e99d41506084ffb05e0bc3a630"><a href="#treehelper-treeparams-buildschema-l2-lambda-ffd665e99d41506084ffb05e0bc3a630" class="header-anchor">#</a> <code>TreeHelper::TreeParams::buildSchema::__l2::&lt;lambda_ffd665e99d41506084ffb05e0bc3a630&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::TreeParams::buildSchema::__l2::&lt;lambda_ffd665e99d41506084ffb05e0bc3a630&gt;
{
  std::function&lt;TreeHelper::TreeParams &amp; __cdecl(FeatureLoading::ConcreteFeatureHolder&lt;VanillaTreeFeature&gt; *)&gt; paramAccessor;
};

</code></pre></div><h3 id="treehelper-treeparams-buildschema-l3-lambda-a7906fd49315030a86f3708933d5a526"><a href="#treehelper-treeparams-buildschema-l3-lambda-a7906fd49315030a86f3708933d5a526" class="header-anchor">#</a> <code>TreeHelper::TreeParams::buildSchema::__l3::&lt;lambda_a7906fd49315030a86f3708933d5a526&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::TreeParams::buildSchema::__l3::&lt;lambda_a7906fd49315030a86f3708933d5a526&gt;
{
  std::function&lt;TreeHelper::TreeParams &amp; __cdecl(FeatureLoading::ConcreteFeatureHolder&lt;VanillaTreeFeature&gt; *)&gt; paramAccessor;
};

</code></pre></div><h3 id="treehelper-treeparams-buildschema-l3-lambda-20a3db3713487e2e69fdcaad7b950e8e"><a href="#treehelper-treeparams-buildschema-l3-lambda-20a3db3713487e2e69fdcaad7b950e8e" class="header-anchor">#</a> <code>TreeHelper::TreeParams::buildSchema::__l3::&lt;lambda_20a3db3713487e2e69fdcaad7b950e8e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::TreeParams::buildSchema::__l3::&lt;lambda_20a3db3713487e2e69fdcaad7b950e8e&gt;
{
  std::function&lt;TreeHelper::TreeParams &amp; __cdecl(FeatureLoading::ConcreteFeatureHolder&lt;VanillaTreeFeature&gt; *)&gt; paramAccessor;
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-8db1885130e9761bfd1f5d45a532424c"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-8db1885130e9761bfd1f5d45a532424c" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_8db1885130e9761bfd1f5d45a532424c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_8db1885130e9761bfd1f5d45a532424c&gt;
{
  std::function&lt;TreeHelper::AttachableDecoration &amp; __cdecl(SimpleTreeTrunk *)&gt; paramAccessor;
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-6532a13bf9bbe1c02a4010743d3008b0"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-6532a13bf9bbe1c02a4010743d3008b0" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_6532a13bf9bbe1c02a4010743d3008b0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_6532a13bf9bbe1c02a4010743d3008b0&gt;
{
  std::function&lt;TreeHelper::AttachableDecoration &amp; __cdecl(SimpleTreeTrunk *)&gt; paramAccessor;
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-85bae5b79c8184c2116d8fc5da3d0e07"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-85bae5b79c8184c2116d8fc5da3d0e07" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_85bae5b79c8184c2116d8fc5da3d0e07&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_85bae5b79c8184c2116d8fc5da3d0e07&gt;
{
  std::function&lt;TreeHelper::AttachableDecoration &amp; __cdecl(MegaTreeTrunk *)&gt; paramAccessor;
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-ea5db8857e8fb58674ec19b155c943c9"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-ea5db8857e8fb58674ec19b155c943c9" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_ea5db8857e8fb58674ec19b155c943c9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_ea5db8857e8fb58674ec19b155c943c9&gt;
{
  std::function&lt;TreeHelper::AttachableDecoration &amp; __cdecl(MegaTreeTrunk *)&gt; paramAccessor;
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-8d488a2c84209dd0831ffb054e5850e6"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-8d488a2c84209dd0831ffb054e5850e6" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_8d488a2c84209dd0831ffb054e5850e6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_8d488a2c84209dd0831ffb054e5850e6&gt;
{
  std::function&lt;TreeHelper::AttachableDecoration &amp; __cdecl(FallenTreeTrunk *)&gt; paramAccessor;
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-6d2a08d73f83e3ab1661efe36a98ace1"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-6d2a08d73f83e3ab1661efe36a98ace1" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_6d2a08d73f83e3ab1661efe36a98ace1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_6d2a08d73f83e3ab1661efe36a98ace1&gt;
{
  std::function&lt;TreeHelper::AttachableDecoration &amp; __cdecl(FallenTreeTrunk *)&gt; paramAccessor;
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-61a38999c743ca7361dc2e73d0aaff62"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-61a38999c743ca7361dc2e73d0aaff62" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_61a38999c743ca7361dc2e73d0aaff62&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_61a38999c743ca7361dc2e73d0aaff62&gt;
{
  std::function&lt;TreeHelper::AttachableDecoration &amp; __cdecl(AcaciaTreeTrunk *)&gt; paramAccessor;
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-7eb97c3261170c5e4b05f8dd225213fd"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-7eb97c3261170c5e4b05f8dd225213fd" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_7eb97c3261170c5e4b05f8dd225213fd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_7eb97c3261170c5e4b05f8dd225213fd&gt;
{
  std::function&lt;TreeHelper::AttachableDecoration &amp; __cdecl(AcaciaTreeTrunk *)&gt; paramAccessor;
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-08e01a5f67d647a919dd40f16a254eca"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-08e01a5f67d647a919dd40f16a254eca" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_08e01a5f67d647a919dd40f16a254eca&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_08e01a5f67d647a919dd40f16a254eca&gt;
{
  std::function&lt;TreeHelper::AttachableDecoration &amp; __cdecl(SimpleTreeCanopy *)&gt; paramAccessor;
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-33302b0860d3bfb4716cc13d3364c310"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-33302b0860d3bfb4716cc13d3364c310" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_33302b0860d3bfb4716cc13d3364c310&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_33302b0860d3bfb4716cc13d3364c310&gt;
{
  std::function&lt;TreeHelper::AttachableDecoration &amp; __cdecl(SimpleTreeCanopy *)&gt; paramAccessor;
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-db6354e9b07bcb09c3bb7e2f25399ac4"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-db6354e9b07bcb09c3bb7e2f25399ac4" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_db6354e9b07bcb09c3bb7e2f25399ac4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_db6354e9b07bcb09c3bb7e2f25399ac4&gt;
{
  std::function&lt;TreeHelper::AttachableDecoration &amp; __cdecl(SimpleTreeCanopy *)&gt; paramAccessor;
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-61e95202bfc74f0d4a7ca173ac48da7f"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-61e95202bfc74f0d4a7ca173ac48da7f" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_61e95202bfc74f0d4a7ca173ac48da7f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_61e95202bfc74f0d4a7ca173ac48da7f&gt;
{
  std::function&lt;TreeHelper::AttachableDecoration &amp; __cdecl(SimpleTreeCanopy *)&gt; paramAccessor;
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-abae1b4ad9f5adc8002c7f845728efe6"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-abae1b4ad9f5adc8002c7f845728efe6" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_abae1b4ad9f5adc8002c7f845728efe6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_abae1b4ad9f5adc8002c7f845728efe6&gt;
{
  std::function&lt;TreeHelper::AttachableDecoration &amp; __cdecl(SimpleTreeCanopy *)&gt; paramAccessor;
};

</code></pre></div><h3 id="transformationmixerlayer-weightedbiomeattributes-rivertransformation"><a href="#transformationmixerlayer-weightedbiomeattributes-rivertransformation" class="header-anchor">#</a> <code>TransformationMixerLayer&lt;WeightedBiomeAttributes&lt;RiverTransformation&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TransformationMixerLayer&lt;WeightedBiomeAttributes&lt;RiverTransformation&gt; &gt; : MixerLayer&lt;Biome *,Biome *,bool&gt;
{
  Biome *mDefaultTransformation;
};

</code></pre></div><h3 id="transformationmixerlayer-weightedbiomeattributes-rivertransformation-vtbl"><a href="#transformationmixerlayer-weightedbiomeattributes-rivertransformation-vtbl" class="header-anchor">#</a> <code>TransformationMixerLayer&lt;WeightedBiomeAttributes&lt;RiverTransformation&gt; &gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TransformationMixerLayer&lt;WeightedBiomeAttributes&lt;RiverTransformation&gt; &gt;_vtbl
{
  void (__fastcall *~LayerBase)(LayerDetails::LayerBase *this);
  void (__fastcall *init)(LayerDetails::LayerBase *this, __int64);
  LayerDetails::TransferData&lt;Biome *&gt; *(__fastcall *_allocateAndFill)(Layer&lt;Biome *&gt; *this, LayerDetails::TransferData&lt;Biome *&gt; *result, unsigned __int64, int, int, unsigned int, unsigned int);
  void (__fastcall *_fillArea)(MixerLayer&lt;Biome *,Biome *,bool&gt; *this, LayerDetails::WorkingData&lt;Biome *,Biome *&gt; *, int, int, int, int, int, LayerResult&lt;bool&gt;);
  std::tuple&lt;int,int,unsigned int,unsigned int&gt; *(__fastcall *_getAreaRead)(MixerLayer&lt;Biome *,Biome *,bool&gt; *this, std::tuple&lt;int,int,unsigned int,unsigned int&gt; *result, int, int, unsigned int, unsigned int);
};

</code></pre></div><h3 id="touchtextbuttoncontrol"><a href="#touchtextbuttoncontrol" class="header-anchor">#</a> <code>TouchTextButtonControl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TouchTextButtonControl : TouchGlyphButtonControl
{
  std::function&lt;glm::tvec2&lt;float,0&gt; __cdecl(void)&gt; mPosition;
  std::function&lt;std::string __cdecl(void)&gt; mLabel;
  glm::tvec2&lt;float,0&gt; mCurrentPosition;
  RectangleArea mCurrentRect;
};

</code></pre></div><h3 id="touchtextbuttoncontrol-vtbl"><a href="#touchtextbuttoncontrol-vtbl" class="header-anchor">#</a> <code>TouchTextButtonControl_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TouchTextButtonControl_vtbl
{
  void (__fastcall *~TouchControl)(TouchControl *this);
  void (__fastcall *render)(TouchControl *this, InputRenderContext *);
  void (__fastcall *tick)(TouchControl *this, InputEventQueue *, TouchPointResults *, int);
  void (__fastcall *release)(TouchControl *this, InputEventQueue *);
};

</code></pre></div><h3 id="touchtextbuttoncontrol-lambda-d981cd7e616c973c1d1b4f1442f5f224"><a href="#touchtextbuttoncontrol-lambda-d981cd7e616c973c1d1b4f1442f5f224" class="header-anchor">#</a> <code>TouchTextButtonControl::&lt;lambda_d981cd7e616c973c1d1b4f1442f5f224&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TouchTextButtonControl::&lt;lambda_d981cd7e616c973c1d1b4f1442f5f224&gt;
{
  TouchTextButtonControl *const __this;
};

</code></pre></div><h3 id="touchguipassthroughcontrol"><a href="#touchguipassthroughcontrol" class="header-anchor">#</a> <code>TouchGuiPassthroughControl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TouchGuiPassthroughControl : TouchControl
{
  ButtonState mButtonState;
  const unsigned int mButtonId;
};

</code></pre></div><h3 id="touchguipassthroughcontrol-vtbl"><a href="#touchguipassthroughcontrol-vtbl" class="header-anchor">#</a> <code>TouchGuiPassthroughControl_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TouchGuiPassthroughControl_vtbl
{
  void (__fastcall *~TouchControl)(TouchControl *this);
  void (__fastcall *render)(TouchControl *this, InputRenderContext *);
  void (__fastcall *tick)(TouchControl *this, InputEventQueue *, TouchPointResults *, int);
  void (__fastcall *release)(TouchControl *this, InputEventQueue *);
};

</code></pre></div><h3 id="threaddatainterface"><a href="#threaddatainterface" class="header-anchor">#</a> <code>ThreadDataInterface</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ThreadDataInterface
{
  ThreadDataInterface_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="threaddatainterface-vtbl"><a href="#threaddatainterface-vtbl" class="header-anchor">#</a> <code>ThreadDataInterface_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ThreadDataInterface_vtbl
{
  void (__fastcall *~ThreadDataInterface)(ThreadDataInterface *this);
  void *(__fastcall *PerThreadFactory)(ThreadDataInterface *this, void *);
  void (__fastcall *PerThreadDestructor)(ThreadDataInterface *this, void *, void *);
};

</code></pre></div><h3 id="threadpool-raknet-filelisttransfer-threaddata-int"><a href="#threadpool-raknet-filelisttransfer-threaddata-int" class="header-anchor">#</a> <code>ThreadPool&lt;RakNet::FileListTransfer::ThreadData,int&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ThreadPool&lt;RakNet::FileListTransfer::ThreadData,int&gt;
{
  RakNet::SimpleMutex inputQueueMutex;
  RakNet::SimpleMutex outputQueueMutex;
  RakNet::SimpleMutex workingThreadCountMutex;
  RakNet::SimpleMutex runThreadsMutex;
  void *(__fastcall *perThreadDataFactory)();
  void (__fastcall *perThreadDataDestructor)(void *);
  DataStructures::Queue&lt;int (__cdecl*)(RakNet::FileListTransfer::ThreadData,bool *,void *)&gt; inputFunctionQueue;
  DataStructures::Queue&lt;RakNet::FileListTransfer::ThreadData&gt; inputQueue;
  DataStructures::Queue&lt;int&gt; outputQueue;
  ThreadDataInterface *threadDataInterface;
  void *tdiContext;
  bool runThreads;
  int numThreadsRunning;
  int numThreadsWorking;
  RakNet::SimpleMutex numThreadsRunningMutex;
  RakNet::SignaledEvent quitAndIncomingDataEvents;
};

</code></pre></div><h3 id="timezone"><a href="#timezone" class="header-anchor">#</a> <code>timezone</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct timezone
{
  int tz_minuteswest;
  int tz_dsttime;
};

</code></pre></div><h3 id="timeb"><a href="#timeb" class="header-anchor">#</a> <code>timeb</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(4)) timeb
{
  __int64 time;
  unsigned __int16 millitm;
  __int16 timezone;
  __int16 dstflag;
};

</code></pre></div><h3 id="texteditfocuscontroller"><a href="#texteditfocuscontroller" class="header-anchor">#</a> <code>TextEditFocusController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) TextEditFocusController
{
  std::function&lt;void __cdecl(std::string const &amp;,int,bool,bool,glm::tvec2&lt;float,0&gt; const &amp;,bool)&gt; mShowCallback;
  std::function&lt;void __cdecl(void)&gt; mHideCallback;
  std::function&lt;void __cdecl(std::string const &amp;)&gt; mUpdateCallback;
  bool mShowOnFocus;
  bool mFocused;
  bool mSelected;
};

</code></pre></div><h3 id="taskdetails-backgroundtaskdetails-taskresult-void-void"><a href="#taskdetails-backgroundtaskdetails-taskresult-void-void" class="header-anchor">#</a> <code>TaskDetails::BackgroundTaskDetails&lt;TaskResult,void,void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TaskDetails::BackgroundTaskDetails&lt;TaskResult,void,void&gt; : Bedrock::Threading::IAsyncResult&lt;void&gt;
{
  std::function&lt;TaskResult __cdecl(void)&gt; mTask;
};

</code></pre></div><h3 id="taskdetails-backgroundtaskdetails-taskresult-void-void-vtbl"><a href="#taskdetails-backgroundtaskdetails-taskresult-void-void-vtbl" class="header-anchor">#</a> <code>TaskDetails::BackgroundTaskDetails&lt;TaskResult,void,void&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TaskDetails::BackgroundTaskDetails&lt;TaskResult,void,void&gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;void&gt;)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::exception_ptr *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;void&gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="taskdetails-backgroundtaskdetails-void-void-void"><a href="#taskdetails-backgroundtaskdetails-void-void-void" class="header-anchor">#</a> <code>TaskDetails::BackgroundTaskDetails&lt;void,void,void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TaskDetails::BackgroundTaskDetails&lt;void,void,void&gt; : Bedrock::Threading::IAsyncResult&lt;void&gt;
{
  std::function&lt;void __cdecl(void)&gt; mTask;
};

</code></pre></div><h3 id="taskdetails-backgroundtaskdetails-void-void-void-vtbl"><a href="#taskdetails-backgroundtaskdetails-void-void-void-vtbl" class="header-anchor">#</a> <code>TaskDetails::BackgroundTaskDetails&lt;void,void,void&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TaskDetails::BackgroundTaskDetails&lt;void,void,void&gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;void&gt;)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::exception_ptr *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;void&gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="taskgroup-flush-l24-lambda-f858309b3640be0291f38b673f2e0168"><a href="#taskgroup-flush-l24-lambda-f858309b3640be0291f38b673f2e0168" class="header-anchor">#</a> <code>TaskGroup::flush::__l24::&lt;lambda_f858309b3640be0291f38b673f2e0168&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TaskGroup::flush::__l24::&lt;lambda_f858309b3640be0291f38b673f2e0168&gt;
{
};

</code></pre></div><h3 id="taskgroup-resume-l2-lambda-22aee7be42bb8fb01cff1768f3f0c0b9"><a href="#taskgroup-resume-l2-lambda-22aee7be42bb8fb01cff1768f3f0c0b9" class="header-anchor">#</a> <code>TaskGroup::resume::__l2::&lt;lambda_22aee7be42bb8fb01cff1768f3f0c0b9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TaskGroup::resume::__l2::&lt;lambda_22aee7be42bb8fb01cff1768f3f0c0b9&gt;
{
  TaskGroup *const __this;
};

</code></pre></div><h3 id="taskgroup-resume-l2-lambda-22aee7be42bb8fb01cff1768f3f0c0b9-l2-lambda-d91f59a878019cd825e76c11990156bd"><a href="#taskgroup-resume-l2-lambda-22aee7be42bb8fb01cff1768f3f0c0b9-l2-lambda-d91f59a878019cd825e76c11990156bd" class="header-anchor">#</a> <code>TaskGroup::resume::__l2::&lt;lambda_22aee7be42bb8fb01cff1768f3f0c0b9&gt;::()::__l2::&lt;lambda_d91f59a878019cd825e76c11990156bd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TaskGroup::resume::__l2::&lt;lambda_22aee7be42bb8fb01cff1768f3f0c0b9&gt;::()::__l2::&lt;lambda_d91f59a878019cd825e76c11990156bd&gt;
{
  TaskGroup *const __this;
};

</code></pre></div><h3 id="tt-gasprangerec"><a href="#tt-gasprangerec" class="header-anchor">#</a> <code>TT_GaspRangeRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_GaspRangeRec_
{
  unsigned __int16 maxPPEM;
  unsigned __int16 gaspFlag;
};

</code></pre></div><h3 id="tt-post-25"><a href="#tt-post-25" class="header-anchor">#</a> <code>TT_Post_25_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_Post_25_
{
  unsigned __int16 num_glyphs;
  char *offsets;
};

</code></pre></div><h3 id="ttc-headerrec"><a href="#ttc-headerrec" class="header-anchor">#</a> <code>TTC_HeaderRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TTC_HeaderRec_
{
  unsigned int tag;
  int version;
  int count;
  unsigned int *offsets;
};

</code></pre></div><h3 id="tt-tablerec"><a href="#tt-tablerec" class="header-anchor">#</a> <code>TT_TableRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_TableRec_
{
  unsigned int Tag;
  unsigned int CheckSum;
  unsigned int Offset;
  unsigned int Length;
};

</code></pre></div><h3 id="tt-header"><a href="#tt-header" class="header-anchor">#</a> <code>TT_Header_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(4)) TT_Header_
{
  int Table_Version;
  int Font_Revision;
  int CheckSum_Adjust;
  int Magic_Number;
  unsigned __int16 Flags;
  unsigned __int16 Units_Per_EM;
  unsigned int Created[2];
  unsigned int Modified[2];
  __int16 xMin;
  __int16 yMin;
  __int16 xMax;
  __int16 yMax;
  unsigned __int16 Mac_Style;
  unsigned __int16 Lowest_Rec_PPEM;
  __int16 Font_Direction;
  __int16 Index_To_Loc_Format;
  __int16 Glyph_Data_Format;
};

</code></pre></div><h3 id="tt-horiheader"><a href="#tt-horiheader" class="header-anchor">#</a> <code>TT_HoriHeader_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_HoriHeader_
{
  int Version;
  __int16 Ascender;
  __int16 Descender;
  __int16 Line_Gap;
  unsigned __int16 advance_Width_Max;
  __int16 min_Left_Side_Bearing;
  __int16 min_Right_Side_Bearing;
  __int16 xMax_Extent;
  __int16 caret_Slope_Rise;
  __int16 caret_Slope_Run;
  __int16 caret_Offset;
  __int16 Reserved[4];
  __int16 metric_Data_Format;
  unsigned __int16 number_Of_HMetrics;
  void *long_metrics;
  void *short_metrics;
};

</code></pre></div><h3 id="tt-maxprofile"><a href="#tt-maxprofile" class="header-anchor">#</a> <code>TT_MaxProfile_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_MaxProfile_
{
  int version;
  unsigned __int16 numGlyphs;
  unsigned __int16 maxPoints;
  unsigned __int16 maxContours;
  unsigned __int16 maxCompositePoints;
  unsigned __int16 maxCompositeContours;
  unsigned __int16 maxZones;
  unsigned __int16 maxTwilightPoints;
  unsigned __int16 maxStorage;
  unsigned __int16 maxFunctionDefs;
  unsigned __int16 maxInstructionDefs;
  unsigned __int16 maxStackElements;
  unsigned __int16 maxSizeOfInstructions;
  unsigned __int16 maxComponentElements;
  unsigned __int16 maxComponentDepth;
};

</code></pre></div><h3 id="tt-vertheader"><a href="#tt-vertheader" class="header-anchor">#</a> <code>TT_VertHeader_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_VertHeader_
{
  int Version;
  __int16 Ascender;
  __int16 Descender;
  __int16 Line_Gap;
  unsigned __int16 advance_Height_Max;
  __int16 min_Top_Side_Bearing;
  __int16 min_Bottom_Side_Bearing;
  __int16 yMax_Extent;
  __int16 caret_Slope_Rise;
  __int16 caret_Slope_Run;
  __int16 caret_Offset;
  __int16 Reserved[4];
  __int16 metric_Data_Format;
  unsigned __int16 number_Of_VMetrics;
  void *long_metrics;
  void *short_metrics;
};

</code></pre></div><h3 id="tt-namerec"><a href="#tt-namerec" class="header-anchor">#</a> <code>TT_NameRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_NameRec_
{
  unsigned __int16 platformID;
  unsigned __int16 encodingID;
  unsigned __int16 languageID;
  unsigned __int16 nameID;
  unsigned __int16 stringLength;
  unsigned int stringOffset;
  unsigned __int8 *string;
};

</code></pre></div><h3 id="tt-langtagrec"><a href="#tt-langtagrec" class="header-anchor">#</a> <code>TT_LangTagRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_LangTagRec_
{
  unsigned __int16 stringLength;
  unsigned int stringOffset;
  unsigned __int8 *string;
};

</code></pre></div><h3 id="tt-nametablerec"><a href="#tt-nametablerec" class="header-anchor">#</a> <code>TT_NameTableRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_NameTableRec_
{
  unsigned __int16 format;
  unsigned int numNameRecords;
  unsigned int storageOffset;
  TT_NameRec_ *names;
  unsigned int numLangTagRecords;
  TT_LangTagRec_ *langTags;
  FT_StreamRec_ *stream;
};

</code></pre></div><h3 id="tt-os2"><a href="#tt-os2" class="header-anchor">#</a> <code>TT_OS2_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(4)) TT_OS2_
{
  unsigned __int16 version;
  __int16 xAvgCharWidth;
  unsigned __int16 usWeightClass;
  unsigned __int16 usWidthClass;
  unsigned __int16 fsType;
  __int16 ySubscriptXSize;
  __int16 ySubscriptYSize;
  __int16 ySubscriptXOffset;
  __int16 ySubscriptYOffset;
  __int16 ySuperscriptXSize;
  __int16 ySuperscriptYSize;
  __int16 ySuperscriptXOffset;
  __int16 ySuperscriptYOffset;
  __int16 yStrikeoutSize;
  __int16 yStrikeoutPosition;
  __int16 sFamilyClass;
  unsigned __int8 panose[10];
  unsigned int ulUnicodeRange1;
  unsigned int ulUnicodeRange2;
  unsigned int ulUnicodeRange3;
  unsigned int ulUnicodeRange4;
  char achVendID[4];
  unsigned __int16 fsSelection;
  unsigned __int16 usFirstCharIndex;
  unsigned __int16 usLastCharIndex;
  __int16 sTypoAscender;
  __int16 sTypoDescender;
  __int16 sTypoLineGap;
  unsigned __int16 usWinAscent;
  unsigned __int16 usWinDescent;
  unsigned int ulCodePageRange1;
  unsigned int ulCodePageRange2;
  __int16 sxHeight;
  __int16 sCapHeight;
  unsigned __int16 usDefaultChar;
  unsigned __int16 usBreakChar;
  unsigned __int16 usMaxContext;
  unsigned __int16 usLowerOpticalPointSize;
  unsigned __int16 usUpperOpticalPointSize;
};

</code></pre></div><h3 id="tt-postscript"><a href="#tt-postscript" class="header-anchor">#</a> <code>TT_Postscript_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_Postscript_
{
  int FormatType;
  int italicAngle;
  __int16 underlinePosition;
  __int16 underlineThickness;
  unsigned int isFixedPitch;
  unsigned int minMemType42;
  unsigned int maxMemType42;
  unsigned int minMemType1;
  unsigned int maxMemType1;
};

</code></pre></div><h3 id="tt-facerec"><a href="#tt-facerec" class="header-anchor">#</a> <code>TT_FaceRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_FaceRec_
{
  FT_FaceRec_ root;
  TTC_HeaderRec_ ttc_header;
  unsigned int format_tag;
  unsigned __int16 num_tables;
  TT_TableRec_ *dir_tables;
  TT_Header_ header;
  TT_HoriHeader_ horizontal;
  TT_MaxProfile_ max_profile;
  unsigned __int8 vertical_info;
  TT_VertHeader_ vertical;
  unsigned __int16 num_names;
  TT_NameTableRec_ name_table;
  TT_OS2_ os2;
  TT_Postscript_ postscript;
  unsigned __int8 *cmap_table;
  unsigned int cmap_size;
  int (__fastcall *goto_table)(TT_FaceRec_ *, unsigned int, FT_StreamRec_ *, unsigned int *);
  int (__fastcall *access_glyph_frame)(TT_LoaderRec_ *, unsigned int, unsigned int, unsigned int);
  void (__fastcall *forget_glyph_frame)(TT_LoaderRec_ *);
  int (__fastcall *read_glyph_header)(TT_LoaderRec_ *);
  int (__fastcall *read_simple_glyph)(TT_LoaderRec_ *);
  int (__fastcall *read_composite_glyph)(TT_LoaderRec_ *);
  void *sfnt;
  void *psnames;
  void *mm;
  void *var;
  void *psaux;
  TT_Gasp_ gasp;
  TT_PCLT_ pclt;
  unsigned int num_sbit_scales;
  TT_SBit_ScaleRec_ *sbit_scales;
  TT_Post_NamesRec_ postscript_names;
  FT_Palette_Data_ palette_data;
  unsigned __int16 palette_index;
  FT_Color_ *palette;
  unsigned __int8 have_foreground_color;
  FT_Color_ foreground_color;
  unsigned int font_program_size;
  unsigned __int8 *font_program;
  unsigned int cvt_program_size;
  unsigned __int8 *cvt_program;
  unsigned int cvt_size;
  int *cvt;
  int (__fastcall *interpreter)(void *);
  FT_Generic_ extra;
  const char *postscript_name;
  unsigned int glyf_len;
  unsigned int glyf_offset;
  unsigned __int8 is_cff2;
  unsigned __int8 doblend;
  GX_BlendRec_ *blend;
  unsigned int variation_support;
  const char *var_postscript_prefix;
  unsigned int var_postscript_prefix_len;
  unsigned int horz_metrics_size;
  unsigned int vert_metrics_size;
  unsigned int num_locations;
  unsigned __int8 *glyph_locations;
  unsigned __int8 *hdmx_table;
  unsigned int hdmx_table_size;
  unsigned int hdmx_record_count;
  unsigned int hdmx_record_size;
  unsigned __int8 *hdmx_record_sizes;
  unsigned __int8 *sbit_table;
  unsigned int sbit_table_size;
  TT_SbitTableType_ sbit_table_type;
  unsigned int sbit_num_strikes;
  unsigned int *sbit_strike_map;
  unsigned __int8 *kern_table;
  unsigned int kern_table_size;
  unsigned int num_kern_tables;
  unsigned int kern_avail_bits;
  unsigned int kern_order_bits;
  TT_BDFRec_ bdf;
  unsigned int horz_metrics_offset;
  unsigned int vert_metrics_offset;
  unsigned int ebdt_start;
  unsigned int ebdt_size;
  void *cpal;
  void *colr;
};

</code></pre></div><h3 id="tt-size-metrics"><a href="#tt-size-metrics" class="header-anchor">#</a> <code>TT_Size_Metrics_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(2)) TT_Size_Metrics_
{
  int x_ratio;
  int y_ratio;
  unsigned __int16 ppem;
  int ratio;
  int scale;
  int compensations[4];
  unsigned __int8 valid;
  unsigned __int8 rotated;
  unsigned __int8 stretched;
};

</code></pre></div><h3 id="tt-defrecord"><a href="#tt-defrecord" class="header-anchor">#</a> <code>TT_DefRecord_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_DefRecord_
{
  int range;
  int start;
  int end;
  unsigned int opc;
  unsigned __int8 active;
  unsigned __int8 inline_delta;
  unsigned int sph_fdef_flags;
};

</code></pre></div><h3 id="tt-coderange"><a href="#tt-coderange" class="header-anchor">#</a> <code>TT_CodeRange_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(8)) TT_CodeRange_
{
  unsigned __int8 *base;
  int size;
};

</code></pre></div><h3 id="tt-sizerec"><a href="#tt-sizerec" class="header-anchor">#</a> <code>TT_SizeRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_SizeRec_
{
  FT_SizeRec_ root;
  FT_Size_Metrics_ *metrics;
  FT_Size_Metrics_ hinted_metrics;
  TT_Size_Metrics_ ttmetrics;
  unsigned int strike_index;
  int point_size;
  unsigned int num_function_defs;
  unsigned int max_function_defs;
  TT_DefRecord_ *function_defs;
  unsigned int num_instruction_defs;
  unsigned int max_instruction_defs;
  TT_DefRecord_ *instruction_defs;
  unsigned int max_func;
  unsigned int max_ins;
  TT_CodeRange_ codeRangeTable[3];
  TT_GraphicsState_ GS;
  unsigned int cvt_size;
  int *cvt;
  unsigned __int16 storage_size;
  int *storage;
  TT_GlyphZoneRec_ twilight;
  TT_ExecContextRec_ *context;
  int bytecode_ready;
  int cvt_ready;
};

</code></pre></div><h3 id="tt-callrec"><a href="#tt-callrec" class="header-anchor">#</a> <code>TT_CallRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_CallRec_
{
  int Caller_Range;
  int Caller_IP;
  int Cur_Count;
  TT_DefRecord_ *Def;
};

</code></pre></div><h3 id="tt-execcontextrec"><a href="#tt-execcontextrec" class="header-anchor">#</a> <code>TT_ExecContextRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_ExecContextRec_
{
  TT_FaceRec_ *face;
  TT_SizeRec_ *size;
  FT_MemoryRec_ *memory;
  int error;
  int top;
  int stackSize;
  int *stack;
  int args;
  int new_top;
  TT_GlyphZoneRec_ zp0;
  TT_GlyphZoneRec_ zp1;
  TT_GlyphZoneRec_ zp2;
  TT_GlyphZoneRec_ pts;
  TT_GlyphZoneRec_ twilight;
  int pointSize;
  FT_Size_Metrics_ metrics;
  TT_Size_Metrics_ tt_metrics;
  TT_GraphicsState_ GS;
  int curRange;
  unsigned __int8 *code;
  int IP;
  int codeSize;
  unsigned __int8 opcode;
  int length;
  unsigned __int8 step_ins;
  unsigned int cvtSize;
  int *cvt;
  unsigned int glyphSize;
  unsigned __int8 *glyphIns;
  unsigned int numFDefs;
  unsigned int maxFDefs;
  TT_DefRecord_ *FDefs;
  unsigned int numIDefs;
  unsigned int maxIDefs;
  TT_DefRecord_ *IDefs;
  unsigned int maxFunc;
  unsigned int maxIns;
  int callTop;
  int callSize;
  TT_CallRec_ *callStack;
  unsigned __int16 maxPoints;
  __int16 maxContours;
  TT_CodeRange_ codeRangeTable[3];
  unsigned __int16 storeSize;
  int *storage;
  int period;
  int phase;
  int threshold;
  unsigned __int8 instruction_trap;
  TT_GraphicsState_ default_GS;
  unsigned __int8 is_composite;
  unsigned __int8 pedantic_hinting;
  int F_dot_P;
  int (__fastcall *func_round)(TT_ExecContextRec_ *, int, int);
  int (__fastcall *func_project)(TT_ExecContextRec_ *, int, int);
  int (__fastcall *func_dualproj)(TT_ExecContextRec_ *, int, int);
  int (__fastcall *func_freeProj)(TT_ExecContextRec_ *, int, int);
  void (__fastcall *func_move)(TT_ExecContextRec_ *, TT_GlyphZoneRec_ *, unsigned __int16, int);
  void (__fastcall *func_move_orig)(TT_ExecContextRec_ *, TT_GlyphZoneRec_ *, unsigned __int16, int);
  int (__fastcall *func_cur_ppem)(TT_ExecContextRec_ *);
  int (__fastcall *func_read_cvt)(TT_ExecContextRec_ *, unsigned int);
  void (__fastcall *func_write_cvt)(TT_ExecContextRec_ *, unsigned int, int);
  void (__fastcall *func_move_cvt)(TT_ExecContextRec_ *, unsigned int, int);
  unsigned __int8 grayscale;
  unsigned __int8 subpixel_hinting_lean;
  unsigned __int8 vertical_lcd_lean;
  unsigned __int8 backward_compatibility;
  unsigned __int8 iupx_called;
  unsigned __int8 iupy_called;
  unsigned __int8 grayscale_cleartype;
  unsigned int loopcall_counter;
  unsigned int loopcall_counter_max;
  unsigned int neg_jump_counter;
  unsigned int neg_jump_counter_max;
};

</code></pre></div><h3 id="tt-gasp"><a href="#tt-gasp" class="header-anchor">#</a> <code>TT_Gasp_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_Gasp_
{
  unsigned __int16 version;
  unsigned __int16 numRanges;
  TT_GaspRangeRec_ *gaspRanges;
};

</code></pre></div><h3 id="tt-pclt"><a href="#tt-pclt" class="header-anchor">#</a> <code>TT_PCLT_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(4)) TT_PCLT_
{
  int Version;
  unsigned int FontNumber;
  unsigned __int16 Pitch;
  unsigned __int16 xHeight;
  unsigned __int16 Style;
  unsigned __int16 TypeFamily;
  unsigned __int16 CapHeight;
  unsigned __int16 SymbolSet;
  char TypeFace[16];
  char CharacterComplement[8];
  char FileName[6];
  char StrokeWeight;
  char WidthType;
  unsigned __int8 SerifStyle;
  unsigned __int8 Reserved;
};

</code></pre></div><h3 id="tt-sbit-linemetricsrec"><a href="#tt-sbit-linemetricsrec" class="header-anchor">#</a> <code>TT_SBit_LineMetricsRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_SBit_LineMetricsRec_
{
  char ascender;
  char descender;
  unsigned __int8 max_width;
  char caret_slope_numerator;
  char caret_slope_denominator;
  char caret_offset;
  char min_origin_SB;
  char min_advance_SB;
  char max_before_BL;
  char min_after_BL;
  char pads[2];
};

</code></pre></div><h3 id="tt-sbit-scalerec"><a href="#tt-sbit-scalerec" class="header-anchor">#</a> <code>TT_SBit_ScaleRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_SBit_ScaleRec_
{
  TT_SBit_LineMetricsRec_ hori;
  TT_SBit_LineMetricsRec_ vert;
  unsigned __int8 x_ppem;
  unsigned __int8 y_ppem;
  unsigned __int8 x_ppem_substitute;
  unsigned __int8 y_ppem_substitute;
};

</code></pre></div><h3 id="tt-post-20rec"><a href="#tt-post-20rec" class="header-anchor">#</a> <code>TT_Post_20Rec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_Post_20Rec_
{
  unsigned __int16 num_glyphs;
  unsigned __int16 num_names;
  wchar_t *glyph_indices;
  char **glyph_names;
};

</code></pre></div><h3 id="tt-post-namesrec"><a href="#tt-post-namesrec" class="header-anchor">#</a> <code>TT_Post_NamesRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_Post_NamesRec_
{
  unsigned __int8 loaded;
  union
  {
    TT_Post_20Rec_ format_20;
    TT_Post_25_ format_25;
  } names;
};

</code></pre></div><h3 id="tt-bdfrec"><a href="#tt-bdfrec" class="header-anchor">#</a> <code>TT_BDFRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(8)) TT_BDFRec_
{
  unsigned __int8 *table;
  unsigned __int8 *table_end;
  unsigned __int8 *strings;
  unsigned int strings_size;
  unsigned int num_strikes;
  unsigned __int8 loaded;
};

</code></pre></div><h3 id="tt-cmapinfo"><a href="#tt-cmapinfo" class="header-anchor">#</a> <code>TT_CMapInfo_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_CMapInfo_
{
  unsigned int language;
  int format;
};

</code></pre></div><h3 id="tt-sbit-metricsrec"><a href="#tt-sbit-metricsrec" class="header-anchor">#</a> <code>TT_SBit_MetricsRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_SBit_MetricsRec_
{
  unsigned __int16 height;
  unsigned __int16 width;
  __int16 horiBearingX;
  __int16 horiBearingY;
  unsigned __int16 horiAdvance;
  __int16 vertBearingX;
  __int16 vertBearingY;
  unsigned __int16 vertAdvance;
};

</code></pre></div><h3 id="tbbox-rec"><a href="#tbbox-rec" class="header-anchor">#</a> <code>TBBox_Rec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TBBox_Rec_
{
  FT_Vector_ last;
  FT_BBox_ bbox;
};

</code></pre></div><h3 id="t1-hints-funcsrec"><a href="#t1-hints-funcsrec" class="header-anchor">#</a> <code>T1_Hints_FuncsRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct T1_Hints_FuncsRec_
{
  struct T1_HintsRec_ *hints;
  void (__fastcall *open)(struct T1_HintsRec_ *);
  int (__fastcall *close)(struct T1_HintsRec_ *, unsigned int);
  void (__fastcall *stem)(struct T1_HintsRec_ *, unsigned int, int *);
  void (__fastcall *stem3)(struct T1_HintsRec_ *, unsigned int, int *);
  void (__fastcall *reset)(struct T1_HintsRec_ *, unsigned int);
  int (__fastcall *apply)(struct T1_HintsRec_ *, FT_Outline_ *, PSH_GlobalsRec_ *, FT_Render_Mode_);
};

</code></pre></div><h3 id="t2-hints-funcsrec"><a href="#t2-hints-funcsrec" class="header-anchor">#</a> <code>T2_Hints_FuncsRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct T2_Hints_FuncsRec_
{
  struct T2_HintsRec_ *hints;
  void (__fastcall *open)(struct T2_HintsRec_ *);
  int (__fastcall *close)(struct T2_HintsRec_ *, unsigned int);
  void (__fastcall *stems)(struct T2_HintsRec_ *, unsigned int, int, int *);
  void (__fastcall *hintmask)(struct T2_HintsRec_ *, unsigned int, unsigned int, const unsigned __int8 *);
  void (__fastcall *counter)(struct T2_HintsRec_ *, unsigned int, const unsigned __int8 *);
  int (__fastcall *apply)(struct T2_HintsRec_ *, FT_Outline_ *, PSH_GlobalsRec_ *, FT_Render_Mode_);
};

</code></pre></div><h3 id="t1-cmapcustomrec"><a href="#t1-cmapcustomrec" class="header-anchor">#</a> <code>T1_CMapCustomRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct T1_CMapCustomRec_
{
  FT_CMapRec_ cmap;
  unsigned int first;
  unsigned int count;
  wchar_t *indices;
};

</code></pre></div><h3 id="t1-encodingrecrec"><a href="#t1-encodingrecrec" class="header-anchor">#</a> <code>T1_EncodingRecRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct T1_EncodingRecRec_
{
  int num_chars;
  int code_first;
  int code_last;
  wchar_t *char_index;
  const char **char_name;
};

</code></pre></div><h3 id="t1-fontrec"><a href="#t1-fontrec" class="header-anchor">#</a> <code>T1_FontRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(8)) T1_FontRec_
{
  PS_FontInfoRec_ font_info;
  PS_FontExtraRec_ font_extra;
  PS_PrivateRec_ private_dict;
  char *font_name;
  T1_EncodingType_ encoding_type;
  T1_EncodingRecRec_ encoding;
  unsigned __int8 *subrs_block;
  unsigned __int8 *charstrings_block;
  unsigned __int8 *glyph_names_block;
  int num_subrs;
  unsigned __int8 **subrs;
  unsigned int *subrs_len;
  FT_HashRec_ *subrs_hash;
  int num_glyphs;
  char **glyph_names;
  unsigned __int8 **charstrings;
  unsigned int *charstrings_len;
  unsigned __int8 paint_type;
  unsigned __int8 font_type;
  FT_Matrix_ font_matrix;
  FT_Vector_ font_offset;
  FT_BBox_ font_bbox;
  int font_id;
  int stroke_width;
};

</code></pre></div><h3 id="t1-cmapstdrec"><a href="#t1-cmapstdrec" class="header-anchor">#</a> <code>T1_CMapStdRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct T1_CMapStdRec_
{
  FT_CMapRec_ cmap;
  const unsigned __int16 *code_to_sid;
  const char *(__fastcall *sid_to_string)(unsigned int);
  unsigned int num_glyphs;
  const char *const *glyph_names;
};

</code></pre></div><h3 id="t1-facerec"><a href="#t1-facerec" class="header-anchor">#</a> <code>T1_FaceRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct T1_FaceRec_
{
  FT_FaceRec_ root;
  T1_FontRec_ type1;
  const void *psnames;
  const void *psaux;
  const void *afm_data;
  FT_CharMapRec_ charmaprecs[2];
  FT_CharMapRec_ *charmaps[2];
  PS_BlendRec_ *blend;
  int ndv_idx;
  int cdv_idx;
  unsigned int len_buildchar;
  int *buildchar;
  const void *pshinter;
};

</code></pre></div><h3 id="tprofile"><a href="#tprofile" class="header-anchor">#</a> <code>TProfile_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TProfile_
{
  int X;
  TProfile_ *link;
  int *offset;
  unsigned __int16 flags;
  int height;
  int start;
  int countL;
  TProfile_ *next;
};

</code></pre></div><h3 id="tt-cmaprec"><a href="#tt-cmaprec" class="header-anchor">#</a> <code>TT_CMapRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(8)) TT_CMapRec_
{
  FT_CMapRec_ cmap;
  unsigned __int8 *data;
  int flags;
};

</code></pre></div><h3 id="tt-cmap12rec"><a href="#tt-cmap12rec" class="header-anchor">#</a> <code>TT_CMap12Rec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(8)) TT_CMap12Rec_
{
  TT_CMapRec_ cmap;
  unsigned __int8 valid;
  unsigned int cur_charcode;
  unsigned int cur_gindex;
  unsigned int cur_group;
  unsigned int num_groups;
};

</code></pre></div><h3 id="tt-cmap14rec"><a href="#tt-cmap14rec" class="header-anchor">#</a> <code>TT_CMap14Rec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_CMap14Rec_
{
  TT_CMapRec_ cmap;
  unsigned int num_selectors;
  unsigned int max_results;
  unsigned int *results;
  FT_MemoryRec_ *memory;
};

</code></pre></div><h3 id="tt-validatorrec"><a href="#tt-validatorrec" class="header-anchor">#</a> <code>TT_ValidatorRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(16)) TT_ValidatorRec_
{
  FT_ValidatorRec_ validator;
  unsigned int num_glyphs;
};

</code></pre></div><h3 id="tt-cmap13rec"><a href="#tt-cmap13rec" class="header-anchor">#</a> <code>TT_CMap13Rec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(8)) TT_CMap13Rec_
{
  TT_CMapRec_ cmap;
  unsigned __int8 valid;
  unsigned int cur_charcode;
  unsigned int cur_gindex;
  unsigned int cur_group;
  unsigned int num_groups;
};

</code></pre></div><h3 id="tt-cmap4rec"><a href="#tt-cmap4rec" class="header-anchor">#</a> <code>TT_CMap4Rec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TT_CMap4Rec_
{
  TT_CMapRec_ cmap;
  unsigned int cur_charcode;
  unsigned int cur_gindex;
  unsigned int num_ranges;
  unsigned int cur_range;
  unsigned int cur_start;
  unsigned int cur_end;
  int cur_delta;
  unsigned __int8 *cur_values;
};

</code></pre></div><h3 id="tcell"><a href="#tcell" class="header-anchor">#</a> <code>TCell_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TCell_
{
  int x;
  int cover;
  int area;
  TCell_ *next;
};

</code></pre></div><h3 id="tt-driverrec"><a href="#tt-driverrec" class="header-anchor">#</a> <code>TT_DriverRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(8)) TT_DriverRec_
{
  FT_DriverRec_ root;
  TT_GlyphZoneRec_ zone;
  unsigned int interpreter_version;
};

</code></pre></div><h3 id="t1-loader"><a href="#t1-loader" class="header-anchor">#</a> <code>T1_Loader_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct T1_Loader_
{
  T1_ParserRec_ parser;
  int num_chars;
  PS_TableRec_ encoding_table;
  int num_glyphs;
  PS_TableRec_ glyph_names;
  PS_TableRec_ charstrings;
  PS_TableRec_ swap_table;
  int num_subrs;
  PS_TableRec_ subrs;
  FT_HashRec_ *subrs_hash;
  unsigned __int8 fontdata;
  unsigned int keywords_encountered;
};

</code></pre></div><h3 id="t1-sizerec"><a href="#t1-sizerec" class="header-anchor">#</a> <code>T1_SizeRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct T1_SizeRec_
{
  FT_SizeRec_ root;
};

</code></pre></div><h3 id="t1-glyphslotrec"><a href="#t1-glyphslotrec" class="header-anchor">#</a> <code>T1_GlyphSlotRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(8)) T1_GlyphSlotRec_
{
  FT_GlyphSlotRec_ root;
  unsigned __int8 hint;
  unsigned __int8 scaled;
  int x_scale;
  int y_scale;
  int max_points;
  int max_contours;
};

</code></pre></div><h3 id="t42-driverrec"><a href="#t42-driverrec" class="header-anchor">#</a> <code>T42_DriverRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct T42_DriverRec_
{
  FT_DriverRec_ root;
  FT_Driver_ClassRec_ *ttclazz;
};

</code></pre></div><h3 id="t42-glyphslotrec"><a href="#t42-glyphslotrec" class="header-anchor">#</a> <code>T42_GlyphSlotRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct T42_GlyphSlotRec_
{
  FT_GlyphSlotRec_ root;
  FT_GlyphSlotRec_ *ttslot;
};

</code></pre></div><h3 id="t42-loader"><a href="#t42-loader" class="header-anchor">#</a> <code>T42_Loader_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct T42_Loader_
{
  T42_ParserRec_ parser;
  int num_chars;
  PS_TableRec_ encoding_table;
  int num_glyphs;
  PS_TableRec_ glyph_names;
  PS_TableRec_ charstrings;
  PS_TableRec_ swap_table;
};

</code></pre></div><h3 id="t42-facerec"><a href="#t42-facerec" class="header-anchor">#</a> <code>T42_FaceRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct T42_FaceRec_
{
  FT_FaceRec_ root;
  T1_FontRec_ type1;
  const void *psnames;
  const void *psaux;
  unsigned __int8 *ttf_data;
  int ttf_size;
  FT_FaceRec_ *ttf_face;
  FT_CharMapRec_ charmaprecs[2];
  FT_CharMapRec_ *charmaps[2];
  PS_UnicodesRec_ unicode_map;
};

</code></pre></div><h3 id="t42-sizerec"><a href="#t42-sizerec" class="header-anchor">#</a> <code>T42_SizeRec_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct T42_SizeRec_
{
  FT_SizeRec_ root;
  FT_SizeRec_ *ttsize;
};

</code></pre></div><h3 id="threadinfo-profilegroupinfo"><a href="#threadinfo-profilegroupinfo" class="header-anchor">#</a> <code>ThreadInfo::ProfileGroupInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ThreadInfo::ProfileGroupInfo
{
  int mStackDepth;
};

</code></pre></div><h3 id="threadinfo"><a href="#threadinfo" class="header-anchor">#</a> <code>ThreadInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ThreadInfo
{
  std::vector&lt;ThreadInfo::ProfileGroupInfo&gt; mProfileGroups;
};

</code></pre></div><h3 id="teedataobject"><a href="#teedataobject" class="header-anchor">#</a> <code>teedataobject</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct teedataobject
{
  __int64 ob_refcnt;
  _typeobject *ob_type;
  _object *it;
  int numread;
  _object *nextlink;
  _object *values[57];
};

</code></pre></div><h3 id="takewhileobject"><a href="#takewhileobject" class="header-anchor">#</a> <code>takewhileobject</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(8)) takewhileobject
{
  __int64 ob_refcnt;
  _typeobject *ob_type;
  _object *func;
  _object *it;
  int stop;
};

</code></pre></div><h3 id="teeobject"><a href="#teeobject" class="header-anchor">#</a> <code>teeobject</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct teeobject
{
  __int64 ob_refcnt;
  _typeobject *ob_type;
  teedataobject *dataobj;
  int index;
  _object *weakreflist;
};

</code></pre></div><h3 id="tcp-keepalive"><a href="#tcp-keepalive" class="header-anchor">#</a> <code>tcp_keepalive</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tcp_keepalive
{
  unsigned int onoff;
  unsigned int keepalivetime;
  unsigned int keepaliveinterval;
};

</code></pre></div><h3 id="tupleiterobject"><a href="#tupleiterobject" class="header-anchor">#</a> <code>tupleiterobject</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tupleiterobject
{
  __int64 ob_refcnt;
  _typeobject *ob_type;
  int it_index;
  PyTupleObject *it_seq;
};

</code></pre></div><h3 id="tok-state"><a href="#tok-state" class="header-anchor">#</a> <code>tok_state</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tok_state
{
  char *buf;
  char *cur;
  char *inp;
  char *end;
  char *start;
  int done;
  _iobuf *fp;
  int tabsize;
  int indent;
  int indstack[100];
  int atbol;
  int pendin;
  char *prompt;
  char *nextprompt;
  int lineno;
  int level;
  const char *filename;
  int altwarning;
  int alterror;
  int alttabsize;
  int altindstack[100];
  int decoding_state;
  int decoding_erred;
  int read_coding_spec;
  char *encoding;
  int cont_line;
  const char *line_start;
  _object *decoding_readline;
  _object *decoding_buffer;
  const char *enc;
  const char *str;
  const char *input;
};

</code></pre></div><h3 id="tinystl-unordered-hash-node-unsigned-short-void"><a href="#tinystl-unordered-hash-node-unsigned-short-void" class="header-anchor">#</a> <code>tinystl::unordered_hash_node&lt;unsigned short,void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_node&lt;unsigned short,void&gt;
{
  const unsigned __int16 first;
  tinystl::unordered_hash_node&lt;unsigned short,void&gt; *next;
  tinystl::unordered_hash_node&lt;unsigned short,void&gt; *prev;
};

</code></pre></div><h3 id="tinystl-buffer-tinystl-unordered-hash-node-unsigned-short-void-bgfx-tinystlallocator"><a href="#tinystl-buffer-tinystl-unordered-hash-node-unsigned-short-void-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned short,void&gt; *,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned short,void&gt; *,bgfx::TinyStlAllocator&gt;
{
  tinystl::unordered_hash_node&lt;unsigned short,void&gt; **first;
  tinystl::unordered_hash_node&lt;unsigned short,void&gt; **last;
  tinystl::unordered_hash_node&lt;unsigned short,void&gt; **capacity;
};

</code></pre></div><h3 id="tinystl-unordered-set-unsigned-short-bgfx-tinystlallocator"><a href="#tinystl-unordered-set-unsigned-short-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::unordered_set&lt;unsigned short,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_set&lt;unsigned short,bgfx::TinyStlAllocator&gt;
{
  unsigned __int64 m_size;
  tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned short,void&gt; *,bgfx::TinyStlAllocator&gt; m_buckets;
};

</code></pre></div><h3 id="tinystl-unordered-hash-node-unsigned-int64-unsigned-int"><a href="#tinystl-unordered-hash-node-unsigned-int64-unsigned-int" class="header-anchor">#</a> <code>tinystl::unordered_hash_node&lt;unsigned __int64,unsigned int&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_node&lt;unsigned __int64,unsigned int&gt;
{
  const unsigned __int64 first;
  unsigned int second;
  tinystl::unordered_hash_node&lt;unsigned __int64,unsigned int&gt; *next;
  tinystl::unordered_hash_node&lt;unsigned __int64,unsigned int&gt; *prev;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-short-void-const"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-short-void-const" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned short,void&gt; const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned short,void&gt; const &gt;
{
  tinystl::unordered_hash_node&lt;unsigned short,void&gt; *node;
};

</code></pre></div><h3 id="tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-short-void-const-bool"><a href="#tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-short-void-const-bool" class="header-anchor">#</a> <code>tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned short,void&gt; const &gt;,bool&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned short,void&gt; const &gt;,bool&gt;
{
  tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned short,void&gt; const &gt; first;
  bool second;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-unsigned-int-const"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-unsigned-int-const" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,unsigned int&gt; const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,unsigned int&gt; const &gt;
{
  const tinystl::unordered_hash_node&lt;unsigned __int64,unsigned int&gt; *node;
};

</code></pre></div><h3 id="tinystl-placeholder"><a href="#tinystl-placeholder" class="header-anchor">#</a> <code>tinystl::placeholder</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::placeholder
{
};

</code></pre></div><h3 id="tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-short-void-1"><a href="#tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-short-void-1" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned short,void&gt; *,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned short,void&gt; *,1&gt;
{
};

</code></pre></div><h3 id="tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-unsigned-int-1"><a href="#tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-unsigned-int-1" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,unsigned int&gt; *,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,unsigned int&gt; *,1&gt;
{
};

</code></pre></div><h3 id="tinystl-pod-traits-bgfx-nonlocalallocator-free-0"><a href="#tinystl-pod-traits-bgfx-nonlocalallocator-free-0" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;bgfx::NonLocalAllocator::Free,0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;bgfx::NonLocalAllocator::Free,0&gt;
{
};

</code></pre></div><h3 id="tinystl-buffer-id3d12resource-bgfx-tinystlallocator"><a href="#tinystl-buffer-id3d12resource-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::buffer&lt;ID3D12Resource *,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::buffer&lt;ID3D12Resource *,bgfx::TinyStlAllocator&gt;
{
  ID3D12Resource **first;
  ID3D12Resource **last;
  ID3D12Resource **capacity;
};

</code></pre></div><h3 id="tinystl-vector-id3d12resource-bgfx-tinystlallocator"><a href="#tinystl-vector-id3d12resource-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::vector&lt;ID3D12Resource *,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::vector&lt;ID3D12Resource *,bgfx::TinyStlAllocator&gt;
{
  tinystl::buffer&lt;ID3D12Resource *,bgfx::TinyStlAllocator&gt; m_buffer;
};

</code></pre></div><h3 id="tinystl-unordered-hash-node-unsigned-int64-unsigned-short"><a href="#tinystl-unordered-hash-node-unsigned-int64-unsigned-short" class="header-anchor">#</a> <code>tinystl::unordered_hash_node&lt;unsigned __int64,unsigned short&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_node&lt;unsigned __int64,unsigned short&gt;
{
  const unsigned __int64 first;
  unsigned __int16 second;
  tinystl::unordered_hash_node&lt;unsigned __int64,unsigned short&gt; *next;
  tinystl::unordered_hash_node&lt;unsigned __int64,unsigned short&gt; *prev;
};

</code></pre></div><h3 id="tinystl-buffer-tinystl-unordered-hash-node-unsigned-int64-unsigned-short-bgfx-tinystlallocator"><a href="#tinystl-buffer-tinystl-unordered-hash-node-unsigned-int64-unsigned-short-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,unsigned short&gt; *,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,unsigned short&gt; *,bgfx::TinyStlAllocator&gt;
{
  tinystl::unordered_hash_node&lt;unsigned __int64,unsigned short&gt; **first;
  tinystl::unordered_hash_node&lt;unsigned __int64,unsigned short&gt; **last;
  tinystl::unordered_hash_node&lt;unsigned __int64,unsigned short&gt; **capacity;
};

</code></pre></div><h3 id="tinystl-unordered-map-unsigned-int64-unsigned-short-bgfx-tinystlallocator"><a href="#tinystl-unordered-map-unsigned-int64-unsigned-short-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::unordered_map&lt;unsigned __int64,unsigned short,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_map&lt;unsigned __int64,unsigned short,bgfx::TinyStlAllocator&gt;
{
  unsigned __int64 m_size;
  tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,unsigned short&gt; *,bgfx::TinyStlAllocator&gt; m_buckets;
};

</code></pre></div><h3 id="tinystl-unordered-hash-node-unsigned-int64-id3d12pipelinestate"><a href="#tinystl-unordered-hash-node-unsigned-int64-id3d12pipelinestate" class="header-anchor">#</a> <code>tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt;
{
  const unsigned __int64 first;
  ID3D12PipelineState *second;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt; *next;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt; *prev;
};

</code></pre></div><h3 id="tinystl-buffer-tinystl-unordered-hash-node-unsigned-int64-id3d12pipelinestate-bgfx-tinystlallocator"><a href="#tinystl-buffer-tinystl-unordered-hash-node-unsigned-int64-id3d12pipelinestate-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt; *,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt; *,bgfx::TinyStlAllocator&gt;
{
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt; **first;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt; **last;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt; **capacity;
};

</code></pre></div><h3 id="tinystl-unordered-map-unsigned-int64-id3d12pipelinestate-bgfx-tinystlallocator"><a href="#tinystl-unordered-map-unsigned-int64-id3d12pipelinestate-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::unordered_map&lt;unsigned __int64,ID3D12PipelineState *,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_map&lt;unsigned __int64,ID3D12PipelineState *,bgfx::TinyStlAllocator&gt;
{
  unsigned __int64 m_size;
  tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt; *,bgfx::TinyStlAllocator&gt; m_buckets;
};

</code></pre></div><h3 id="tinystl-pod-traits-id3d12resource-1"><a href="#tinystl-pod-traits-id3d12resource-1" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;ID3D12Resource *,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;ID3D12Resource *,1&gt;
{
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-unsigned-short-const"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-unsigned-short-const" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,unsigned short&gt; const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,unsigned short&gt; const &gt;
{
  const tinystl::unordered_hash_node&lt;unsigned __int64,unsigned short&gt; *node;
};

</code></pre></div><h3 id="tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-unsigned-short-1"><a href="#tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-unsigned-short-1" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,unsigned short&gt; *,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,unsigned short&gt; *,1&gt;
{
};

</code></pre></div><h3 id="tinystl-pod-traits-unsigned-int-1"><a href="#tinystl-pod-traits-unsigned-int-1" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;unsigned int,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;unsigned int,1&gt;
{
};

</code></pre></div><h3 id="tinystl-pod-traits-bgfx-dxbcsignature-element-0"><a href="#tinystl-pod-traits-bgfx-dxbcsignature-element-0" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;bgfx::DxbcSignature::Element,0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;bgfx::DxbcSignature::Element,0&gt;
{
};

</code></pre></div><h3 id="tinystl-pair-unsigned-int64-unsigned-short"><a href="#tinystl-pair-unsigned-int64-unsigned-short" class="header-anchor">#</a> <code>tinystl::pair&lt;unsigned __int64,unsigned short&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) tinystl::pair&lt;unsigned __int64,unsigned short&gt;
{
  unsigned __int64 first;
  unsigned __int16 second;
};

</code></pre></div><h3 id="tinystl-unordered-hash-node-unsigned-int-unsigned-int"><a href="#tinystl-unordered-hash-node-unsigned-int-unsigned-int" class="header-anchor">#</a> <code>tinystl::unordered_hash_node&lt;unsigned int,unsigned int&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_node&lt;unsigned int,unsigned int&gt;
{
  const unsigned int first;
  unsigned int second;
  tinystl::unordered_hash_node&lt;unsigned int,unsigned int&gt; *next;
  tinystl::unordered_hash_node&lt;unsigned int,unsigned int&gt; *prev;
};

</code></pre></div><h3 id="tinystl-buffer-tinystl-unordered-hash-node-unsigned-int-unsigned-int-bgfx-tinystlallocator"><a href="#tinystl-buffer-tinystl-unordered-hash-node-unsigned-int-unsigned-int-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned int,unsigned int&gt; *,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned int,unsigned int&gt; *,bgfx::TinyStlAllocator&gt;
{
  tinystl::unordered_hash_node&lt;unsigned int,unsigned int&gt; **first;
  tinystl::unordered_hash_node&lt;unsigned int,unsigned int&gt; **last;
  tinystl::unordered_hash_node&lt;unsigned int,unsigned int&gt; **capacity;
};

</code></pre></div><h3 id="tinystl-unordered-map-unsigned-int-unsigned-int-bgfx-tinystlallocator"><a href="#tinystl-unordered-map-unsigned-int-unsigned-int-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::unordered_map&lt;unsigned int,unsigned int,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_map&lt;unsigned int,unsigned int,bgfx::TinyStlAllocator&gt;
{
  unsigned __int64 m_size;
  tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned int,unsigned int&gt; *,bgfx::TinyStlAllocator&gt; m_buckets;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int-unsigned-int-const"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int-unsigned-int-const" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned int,unsigned int&gt; const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned int,unsigned int&gt; const &gt;
{
  const tinystl::unordered_hash_node&lt;unsigned int,unsigned int&gt; *node;
};

</code></pre></div><h3 id="tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int-unsigned-int-1"><a href="#tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int-unsigned-int-1" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned int,unsigned int&gt; *,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned int,unsigned int&gt; *,1&gt;
{
};

</code></pre></div><h3 id="tinystl-unordered-hash-node-unsigned-int64-id3d11blendstate"><a href="#tinystl-unordered-hash-node-unsigned-int64-id3d11blendstate" class="header-anchor">#</a> <code>tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt;
{
  const unsigned __int64 first;
  ID3D11BlendState *second;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt; *next;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt; *prev;
};

</code></pre></div><h3 id="tinystl-buffer-tinystl-unordered-hash-node-unsigned-int64-id3d11blendstate-bgfx-tinystlallocator"><a href="#tinystl-buffer-tinystl-unordered-hash-node-unsigned-int64-id3d11blendstate-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt; *,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt; *,bgfx::TinyStlAllocator&gt;
{
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt; **first;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt; **last;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt; **capacity;
};

</code></pre></div><h3 id="tinystl-unordered-map-unsigned-int64-id3d11blendstate-bgfx-tinystlallocator"><a href="#tinystl-unordered-map-unsigned-int64-id3d11blendstate-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::unordered_map&lt;unsigned __int64,ID3D11BlendState *,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_map&lt;unsigned __int64,ID3D11BlendState *,bgfx::TinyStlAllocator&gt;
{
  unsigned __int64 m_size;
  tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt; *,bgfx::TinyStlAllocator&gt; m_buckets;
};

</code></pre></div><h3 id="tinystl-unordered-hash-node-unsigned-int64-id3d11depthstencilstate"><a href="#tinystl-unordered-hash-node-unsigned-int64-id3d11depthstencilstate" class="header-anchor">#</a> <code>tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt;
{
  const unsigned __int64 first;
  ID3D11DepthStencilState *second;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt; *next;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt; *prev;
};

</code></pre></div><h3 id="tinystl-buffer-tinystl-unordered-hash-node-unsigned-int64-id3d11depthstencilstate-bgfx-tinystlallocator"><a href="#tinystl-buffer-tinystl-unordered-hash-node-unsigned-int64-id3d11depthstencilstate-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt; *,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt; *,bgfx::TinyStlAllocator&gt;
{
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt; **first;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt; **last;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt; **capacity;
};

</code></pre></div><h3 id="tinystl-unordered-map-unsigned-int64-id3d11depthstencilstate-bgfx-tinystlallocator"><a href="#tinystl-unordered-map-unsigned-int64-id3d11depthstencilstate-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::unordered_map&lt;unsigned __int64,ID3D11DepthStencilState *,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_map&lt;unsigned __int64,ID3D11DepthStencilState *,bgfx::TinyStlAllocator&gt;
{
  unsigned __int64 m_size;
  tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt; *,bgfx::TinyStlAllocator&gt; m_buckets;
};

</code></pre></div><h3 id="tinystl-unordered-hash-node-unsigned-int64-id3d11inputlayout"><a href="#tinystl-unordered-hash-node-unsigned-int64-id3d11inputlayout" class="header-anchor">#</a> <code>tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt;
{
  const unsigned __int64 first;
  ID3D11InputLayout *second;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt; *next;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt; *prev;
};

</code></pre></div><h3 id="tinystl-buffer-tinystl-unordered-hash-node-unsigned-int64-id3d11inputlayout-bgfx-tinystlallocator"><a href="#tinystl-buffer-tinystl-unordered-hash-node-unsigned-int64-id3d11inputlayout-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt; *,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt; *,bgfx::TinyStlAllocator&gt;
{
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt; **first;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt; **last;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt; **capacity;
};

</code></pre></div><h3 id="tinystl-unordered-map-unsigned-int64-id3d11inputlayout-bgfx-tinystlallocator"><a href="#tinystl-unordered-map-unsigned-int64-id3d11inputlayout-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::unordered_map&lt;unsigned __int64,ID3D11InputLayout *,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_map&lt;unsigned __int64,ID3D11InputLayout *,bgfx::TinyStlAllocator&gt;
{
  unsigned __int64 m_size;
  tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt; *,bgfx::TinyStlAllocator&gt; m_buckets;
};

</code></pre></div><h3 id="tinystl-unordered-hash-node-unsigned-int64-id3d11rasterizerstate"><a href="#tinystl-unordered-hash-node-unsigned-int64-id3d11rasterizerstate" class="header-anchor">#</a> <code>tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt;
{
  const unsigned __int64 first;
  ID3D11RasterizerState *second;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt; *next;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt; *prev;
};

</code></pre></div><h3 id="tinystl-buffer-tinystl-unordered-hash-node-unsigned-int64-id3d11rasterizerstate-bgfx-tinystlallocator"><a href="#tinystl-buffer-tinystl-unordered-hash-node-unsigned-int64-id3d11rasterizerstate-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt; *,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt; *,bgfx::TinyStlAllocator&gt;
{
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt; **first;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt; **last;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt; **capacity;
};

</code></pre></div><h3 id="tinystl-unordered-map-unsigned-int64-id3d11rasterizerstate-bgfx-tinystlallocator"><a href="#tinystl-unordered-map-unsigned-int64-id3d11rasterizerstate-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::unordered_map&lt;unsigned __int64,ID3D11RasterizerState *,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_map&lt;unsigned __int64,ID3D11RasterizerState *,bgfx::TinyStlAllocator&gt;
{
  unsigned __int64 m_size;
  tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt; *,bgfx::TinyStlAllocator&gt; m_buckets;
};

</code></pre></div><h3 id="tinystl-unordered-hash-node-unsigned-int64-id3d11samplerstate"><a href="#tinystl-unordered-hash-node-unsigned-int64-id3d11samplerstate" class="header-anchor">#</a> <code>tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt;
{
  const unsigned __int64 first;
  ID3D11SamplerState *second;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt; *next;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt; *prev;
};

</code></pre></div><h3 id="tinystl-buffer-tinystl-unordered-hash-node-unsigned-int64-id3d11samplerstate-bgfx-tinystlallocator"><a href="#tinystl-buffer-tinystl-unordered-hash-node-unsigned-int64-id3d11samplerstate-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt; *,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt; *,bgfx::TinyStlAllocator&gt;
{
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt; **first;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt; **last;
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt; **capacity;
};

</code></pre></div><h3 id="tinystl-unordered-map-unsigned-int64-id3d11samplerstate-bgfx-tinystlallocator"><a href="#tinystl-unordered-map-unsigned-int64-id3d11samplerstate-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::unordered_map&lt;unsigned __int64,ID3D11SamplerState *,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_map&lt;unsigned __int64,ID3D11SamplerState *,bgfx::TinyStlAllocator&gt;
{
  unsigned __int64 m_size;
  tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt; *,bgfx::TinyStlAllocator&gt; m_buckets;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11blendstate-const"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11blendstate-const" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt; const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt; const &gt;
{
  const tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt; *node;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11blendstate"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11blendstate" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt; &gt;
{
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt; *node;
};

</code></pre></div><h3 id="tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-id3d11inputlayout-1"><a href="#tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-id3d11inputlayout-1" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt; *,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt; *,1&gt;
{
};

</code></pre></div><h3 id="tinystl-pair-unsigned-int64-id3d11blendstate"><a href="#tinystl-pair-unsigned-int64-id3d11blendstate" class="header-anchor">#</a> <code>tinystl::pair&lt;unsigned __int64,ID3D11BlendState *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pair&lt;unsigned __int64,ID3D11BlendState *&gt;
{
  unsigned __int64 first;
  ID3D11BlendState *second;
};

</code></pre></div><h3 id="tinystl-pair-unsigned-int64-id3d11depthstencilstate"><a href="#tinystl-pair-unsigned-int64-id3d11depthstencilstate" class="header-anchor">#</a> <code>tinystl::pair&lt;unsigned __int64,ID3D11DepthStencilState *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pair&lt;unsigned __int64,ID3D11DepthStencilState *&gt;
{
  unsigned __int64 first;
  ID3D11DepthStencilState *second;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11depthstencilstate-const"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11depthstencilstate-const" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt; const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt; const &gt;
{
  const tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt; *node;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11depthstencilstate"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11depthstencilstate" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt; &gt;
{
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt; *node;
};

</code></pre></div><h3 id="tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11depthstencilstate-bool"><a href="#tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11depthstencilstate-bool" class="header-anchor">#</a> <code>tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt; &gt;,bool&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt; &gt;,bool&gt;
{
  tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt; &gt; first;
  bool second;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11inputlayout"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11inputlayout" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt; &gt;
{
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt; *node;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11samplerstate"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11samplerstate" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt; &gt;
{
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt; *node;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11rasterizerstate"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11rasterizerstate" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt; &gt;
{
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt; *node;
};

</code></pre></div><h3 id="tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11rasterizerstate-bool"><a href="#tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11rasterizerstate-bool" class="header-anchor">#</a> <code>tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt; &gt;,bool&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt; &gt;,bool&gt;
{
  tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt; &gt; first;
  bool second;
};

</code></pre></div><h3 id="tinystl-pair-unsigned-int64-id3d11inputlayout"><a href="#tinystl-pair-unsigned-int64-id3d11inputlayout" class="header-anchor">#</a> <code>tinystl::pair&lt;unsigned __int64,ID3D11InputLayout *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pair&lt;unsigned __int64,ID3D11InputLayout *&gt;
{
  unsigned __int64 first;
  ID3D11InputLayout *second;
};

</code></pre></div><h3 id="tinystl-pair-unsigned-int64-id3d11rasterizerstate"><a href="#tinystl-pair-unsigned-int64-id3d11rasterizerstate" class="header-anchor">#</a> <code>tinystl::pair&lt;unsigned __int64,ID3D11RasterizerState *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pair&lt;unsigned __int64,ID3D11RasterizerState *&gt;
{
  unsigned __int64 first;
  ID3D11RasterizerState *second;
};

</code></pre></div><h3 id="tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11inputlayout-bool"><a href="#tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11inputlayout-bool" class="header-anchor">#</a> <code>tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt; &gt;,bool&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt; &gt;,bool&gt;
{
  tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt; &gt; first;
  bool second;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11rasterizerstate-const"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11rasterizerstate-const" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt; const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt; const &gt;
{
  const tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt; *node;
};

</code></pre></div><h3 id="tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11blendstate-bool"><a href="#tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11blendstate-bool" class="header-anchor">#</a> <code>tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt; &gt;,bool&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt; &gt;,bool&gt;
{
  tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt; &gt; first;
  bool second;
};

</code></pre></div><h3 id="tinystl-pod-traits-unsigned-char-1"><a href="#tinystl-pod-traits-unsigned-char-1" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;unsigned char,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;unsigned char,1&gt;
{
};

</code></pre></div><h3 id="tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-id3d11rasterizerstate-1"><a href="#tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-id3d11rasterizerstate-1" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt; *,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11RasterizerState *&gt; *,1&gt;
{
};

</code></pre></div><h3 id="tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11samplerstate-bool"><a href="#tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11samplerstate-bool" class="header-anchor">#</a> <code>tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt; &gt;,bool&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt; &gt;,bool&gt;
{
  tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt; &gt; first;
  bool second;
};

</code></pre></div><h3 id="tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-id3d11depthstencilstate-1"><a href="#tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-id3d11depthstencilstate-1" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt; *,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11DepthStencilState *&gt; *,1&gt;
{
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11samplerstate-const"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11samplerstate-const" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt; const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt; const &gt;
{
  const tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt; *node;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11inputlayout-const"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d11inputlayout-const" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt; const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt; const &gt;
{
  const tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11InputLayout *&gt; *node;
};

</code></pre></div><h3 id="tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-id3d11blendstate-1"><a href="#tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-id3d11blendstate-1" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt; *,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11BlendState *&gt; *,1&gt;
{
};

</code></pre></div><h3 id="tinystl-pair-unsigned-int64-id3d11samplerstate"><a href="#tinystl-pair-unsigned-int64-id3d11samplerstate" class="header-anchor">#</a> <code>tinystl::pair&lt;unsigned __int64,ID3D11SamplerState *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pair&lt;unsigned __int64,ID3D11SamplerState *&gt;
{
  unsigned __int64 first;
  ID3D11SamplerState *second;
};

</code></pre></div><h3 id="tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-id3d11samplerstate-1"><a href="#tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-id3d11samplerstate-1" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt; *,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D11SamplerState *&gt; *,1&gt;
{
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d12pipelinestate"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d12pipelinestate" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt; &gt;
{
  tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt; *node;
};

</code></pre></div><h3 id="tinystl-pair-unsigned-int64-id3d12pipelinestate"><a href="#tinystl-pair-unsigned-int64-id3d12pipelinestate" class="header-anchor">#</a> <code>tinystl::pair&lt;unsigned __int64,ID3D12PipelineState *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pair&lt;unsigned __int64,ID3D12PipelineState *&gt;
{
  unsigned __int64 first;
  ID3D12PipelineState *second;
};

</code></pre></div><h3 id="tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d12pipelinestate-bool"><a href="#tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d12pipelinestate-bool" class="header-anchor">#</a> <code>tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt; &gt;,bool&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt; &gt;,bool&gt;
{
  tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt; &gt; first;
  bool second;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d12pipelinestate-const"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-id3d12pipelinestate-const" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt; const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt; const &gt;
{
  const tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt; *node;
};

</code></pre></div><h3 id="tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-id3d12pipelinestate-1"><a href="#tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-id3d12pipelinestate-1" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt; *,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,ID3D12PipelineState *&gt; *,1&gt;
{
};

</code></pre></div><h3 id="tinystl-unordered-hash-node-unsigned-int64-idirect3dvertexdeclaration9"><a href="#tinystl-unordered-hash-node-unsigned-int64-idirect3dvertexdeclaration9" class="header-anchor">#</a> <code>tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt;
{
  const unsigned __int64 first;
  IDirect3DVertexDeclaration9 *second;
  tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt; *next;
  tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt; *prev;
};

</code></pre></div><h3 id="tinystl-buffer-tinystl-unordered-hash-node-unsigned-int64-idirect3dvertexdeclaration9-bgfx-tinystlallocator"><a href="#tinystl-buffer-tinystl-unordered-hash-node-unsigned-int64-idirect3dvertexdeclaration9-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt; *,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt; *,bgfx::TinyStlAllocator&gt;
{
  tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt; **first;
  tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt; **last;
  tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt; **capacity;
};

</code></pre></div><h3 id="tinystl-unordered-map-unsigned-int64-idirect3dvertexdeclaration9-bgfx-tinystlallocator"><a href="#tinystl-unordered-map-unsigned-int64-idirect3dvertexdeclaration9-bgfx-tinystlallocator" class="header-anchor">#</a> <code>tinystl::unordered_map&lt;unsigned __int64,IDirect3DVertexDeclaration9 *,bgfx::TinyStlAllocator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_map&lt;unsigned __int64,IDirect3DVertexDeclaration9 *,bgfx::TinyStlAllocator&gt;
{
  unsigned __int64 m_size;
  tinystl::buffer&lt;tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt; *,bgfx::TinyStlAllocator&gt; m_buckets;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-idirect3dvertexdeclaration9"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-idirect3dvertexdeclaration9" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt; &gt;
{
  tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt; *node;
};

</code></pre></div><h3 id="tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-idirect3dvertexdeclaration9-bool"><a href="#tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-idirect3dvertexdeclaration9-bool" class="header-anchor">#</a> <code>tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt; &gt;,bool&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt; &gt;,bool&gt;
{
  tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt; &gt; first;
  bool second;
};

</code></pre></div><h3 id="tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-idirect3dvertexdeclaration9-1"><a href="#tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-idirect3dvertexdeclaration9-1" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt; *,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt; *,1&gt;
{
};

</code></pre></div><h3 id="tinystl-pair-unsigned-int64-idirect3dvertexdeclaration9"><a href="#tinystl-pair-unsigned-int64-idirect3dvertexdeclaration9" class="header-anchor">#</a> <code>tinystl::pair&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pair&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt;
{
  unsigned __int64 first;
  IDirect3DVertexDeclaration9 *second;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-idirect3dvertexdeclaration9-const"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-idirect3dvertexdeclaration9-const" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt; const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt; const &gt;
{
  const tinystl::unordered_hash_node&lt;unsigned __int64,IDirect3DVertexDeclaration9 *&gt; *node;
};

</code></pre></div><h3 id="tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkpipeline"><a href="#tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkpipeline" class="header-anchor">#</a> <code>tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkPipeline&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkPipeline&gt;
{
  const unsigned __int64 first;
  bgfx::vk::VkPipeline second;
  tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkPipeline&gt; *next;
  tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkPipeline&gt; *prev;
};

</code></pre></div><h3 id="tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkdescriptorsetlayout"><a href="#tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkdescriptorsetlayout" class="header-anchor">#</a> <code>tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkDescriptorSetLayout&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkDescriptorSetLayout&gt;
{
  const unsigned __int64 first;
  bgfx::vk::VkDescriptorSetLayout second;
  tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkDescriptorSetLayout&gt; *next;
  tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkDescriptorSetLayout&gt; *prev;
};

</code></pre></div><h3 id="tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkrenderpass"><a href="#tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkrenderpass" class="header-anchor">#</a> <code>tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkRenderPass&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkRenderPass&gt;
{
  const unsigned __int64 first;
  bgfx::vk::VkRenderPass second;
  tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkRenderPass&gt; *next;
  tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkRenderPass&gt; *prev;
};

</code></pre></div><h3 id="tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vksampler"><a href="#tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vksampler" class="header-anchor">#</a> <code>tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkSampler&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkSampler&gt;
{
  const unsigned __int64 first;
  bgfx::vk::VkSampler second;
  tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkSampler&gt; *next;
  tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkSampler&gt; *prev;
};

</code></pre></div><h3 id="tinystl-pair-unsigned-int64-bgfx-vk-vkrenderpass"><a href="#tinystl-pair-unsigned-int64-bgfx-vk-vkrenderpass" class="header-anchor">#</a> <code>tinystl::pair&lt;unsigned __int64,bgfx::vk::VkRenderPass&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pair&lt;unsigned __int64,bgfx::vk::VkRenderPass&gt;
{
  unsigned __int64 first;
  bgfx::vk::VkRenderPass second;
};

</code></pre></div><h3 id="tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkrenderpass-1"><a href="#tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkrenderpass-1" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkRenderPass&gt; *,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkRenderPass&gt; *,1&gt;
{
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vksampler-const"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vksampler-const" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkSampler&gt; const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkSampler&gt; const &gt;
{
  const tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkSampler&gt; *node;
};

</code></pre></div><h3 id="tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkdescriptorsetlayout-1"><a href="#tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkdescriptorsetlayout-1" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkDescriptorSetLayout&gt; *,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkDescriptorSetLayout&gt; *,1&gt;
{
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkdescriptorsetlayout"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkdescriptorsetlayout" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkDescriptorSetLayout&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkDescriptorSetLayout&gt; &gt;
{
  tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkDescriptorSetLayout&gt; *node;
};

</code></pre></div><h3 id="tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkdescriptorsetlayout-bool"><a href="#tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkdescriptorsetlayout-bool" class="header-anchor">#</a> <code>tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkDescriptorSetLayout&gt; &gt;,bool&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkDescriptorSetLayout&gt; &gt;,bool&gt;
{
  tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkDescriptorSetLayout&gt; &gt; first;
  bool second;
};

</code></pre></div><h3 id="tinystl-pair-unsigned-int64-bgfx-vk-vkdescriptorsetlayout"><a href="#tinystl-pair-unsigned-int64-bgfx-vk-vkdescriptorsetlayout" class="header-anchor">#</a> <code>tinystl::pair&lt;unsigned __int64,bgfx::vk::VkDescriptorSetLayout&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pair&lt;unsigned __int64,bgfx::vk::VkDescriptorSetLayout&gt;
{
  unsigned __int64 first;
  bgfx::vk::VkDescriptorSetLayout second;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkdescriptorsetlayout-const"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkdescriptorsetlayout-const" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkDescriptorSetLayout&gt; const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkDescriptorSetLayout&gt; const &gt;
{
  const tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkDescriptorSetLayout&gt; *node;
};

</code></pre></div><h3 id="tinystl-pair-unsigned-int64-bgfx-vk-vkpipeline"><a href="#tinystl-pair-unsigned-int64-bgfx-vk-vkpipeline" class="header-anchor">#</a> <code>tinystl::pair&lt;unsigned __int64,bgfx::vk::VkPipeline&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pair&lt;unsigned __int64,bgfx::vk::VkPipeline&gt;
{
  unsigned __int64 first;
  bgfx::vk::VkPipeline second;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkrenderpass-const"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkrenderpass-const" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkRenderPass&gt; const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkRenderPass&gt; const &gt;
{
  const tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkRenderPass&gt; *node;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkrenderpass"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkrenderpass" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkRenderPass&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkRenderPass&gt; &gt;
{
  tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkRenderPass&gt; *node;
};

</code></pre></div><h3 id="tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vksampler-1"><a href="#tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vksampler-1" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkSampler&gt; *,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkSampler&gt; *,1&gt;
{
};

</code></pre></div><h3 id="tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkrenderpass-bool"><a href="#tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkrenderpass-bool" class="header-anchor">#</a> <code>tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkRenderPass&gt; &gt;,bool&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkRenderPass&gt; &gt;,bool&gt;
{
  tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkRenderPass&gt; &gt; first;
  bool second;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkpipeline-const"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkpipeline-const" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkPipeline&gt; const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkPipeline&gt; const &gt;
{
  const tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkPipeline&gt; *node;
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkpipeline"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkpipeline" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkPipeline&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkPipeline&gt; &gt;
{
  tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkPipeline&gt; *node;
};

</code></pre></div><h3 id="tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkpipeline-bool"><a href="#tinystl-pair-tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkpipeline-bool" class="header-anchor">#</a> <code>tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkPipeline&gt; &gt;,bool&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) tinystl::pair&lt;tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkPipeline&gt; &gt;,bool&gt;
{
  tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkPipeline&gt; &gt; first;
  bool second;
};

</code></pre></div><h3 id="tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkpipeline-1"><a href="#tinystl-pod-traits-tinystl-unordered-hash-node-unsigned-int64-bgfx-vk-vkpipeline-1" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkPipeline&gt; *,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;unsigned __int64,bgfx::vk::VkPipeline&gt; *,1&gt;
{
};

</code></pre></div><h3 id="tinystl-unordered-hash-node-tinystl-stringt-bgfx-tinystlallocator-unsigned-int"><a href="#tinystl-unordered-hash-node-tinystl-stringt-bgfx-tinystlallocator-unsigned-int" class="header-anchor">#</a> <code>tinystl::unordered_hash_node&lt;tinystl::stringT&lt;bgfx::TinyStlAllocator&gt;,unsigned int&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_node&lt;tinystl::stringT&lt;bgfx::TinyStlAllocator&gt;,unsigned int&gt;
{
  const tinystl::stringT&lt;bgfx::TinyStlAllocator&gt; first;
  unsigned int second;
  tinystl::unordered_hash_node&lt;tinystl::stringT&lt;bgfx::TinyStlAllocator&gt;,unsigned int&gt; *next;
  tinystl::unordered_hash_node&lt;tinystl::stringT&lt;bgfx::TinyStlAllocator&gt;,unsigned int&gt; *prev;
};

</code></pre></div><h3 id="tinystl-pair-tinystl-stringt-bgfx-tinystlallocator-unsigned-int"><a href="#tinystl-pair-tinystl-stringt-bgfx-tinystlallocator-unsigned-int" class="header-anchor">#</a> <code>tinystl::pair&lt;tinystl::stringT&lt;bgfx::TinyStlAllocator&gt;,unsigned int&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) tinystl::pair&lt;tinystl::stringT&lt;bgfx::TinyStlAllocator&gt;,unsigned int&gt;
{
  tinystl::stringT&lt;bgfx::TinyStlAllocator&gt; first;
  unsigned int second;
};

</code></pre></div><h3 id="tinystl-pod-traits-tinystl-unordered-hash-node-tinystl-stringt-bgfx-tinystlallocator-unsigned-int-1"><a href="#tinystl-pod-traits-tinystl-unordered-hash-node-tinystl-stringt-bgfx-tinystlallocator-unsigned-int-1" class="header-anchor">#</a> <code>tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;tinystl::stringT&lt;bgfx::TinyStlAllocator&gt;,unsigned int&gt; *,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::pod_traits&lt;tinystl::unordered_hash_node&lt;tinystl::stringT&lt;bgfx::TinyStlAllocator&gt;,unsigned int&gt; *,1&gt;
{
};

</code></pre></div><h3 id="tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-tinystl-stringt-bgfx-tinystlallocator-unsigned-int-const"><a href="#tinystl-unordered-hash-iterator-tinystl-unordered-hash-node-tinystl-stringt-bgfx-tinystlallocator-unsigned-int-const" class="header-anchor">#</a> <code>tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;tinystl::stringT&lt;bgfx::TinyStlAllocator&gt;,unsigned int&gt; const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::unordered_hash_iterator&lt;tinystl::unordered_hash_node&lt;tinystl::stringT&lt;bgfx::TinyStlAllocator&gt;,unsigned int&gt; const &gt;
{
  const tinystl::unordered_hash_node&lt;tinystl::stringT&lt;bgfx::TinyStlAllocator&gt;,unsigned int&gt; *node;
};

</code></pre></div><h3 id="trialmanager-settrialabtest-l2-lambda-c30bbd6b5b06c9cde920159e96e64d3e-l2-lambda-eff4589c59d336c8838d8d2f4d341069"><a href="#trialmanager-settrialabtest-l2-lambda-c30bbd6b5b06c9cde920159e96e64d3e-l2-lambda-eff4589c59d336c8838d8d2f4d341069" class="header-anchor">#</a> <code>TrialManager::setTrialABTest::__l2::&lt;lambda_c30bbd6b5b06c9cde920159e96e64d3e&gt;::()::__l2::&lt;lambda_eff4589c59d336c8838d8d2f4d341069&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TrialManager::setTrialABTest::__l2::&lt;lambda_c30bbd6b5b06c9cde920159e96e64d3e&gt;::()::__l2::&lt;lambda_eff4589c59d336c8838d8d2f4d341069&gt;
{
};

</code></pre></div><h3 id="truetypefont-getsheet-l2-lambda-353d794a8b96987352e47142585db63e"><a href="#truetypefont-getsheet-l2-lambda-353d794a8b96987352e47142585db63e" class="header-anchor">#</a> <code>TrueTypeFont::getSheet::__l2::&lt;lambda_353d794a8b96987352e47142585db63e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TrueTypeFont::getSheet::__l2::&lt;lambda_353d794a8b96987352e47142585db63e&gt;
{
  TrueTypeFont *const __this;
};

</code></pre></div><h3 id="templateexportscreencontroller-picktemplateimage-l2-lambda-95e956f9c0e719a6eb64ab92ca969fed-l6-lambda-fac14e20a7e48827b06b0675210910ed"><a href="#templateexportscreencontroller-picktemplateimage-l2-lambda-95e956f9c0e719a6eb64ab92ca969fed-l6-lambda-fac14e20a7e48827b06b0675210910ed" class="header-anchor">#</a> <code>TemplateExportScreenController::_pickTemplateImage::__l2::&lt;lambda_95e956f9c0e719a6eb64ab92ca969fed&gt;::()::__l6::&lt;lambda_fac14e20a7e48827b06b0675210910ed&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TemplateExportScreenController::_pickTemplateImage::__l2::&lt;lambda_95e956f9c0e719a6eb64ab92ca969fed&gt;::()::__l6::&lt;lambda_fac14e20a7e48827b06b0675210910ed&gt;
{
  const Core::PathBuffer&lt;std::string &gt; *fileExtension;
};

</code></pre></div><h3 id="ttseventmanager-clearallttsevents-l2-lambda-166fbc57a43bf4c72b542d3926f6b284"><a href="#ttseventmanager-clearallttsevents-l2-lambda-166fbc57a43bf4c72b542d3926f6b284" class="header-anchor">#</a> <code>TTSEventManager::clearAllTTSEvents::__l2::&lt;lambda_166fbc57a43bf4c72b542d3926f6b284&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TTSEventManager::clearAllTTSEvents::__l2::&lt;lambda_166fbc57a43bf4c72b542d3926f6b284&gt;
{
};

</code></pre></div><h3 id="texturesethelpers-texturesetdefinitionparser-postvalidation-l2-lambda-ccfc458045cdb218bb681a058ac9c64c"><a href="#texturesethelpers-texturesetdefinitionparser-postvalidation-l2-lambda-ccfc458045cdb218bb681a058ac9c64c" class="header-anchor">#</a> <code>TextureSetHelpers::TextureSetDefinitionParser::_postValidation::__l2::&lt;lambda_ccfc458045cdb218bb681a058ac9c64c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TextureSetHelpers::TextureSetDefinitionParser::_postValidation::__l2::&lt;lambda_ccfc458045cdb218bb681a058ac9c64c&gt;
{
  std::unordered_set&lt;std::string&gt; *specifiedLayers;
};

</code></pre></div><h3 id="transformationcomponent-maintainolddata-l2-lambda-0ebed9bb243823bd2c6449afa59ff071"><a href="#transformationcomponent-maintainolddata-l2-lambda-0ebed9bb243823bd2c6449afa59ff071" class="header-anchor">#</a> <code>TransformationComponent::maintainOldData::__l2::&lt;lambda_0ebed9bb243823bd2c6449afa59ff071&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TransformationComponent::maintainOldData::__l2::&lt;lambda_0ebed9bb243823bd2c6449afa59ff071&gt;
{
  SynchedActorData *originalData;
  SynchedActorData *transformedData;
};

</code></pre></div><h3 id="treatmentpacksource-load-l5-lambda-b6e7809886387660f36c54eb091a8cb1-l6-lambda-c49aa7eff27558e257190c445686bc48"><a href="#treatmentpacksource-load-l5-lambda-b6e7809886387660f36c54eb091a8cb1-l6-lambda-c49aa7eff27558e257190c445686bc48" class="header-anchor">#</a> <code>TreatmentPackSource::load::__l5::&lt;lambda_b6e7809886387660f36c54eb091a8cb1&gt;::()::__l6::&lt;lambda_c49aa7eff27558e257190c445686bc48&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreatmentPackSource::load::__l5::&lt;lambda_b6e7809886387660f36c54eb091a8cb1&gt;::()::__l6::&lt;lambda_c49aa7eff27558e257190c445686bc48&gt;
{
  std::unique_ptr&lt;Pack&gt; *pack;
};

</code></pre></div><h3 id="titlerawcommand-sendtitlepackettextobject-l5-lambda-48454f3bf36a4e2de18c670fda8587c6"><a href="#titlerawcommand-sendtitlepackettextobject-l5-lambda-48454f3bf36a4e2de18c670fda8587c6" class="header-anchor">#</a> <code>TitleRawCommand::_sendTitlePacketTextObject::__l5::&lt;lambda_48454f3bf36a4e2de18c670fda8587c6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TitleRawCommand::_sendTitlePacketTextObject::__l5::&lt;lambda_48454f3bf36a4e2de18c670fda8587c6&gt;
{
};

</code></pre></div><h3 id="tellrawcommand-execute-l14-lambda-90cef47ec8b6c76c849ede2c103fd1bf"><a href="#tellrawcommand-execute-l14-lambda-90cef47ec8b6c76c849ede2c103fd1bf" class="header-anchor">#</a> <code>TellRawCommand::execute::__l14::&lt;lambda_90cef47ec8b6c76c849ede2c103fd1bf&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TellRawCommand::execute::__l14::&lt;lambda_90cef47ec8b6c76c849ede2c103fd1bf&gt;
{
};

</code></pre></div><h3 id="titlerawcommand-execute-l2-lambda-5b9cafa6ff6d46b3d004c39e0990394f"><a href="#titlerawcommand-execute-l2-lambda-5b9cafa6ff6d46b3d004c39e0990394f" class="header-anchor">#</a> <code>TitleRawCommand::execute::__l2::&lt;lambda_5b9cafa6ff6d46b3d004c39e0990394f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TitleRawCommand::execute::__l2::&lt;lambda_5b9cafa6ff6d46b3d004c39e0990394f&gt;
{
  const TitleRawCommand *const __this;
  const CommandOrigin *origin;
  CommandSelectorResults&lt;Player&gt; *targets;
};

</code></pre></div><h3 id="tagcommand-listtags-l2-lambda-c84dc9b6a1b3669bc322e4aa9ab60776"><a href="#tagcommand-listtags-l2-lambda-c84dc9b6a1b3669bc322e4aa9ab60776" class="header-anchor">#</a> <code>TagCommand::_listTags::__l2::&lt;lambda_c84dc9b6a1b3669bc322e4aa9ab60776&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TagCommand::_listTags::__l2::&lt;lambda_c84dc9b6a1b3669bc322e4aa9ab60776&gt;
{
};

</code></pre></div><h3 id="textobjectparser-parseselectortextobject-l2-lambda-5827802121b532aadf729a581dac69a9"><a href="#textobjectparser-parseselectortextobject-l2-lambda-5827802121b532aadf729a581dac69a9" class="header-anchor">#</a> <code>TextObjectParser::_parseSelectorTextObject::__l2::&lt;lambda_5827802121b532aadf729a581dac69a9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TextObjectParser::_parseSelectorTextObject::__l2::&lt;lambda_5827802121b532aadf729a581dac69a9&gt;
{
};

</code></pre></div><h3 id="tropicalfish-updateentityspecificmolangvariables-l2-lambda-153bf7c72ef5d891dfc82eaf261a9098-l2-literal"><a href="#tropicalfish-updateentityspecificmolangvariables-l2-lambda-153bf7c72ef5d891dfc82eaf261a9098-l2-literal" class="header-anchor">#</a> <code>TropicalFish::updateEntitySpecificMolangVariables::__l2::&lt;lambda_153bf7c72ef5d891dfc82eaf261a9098&gt;::()::__l2::Literal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TropicalFish::updateEntitySpecificMolangVariables::__l2::&lt;lambda_153bf7c72ef5d891dfc82eaf261a9098&gt;::()::__l2::Literal
{
};

</code></pre></div><h3 id="tropicalfish-updateentityspecificmolangvariables-l2-lambda-4d52faecc4bfe184f922644e28fd1416-l2-literal"><a href="#tropicalfish-updateentityspecificmolangvariables-l2-lambda-4d52faecc4bfe184f922644e28fd1416-l2-literal" class="header-anchor">#</a> <code>TropicalFish::updateEntitySpecificMolangVariables::__l2::&lt;lambda_4d52faecc4bfe184f922644e28fd1416&gt;::()::__l2::Literal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TropicalFish::updateEntitySpecificMolangVariables::__l2::&lt;lambda_4d52faecc4bfe184f922644e28fd1416&gt;::()::__l2::Literal
{
};

</code></pre></div><h3 id="tropicalfish-updateentityspecificmolangvariables-l2-lambda-2676d2d87e2d93db1c35d755ebed2598-l2-literal"><a href="#tropicalfish-updateentityspecificmolangvariables-l2-lambda-2676d2d87e2d93db1c35d755ebed2598-l2-literal" class="header-anchor">#</a> <code>TropicalFish::updateEntitySpecificMolangVariables::__l2::&lt;lambda_2676d2d87e2d93db1c35d755ebed2598&gt;::()::__l2::Literal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TropicalFish::updateEntitySpecificMolangVariables::__l2::&lt;lambda_2676d2d87e2d93db1c35d755ebed2598&gt;::()::__l2::Literal
{
};

</code></pre></div><h3 id="tropicalfish-updateentityspecificmolangvariables-l2-lambda-153bf7c72ef5d891dfc82eaf261a9098"><a href="#tropicalfish-updateentityspecificmolangvariables-l2-lambda-153bf7c72ef5d891dfc82eaf261a9098" class="header-anchor">#</a> <code>TropicalFish::updateEntitySpecificMolangVariables::__l2::&lt;lambda_153bf7c72ef5d891dfc82eaf261a9098&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TropicalFish::updateEntitySpecificMolangVariables::__l2::&lt;lambda_153bf7c72ef5d891dfc82eaf261a9098&gt;
{
};

</code></pre></div><h3 id="tropicalfish-updateentityspecificmolangvariables-l2-lambda-2676d2d87e2d93db1c35d755ebed2598"><a href="#tropicalfish-updateentityspecificmolangvariables-l2-lambda-2676d2d87e2d93db1c35d755ebed2598" class="header-anchor">#</a> <code>TropicalFish::updateEntitySpecificMolangVariables::__l2::&lt;lambda_2676d2d87e2d93db1c35d755ebed2598&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TropicalFish::updateEntitySpecificMolangVariables::__l2::&lt;lambda_2676d2d87e2d93db1c35d755ebed2598&gt;
{
};

</code></pre></div><h3 id="tropicalfish-updateentityspecificmolangvariables-l2-lambda-4d52faecc4bfe184f922644e28fd1416"><a href="#tropicalfish-updateentityspecificmolangvariables-l2-lambda-4d52faecc4bfe184f922644e28fd1416" class="header-anchor">#</a> <code>TropicalFish::updateEntitySpecificMolangVariables::__l2::&lt;lambda_4d52faecc4bfe184f922644e28fd1416&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TropicalFish::updateEntitySpecificMolangVariables::__l2::&lt;lambda_4d52faecc4bfe184f922644e28fd1416&gt;
{
};

</code></pre></div><h3 id="tripodcamera-updateentityspecificmolangvariables-l2-lambda-b93ca8c09ad5ed9c2d4ef65764501a75-l2-literal"><a href="#tripodcamera-updateentityspecificmolangvariables-l2-lambda-b93ca8c09ad5ed9c2d4ef65764501a75-l2-literal" class="header-anchor">#</a> <code>TripodCamera::updateEntitySpecificMolangVariables::__l2::&lt;lambda_b93ca8c09ad5ed9c2d4ef65764501a75&gt;::()::__l2::Literal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TripodCamera::updateEntitySpecificMolangVariables::__l2::&lt;lambda_b93ca8c09ad5ed9c2d4ef65764501a75&gt;::()::__l2::Literal
{
};

</code></pre></div><h3 id="tripodcamera-updateentityspecificmolangvariables-l2-lambda-b93ca8c09ad5ed9c2d4ef65764501a75"><a href="#tripodcamera-updateentityspecificmolangvariables-l2-lambda-b93ca8c09ad5ed9c2d4ef65764501a75" class="header-anchor">#</a> <code>TripodCamera::updateEntitySpecificMolangVariables::__l2::&lt;lambda_b93ca8c09ad5ed9c2d4ef65764501a75&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TripodCamera::updateEntitySpecificMolangVariables::__l2::&lt;lambda_b93ca8c09ad5ed9c2d4ef65764501a75&gt;
{
};

</code></pre></div><h3 id="tickingareasmanager-processadds-l4-lambda-63152a68d4422458414da9e103d40c16"><a href="#tickingareasmanager-processadds-l4-lambda-63152a68d4422458414da9e103d40c16" class="header-anchor">#</a> <code>TickingAreasManager::_processAdds::__l4::&lt;lambda_63152a68d4422458414da9e103d40c16&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TickingAreasManager::_processAdds::__l4::&lt;lambda_63152a68d4422458414da9e103d40c16&gt;
{
};

</code></pre></div><h3 id="tickingareasmanager-processadds-l7-lambda-e901f167a717222a1fd8ef2ad4565724"><a href="#tickingareasmanager-processadds-l7-lambda-e901f167a717222a1fd8ef2ad4565724" class="header-anchor">#</a> <code>TickingAreasManager::_processAdds::__l7::&lt;lambda_e901f167a717222a1fd8ef2ad4565724&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TickingAreasManager::_processAdds::__l7::&lt;lambda_e901f167a717222a1fd8ef2ad4565724&gt;
{
};

</code></pre></div><h3 id="tickingareasmanager-requeueentityarea-l2-lambda-09aa79e11f608c65fa6ce4e15589cb72"><a href="#tickingareasmanager-requeueentityarea-l2-lambda-09aa79e11f608c65fa6ce4e15589cb72" class="header-anchor">#</a> <code>TickingAreasManager::_requeueEntityArea::__l2::&lt;lambda_09aa79e11f608c65fa6ce4e15589cb72&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TickingAreasManager::_requeueEntityArea::__l2::&lt;lambda_09aa79e11f608c65fa6ce4e15589cb72&gt;
{
  const ActorUniqueID *entityId;
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-f533ab86d1884dfcc519909eacc041e1-l2-literal"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-f533ab86d1884dfcc519909eacc041e1-l2-literal" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_f533ab86d1884dfcc519909eacc041e1&gt;::()::__l2::Literal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_f533ab86d1884dfcc519909eacc041e1&gt;::()::__l2::Literal
{
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-f533ab86d1884dfcc519909eacc041e1"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-f533ab86d1884dfcc519909eacc041e1" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_f533ab86d1884dfcc519909eacc041e1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_f533ab86d1884dfcc519909eacc041e1&gt;
{
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-316bfc304bdbebc8fca92470bfb64ac8-l2-literal"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-316bfc304bdbebc8fca92470bfb64ac8-l2-literal" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_316bfc304bdbebc8fca92470bfb64ac8&gt;::()::__l2::Literal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_316bfc304bdbebc8fca92470bfb64ac8&gt;::()::__l2::Literal
{
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-316bfc304bdbebc8fca92470bfb64ac8"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-316bfc304bdbebc8fca92470bfb64ac8" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_316bfc304bdbebc8fca92470bfb64ac8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_316bfc304bdbebc8fca92470bfb64ac8&gt;
{
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-c210cc24a08cbb4b0a1f4a27569b8da3-l2-literal"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-c210cc24a08cbb4b0a1f4a27569b8da3-l2-literal" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_c210cc24a08cbb4b0a1f4a27569b8da3&gt;::()::__l2::Literal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_c210cc24a08cbb4b0a1f4a27569b8da3&gt;::()::__l2::Literal
{
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-c210cc24a08cbb4b0a1f4a27569b8da3"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-c210cc24a08cbb4b0a1f4a27569b8da3" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_c210cc24a08cbb4b0a1f4a27569b8da3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_c210cc24a08cbb4b0a1f4a27569b8da3&gt;
{
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-0cdc4f7a090cfec7fa19fe15fd63dac7-l2-literal"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-0cdc4f7a090cfec7fa19fe15fd63dac7-l2-literal" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_0cdc4f7a090cfec7fa19fe15fd63dac7&gt;::()::__l2::Literal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_0cdc4f7a090cfec7fa19fe15fd63dac7&gt;::()::__l2::Literal
{
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-0cdc4f7a090cfec7fa19fe15fd63dac7"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-0cdc4f7a090cfec7fa19fe15fd63dac7" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_0cdc4f7a090cfec7fa19fe15fd63dac7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_0cdc4f7a090cfec7fa19fe15fd63dac7&gt;
{
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-06388885ee2d8055895fa3b9a937a087-l2-literal"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-06388885ee2d8055895fa3b9a937a087-l2-literal" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_06388885ee2d8055895fa3b9a937a087&gt;::()::__l2::Literal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_06388885ee2d8055895fa3b9a937a087&gt;::()::__l2::Literal
{
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-06388885ee2d8055895fa3b9a937a087"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-06388885ee2d8055895fa3b9a937a087" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_06388885ee2d8055895fa3b9a937a087&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_06388885ee2d8055895fa3b9a937a087&gt;
{
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-d3254b4d25ff1821a3cd24c1d807c792-l2-literal"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-d3254b4d25ff1821a3cd24c1d807c792-l2-literal" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_d3254b4d25ff1821a3cd24c1d807c792&gt;::()::__l2::Literal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_d3254b4d25ff1821a3cd24c1d807c792&gt;::()::__l2::Literal
{
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-d3254b4d25ff1821a3cd24c1d807c792"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-d3254b4d25ff1821a3cd24c1d807c792" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_d3254b4d25ff1821a3cd24c1d807c792&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_d3254b4d25ff1821a3cd24c1d807c792&gt;
{
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-244d7cc81ad86e682410034be2e19209-l2-literal"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-244d7cc81ad86e682410034be2e19209-l2-literal" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_244d7cc81ad86e682410034be2e19209&gt;::()::__l2::Literal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_244d7cc81ad86e682410034be2e19209&gt;::()::__l2::Literal
{
};

</code></pre></div><h3 id="treehelper-attachabledecoration-buildschema-l2-lambda-244d7cc81ad86e682410034be2e19209"><a href="#treehelper-attachabledecoration-buildschema-l2-lambda-244d7cc81ad86e682410034be2e19209" class="header-anchor">#</a> <code>TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_244d7cc81ad86e682410034be2e19209&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::AttachableDecoration::buildSchema::__l2::&lt;lambda_244d7cc81ad86e682410034be2e19209&gt;
{
};

</code></pre></div><h3 id="treehelper-treeparams-buildschema-l2-lambda-8fc19ea07e2c80707579cacdb274625e-l2-literal"><a href="#treehelper-treeparams-buildschema-l2-lambda-8fc19ea07e2c80707579cacdb274625e-l2-literal" class="header-anchor">#</a> <code>TreeHelper::TreeParams::buildSchema::__l2::&lt;lambda_8fc19ea07e2c80707579cacdb274625e&gt;::()::__l2::Literal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::TreeParams::buildSchema::__l2::&lt;lambda_8fc19ea07e2c80707579cacdb274625e&gt;::()::__l2::Literal
{
};

</code></pre></div><h3 id="treehelper-treeparams-buildschema-l2-lambda-8fc19ea07e2c80707579cacdb274625e"><a href="#treehelper-treeparams-buildschema-l2-lambda-8fc19ea07e2c80707579cacdb274625e" class="header-anchor">#</a> <code>TreeHelper::TreeParams::buildSchema::__l2::&lt;lambda_8fc19ea07e2c80707579cacdb274625e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TreeHelper::TreeParams::buildSchema::__l2::&lt;lambda_8fc19ea07e2c80707579cacdb274625e&gt;
{
};

</code></pre></div><h3 id="touchmapper-tick-l4-lambda-dee5fc28587d2581bc2aae741d21bd8b"><a href="#touchmapper-tick-l4-lambda-dee5fc28587d2581bc2aae741d21bd8b" class="header-anchor">#</a> <code>TouchMapper::tick::__l4::&lt;lambda_dee5fc28587d2581bc2aae741d21bd8b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj TouchMapper::tick::__l4::&lt;lambda_dee5fc28587d2581bc2aae741d21bd8b&gt;
{
  int p;
};

</code></pre></div><h3 id="tencoding"><a href="#tencoding" class="header-anchor">#</a> <code>TEncoding_</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct TEncoding_
{
  int platform_id;
  int encoding_id;
  FT_Encoding_ encoding;
};

</code></pre></div><h3 id="tinystl-list-bgfx-nonlocalallocator-free-bgfx-tinystlallocator-sort-l2-lambda-2ab4b9f78ebe988ca785909f38c65d48"><a href="#tinystl-list-bgfx-nonlocalallocator-free-bgfx-tinystlallocator-sort-l2-lambda-2ab4b9f78ebe988ca785909f38c65d48" class="header-anchor">#</a> <code>tinystl::list&lt;bgfx::NonLocalAllocator::Free,bgfx::TinyStlAllocator&gt;::sort::__l2::&lt;lambda_2ab4b9f78ebe988ca785909f38c65d48&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj tinystl::list&lt;bgfx::NonLocalAllocator::Free,bgfx::TinyStlAllocator&gt;::sort::__l2::&lt;lambda_2ab4b9f78ebe988ca785909f38c65d48&gt;
{
};

</code></pre></div><h3 id="togglecomponent-vtbl"><a href="#togglecomponent-vtbl" class="header-anchor">#</a> <code>ToggleComponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ToggleComponent_vtbl
{
  void (__fastcall *~UIComponent)(UIComponent *this);
  void (__fastcall *OnScreenPop)(UIComponent *this);
  std::unique_ptr&lt;UIComponent&gt; *(__fastcall *clone)(UIComponent *this, std::unique_ptr&lt;UIComponent&gt; *result, UIControl *);
  ComponentReceiveActionType (__fastcall *receive)(UIComponent *this, const ScreenEvent *);
  ComponentReceiveActionType (__fastcall *receive)(UIComponent *this, VisualTree *, ScreenInputContext *, UIAnimationController *, const ScreenEvent *);
  void (__fastcall *onNotifyChildAdded)(UIComponent *this);
  void (__fastcall *onNotifyChildRemoved)(UIComponent *this);
  void (__fastcall *onRemoved)(UIComponent *this);
  void (__fastcall *onAdded)(UIComponent *this);
  void (__fastcall *onVisibilityChanged)(UIComponent *this, bool);
  void (__fastcall *onEnabledChanged)(UIComponent *this, bool);
  bool (__fastcall *isRenderableComponent)(UIComponent *this);
  bool (__fastcall *onLayoutChange)(UIComponent *this);
  void (__fastcall *reset)(UIComponent *this);
  void (__fastcall *reload)(UIComponent *this, const UIComponent *);
  const std::string *(__fastcall *getTextToSpeechComponentValue)(UIComponent *this);
};

</code></pre></div><h3 id="tripodcamera-vtbl"><a href="#tripodcamera-vtbl" class="header-anchor">#</a> <code>TripodCamera_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TripodCamera_vtbl
{
  bool (__fastcall *hasComponent)(Actor *this, const HashedString *);
  void (__fastcall *reloadHardcoded)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadHardcodedClient)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *initializeComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *_serverInitItemStackIds)(Actor *this);
  void (__fastcall *_doInitialMove)(Actor *this);
  bool (__fastcall *checkAllSensitiveWords)(Actor *this);
  bool (__fastcall *checkNameTag)(Actor *this);
  void (__fastcall *~Actor)(Actor *this);
  void (__fastcall *reset)(Actor *this);
  int (__fastcall *getOnDeathExperience)(Actor *this);
  ActorType (__fastcall *getOwnerEntityType)(Actor *this);
  void (__fastcall *remove)(Actor *this);
  void (__fastcall *setPos)(Actor *this, const Vec3 *);
  const PredictedMovementValues *(__fastcall *getPredictedMovementValues)(Actor *this);
  const Vec3 *(__fastcall *getPos)(Actor *this);
  const Vec3 *(__fastcall *getPosOld)(Actor *this);
  const Vec3 *(__fastcall *getPosExtrapolated)(Actor *this, const Vec3 *result, float);
  Vec3 *(__fastcall *getAttachPos)(Actor *this, Vec3 *result, ActorLocation, float);
  Vec3 *(__fastcall *getFiringPos)(Actor *this, Vec3 *result);
  void (__fastcall *setRot)(Actor *this, const Vec2 *);
  void (__fastcall *move)(Actor *this, IActorMovementProxy *, const Vec3 *);
  void (__fastcall *move)(Actor *this, const Vec3 *);
  Vec3 *(__fastcall *getInterpolatedRidingPosition)(Actor *this, Vec3 *result, float);
  float (__fastcall *getInterpolatedBodyRot)(Actor *this, float);
  float (__fastcall *getInterpolatedHeadRot)(Actor *this, float);
  float (__fastcall *getInterpolatedBodyYaw)(Actor *this, float);
  float (__fastcall *getYawSpeedInDegreesPerSecond)(Actor *this);
  float (__fastcall *getInterpolatedWalkAnimSpeed)(Actor *this, float);
  Vec3 *(__fastcall *getInterpolatedRidingOffset)(Actor *this, Vec3 *result, float);
  void (__fastcall *checkBlockCollisions)(Actor *this);
  void (__fastcall *checkBlockCollisions)(Actor *this, const AABB *, std::function&lt;void __cdecl(BlockSource &amp;,Block const &amp;,BlockPos const &amp;,Actor &amp;)&gt;);
  bool (__fastcall *isFireImmune)(Actor *this);
  bool (__fastcall *breaksFallingBlocks)(Actor *this);
  void (__fastcall *blockedByShield)(Actor *this, const ActorDamageSource *, Actor *);
  void (__fastcall *teleportTo)(Actor *this, const Vec3 *, bool, int, int, const ActorUniqueID *);
  bool (__fastcall *tryTeleportTo)(Actor *this, const Vec3 *, bool, bool, int, int);
  void (__fastcall *chorusFruitTeleport)(Actor *this, Vec3 *);
  void (__fastcall *lerpTo)(Actor *this, const Vec3 *, const Vec2 *, int);
  void (__fastcall *lerpMotion)(Actor *this, const Vec3 *);
  std::unique_ptr&lt;AddActorBasePacket&gt; *(__fastcall *getAddPacket)(Actor *this, std::unique_ptr&lt;AddActorBasePacket&gt; *result);
  void (__fastcall *normalTick)(Actor *this);
  void (__fastcall *baseTick)(Actor *this);
  void (__fastcall *rideTick)(Actor *this);
  void (__fastcall *positionRider)(Actor *this, Actor *, float);
  float (__fastcall *getRidingHeight)(Actor *this);
  bool (__fastcall *startRiding)(Actor *this, Actor *);
  void (__fastcall *addRider)(Actor *this, Actor *);
  void (__fastcall *flagRiderToRemove)(Actor *this, Actor *);
  std::string *(__fastcall *getExitTip)(Actor *this, std::string *result, const std::string *, InputMode);
  bool (__fastcall *intersects)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *, float);
  bool (__fastcall *isInWall)(Actor *this);
  bool (__fastcall *isInvisible)(Actor *this);
  bool (__fastcall *canShowNameTag)(Actor *this);
  bool (__fastcall *canExistInPeaceful)(Actor *this);
  void (__fastcall *setNameTagVisible)(Actor *this, bool);
  const std::string *(__fastcall *getNameTag)(Actor *this);
  unsigned __int64 (__fastcall *getNameTagAsHash)(Actor *this);
  std::string *(__fastcall *getFormattedNameTag)(Actor *this, std::string *result);
  void (__fastcall *filterFormattedNameTag)(Actor *this, const UIProfanityContext *);
  void (__fastcall *setNameTag)(Actor *this, const std::string *);
  bool (__fastcall *getAlwaysShowNameTag)(Actor *this);
  void (__fastcall *setScoreTag)(Actor *this, const std::string *);
  const std::string *(__fastcall *getScoreTag)(Actor *this);
  bool (__fastcall *isInWater)(Actor *this);
  bool (__fastcall *hasEnteredWater)(Actor *this);
  bool (__fastcall *isImmersedInWater)(Actor *this);
  bool (__fastcall *isInWaterOrRain)(Actor *this);
  bool (__fastcall *isInLava)(Actor *this);
  bool (__fastcall *isUnderLiquid)(Actor *this, MaterialType);
  bool (__fastcall *isOverWater)(Actor *this);
  void (__fastcall *makeStuckInBlock)(Actor *this, const Vec3 *);
  float (__fastcall *getCameraOffset)(Actor *this);
  float (__fastcall *getShadowHeightOffs)(Actor *this);
  float (__fastcall *getShadowRadius)(Actor *this);
  Vec3 *(__fastcall *getHeadLookVector)(Actor *this, Vec3 *result, float);
  bool (__fastcall *canSeeInvisible)(Actor *this);
  bool (__fastcall *canSee)(Actor *this, const Vec3 *);
  bool (__fastcall *canSee)(Actor *this, const Actor *);
  bool (__fastcall *isSkyLit)(Actor *this, float);
  float (__fastcall *getBrightness)(Actor *this, float);
  bool (__fastcall *interactPreventDefault)(Actor *this);
  void (__fastcall *playerTouch)(Actor *this, Player *);
  void (__fastcall *onAboveBubbleColumn)(Actor *this, const bool);
  void (__fastcall *onInsideBubbleColumn)(Actor *this, const bool);
  bool (__fastcall *isImmobile)(Actor *this);
  bool (__fastcall *isSilent)(Actor *this);
  bool (__fastcall *isPickable)(Actor *this);
  bool (__fastcall *isFishable)(Actor *this);
  bool (__fastcall *isSleeping)(Actor *this);
  bool (__fastcall *isShootable)(Actor *this);
  void (__fastcall *setSneaking)(Actor *this, bool);
  bool (__fastcall *isBlocking)(Actor *this);
  bool (__fastcall *isDamageBlocked)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *isAlive)(Actor *this);
  bool (__fastcall *isOnFire)(Actor *this);
  bool (__fastcall *isOnHotBlock)(Actor *this);
  bool (__fastcall *isCreativeModeAllowed)(Actor *this);
  bool (__fastcall *isSurfaceMob)(Actor *this);
  bool (__fastcall *isTargetable)(Actor *this);
  bool (__fastcall *isLocalPlayer)(Actor *this);
  bool (__fastcall *isPlayer)(Actor *this);
  bool (__fastcall *canAttack)(Actor *this, Actor *, bool);
  void (__fastcall *setTarget)(Actor *this, Actor *);
  Actor *(__fastcall *findAttackTarget)(Actor *this);
  bool (__fastcall *isValidTarget)(Actor *this, Actor *);
  bool (__fastcall *attack)(Actor *this, Actor *);
  void (__fastcall *performRangedAttack)(Actor *this, Actor *, float);
  void (__fastcall *adjustDamageAmount)(Actor *this, int *);
  int (__fastcall *getEquipmentCount)(Actor *this);
  void (__fastcall *setOwner)(Actor *this, const ActorUniqueID);
  void (__fastcall *setSitting)(Actor *this, bool);
  void (__fastcall *onTame)(Actor *this);
  void (__fastcall *onFailedTame)(Actor *this);
  int (__fastcall *getInventorySize)(Actor *this);
  int (__fastcall *getEquipSlots)(Actor *this);
  int (__fastcall *getChestSlots)(Actor *this);
  void (__fastcall *setStanding)(Actor *this, bool);
  bool (__fastcall *canPowerJump)(Actor *this);
  void (__fastcall *setCanPowerJump)(Actor *this, bool);
  bool (__fastcall *isJumping)(Actor *this);
  bool (__fastcall *isEnchanted)(Actor *this);
  void (__fastcall *rideJumped)(Actor *this);
  void (__fastcall *rideLanded)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *shouldRender)(Actor *this);
  bool (__fastcall *isInvulnerableTo)(Actor *this, const ActorDamageSource *);
  ActorDamageCause (__fastcall *getBlockDamageCause)(Actor *this, const Block *);
  void (__fastcall *actuallyHurt)(Actor *this, int, const ActorDamageSource *, bool);
  void (__fastcall *animateHurt)(Actor *this);
  bool (__fastcall *doFireHurt)(Actor *this, int);
  void (__fastcall *onLightningHit)(Actor *this);
  void (__fastcall *onBounceStarted)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *feed)(Actor *this, int);
  void (__fastcall *handleEntityEvent)(Actor *this, ActorEvent, int);
  float (__fastcall *getPickRadius)(Actor *this);
  const HashedString *(__fastcall *getActorRendererId)(Actor *this);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const ItemStack *, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int);
  void (__fastcall *despawn)(Actor *this);
  void (__fastcall *killed)(Actor *this, Actor *);
  void (__fastcall *awardKillScore)(Actor *this, Actor *, int);
  void (__fastcall *setArmor)(Actor *this, ArmorSlot, const ItemStack *);
  const ItemStack *(__fastcall *getArmor)(Actor *this, ArmorSlot);
  ArmorMaterialType (__fastcall *getArmorMaterialTypeInSlot)(Actor *this, ArmorSlot);
  ArmorTextureType (__fastcall *getArmorMaterialTextureTypeInSlot)(Actor *this, ArmorSlot);
  float (__fastcall *getArmorColorInSlot)(Actor *this, ArmorSlot, int);
  const ItemStack *(__fastcall *getEquippedSlot)(Actor *this, EquipmentSlot);
  void (__fastcall *setEquippedSlot)(Actor *this, EquipmentSlot, const ItemStack *);
  const ItemStack *(__fastcall *getCarriedItem)(Actor *this);
  void (__fastcall *setCarriedItem)(Actor *this, const ItemStack *);
  void (__fastcall *setOffhandSlot)(Actor *this, const ItemStack *);
  const ItemStack *(__fastcall *getEquippedTotem)(Actor *this);
  bool (__fastcall *consumeTotem)(Actor *this);
  bool (__fastcall *save)(Actor *this, CompoundTag *);
  void (__fastcall *saveWithoutId)(Actor *this, CompoundTag *);
  bool (__fastcall *load)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *loadLinks)(Actor *this, const CompoundTag *, std::vector&lt;ActorLink&gt; *, DataLoadHelper *);
  ActorType (__fastcall *getEntityTypeId)(Actor *this);
  const HashedString *(__fastcall *queryEntityRenderer)(Actor *this);
  ActorUniqueID *(__fastcall *getSourceUniqueID)(Actor *this, ActorUniqueID *result);
  void (__fastcall *setOnFire)(Actor *this, int);
  AABB *(__fastcall *getHandleWaterAABB)(Actor *this, AABB *result);
  void (__fastcall *handleInsidePortal)(Actor *this, const BlockPos *);
  int (__fastcall *getPortalCooldown)(Actor *this);
  int (__fastcall *getPortalWaitTime)(Actor *this);
  AutomaticID&lt;Dimension,int&gt; *(__fastcall *getDimensionId)(Actor *this, AutomaticID&lt;Dimension,int&gt; *result);
  bool (__fastcall *canChangeDimensions)(Actor *this);
  void (__fastcall *changeDimension)(Actor *this, const ChangeDimensionPacket *);
  void (__fastcall *changeDimension)(Actor *this, AutomaticID&lt;Dimension,int&gt;, bool);
  ActorUniqueID *(__fastcall *getControllingPlayer)(Actor *this, ActorUniqueID *result);
  void (__fastcall *checkFallDamage)(Actor *this, float, bool);
  void (__fastcall *causeFallDamage)(Actor *this, float);
  void (__fastcall *handleFallDistanceOnServer)(Actor *this, float, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, int, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, const Block *, bool);
  void (__fastcall *onSynchedDataUpdate)(Actor *this, int);
  bool (__fastcall *canAddRider)(Actor *this, Actor *);
  bool (__fastcall *canPickupItem)(Actor *this, const ItemStack *);
  bool (__fastcall *canBePulledIntoVehicle)(Actor *this);
  bool (__fastcall *inCaravan)(Actor *this);
  bool (__fastcall *isLeashableType)(Actor *this);
  void (__fastcall *tickLeash)(Actor *this);
  void (__fastcall *sendMotionPacketIfNeeded)(Actor *this);
  bool (__fastcall *canSynchronizeNewEntity)(Actor *this);
  bool (__fastcall *stopRiding)(Actor *this, bool, bool, bool, bool);
  void (__fastcall *startSwimming)(Actor *this);
  void (__fastcall *stopSwimming)(Actor *this);
  void (__fastcall *buildDebugInfo)(Actor *this, std::string *);
  CommandPermissionLevel (__fastcall *getCommandPermissionLevel)(Actor *this);
  AttributeInstance *(__fastcall *getMutableAttribute)(Actor *this, const Attribute *);
  const AttributeInstance *(__fastcall *getAttribute)(Actor *this, const Attribute *);
  int (__fastcall *getDeathTime)(Actor *this);
  void (__fastcall *heal)(Actor *this, int);
  bool (__fastcall *isInvertedHealAndHarm)(Actor *this);
  bool (__fastcall *canBeAffected)(Actor *this, const MobEffectInstance *);
  bool (__fastcall *canBeAffected)(Actor *this, int);
  bool (__fastcall *canBeAffectedByArrow)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectAdded)(Actor *this, MobEffectInstance *);
  void (__fastcall *onEffectUpdated)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectRemoved)(Actor *this, MobEffectInstance *);
  AnimationComponent *(__fastcall *getAnimationComponent)(Actor *this);
  void (__fastcall *openContainerComponent)(Actor *this, Player *);
  void (__fastcall *swing)(Actor *this);
  void (__fastcall *useItem)(Actor *this, ItemStackBase *, ItemUseMethod, bool);
  bool (__fastcall *hasOutputSignal)(Actor *this, unsigned __int8);
  int (__fastcall *getOutputSignal)(Actor *this);
  void (__fastcall *getDebugText)(Actor *this, std::vector&lt;std::string&gt; *);
  float (__fastcall *getMapDecorationRotation)(Actor *this);
  float (__fastcall *getRiderYRotation)(Actor *this, const Actor *);
  float (__fastcall *getYHeadRot)(Actor *this);
  bool (__fastcall *isWorldBuilder)(Actor *this);
  bool (__fastcall *isCreative)(Actor *this);
  bool (__fastcall *isAdventure)(Actor *this);
  bool (__fastcall *add)(Actor *this, ItemStack *);
  bool (__fastcall *drop)(Actor *this, const ItemStack *, bool);
  bool (__fastcall *getInteraction)(Actor *this, Player *, ActorInteraction *, const Vec3 *);
  bool (__fastcall *canDestroyBlock)(Actor *this, const Block *);
  void (__fastcall *setAuxValue)(Actor *this, int);
  void (__fastcall *setSize)(Actor *this, float, float);
  int (__fastcall *getLifeSpan)(Actor *this);
  void (__fastcall *onOrphan)(Actor *this);
  void (__fastcall *wobble)(Actor *this);
  bool (__fastcall *wasHurt)(Actor *this);
  void (__fastcall *startSpinAttack)(Actor *this);
  void (__fastcall *stopSpinAttack)(Actor *this);
  void (__fastcall *setDamageNearbyMobs)(Actor *this, bool);
  bool (__fastcall *hasCritBox)(Actor *this);
  bool (__fastcall *isCritHit)(Actor *this);
  void (__fastcall *renderDebugServerState)(Actor *this, const Options *);
  void (__fastcall *reloadLootTable)(Actor *this, const EquipmentTableDefinition *);
  void (__fastcall *reloadLootTable)(Actor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(Actor *this);
  void (__fastcall *kill)(Actor *this);
  void (__fastcall *die)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *shouldTick)(Actor *this);
  std::shared_ptr&lt;IActorMovementProxy&gt; *(__fastcall *createMovementProxy)(Actor *this, std::shared_ptr&lt;IActorMovementProxy&gt; *result);
  void (__fastcall *updateEntitySpecificMolangVariables)(Actor *this, RenderParams *);
  bool (__fastcall *shouldTryMakeStepSound)(Actor *this);
  float (__fastcall *getNextStep)(Actor *this, const float);
  bool (__fastcall *canMakeStepSound)(Actor *this);
  void (__fastcall *outOfWorld)(Actor *this);
  bool (__fastcall *_hurt)(Actor *this, const ActorDamageSource *, int, bool, bool);
  void (__fastcall *markHurt)(Actor *this);
  void (__fastcall *readAdditionalSaveData)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *addAdditionalSaveData)(Actor *this, CompoundTag *);
  void (__fastcall *_playStepSound)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *_playFlySound)(Actor *this, const BlockPos *, const Block *);
  bool (__fastcall *_makeFlySound)(Actor *this);
  void (__fastcall *checkInsideBlocks)(Actor *this, float);
  void (__fastcall *pushOutOfBlocks)(Actor *this, const Vec3 *);
  bool (__fastcall *updateWaterState)(Actor *this);
  void (__fastcall *doWaterSplashEffect)(Actor *this);
  void (__fastcall *spawnTrailBubbles)(Actor *this);
  void (__fastcall *updateInsideBlock)(Actor *this);
  LootTable *(__fastcall *getLootTable)(Actor *this);
  LootTable *(__fastcall *getDefaultLootTable)(Actor *this);
  void (__fastcall *_removeRider)(Actor *this, const ActorUniqueID *, bool, bool, bool);
  void (__fastcall *_onSizeUpdated)(Actor *this);
  void (__fastcall *_doAutoAttackOnTouch)(Actor *this, Actor *);
  void (__fastcall *knockback)(Mob *this, Actor *, int, float, float, float, float, float);
  void (__fastcall *resolveDeathLoot)(Mob *this, int, const ActorDamageSource *);
  void (__fastcall *spawnAnim)(Mob *this);
  void (__fastcall *setSleeping)(Mob *this, bool);
  void (__fastcall *setSprinting)(Mob *this, bool);
  void (__fastcall *playAmbientSound)(Mob *this);
  LevelSoundEvent (__fastcall *getAmbientSound)(Mob *this);
  int (__fastcall *getAmbientSoundPostponeTicks)(Mob *this);
  int (__fastcall *getAmbientSoundPostponeTicksRange)(Mob *this);
  const TextureUVCoordinateSet *(__fastcall *getItemInHandIcon)(Mob *this, const ItemStack *, int);
  float (__fastcall *getSpeed)(Mob *this);
  void (__fastcall *setSpeed)(Mob *this, float);
  float (__fastcall *getJumpPower)(Mob *this);
  bool (__fastcall *hurtEffects)(Mob *this, const ActorDamageSource *, int, bool, bool);
  int (__fastcall *getMeleeWeaponDamageBonus)(Mob *this, Mob *);
  int (__fastcall *getMeleeKnockbackBonus)(Mob *this);
  void (__fastcall *travel)(Mob *this, IMobMovementProxy *, float, float, float);
  void (__fastcall *travel)(Mob *this, float, float, float);
  void (__fastcall *applyFinalFriction)(Mob *this, float, bool);
  void (__fastcall *updateWalkAnim)(Mob *this);
  void (__fastcall *aiStep)(Mob *this, IMobMovementProxy *);
  void (__fastcall *aiStep)(Mob *this);
  void (__fastcall *pushActors)(Mob *this);
  void (__fastcall *lookAt)(Mob *this, Actor *, float, float);
  bool (__fastcall *isLookingAtAnEntity)(Mob *this);
  bool (__fastcall *checkSpawnRules)(Mob *this, bool);
  bool (__fastcall *checkSpawnObstruction)(Mob *this);
  float (__fastcall *getAttackAnim)(Mob *this, float);
  int (__fastcall *getItemUseDuration)(Mob *this);
  float (__fastcall *getItemUseStartupProgress)(Mob *this);
  float (__fastcall *getItemUseIntervalProgress)(Mob *this);
  int (__fastcall *getItemuseIntervalAxis)(Mob *this);
  int (__fastcall *getTimeAlongSwing)(Mob *this);
  void (__fastcall *ate)(Mob *this);
  float (__fastcall *getMaxHeadXRot)(Mob *this);
  Mob *(__fastcall *getLastHurtByMob)(Mob *this);
  void (__fastcall *setLastHurtByMob)(Mob *this, Mob *);
  Player *(__fastcall *getLastHurtByPlayer)(Mob *this);
  void (__fastcall *setLastHurtByPlayer)(Mob *this, Player *);
  Mob *(__fastcall *getLastHurtMob)(Mob *this);
  void (__fastcall *setLastHurtMob)(Mob *this, Actor *);
  bool (__fastcall *isAlliedTo)(Mob *this, Mob *);
  bool (__fastcall *doHurtTarget)(Mob *this, Actor *);
  bool (__fastcall *canBeControlledByRider)(Mob *this);
  void (__fastcall *leaveCaravan)(Mob *this);
  void (__fastcall *joinCaravan)(Mob *this, Mob *);
  bool (__fastcall *hasCaravanTail)(Mob *this);
  ActorUniqueID *(__fastcall *getCaravanHead)(Mob *this, ActorUniqueID *result);
  int (__fastcall *getArmorValue)(Mob *this);
  float (__fastcall *getArmorCoverPercentage)(Mob *this);
  void (__fastcall *hurtArmor)(Mob *this, const ActorDamageSource *, int, const std::bitset&lt;4&gt; *);
  void (__fastcall *hurtArmor)(Mob *this, const ActorDamageSource *, int);
  void (__fastcall *hurtArmorSlot)(Mob *this, const ActorDamageSource *, int, ArmorSlot);
  void (__fastcall *setDamagedArmor)(Mob *this, ArmorSlot, const ItemStack *);
  void (__fastcall *sendArmorDamage)(Mob *this, const std::bitset&lt;4&gt; *);
  void (__fastcall *sendArmor)(Mob *this, const std::bitset&lt;4&gt; *);
  void (__fastcall *containerChanged)(Mob *this, int);
  void (__fastcall *updateEquipment)(Mob *this);
  int (__fastcall *clearEquipment)(Mob *this);
  std::vector&lt;ItemStack const *&gt; *(__fastcall *getAllArmor)(Mob *this, std::vector&lt;ItemStack const *&gt; *result);
  std::vector&lt;int&gt; *(__fastcall *getAllArmorID)(Mob *this, std::vector&lt;int&gt; *result);
  std::vector&lt;ItemStack const *&gt; *(__fastcall *getAllHand)(Mob *this, std::vector&lt;ItemStack const *&gt; *result);
  std::vector&lt;ItemStack const *&gt; *(__fastcall *getAllEquipment)(Mob *this, std::vector&lt;ItemStack const *&gt; *result);
  int (__fastcall *getArmorTypeHash)(Mob *this);
  void (__fastcall *dropEquipmentOnDeath)(Mob *this);
  void (__fastcall *dropEquipmentOnDeath)(Mob *this, const ActorDamageSource *, int);
  void (__fastcall *clearVanishEnchantedItemsOnDeath)(Mob *this);
  void (__fastcall *sendInventory)(Mob *this, bool);
  int (__fastcall *getDamageAfterMagicAbsorb)(Mob *this, const ActorDamageSource *, int);
  bool (__fastcall *createAIGoals)(Mob *this);
  void (__fastcall *onBorn)(Mob *this, Actor *, Actor *);
  bool (__fastcall *setItemSlot)(Mob *this, EquipmentSlot, const ItemStack *);
  void (__fastcall *setTransitioningSitting)(Mob *this, bool);
  void (__fastcall *attackAnimation)(Mob *this, Actor *, float);
  int (__fastcall *getAttackTime)(Mob *this);
  float (__fastcall *_getWalkTargetValue)(Mob *this, const BlockPos *);
  bool (__fastcall *canExistWhenDisallowMob)(Mob *this);
  bool (__fastcall *useNewAi)(Mob *this);
  void (__fastcall *ascendLadder)(Mob *this);
  void (__fastcall *ascendScaffolding)(Mob *this);
  void (__fastcall *descendScaffolding)(Mob *this);
  void (__fastcall *dropContainer)(Mob *this);
  std::unique_ptr&lt;BodyControl&gt; *(__fastcall *initBodyControl)(Mob *this, std::unique_ptr&lt;BodyControl&gt; *result);
  void (__fastcall *jumpFromGround)(Mob *this, IMobMovementProxy *);
  void (__fastcall *jumpFromGround)(Mob *this);
  void (__fastcall *updateAi)(Mob *this);
  void (__fastcall *newServerAiStep)(Mob *this);
  void (__fastcall *_serverAiMobStep)(Mob *this);
  int (__fastcall *getDamageAfterEnchantReduction)(Mob *this, const ActorDamageSource *, int);
  int (__fastcall *getDamageAfterArmorAbsorb)(Mob *this, const ActorDamageSource *, int);
  void (__fastcall *dropBags)(Mob *this);
  void (__fastcall *tickDeath)(Mob *this);
  void (__fastcall *updateGliding)(Mob *this);
  bool (__fastcall *_allowAscendingScaffolding)(Mob *this);
};

</code></pre></div><h3 id="theenddimension-vtbl"><a href="#theenddimension-vtbl" class="header-anchor">#</a> <code>TheEndDimension_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TheEndDimension_vtbl
{
  void (__fastcall *~BlockSourceListener)(BlockSourceListener *this);
  void (__fastcall *onSourceCreated)(BlockSourceListener *this, BlockSource *);
  void (__fastcall *onSourceDestroyed)(BlockSourceListener *this, BlockSource *);
  void (__fastcall *onAreaChanged)(BlockSourceListener *this, BlockSource *, const BlockPos *, const BlockPos *);
  void (__fastcall *onBlockChanged)(BlockSourceListener *this, BlockSource *, const BlockPos *, unsigned int, const Block *, const Block *, int, const ActorBlockSyncMessage *);
  void (__fastcall *onBrightnessChanged)(BlockSourceListener *this, BlockSource *, const BlockPos *);
  void (__fastcall *onBlockEntityChanged)(BlockSourceListener *this, BlockSource *, BlockActor *);
  void (__fastcall *onBlockEntityAboutToBeRemoved)(BlockSourceListener *this, BlockSource *, std::shared_ptr&lt;BlockActor&gt;);
  void (__fastcall *onEntityChanged)(BlockSourceListener *this, BlockSource *, Actor *);
  void (__fastcall *onBlockEvent)(BlockSourceListener *this, BlockSource *, int, int, int, int, int);
  void (__fastcall *allChanged)(LevelListener *this);
  Particle *(__fastcall *addParticle)(LevelListener *this, ParticleType, const Vec3 *, const Vec3 *, int, const CompoundTag *, bool);
  void (__fastcall *sendServerLegacyParticle)(LevelListener *this, ParticleType, const Vec3 *, const Vec3 *, int);
  void (__fastcall *addParticleEffect)(LevelListener *this, const HashedString *, const Actor *, const HashedString *, const Vec3 *, const MolangVariableMap *);
  void (__fastcall *addParticleEffect)(LevelListener *this, const HashedString *, const Vec3 *, const MolangVariableMap *);
  void (__fastcall *addTerrainParticleEffect)(LevelListener *this, const BlockPos *, const Block *, const Vec3 *, float, float, float);
  void (__fastcall *addTerrainSlideEffect)(LevelListener *this, const BlockPos *, const Block *, const Vec3 *, float, float, float);
  void (__fastcall *addBreakingItemParticleEffect)(LevelListener *this, const Vec3 *, ParticleType, const TextureUVCoordinateSet *, bool);
  void (__fastcall *playMusic)(LevelListener *this, const std::string *, const Vec3 *, float, float);
  void (__fastcall *playStreamingMusic)(LevelListener *this, const std::string *, int, int, int);
  void (__fastcall *onEntityAdded)(LevelListener *this, Actor *);
  void (__fastcall *onEntityRemoved)(LevelListener *this, Actor *);
  void (__fastcall *onChunkLoaded)(LevelListener *this, ChunkSource *, LevelChunk *);
  void (__fastcall *onChunkUnloaded)(LevelListener *this, LevelChunk *);
  void (__fastcall *onLevelDestruction)(LevelListener *this, const std::string *);
  void (__fastcall *levelEvent)(LevelListener *this, LevelEvent, const CompoundTag *);
  void (__fastcall *levelEvent)(LevelListener *this, LevelEvent, const Vec3 *, int);
  void (__fastcall *levelSoundEvent)(LevelListener *this, const std::string *, const Vec3 *, float, float);
  void (__fastcall *levelSoundEvent)(LevelListener *this, LevelSoundEvent, const Vec3 *, int, const ActorDefinitionIdentifier *, bool, bool);
  void (__fastcall *stopSoundEvent)(LevelListener *this, const std::string *);
  void (__fastcall *stopAllSounds)(LevelListener *this);
  void (__fastcall *takePicture)(LevelListener *this, cg::ImageBuffer *, Actor *, Actor *, ScreenshotOptions *);
  void (__fastcall *playerListChanged)(LevelListener *this);
  void (__fastcall *init)(Dimension *this);
  void (__fastcall *tick)(Dimension *this);
  void (__fastcall *tickRedstone)(Dimension *this);
  std::tuple&lt;std::unique_ptr&lt;ChunkSource&gt;,WorldGenerator *&gt; *(__fastcall *createGenerator)(Dimension *this, std::tuple&lt;std::unique_ptr&lt;ChunkSource&gt;,WorldGenerator *&gt; *result);
  void (__fastcall *upgradeLevelChunk)(Dimension *this, ChunkSource *, LevelChunk *);
  void (__fastcall *fixWallChunk)(Dimension *this, ChunkSource *, LevelChunk *);
  bool (__fastcall *isNaturalDimension)(Dimension *this);
  bool (__fastcall *isValidSpawn)(Dimension *this, int, int);
  mce::Color *(__fastcall *getBrightnessDependentFogColor)(Dimension *this, mce::Color *result, const mce::Color *, float);
  float (__fastcall *getMaxFogEnd)(Dimension *this);
  float (__fastcall *getMaxFogStart)(Dimension *this);
  bool (__fastcall *isFoggyAt)(Dimension *this, int, int);
  __int16 (__fastcall *getCloudHeight)(Dimension *this);
  int (__fastcall *getDefaultBiome)(Dimension *this);
  bool (__fastcall *mayRespawnViaBed)(Dimension *this);
  bool (__fastcall *hasGround)(Dimension *this);
  BlockPos *(__fastcall *getSpawnPos)(Dimension *this, BlockPos *result);
  int (__fastcall *getSpawnYPosition)(Dimension *this);
  bool (__fastcall *hasBedrockFog)(Dimension *this);
  float (__fastcall *getClearColorScale)(Dimension *this);
  bool (__fastcall *showSky)(Dimension *this);
  bool (__fastcall *isDay)(Dimension *this);
  float (__fastcall *getTimeOfDay)(Dimension *this, int, float);
  float (__fastcall *getSunIntensity)(Dimension *this, float, const Vec3 *, float);
  bool (__fastcall *forceCheckAllNeighChunkSavedStat)(Dimension *this);
  Vec3 *(__fastcall *translatePosAcrossDimension)(Dimension *this, Vec3 *result, const Vec3 *, AutomaticID&lt;Dimension,int&gt;);
  void (__fastcall *sendBroadcast)(Dimension *this, const Packet *, Player *);
  bool (__fastcall *is2DPositionRelevantForPlayer)(Dimension *this, const BlockPos *, Player *);
  bool (__fastcall *isEntityRelevantForPlayer)(Dimension *this, Player *, const Actor *);
  BaseLightTextureImageBuilder *(__fastcall *getLightTextureImageBuilder)(Dimension *this);
  const DimensionBrightnessRamp *(__fastcall *getBrightnessRamp)(Dimension *this);
  void (__fastcall *startLeaveGame)(Dimension *this);
  std::unique_ptr&lt;ChunkBuildOrderPolicyBase&gt; *(__fastcall *_createChunkBuildOrderPolicy)(Dimension *this, std::unique_ptr&lt;ChunkBuildOrderPolicyBase&gt; *result);
  void (__fastcall *_upgradeOldLimboEntity)(Dimension *this, CompoundTag *, LimboEntitiesVersion);
  std::unique_ptr&lt;ChunkSource&gt; *(__fastcall *_wrapStorageForVersionCompatibility)(Dimension *this, std::unique_ptr&lt;ChunkSource&gt; *result, std::unique_ptr&lt;ChunkSource&gt;, StorageVersion);
};

</code></pre></div><h3 id="tropicalfish-vtbl"><a href="#tropicalfish-vtbl" class="header-anchor">#</a> <code>TropicalFish_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ TropicalFish_vtbl
{
  bool (__fastcall *hasComponent)(Actor *this, const HashedString *);
  void (__fastcall *reloadHardcoded)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadHardcodedClient)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *initializeComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *_serverInitItemStackIds)(Actor *this);
  void (__fastcall *_doInitialMove)(Actor *this);
  bool (__fastcall *checkAllSensitiveWords)(Actor *this);
  bool (__fastcall *checkNameTag)(Actor *this);
  void (__fastcall *~Actor)(Actor *this);
  void (__fastcall *reset)(Actor *this);
  int (__fastcall *getOnDeathExperience)(Actor *this);
  ActorType (__fastcall *getOwnerEntityType)(Actor *this);
  void (__fastcall *remove)(Actor *this);
  void (__fastcall *setPos)(Actor *this, const Vec3 *);
  const PredictedMovementValues *(__fastcall *getPredictedMovementValues)(Actor *this);
  const Vec3 *(__fastcall *getPos)(Actor *this);
  const Vec3 *(__fastcall *getPosOld)(Actor *this);
  const Vec3 *(__fastcall *getPosExtrapolated)(Actor *this, const Vec3 *result, float);
  Vec3 *(__fastcall *getAttachPos)(Actor *this, Vec3 *result, ActorLocation, float);
  Vec3 *(__fastcall *getFiringPos)(Actor *this, Vec3 *result);
  void (__fastcall *setRot)(Actor *this, const Vec2 *);
  void (__fastcall *move)(Actor *this, IActorMovementProxy *, const Vec3 *);
  void (__fastcall *move)(Actor *this, const Vec3 *);
  Vec3 *(__fastcall *getInterpolatedRidingPosition)(Actor *this, Vec3 *result, float);
  float (__fastcall *getInterpolatedBodyRot)(Actor *this, float);
  float (__fastcall *getInterpolatedHeadRot)(Actor *this, float);
  float (__fastcall *getInterpolatedBodyYaw)(Actor *this, float);
  float (__fastcall *getYawSpeedInDegreesPerSecond)(Actor *this);
  float (__fastcall *getInterpolatedWalkAnimSpeed)(Actor *this, float);
  Vec3 *(__fastcall *getInterpolatedRidingOffset)(Actor *this, Vec3 *result, float);
  void (__fastcall *checkBlockCollisions)(Actor *this);
  void (__fastcall *checkBlockCollisions)(Actor *this, const AABB *, std::function&lt;void __cdecl(BlockSource &amp;,Block const &amp;,BlockPos const &amp;,Actor &amp;)&gt;);
  bool (__fastcall *isFireImmune)(Actor *this);
  bool (__fastcall *breaksFallingBlocks)(Actor *this);
  void (__fastcall *blockedByShield)(Actor *this, const ActorDamageSource *, Actor *);
  void (__fastcall *teleportTo)(Actor *this, const Vec3 *, bool, int, int, const ActorUniqueID *);
  bool (__fastcall *tryTeleportTo)(Actor *this, const Vec3 *, bool, bool, int, int);
  void (__fastcall *chorusFruitTeleport)(Actor *this, Vec3 *);
  void (__fastcall *lerpTo)(Actor *this, const Vec3 *, const Vec2 *, int);
  void (__fastcall *lerpMotion)(Actor *this, const Vec3 *);
  std::unique_ptr&lt;AddActorBasePacket&gt; *(__fastcall *getAddPacket)(Actor *this, std::unique_ptr&lt;AddActorBasePacket&gt; *result);
  void (__fastcall *normalTick)(Actor *this);
  void (__fastcall *baseTick)(Actor *this);
  void (__fastcall *rideTick)(Actor *this);
  void (__fastcall *positionRider)(Actor *this, Actor *, float);
  float (__fastcall *getRidingHeight)(Actor *this);
  bool (__fastcall *startRiding)(Actor *this, Actor *);
  void (__fastcall *addRider)(Actor *this, Actor *);
  void (__fastcall *flagRiderToRemove)(Actor *this, Actor *);
  std::string *(__fastcall *getExitTip)(Actor *this, std::string *result, const std::string *, InputMode);
  bool (__fastcall *intersects)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *, float);
  bool (__fastcall *isInWall)(Actor *this);
  bool (__fastcall *isInvisible)(Actor *this);
  bool (__fastcall *canShowNameTag)(Actor *this);
  bool (__fastcall *canExistInPeaceful)(Actor *this);
  void (__fastcall *setNameTagVisible)(Actor *this, bool);
  const std::string *(__fastcall *getNameTag)(Actor *this);
  unsigned __int64 (__fastcall *getNameTagAsHash)(Actor *this);
  std::string *(__fastcall *getFormattedNameTag)(Actor *this, std::string *result);
  void (__fastcall *filterFormattedNameTag)(Actor *this, const UIProfanityContext *);
  void (__fastcall *setNameTag)(Actor *this, const std::string *);
  bool (__fastcall *getAlwaysShowNameTag)(Actor *this);
  void (__fastcall *setScoreTag)(Actor *this, const std::string *);
  const std::string *(__fastcall *getScoreTag)(Actor *this);
  bool (__fastcall *isInWater)(Actor *this);
  bool (__fastcall *hasEnteredWater)(Actor *this);
  bool (__fastcall *isImmersedInWater)(Actor *this);
  bool (__fastcall *isInWaterOrRain)(Actor *this);
  bool (__fastcall *isInLava)(Actor *this);
  bool (__fastcall *isUnderLiquid)(Actor *this, MaterialType);
  bool (__fastcall *isOverWater)(Actor *this);
  void (__fastcall *makeStuckInBlock)(Actor *this, const Vec3 *);
  float (__fastcall *getCameraOffset)(Actor *this);
  float (__fastcall *getShadowHeightOffs)(Actor *this);
  float (__fastcall *getShadowRadius)(Actor *this);
  Vec3 *(__fastcall *getHeadLookVector)(Actor *this, Vec3 *result, float);
  bool (__fastcall *canSeeInvisible)(Actor *this);
  bool (__fastcall *canSee)(Actor *this, const Vec3 *);
  bool (__fastcall *canSee)(Actor *this, const Actor *);
  bool (__fastcall *isSkyLit)(Actor *this, float);
  float (__fastcall *getBrightness)(Actor *this, float);
  bool (__fastcall *interactPreventDefault)(Actor *this);
  void (__fastcall *playerTouch)(Actor *this, Player *);
  void (__fastcall *onAboveBubbleColumn)(Actor *this, const bool);
  void (__fastcall *onInsideBubbleColumn)(Actor *this, const bool);
  bool (__fastcall *isImmobile)(Actor *this);
  bool (__fastcall *isSilent)(Actor *this);
  bool (__fastcall *isPickable)(Actor *this);
  bool (__fastcall *isFishable)(Actor *this);
  bool (__fastcall *isSleeping)(Actor *this);
  bool (__fastcall *isShootable)(Actor *this);
  void (__fastcall *setSneaking)(Actor *this, bool);
  bool (__fastcall *isBlocking)(Actor *this);
  bool (__fastcall *isDamageBlocked)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *isAlive)(Actor *this);
  bool (__fastcall *isOnFire)(Actor *this);
  bool (__fastcall *isOnHotBlock)(Actor *this);
  bool (__fastcall *isCreativeModeAllowed)(Actor *this);
  bool (__fastcall *isSurfaceMob)(Actor *this);
  bool (__fastcall *isTargetable)(Actor *this);
  bool (__fastcall *isLocalPlayer)(Actor *this);
  bool (__fastcall *isPlayer)(Actor *this);
  bool (__fastcall *canAttack)(Actor *this, Actor *, bool);
  void (__fastcall *setTarget)(Actor *this, Actor *);
  Actor *(__fastcall *findAttackTarget)(Actor *this);
  bool (__fastcall *isValidTarget)(Actor *this, Actor *);
  bool (__fastcall *attack)(Actor *this, Actor *);
  void (__fastcall *performRangedAttack)(Actor *this, Actor *, float);
  void (__fastcall *adjustDamageAmount)(Actor *this, int *);
  int (__fastcall *getEquipmentCount)(Actor *this);
  void (__fastcall *setOwner)(Actor *this, const ActorUniqueID);
  void (__fastcall *setSitting)(Actor *this, bool);
  void (__fastcall *onTame)(Actor *this);
  void (__fastcall *onFailedTame)(Actor *this);
  int (__fastcall *getInventorySize)(Actor *this);
  int (__fastcall *getEquipSlots)(Actor *this);
  int (__fastcall *getChestSlots)(Actor *this);
  void (__fastcall *setStanding)(Actor *this, bool);
  bool (__fastcall *canPowerJump)(Actor *this);
  void (__fastcall *setCanPowerJump)(Actor *this, bool);
  bool (__fastcall *isJumping)(Actor *this);
  bool (__fastcall *isEnchanted)(Actor *this);
  void (__fastcall *rideJumped)(Actor *this);
  void (__fastcall *rideLanded)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *shouldRender)(Actor *this);
  bool (__fastcall *isInvulnerableTo)(Actor *this, const ActorDamageSource *);
  ActorDamageCause (__fastcall *getBlockDamageCause)(Actor *this, const Block *);
  void (__fastcall *actuallyHurt)(Actor *this, int, const ActorDamageSource *, bool);
  void (__fastcall *animateHurt)(Actor *this);
  bool (__fastcall *doFireHurt)(Actor *this, int);
  void (__fastcall *onLightningHit)(Actor *this);
  void (__fastcall *onBounceStarted)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *feed)(Actor *this, int);
  void (__fastcall *handleEntityEvent)(Actor *this, ActorEvent, int);
  float (__fastcall *getPickRadius)(Actor *this);
  const HashedString *(__fastcall *getActorRendererId)(Actor *this);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const ItemStack *, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int);
  void (__fastcall *despawn)(Actor *this);
  void (__fastcall *killed)(Actor *this, Actor *);
  void (__fastcall *awardKillScore)(Actor *this, Actor *, int);
  void (__fastcall *setArmor)(Actor *this, ArmorSlot, const ItemStack *);
  const ItemStack *(__fastcall *getArmor)(Actor *this, ArmorSlot);
  ArmorMaterialType (__fastcall *getArmorMaterialTypeInSlot)(Actor *this, ArmorSlot);
  ArmorTextureType (__fastcall *getArmorMaterialTextureTypeInSlot)(Actor *this, ArmorSlot);
  float (__fastcall *getArmorColorInSlot)(Actor *this, ArmorSlot, int);
  const ItemStack *(__fastcall *getEquippedSlot)(Actor *this, EquipmentSlot);
  void (__fastcall *setEquippedSlot)(Actor *this, EquipmentSlot, const ItemStack *);
  const ItemStack *(__fastcall *getCarriedItem)(Actor *this);
  void (__fastcall *setCarriedItem)(Actor *this, const ItemStack *);
  void (__fastcall *setOffhandSlot)(Actor *this, const ItemStack *);
  const ItemStack *(__fastcall *getEquippedTotem)(Actor *this);
  bool (__fastcall *consumeTotem)(Actor *this);
  bool (__fastcall *save)(Actor *this, CompoundTag *);
  void (__fastcall *saveWithoutId)(Actor *this, CompoundTag *);
  bool (__fastcall *load)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *loadLinks)(Actor *this, const CompoundTag *, std::vector&lt;ActorLink&gt; *, DataLoadHelper *);
  ActorType (__fastcall *getEntityTypeId)(Actor *this);
  const HashedString *(__fastcall *queryEntityRenderer)(Actor *this);
  ActorUniqueID *(__fastcall *getSourceUniqueID)(Actor *this, ActorUniqueID *result);
  void (__fastcall *setOnFire)(Actor *this, int);
  AABB *(__fastcall *getHandleWaterAABB)(Actor *this, AABB *result);
  void (__fastcall *handleInsidePortal)(Actor *this, const BlockPos *);
  int (__fastcall *getPortalCooldown)(Actor *this);
  int (__fastcall *getPortalWaitTime)(Actor *this);
  AutomaticID&lt;Dimension,int&gt; *(__fastcall *getDimensionId)(Actor *this, AutomaticID&lt;Dimension,int&gt; *result);
  bool (__fastcall *canChangeDimensions)(Actor *this);
  void (__fastcall *changeDimension)(Actor *this, const ChangeDimensionPacket *);
  void (__fastcall *changeDimension)(Actor *this, AutomaticID&lt;Dimension,int&gt;, bool);
  ActorUniqueID *(__fastcall *getControllingPlayer)(Actor *this, ActorUniqueID *result);
  void (__fastcall *checkFallDamage)(Actor *this, float, bool);
  void (__fastcall *causeFallDamage)(Actor *this, float);
  void (__fastcall *handleFallDistanceOnServer)(Actor *this, float, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, int, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, const Block *, bool);
  void (__fastcall *onSynchedDataUpdate)(Actor *this, int);
  bool (__fastcall *canAddRider)(Actor *this, Actor *);
  bool (__fastcall *canPickupItem)(Actor *this, const ItemStack *);
  bool (__fastcall *canBePulledIntoVehicle)(Actor *this);
  bool (__fastcall *inCaravan)(Actor *this);
  bool (__fastcall *isLeashableType)(Actor *this);
  void (__fastcall *tickLeash)(Actor *this);
  void (__fastcall *sendMotionPacketIfNeeded)(Actor *this);
  bool (__fastcall *canSynchronizeNewEntity)(Actor *this);
  bool (__fastcall *stopRiding)(Actor *this, bool, bool, bool, bool);
  void (__fastcall *startSwimming)(Actor *this);
  void (__fastcall *stopSwimming)(Actor *this);
  void (__fastcall *buildDebugInfo)(Actor *this, std::string *);
  CommandPermissionLevel (__fastcall *getCommandPermissionLevel)(Actor *this);
  AttributeInstance *(__fastcall *getMutableAttribute)(Actor *this, const Attribute *);
  const AttributeInstance *(__fastcall *getAttribute)(Actor *this, const Attribute *);
  int (__fastcall *getDeathTime)(Actor *this);
  void (__fastcall *heal)(Actor *this, int);
  bool (__fastcall *isInvertedHealAndHarm)(Actor *this);
  bool (__fastcall *canBeAffected)(Actor *this, const MobEffectInstance *);
  bool (__fastcall *canBeAffected)(Actor *this, int);
  bool (__fastcall *canBeAffectedByArrow)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectAdded)(Actor *this, MobEffectInstance *);
  void (__fastcall *onEffectUpdated)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectRemoved)(Actor *this, MobEffectInstance *);
  AnimationComponent *(__fastcall *getAnimationComponent)(Actor *this);
  void (__fastcall *openContainerComponent)(Actor *this, Player *);
  void (__fastcall *swing)(Actor *this);
  void (__fastcall *useItem)(Actor *this, ItemStackBase *, ItemUseMethod, bool);
  bool (__fastcall *hasOutputSignal)(Actor *this, unsigned __int8);
  int (__fastcall *getOutputSignal)(Actor *this);
  void (__fastcall *getDebugText)(Actor *this, std::vector&lt;std::string&gt; *);
  float (__fastcall *getMapDecorationRotation)(Actor *this);
  float (__fastcall *getRiderYRotation)(Actor *this, const Actor *);
  float (__fastcall *getYHeadRot)(Actor *this);
  bool (__fastcall *isWorldBuilder)(Actor *this);
  bool (__fastcall *isCreative)(Actor *this);
  bool (__fastcall *isAdventure)(Actor *this);
  bool (__fastcall *add)(Actor *this, ItemStack *);
  bool (__fastcall *drop)(Actor *this, const ItemStack *, bool);
  bool (__fastcall *getInteraction)(Actor *this, Player *, ActorInteraction *, const Vec3 *);
  bool (__fastcall *canDestroyBlock)(Actor *this, const Block *);
  void (__fastcall *setAuxValue)(Actor *this, int);
  void (__fastcall *setSize)(Actor *this, float, float);
  int (__fastcall *getLifeSpan)(Actor *this);
  void (__fastcall *onOrphan)(Actor *this);
  void (__fastcall *wobble)(Actor *this);
  bool (__fastcall *wasHurt)(Actor *this);
  void (__fastcall *startSpinAttack)(Actor *this);
  void (__fastcall *stopSpinAttack)(Actor *this);
  void (__fastcall *setDamageNearbyMobs)(Actor *this, bool);
  bool (__fastcall *hasCritBox)(Actor *this);
  bool (__fastcall *isCritHit)(Actor *this);
  void (__fastcall *renderDebugServerState)(Actor *this, const Options *);
  void (__fastcall *reloadLootTable)(Actor *this, const EquipmentTableDefinition *);
  void (__fastcall *reloadLootTable)(Actor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(Actor *this);
  void (__fastcall *kill)(Actor *this);
  void (__fastcall *die)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *shouldTick)(Actor *this);
  std::shared_ptr&lt;IActorMovementProxy&gt; *(__fastcall *createMovementProxy)(Actor *this, std::shared_ptr&lt;IActorMovementProxy&gt; *result);
  void (__fastcall *updateEntitySpecificMolangVariables)(Actor *this, RenderParams *);
  bool (__fastcall *shouldTryMakeStepSound)(Actor *this);
  float (__fastcall *getNextStep)(Actor *this, const float);
  bool (__fastcall *canMakeStepSound)(Actor *this);
  void (__fastcall *outOfWorld)(Actor *this);
  bool (__fastcall *_hurt)(Actor *this, const ActorDamageSource *, int, bool, bool);
  void (__fastcall *markHurt)(Actor *this);
  void (__fastcall *readAdditionalSaveData)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *addAdditionalSaveData)(Actor *this, CompoundTag *);
  void (__fastcall *_playStepSound)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *_playFlySound)(Actor *this, const BlockPos *, const Block *);
  bool (__fastcall *_makeFlySound)(Actor *this);
  void (__fastcall *checkInsideBlocks)(Actor *this, float);
  void (__fastcall *pushOutOfBlocks)(Actor *this, const Vec3 *);
  bool (__fastcall *updateWaterState)(Actor *this);
  void (__fastcall *doWaterSplashEffect)(Actor *this);
  void (__fastcall *spawnTrailBubbles)(Actor *this);
  void (__fastcall *updateInsideBlock)(Actor *this);
  LootTable *(__fastcall *getLootTable)(Actor *this);
  LootTable *(__fastcall *getDefaultLootTable)(Actor *this);
  void (__fastcall *_removeRider)(Actor *this, const ActorUniqueID *, bool, bool, bool);
  void (__fastcall *_onSizeUpdated)(Actor *this);
  void (__fastcall *_doAutoAttackOnTouch)(Actor *this, Actor *);
  void (__fastcall *knockback)(Mob *this, Actor *, int, float, float, float, float, float);
  void (__fastcall *resolveDeathLoot)(Mob *this, int, const ActorDamageSource *);
  void (__fastcall *spawnAnim)(Mob *this);
  void (__fastcall *setSleeping)(Mob *this, bool);
  void (__fastcall *setSprinting)(Mob *this, bool);
  void (__fastcall *playAmbientSound)(Mob *this);
  LevelSoundEvent (__fastcall *getAmbientSound)(Mob *this);
  int (__fastcall *getAmbientSoundPostponeTicks)(Mob *this);
  int (__fastcall *getAmbientSoundPostponeTicksRange)(Mob *this);
  const TextureUVCoordinateSet *(__fastcall *getItemInHandIcon)(Mob *this, const ItemStack *, int);
  float (__fastcall *getSpeed)(Mob *this);
  void (__fastcall *setSpeed)(Mob *this, float);
  float (__fastcall *getJumpPower)(Mob *this);
  bool (__fastcall *hurtEffects)(Mob *this, const ActorDamageSource *, int, bool, bool);
  int (__fastcall *getMeleeWeaponDamageBonus)(Mob *this, Mob *);
  int (__fastcall *getMeleeKnockbackBonus)(Mob *this);
  void (__fastcall *travel)(Mob *this, IMobMovementProxy *, float, float, float);
  void (__fastcall *travel)(Mob *this, float, float, float);
  void (__fastcall *applyFinalFriction)(Mob *this, float, bool);
  void (__fastcall *updateWalkAnim)(Mob *this);
  void (__fastcall *aiStep)(Mob *this, IMobMovementProxy *);
  void (__fastcall *aiStep)(Mob *this);
  void (__fastcall *pushActors)(Mob *this);
  void (__fastcall *lookAt)(Mob *this, Actor *, float, float);
  bool (__fastcall *isLookingAtAnEntity)(Mob *this);
  bool (__fastcall *checkSpawnRules)(Mob *this, bool);
  bool (__fastcall *checkSpawnObstruction)(Mob *this);
  float (__fastcall *getAttackAnim)(Mob *this, float);
  int (__fastcall *getItemUseDuration)(Mob *this);
  float (__fastcall *getItemUseStartupProgress)(Mob *this);
  float (__fastcall *getItemUseIntervalProgress)(Mob *this);
  int (__fastcall *getItemuseIntervalAxis)(Mob *this);
  int (__fastcall *getTimeAlongSwing)(Mob *this);
  void (__fastcall *ate)(Mob *this);
  float (__fastcall *getMaxHeadXRot)(Mob *this);
  Mob *(__fastcall *getLastHurtByMob)(Mob *this);
  void (__fastcall *setLastHurtByMob)(Mob *this, Mob *);
  Player *(__fastcall *getLastHurtByPlayer)(Mob *this);
  void (__fastcall *setLastHurtByPlayer)(Mob *this, Player *);
  Mob *(__fastcall *getLastHurtMob)(Mob *this);
  void (__fastcall *setLastHurtMob)(Mob *this, Actor *);
  bool (__fastcall *isAlliedTo)(Mob *this, Mob *);
  bool (__fastcall *doHurtTarget)(Mob *this, Actor *);
  bool (__fastcall *canBeControlledByRider)(Mob *this);
  void (__fastcall *leaveCaravan)(Mob *this);
  void (__fastcall *joinCaravan)(Mob *this, Mob *);
  bool (__fastcall *hasCaravanTail)(Mob *this);
  ActorUniqueID *(__fastcall *getCaravanHead)(Mob *this, ActorUniqueID *result);
  int (__fastcall *getArmorValue)(Mob *this);
  float (__fastcall *getArmorCoverPercentage)(Mob *this);
  void (__fastcall *hurtArmor)(Mob *this, const ActorDamageSource *, int, const std::bitset&lt;4&gt; *);
  void (__fastcall *hurtArmor)(Mob *this, const ActorDamageSource *, int);
  void (__fastcall *hurtArmorSlot)(Mob *this, const ActorDamageSource *, int, ArmorSlot);
  void (__fastcall *setDamagedArmor)(Mob *this, ArmorSlot, const ItemStack *);
  void (__fastcall *sendArmorDamage)(Mob *this, const std::bitset&lt;4&gt; *);
  void (__fastcall *sendArmor)(Mob *this, const std::bitset&lt;4&gt; *);
  void (__fastcall *containerChanged)(Mob *this, int);
  void (__fastcall *updateEquipment)(Mob *this);
  int (__fastcall *clearEquipment)(Mob *this);
  std::vector&lt;ItemStack const *&gt; *(__fastcall *getAllArmor)(Mob *this, std::vector&lt;ItemStack const *&gt; *result);
  std::vector&lt;int&gt; *(__fastcall *getAllArmorID)(Mob *this, std::vector&lt;int&gt; *result);
  std::vector&lt;ItemStack const *&gt; *(__fastcall *getAllHand)(Mob *this, std::vector&lt;ItemStack const *&gt; *result);
  std::vector&lt;ItemStack const *&gt; *(__fastcall *getAllEquipment)(Mob *this, std::vector&lt;ItemStack const *&gt; *result);
  int (__fastcall *getArmorTypeHash)(Mob *this);
  void (__fastcall *dropEquipmentOnDeath)(Mob *this);
  void (__fastcall *dropEquipmentOnDeath)(Mob *this, const ActorDamageSource *, int);
  void (__fastcall *clearVanishEnchantedItemsOnDeath)(Mob *this);
  void (__fastcall *sendInventory)(Mob *this, bool);
  int (__fastcall *getDamageAfterMagicAbsorb)(Mob *this, const ActorDamageSource *, int);
  bool (__fastcall *createAIGoals)(Mob *this);
  void (__fastcall *onBorn)(Mob *this, Actor *, Actor *);
  bool (__fastcall *setItemSlot)(Mob *this, EquipmentSlot, const ItemStack *);
  void (__fastcall *setTransitioningSitting)(Mob *this, bool);
  void (__fastcall *attackAnimation)(Mob *this, Actor *, float);
  int (__fastcall *getAttackTime)(Mob *this);
  float (__fastcall *_getWalkTargetValue)(Mob *this, const BlockPos *);
  bool (__fastcall *canExistWhenDisallowMob)(Mob *this);
  bool (__fastcall *useNewAi)(Mob *this);
  void (__fastcall *ascendLadder)(Mob *this);
  void (__fastcall *ascendScaffolding)(Mob *this);
  void (__fastcall *descendScaffolding)(Mob *this);
  void (__fastcall *dropContainer)(Mob *this);
  std::unique_ptr&lt;BodyControl&gt; *(__fastcall *initBodyControl)(Mob *this, std::unique_ptr&lt;BodyControl&gt; *result);
  void (__fastcall *jumpFromGround)(Mob *this, IMobMovementProxy *);
  void (__fastcall *jumpFromGround)(Mob *this);
  void (__fastcall *updateAi)(Mob *this);
  void (__fastcall *newServerAiStep)(Mob *this);
  void (__fastcall *_serverAiMobStep)(Mob *this);
  int (__fastcall *getDamageAfterEnchantReduction)(Mob *this, const ActorDamageSource *, int);
  int (__fastcall *getDamageAfterArmorAbsorb)(Mob *this, const ActorDamageSource *, int);
  void (__fastcall *dropBags)(Mob *this);
  void (__fastcall *tickDeath)(Mob *this);
  void (__fastcall *updateGliding)(Mob *this);
  bool (__fastcall *_allowAscendingScaffolding)(Mob *this);
};

</code></pre></div><h3 id="turtle-vtbl"><a href="#turtle-vtbl" class="header-anchor">#</a> <code>Turtle_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Turtle_vtbl
{
  bool (__fastcall *hasComponent)(Actor *this, const HashedString *);
  void (__fastcall *reloadHardcoded)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadHardcodedClient)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *initializeComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *_serverInitItemStackIds)(Actor *this);
  void (__fastcall *_doInitialMove)(Actor *this);
  bool (__fastcall *checkAllSensitiveWords)(Actor *this);
  bool (__fastcall *checkNameTag)(Actor *this);
  void (__fastcall *~Actor)(Actor *this);
  void (__fastcall *reset)(Actor *this);
  int (__fastcall *getOnDeathExperience)(Actor *this);
  ActorType (__fastcall *getOwnerEntityType)(Actor *this);
  void (__fastcall *remove)(Actor *this);
  void (__fastcall *setPos)(Actor *this, const Vec3 *);
  const PredictedMovementValues *(__fastcall *getPredictedMovementValues)(Actor *this);
  const Vec3 *(__fastcall *getPos)(Actor *this);
  const Vec3 *(__fastcall *getPosOld)(Actor *this);
  const Vec3 *(__fastcall *getPosExtrapolated)(Actor *this, const Vec3 *result, float);
  Vec3 *(__fastcall *getAttachPos)(Actor *this, Vec3 *result, ActorLocation, float);
  Vec3 *(__fastcall *getFiringPos)(Actor *this, Vec3 *result);
  void (__fastcall *setRot)(Actor *this, const Vec2 *);
  void (__fastcall *move)(Actor *this, IActorMovementProxy *, const Vec3 *);
  void (__fastcall *move)(Actor *this, const Vec3 *);
  Vec3 *(__fastcall *getInterpolatedRidingPosition)(Actor *this, Vec3 *result, float);
  float (__fastcall *getInterpolatedBodyRot)(Actor *this, float);
  float (__fastcall *getInterpolatedHeadRot)(Actor *this, float);
  float (__fastcall *getInterpolatedBodyYaw)(Actor *this, float);
  float (__fastcall *getYawSpeedInDegreesPerSecond)(Actor *this);
  float (__fastcall *getInterpolatedWalkAnimSpeed)(Actor *this, float);
  Vec3 *(__fastcall *getInterpolatedRidingOffset)(Actor *this, Vec3 *result, float);
  void (__fastcall *checkBlockCollisions)(Actor *this);
  void (__fastcall *checkBlockCollisions)(Actor *this, const AABB *, std::function&lt;void __cdecl(BlockSource &amp;,Block const &amp;,BlockPos const &amp;,Actor &amp;)&gt;);
  bool (__fastcall *isFireImmune)(Actor *this);
  bool (__fastcall *breaksFallingBlocks)(Actor *this);
  void (__fastcall *blockedByShield)(Actor *this, const ActorDamageSource *, Actor *);
  void (__fastcall *teleportTo)(Actor *this, const Vec3 *, bool, int, int, const ActorUniqueID *);
  bool (__fastcall *tryTeleportTo)(Actor *this, const Vec3 *, bool, bool, int, int);
  void (__fastcall *chorusFruitTeleport)(Actor *this, Vec3 *);
  void (__fastcall *lerpTo)(Actor *this, const Vec3 *, const Vec2 *, int);
  void (__fastcall *lerpMotion)(Actor *this, const Vec3 *);
  std::unique_ptr&lt;AddActorBasePacket&gt; *(__fastcall *getAddPacket)(Actor *this, std::unique_ptr&lt;AddActorBasePacket&gt; *result);
  void (__fastcall *normalTick)(Actor *this);
  void (__fastcall *baseTick)(Actor *this);
  void (__fastcall *rideTick)(Actor *this);
  void (__fastcall *positionRider)(Actor *this, Actor *, float);
  float (__fastcall *getRidingHeight)(Actor *this);
  bool (__fastcall *startRiding)(Actor *this, Actor *);
  void (__fastcall *addRider)(Actor *this, Actor *);
  void (__fastcall *flagRiderToRemove)(Actor *this, Actor *);
  std::string *(__fastcall *getExitTip)(Actor *this, std::string *result, const std::string *, InputMode);
  bool (__fastcall *intersects)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *, float);
  bool (__fastcall *isInWall)(Actor *this);
  bool (__fastcall *isInvisible)(Actor *this);
  bool (__fastcall *canShowNameTag)(Actor *this);
  bool (__fastcall *canExistInPeaceful)(Actor *this);
  void (__fastcall *setNameTagVisible)(Actor *this, bool);
  const std::string *(__fastcall *getNameTag)(Actor *this);
  unsigned __int64 (__fastcall *getNameTagAsHash)(Actor *this);
  std::string *(__fastcall *getFormattedNameTag)(Actor *this, std::string *result);
  void (__fastcall *filterFormattedNameTag)(Actor *this, const UIProfanityContext *);
  void (__fastcall *setNameTag)(Actor *this, const std::string *);
  bool (__fastcall *getAlwaysShowNameTag)(Actor *this);
  void (__fastcall *setScoreTag)(Actor *this, const std::string *);
  const std::string *(__fastcall *getScoreTag)(Actor *this);
  bool (__fastcall *isInWater)(Actor *this);
  bool (__fastcall *hasEnteredWater)(Actor *this);
  bool (__fastcall *isImmersedInWater)(Actor *this);
  bool (__fastcall *isInWaterOrRain)(Actor *this);
  bool (__fastcall *isInLava)(Actor *this);
  bool (__fastcall *isUnderLiquid)(Actor *this, MaterialType);
  bool (__fastcall *isOverWater)(Actor *this);
  void (__fastcall *makeStuckInBlock)(Actor *this, const Vec3 *);
  float (__fastcall *getCameraOffset)(Actor *this);
  float (__fastcall *getShadowHeightOffs)(Actor *this);
  float (__fastcall *getShadowRadius)(Actor *this);
  Vec3 *(__fastcall *getHeadLookVector)(Actor *this, Vec3 *result, float);
  bool (__fastcall *canSeeInvisible)(Actor *this);
  bool (__fastcall *canSee)(Actor *this, const Vec3 *);
  bool (__fastcall *canSee)(Actor *this, const Actor *);
  bool (__fastcall *isSkyLit)(Actor *this, float);
  float (__fastcall *getBrightness)(Actor *this, float);
  bool (__fastcall *interactPreventDefault)(Actor *this);
  void (__fastcall *playerTouch)(Actor *this, Player *);
  void (__fastcall *onAboveBubbleColumn)(Actor *this, const bool);
  void (__fastcall *onInsideBubbleColumn)(Actor *this, const bool);
  bool (__fastcall *isImmobile)(Actor *this);
  bool (__fastcall *isSilent)(Actor *this);
  bool (__fastcall *isPickable)(Actor *this);
  bool (__fastcall *isFishable)(Actor *this);
  bool (__fastcall *isSleeping)(Actor *this);
  bool (__fastcall *isShootable)(Actor *this);
  void (__fastcall *setSneaking)(Actor *this, bool);
  bool (__fastcall *isBlocking)(Actor *this);
  bool (__fastcall *isDamageBlocked)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *isAlive)(Actor *this);
  bool (__fastcall *isOnFire)(Actor *this);
  bool (__fastcall *isOnHotBlock)(Actor *this);
  bool (__fastcall *isCreativeModeAllowed)(Actor *this);
  bool (__fastcall *isSurfaceMob)(Actor *this);
  bool (__fastcall *isTargetable)(Actor *this);
  bool (__fastcall *isLocalPlayer)(Actor *this);
  bool (__fastcall *isPlayer)(Actor *this);
  bool (__fastcall *canAttack)(Actor *this, Actor *, bool);
  void (__fastcall *setTarget)(Actor *this, Actor *);
  Actor *(__fastcall *findAttackTarget)(Actor *this);
  bool (__fastcall *isValidTarget)(Actor *this, Actor *);
  bool (__fastcall *attack)(Actor *this, Actor *);
  void (__fastcall *performRangedAttack)(Actor *this, Actor *, float);
  void (__fastcall *adjustDamageAmount)(Actor *this, int *);
  int (__fastcall *getEquipmentCount)(Actor *this);
  void (__fastcall *setOwner)(Actor *this, const ActorUniqueID);
  void (__fastcall *setSitting)(Actor *this, bool);
  void (__fastcall *onTame)(Actor *this);
  void (__fastcall *onFailedTame)(Actor *this);
  int (__fastcall *getInventorySize)(Actor *this);
  int (__fastcall *getEquipSlots)(Actor *this);
  int (__fastcall *getChestSlots)(Actor *this);
  void (__fastcall *setStanding)(Actor *this, bool);
  bool (__fastcall *canPowerJump)(Actor *this);
  void (__fastcall *setCanPowerJump)(Actor *this, bool);
  bool (__fastcall *isJumping)(Actor *this);
  bool (__fastcall *isEnchanted)(Actor *this);
  void (__fastcall *rideJumped)(Actor *this);
  void (__fastcall *rideLanded)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *shouldRender)(Actor *this);
  bool (__fastcall *isInvulnerableTo)(Actor *this, const ActorDamageSource *);
  ActorDamageCause (__fastcall *getBlockDamageCause)(Actor *this, const Block *);
  void (__fastcall *actuallyHurt)(Actor *this, int, const ActorDamageSource *, bool);
  void (__fastcall *animateHurt)(Actor *this);
  bool (__fastcall *doFireHurt)(Actor *this, int);
  void (__fastcall *onLightningHit)(Actor *this);
  void (__fastcall *onBounceStarted)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *feed)(Actor *this, int);
  void (__fastcall *handleEntityEvent)(Actor *this, ActorEvent, int);
  float (__fastcall *getPickRadius)(Actor *this);
  const HashedString *(__fastcall *getActorRendererId)(Actor *this);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const ItemStack *, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int);
  void (__fastcall *despawn)(Actor *this);
  void (__fastcall *killed)(Actor *this, Actor *);
  void (__fastcall *awardKillScore)(Actor *this, Actor *, int);
  void (__fastcall *setArmor)(Actor *this, ArmorSlot, const ItemStack *);
  const ItemStack *(__fastcall *getArmor)(Actor *this, ArmorSlot);
  ArmorMaterialType (__fastcall *getArmorMaterialTypeInSlot)(Actor *this, ArmorSlot);
  ArmorTextureType (__fastcall *getArmorMaterialTextureTypeInSlot)(Actor *this, ArmorSlot);
  float (__fastcall *getArmorColorInSlot)(Actor *this, ArmorSlot, int);
  const ItemStack *(__fastcall *getEquippedSlot)(Actor *this, EquipmentSlot);
  void (__fastcall *setEquippedSlot)(Actor *this, EquipmentSlot, const ItemStack *);
  const ItemStack *(__fastcall *getCarriedItem)(Actor *this);
  void (__fastcall *setCarriedItem)(Actor *this, const ItemStack *);
  void (__fastcall *setOffhandSlot)(Actor *this, const ItemStack *);
  const ItemStack *(__fastcall *getEquippedTotem)(Actor *this);
  bool (__fastcall *consumeTotem)(Actor *this);
  bool (__fastcall *save)(Actor *this, CompoundTag *);
  void (__fastcall *saveWithoutId)(Actor *this, CompoundTag *);
  bool (__fastcall *load)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *loadLinks)(Actor *this, const CompoundTag *, std::vector&lt;ActorLink&gt; *, DataLoadHelper *);
  ActorType (__fastcall *getEntityTypeId)(Actor *this);
  const HashedString *(__fastcall *queryEntityRenderer)(Actor *this);
  ActorUniqueID *(__fastcall *getSourceUniqueID)(Actor *this, ActorUniqueID *result);
  void (__fastcall *setOnFire)(Actor *this, int);
  AABB *(__fastcall *getHandleWaterAABB)(Actor *this, AABB *result);
  void (__fastcall *handleInsidePortal)(Actor *this, const BlockPos *);
  int (__fastcall *getPortalCooldown)(Actor *this);
  int (__fastcall *getPortalWaitTime)(Actor *this);
  AutomaticID&lt;Dimension,int&gt; *(__fastcall *getDimensionId)(Actor *this, AutomaticID&lt;Dimension,int&gt; *result);
  bool (__fastcall *canChangeDimensions)(Actor *this);
  void (__fastcall *changeDimension)(Actor *this, const ChangeDimensionPacket *);
  void (__fastcall *changeDimension)(Actor *this, AutomaticID&lt;Dimension,int&gt;, bool);
  ActorUniqueID *(__fastcall *getControllingPlayer)(Actor *this, ActorUniqueID *result);
  void (__fastcall *checkFallDamage)(Actor *this, float, bool);
  void (__fastcall *causeFallDamage)(Actor *this, float);
  void (__fastcall *handleFallDistanceOnServer)(Actor *this, float, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, int, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, const Block *, bool);
  void (__fastcall *onSynchedDataUpdate)(Actor *this, int);
  bool (__fastcall *canAddRider)(Actor *this, Actor *);
  bool (__fastcall *canPickupItem)(Actor *this, const ItemStack *);
  bool (__fastcall *canBePulledIntoVehicle)(Actor *this);
  bool (__fastcall *inCaravan)(Actor *this);
  bool (__fastcall *isLeashableType)(Actor *this);
  void (__fastcall *tickLeash)(Actor *this);
  void (__fastcall *sendMotionPacketIfNeeded)(Actor *this);
  bool (__fastcall *canSynchronizeNewEntity)(Actor *this);
  bool (__fastcall *stopRiding)(Actor *this, bool, bool, bool, bool);
  void (__fastcall *startSwimming)(Actor *this);
  void (__fastcall *stopSwimming)(Actor *this);
  void (__fastcall *buildDebugInfo)(Actor *this, std::string *);
  CommandPermissionLevel (__fastcall *getCommandPermissionLevel)(Actor *this);
  AttributeInstance *(__fastcall *getMutableAttribute)(Actor *this, const Attribute *);
  const AttributeInstance *(__fastcall *getAttribute)(Actor *this, const Attribute *);
  int (__fastcall *getDeathTime)(Actor *this);
  void (__fastcall *heal)(Actor *this, int);
  bool (__fastcall *isInvertedHealAndHarm)(Actor *this);
  bool (__fastcall *canBeAffected)(Actor *this, const MobEffectInstance *);
  bool (__fastcall *canBeAffected)(Actor *this, int);
  bool (__fastcall *canBeAffectedByArrow)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectAdded)(Actor *this, MobEffectInstance *);
  void (__fastcall *onEffectUpdated)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectRemoved)(Actor *this, MobEffectInstance *);
  AnimationComponent *(__fastcall *getAnimationComponent)(Actor *this);
  void (__fastcall *openContainerComponent)(Actor *this, Player *);
  void (__fastcall *swing)(Actor *this);
  void (__fastcall *useItem)(Actor *this, ItemStackBase *, ItemUseMethod, bool);
  bool (__fastcall *hasOutputSignal)(Actor *this, unsigned __int8);
  int (__fastcall *getOutputSignal)(Actor *this);
  void (__fastcall *getDebugText)(Actor *this, std::vector&lt;std::string&gt; *);
  float (__fastcall *getMapDecorationRotation)(Actor *this);
  float (__fastcall *getRiderYRotation)(Actor *this, const Actor *);
  float (__fastcall *getYHeadRot)(Actor *this);
  bool (__fastcall *isWorldBuilder)(Actor *this);
  bool (__fastcall *isCreative)(Actor *this);
  bool (__fastcall *isAdventure)(Actor *this);
  bool (__fastcall *add)(Actor *this, ItemStack *);
  bool (__fastcall *drop)(Actor *this, const ItemStack *, bool);
  bool (__fastcall *getInteraction)(Actor *this, Player *, ActorInteraction *, const Vec3 *);
  bool (__fastcall *canDestroyBlock)(Actor *this, const Block *);
  void (__fastcall *setAuxValue)(Actor *this, int);
  void (__fastcall *setSize)(Actor *this, float, float);
  int (__fastcall *getLifeSpan)(Actor *this);
  void (__fastcall *onOrphan)(Actor *this);
  void (__fastcall *wobble)(Actor *this);
  bool (__fastcall *wasHurt)(Actor *this);
  void (__fastcall *startSpinAttack)(Actor *this);
  void (__fastcall *stopSpinAttack)(Actor *this);
  void (__fastcall *setDamageNearbyMobs)(Actor *this, bool);
  bool (__fastcall *hasCritBox)(Actor *this);
  bool (__fastcall *isCritHit)(Actor *this);
  void (__fastcall *renderDebugServerState)(Actor *this, const Options *);
  void (__fastcall *reloadLootTable)(Actor *this, const EquipmentTableDefinition *);
  void (__fastcall *reloadLootTable)(Actor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(Actor *this);
  void (__fastcall *kill)(Actor *this);
  void (__fastcall *die)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *shouldTick)(Actor *this);
  std::shared_ptr&lt;IActorMovementProxy&gt; *(__fastcall *createMovementProxy)(Actor *this, std::shared_ptr&lt;IActorMovementProxy&gt; *result);
  void (__fastcall *updateEntitySpecificMolangVariables)(Actor *this, RenderParams *);
  bool (__fastcall *shouldTryMakeStepSound)(Actor *this);
  float (__fastcall *getNextStep)(Actor *this, const float);
  bool (__fastcall *canMakeStepSound)(Actor *this);
  void (__fastcall *outOfWorld)(Actor *this);
  bool (__fastcall *_hurt)(Actor *this, const ActorDamageSource *, int, bool, bool);
  void (__fastcall *markHurt)(Actor *this);
  void (__fastcall *readAdditionalSaveData)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *addAdditionalSaveData)(Actor *this, CompoundTag *);
  void (__fastcall *_playStepSound)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *_playFlySound)(Actor *this, const BlockPos *, const Block *);
  bool (__fastcall *_makeFlySound)(Actor *this);
  void (__fastcall *checkInsideBlocks)(Actor *this, float);
  void (__fastcall *pushOutOfBlocks)(Actor *this, const Vec3 *);
  bool (__fastcall *updateWaterState)(Actor *this);
  void (__fastcall *doWaterSplashEffect)(Actor *this);
  void (__fastcall *spawnTrailBubbles)(Actor *this);
  void (__fastcall *updateInsideBlock)(Actor *this);
  LootTable *(__fastcall *getLootTable)(Actor *this);
  LootTable *(__fastcall *getDefaultLootTable)(Actor *this);
  void (__fastcall *_removeRider)(Actor *this, const ActorUniqueID *, bool, bool, bool);
  void (__fastcall *_onSizeUpdated)(Actor *this);
  void (__fastcall *_doAutoAttackOnTouch)(Actor *this, Actor *);
  void (__fastcall *knockback)(Mob *this, Actor *, int, float, float, float, float, float);
  void (__fastcall *resolveDeathLoot)(Mob *this, int, const ActorDamageSource *);
  void (__fastcall *spawnAnim)(Mob *this);
  void (__fastcall *setSleeping)(Mob *this, bool);
  void (__fastcall *setSprinting)(Mob *this, bool);
  void (__fastcall *playAmbientSound)(Mob *this);
  LevelSoundEvent (__fastcall *getAmbientSound)(Mob *this);
  int (__fastcall *getAmbientSoundPostponeTicks)(Mob *this);
  int (__fastcall *getAmbientSoundPostponeTicksRange)(Mob *this);
  const TextureUVCoordinateSet *(__fastcall *getItemInHandIcon)(Mob *this, const ItemStack *, int);
  float (__fastcall *getSpeed)(Mob *this);
  void (__fastcall *setSpeed)(Mob *this, float);
  float (__fastcall *getJumpPower)(Mob *this);
  bool (__fastcall *hurtEffects)(Mob *this, const ActorDamageSource *, int, bool, bool);
  int (__fastcall *getMeleeWeaponDamageBonus)(Mob *this, Mob *);
  int (__fastcall *getMeleeKnockbackBonus)(Mob *this);
  void (__fastcall *travel)(Mob *this, IMobMovementProxy *, float, float, float);
  void (__fastcall *travel)(Mob *this, float, float, float);
  void (__fastcall *applyFinalFriction)(Mob *this, float, bool);
  void (__fastcall *updateWalkAnim)(Mob *this);
  void (__fastcall *aiStep)(Mob *this, IMobMovementProxy *);
  void (__fastcall *aiStep)(Mob *this);
  void (__fastcall *pushActors)(Mob *this);
  void (__fastcall *lookAt)(Mob *this, Actor *, float, float);
  bool (__fastcall *isLookingAtAnEntity)(Mob *this);
  bool (__fastcall *checkSpawnRules)(Mob *this, bool);
  bool (__fastcall *checkSpawnObstruction)(Mob *this);
  float (__fastcall *getAttackAnim)(Mob *this, float);
  int (__fastcall *getItemUseDuration)(Mob *this);
  float (__fastcall *getItemUseStartupProgress)(Mob *this);
  float (__fastcall *getItemUseIntervalProgress)(Mob *this);
  int (__fastcall *getItemuseIntervalAxis)(Mob *this);
  int (__fastcall *getTimeAlongSwing)(Mob *this);
  void (__fastcall *ate)(Mob *this);
  float (__fastcall *getMaxHeadXRot)(Mob *this);
  Mob *(__fastcall *getLastHurtByMob)(Mob *this);
  void (__fastcall *setLastHurtByMob)(Mob *this, Mob *);
  Player *(__fastcall *getLastHurtByPlayer)(Mob *this);
  void (__fastcall *setLastHurtByPlayer)(Mob *this, Player *);
  Mob *(__fastcall *getLastHurtMob)(Mob *this);
  void (__fastcall *setLastHurtMob)(Mob *this, Actor *);
  bool (__fastcall *isAlliedTo)(Mob *this, Mob *);
  bool (__fastcall *doHurtTarget)(Mob *this, Actor *);
  bool (__fastcall *canBeControlledByRider)(Mob *this);
  void (__fastcall *leaveCaravan)(Mob *this);
  void (__fastcall *joinCaravan)(Mob *this, Mob *);
  bool (__fastcall *hasCaravanTail)(Mob *this);
  ActorUniqueID *(__fastcall *getCaravanHead)(Mob *this, ActorUniqueID *result);
  int (__fastcall *getArmorValue)(Mob *this);
  float (__fastcall *getArmorCoverPercentage)(Mob *this);
  void (__fastcall *hurtArmor)(Mob *this, const ActorDamageSource *, int, const std::bitset&lt;4&gt; *);
  void (__fastcall *hurtArmor)(Mob *this, const ActorDamageSource *, int);
  void (__fastcall *hurtArmorSlot)(Mob *this, const ActorDamageSource *, int, ArmorSlot);
  void (__fastcall *setDamagedArmor)(Mob *this, ArmorSlot, const ItemStack *);
  void (__fastcall *sendArmorDamage)(Mob *this, const std::bitset&lt;4&gt; *);
  void (__fastcall *sendArmor)(Mob *this, const std::bitset&lt;4&gt; *);
  void (__fastcall *containerChanged)(Mob *this, int);
  void (__fastcall *updateEquipment)(Mob *this);
  int (__fastcall *clearEquipment)(Mob *this);
  std::vector&lt;ItemStack const *&gt; *(__fastcall *getAllArmor)(Mob *this, std::vector&lt;ItemStack const *&gt; *result);
  std::vector&lt;int&gt; *(__fastcall *getAllArmorID)(Mob *this, std::vector&lt;int&gt; *result);
  std::vector&lt;ItemStack const *&gt; *(__fastcall *getAllHand)(Mob *this, std::vector&lt;ItemStack const *&gt; *result);
  std::vector&lt;ItemStack const *&gt; *(__fastcall *getAllEquipment)(Mob *this, std::vector&lt;ItemStack const *&gt; *result);
  int (__fastcall *getArmorTypeHash)(Mob *this);
  void (__fastcall *dropEquipmentOnDeath)(Mob *this);
  void (__fastcall *dropEquipmentOnDeath)(Mob *this, const ActorDamageSource *, int);
  void (__fastcall *clearVanishEnchantedItemsOnDeath)(Mob *this);
  void (__fastcall *sendInventory)(Mob *this, bool);
  int (__fastcall *getDamageAfterMagicAbsorb)(Mob *this, const ActorDamageSource *, int);
  bool (__fastcall *createAIGoals)(Mob *this);
  void (__fastcall *onBorn)(Mob *this, Actor *, Actor *);
  bool (__fastcall *setItemSlot)(Mob *this, EquipmentSlot, const ItemStack *);
  void (__fastcall *setTransitioningSitting)(Mob *this, bool);
  void (__fastcall *attackAnimation)(Mob *this, Actor *, float);
  int (__fastcall *getAttackTime)(Mob *this);
  float (__fastcall *_getWalkTargetValue)(Mob *this, const BlockPos *);
  bool (__fastcall *canExistWhenDisallowMob)(Mob *this);
  bool (__fastcall *useNewAi)(Mob *this);
  void (__fastcall *ascendLadder)(Mob *this);
  void (__fastcall *ascendScaffolding)(Mob *this);
  void (__fastcall *descendScaffolding)(Mob *this);
  void (__fastcall *dropContainer)(Mob *this);
  std::unique_ptr&lt;BodyControl&gt; *(__fastcall *initBodyControl)(Mob *this, std::unique_ptr&lt;BodyControl&gt; *result);
  void (__fastcall *jumpFromGround)(Mob *this, IMobMovementProxy *);
  void (__fastcall *jumpFromGround)(Mob *this);
  void (__fastcall *updateAi)(Mob *this);
  void (__fastcall *newServerAiStep)(Mob *this);
  void (__fastcall *_serverAiMobStep)(Mob *this);
  int (__fastcall *getDamageAfterEnchantReduction)(Mob *this, const ActorDamageSource *, int);
  int (__fastcall *getDamageAfterArmorAbsorb)(Mob *this, const ActorDamageSource *, int);
  void (__fastcall *dropBags)(Mob *this);
  void (__fastcall *tickDeath)(Mob *this);
  void (__fastcall *updateGliding)(Mob *this);
  bool (__fastcall *_allowAscendingScaffolding)(Mob *this);
};

</code></pre></div><h3 id="throwinfo"><a href="#throwinfo" class="header-anchor">#</a> <code>ThrowInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>typedef const struct _s_ThrowInfo ThrowInfo;

</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      
      <a href="/mcstructure/1.16.201/structure/T.html" class="prev">
        T
      </a></span> <span class="next"><a href="/mcstructure/1.16.201/structure/U.html">
        U
      </a>
      
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/mcstructure/assets/js/app.56b0ab36.js" defer></script><script src="/mcstructure/assets/js/2.56e23786.js" defer></script><script src="/mcstructure/assets/js/142.08052153.js" defer></script>
  </body>
</html>
